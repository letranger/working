<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-02-10 Mon 23:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>James Exam</title>
<meta name="author" content="Yung-Chin Yen" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/muse.css" />
<script src="../css/copy_code.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">James Exam</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8667d46">1. Linux使用者與檔案權限</a>
<ul>
<li><a href="#org914d78c">1.1. 使用者類型</a></li>
<li><a href="#org36fc71d">1.2. 檔案權限</a></li>
<li><a href="#org9597eb9">1.3. 題目1</a></li>
</ul>
</li>
<li><a href="#orgda0c753">2. 伺服器管理:crontab</a>
<ul>
<li><a href="#org565dd70">2.1. crontab</a></li>
<li><a href="#org825174b">2.2. 定期備份</a></li>
<li><a href="#org738563a">2.3. 定期更新https證書</a></li>
</ul>
</li>
<li><a href="#org980b462">3. 成大113計概</a>
<ul>
<li><a href="#orgd9793e8">3.1. A-I <code>[40%]</code> Multiple choice questions: (choose only ONE answer for a question; 4% for each question)</a></li>
<li><a href="#org747fd54">3.2. (1)</a></li>
<li><a href="#org0508fa1">3.3. (2)</a></li>
<li><a href="#orgfab3176">3.4. (3)</a></li>
<li><a href="#org3f9b46b">3.5. (4)</a></li>
<li><a href="#org72b5b98">3.6. (5)</a></li>
<li><a href="#org1a6d20f">3.7. (6)</a></li>
<li><a href="#org25ae3f8">3.8. (7)</a></li>
<li><a href="#orgebfdbf4">3.9. (8)</a></li>
<li><a href="#orga6e06cd">3.10. (9)</a></li>
<li><a href="#orge6b3d29">3.11. (10)</a></li>
<li><a href="#orgc5c6991">3.12. A-2 <code>[5%]</code></a></li>
<li><a href="#org7bf86f5">3.13. A-3 <code>[5%]</code></a></li>
<li><a href="#org1f338db">3.14. B-l (4%)</a></li>
<li><a href="#org718b821">3.15. B-2 (4%)</a></li>
<li><a href="#orgf657609">3.16. B-3 (4%)</a></li>
<li><a href="#org97540f1">3.17. B-4 (4%)</a></li>
<li><a href="#org7084551">3.18. B-5 (4%)</a></li>
<li><a href="#org83f1551">3.19. B-6 (4%)</a></li>
<li><a href="#orgb50327b">3.20. B-7 (4%)</a></li>
<li><a href="#org03c7c00">3.21. B-8 (22%)</a></li>
</ul>
</li>
<li><a href="#orga000f87">4. AI相關基本知識</a>
<ul>
<li><a href="#orgf46e80a">4.1. 機器學習的基本類型</a></li>
<li><a href="#org430018c">4.2. 什麼是深度學習</a></li>
<li><a href="#org303d5da">4.3. 什麼是大語言模型</a></li>
<li><a href="#org37b739f">4.4. 什麼是圖靈測試</a></li>
<li><a href="#org117fa1c">4.5. 什麼是圖靈機</a></li>
<li><a href="#org302a755">4.6. AI如何應用於資訊管理</a></li>
</ul>
</li>
<li><a href="#org0bc7f02">5. 中央113計概</a>
<ul>
<li><a href="#orgbce579b">5.1. 1.(10%)</a></li>
<li><a href="#org6e8300e">5.2. 2. (20%)</a></li>
<li><a href="#orgbcd587c">5.3. 3.(15%)</a></li>
<li><a href="#orgb0a40d2">5.4. 4.(5%)</a></li>
<li><a href="#org9337b24">5.5. 5.(5%)</a></li>
<li><a href="#orge726576">5.6. 6. (5%)</a></li>
<li><a href="#orgfeaf8f5">5.7. 7.(15%)</a></li>
<li><a href="#org1fe21e1">5.8. 8.(10%)</a></li>
<li><a href="#org25bb88f">5.9. 解</a></li>
<li><a href="#orga951463">5.10. 9.(5%)</a></li>
<li><a href="#org002a056">5.11. 10.(10%)</a></li>
</ul>
</li>
<li><a href="#org16491cf">6. 中山113計概</a>
<ul>
<li><a href="#orgdb5182e">6.1. |單選</a></li>
<li><a href="#orgb9e8c5b">6.2. 複選</a></li>
<li><a href="#org00bb182">6.3. 第16~19題為簡答題。</a></li>
</ul>
</li>
<li><a href="#org70c1713">7. 成大近三年計概</a>
<ul>
<li><a href="#org7ff9613">7.1. 110</a></li>
<li><a href="#org518cfae">7.2. 111</a></li>
<li><a href="#org3d31d07">7.3. 112</a></li>
</ul>
</li>
<li><a href="#orgf842b13">8. 中央近五年計概</a>
<ul>
<li><a href="#orgbcc8e6b">8.1. 108</a></li>
<li><a href="#org5d44d3b">8.2. 109</a></li>
<li><a href="#orgd8d92c0">8.3. 110</a></li>
<li><a href="#org94c2255">8.4. 111</a></li>
<li><a href="#org4ea8936">8.5. 112</a></li>
</ul>
</li>
<li><a href="#org56034ed">9. 中山近三年考題及詳解</a>
<ul>
<li><a href="#org11ee973">9.1. 110: 中山管理資訊系統</a></li>
<li><a href="#orga8a3aed">9.2. 110: 中山資料結構</a></li>
<li><a href="#org6904b59">9.3. 110: 中山資料結構</a></li>
<li><a href="#org506bb31">9.4. 110: 中山計概</a></li>
<li><a href="#org71e0378">9.5. 110: 中山計概</a></li>
<li><a href="#org55ea3f5">9.6. 111: 中山計概</a></li>
<li><a href="#org2ec8c89">9.7. 111: 管理資訊系統</a></li>
<li><a href="#org1d11cc9">9.8. 111: 資料結構：</a></li>
<li><a href="#org1763610">9.9. 112: 中山計概</a></li>
<li><a href="#orgc8a0095">9.10. 112: 中山管資</a></li>
<li><a href="#orgf99c1ff">9.11. 112: 中山資結</a></li>
</ul>
</li>
<li><a href="#orgc419d53">10. 中山</a>
<ul>
<li><a href="#org9a4fe36">10.1. 近10年趨勢</a></li>
<li><a href="#orgf0ce578">10.2. AI模擬試題</a></li>
<li><a href="#org8e952f4">10.3. 參考答案</a></li>
</ul>
</li>
<li><a href="#orgc72a2f8">11. 中興</a>
<ul>
<li><a href="#org22b2724">11.1. 近10年趨勢</a></li>
<li><a href="#orgd9c31f7">11.2. AI模擬試題</a></li>
<li><a href="#org35a9828">11.3. 詳細解說答案</a></li>
</ul>
</li>
<li><a href="#org1354d3a">12. 清大</a>
<ul>
<li><a href="#orgfd4b08c">12.1. 近10年趨勢</a></li>
<li><a href="#org4fc1889">12.2. AI模擬試題</a></li>
<li><a href="#org1f97b0e">12.3. 詳細解答：</a></li>
</ul>
</li>
<li><a href="#orgcfae4b5">13. 成大</a>
<ul>
<li><a href="#orgeb64d58">13.1. 近10年趨勢</a></li>
<li><a href="#org01b625d">13.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#org7d313df">14. 中央</a>
<ul>
<li><a href="#org954572d">14.1. 近10年趨勢</a></li>
<li><a href="#org964ce68">14.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#orgdd4eb3e">15. 北大</a>
<ul>
<li><a href="#orgd5e4a67">15.1. 近10年趨勢</a></li>
<li><a href="#org8f938eb">15.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#org813de06">16. 林北的考前猜題</a>
<ul>
<li><a href="#org98e2e2f">16.1. 網路</a></li>
<li><a href="#org67e94c8">16.2. 資料庫</a></li>
<li><a href="#orgf30dd4b">16.3. 軟體工程</a></li>
<li><a href="#org24840b5">16.4. AI</a></li>
<li><a href="#org3267b86">16.5. 資管</a></li>
<li><a href="#org7b8b5b7">16.6. 其他</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8667d46" class="outline-2">
<h2 id="org8667d46"><span class="section-number-2">1.</span> Linux使用者與檔案權限</h2>
<div class="outline-text-2" id="text-1">
<p>
在 Linux 系統中，每個使用者（User）都有兩個基本資訊：<br />
</p>
<ul class="org-ul">
<li>使用者名稱（Username）:用於識別登入系統的個人帳戶。<br /></li>
<li>所屬群組（Group）:使用者可以屬於一個或多個群組，系統管理員可以將權限指派給群組，所有屬於該群組的使用者都會擁有相同的權限。<br /></li>
</ul>
</div>
<div id="outline-container-org914d78c" class="outline-3">
<h3 id="org914d78c"><span class="section-number-3">1.1.</span> 使用者類型</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Linux 的使用者可以分為以下幾種類型：<br />
</p>

<ul class="org-ul">
<li>系統管理員（Root）：擁有最高權限的帳戶，能夠執行所有系統管理操作，包含安裝軟體、管理使用者、變更系統設定等。<br /></li>
<li>一般使用者（Regular User）：具有基本權限的帳戶，通常只能存取自己的檔案，執行一般應用程式，但無法直接進行系統層級的變更。<br /></li>
<li>系統使用者（System User）：這類帳戶通常是由系統服務（如 www-data、nobody、mysql）所使用，並不會用來讓人類使用者登入。像網頁伺服器就會用apache或httpd這樣的名稱檔系統使用者，這種邏輯是把程式當成使用者一樣，可以控制程式的權限，這類使用者通常就不被允許由遠端登入系統。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org36fc71d" class="outline-3">
<h3 id="org36fc71d"><span class="section-number-3">1.2.</span> 檔案權限</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在 Linux 中，每個檔案和目錄都有權限設定，以確保系統的安全性。權限分為三個層級：<br />
</p>
<ul class="org-ul">
<li>檔案擁有者（Owner）：通常是建立該檔案的使用者，擁有對該檔案的最高權限。也就是說，如果你是這個檔案的擁有者，你可以對檔案做什麼？系統管理者也許會規定：你可以看、改、刪這個檔案。<br /></li>
<li>群組（Group）：如果使用者屬於該檔案的群組，則可以根據群組權限存取該檔案。也就是說，如果你和檔案擁有者是同一個群組，你可以對它做什麼？系統管理者也許會規定：你可以看(讀取)，但不能寫入。<br /></li>
<li>其他使用者（Others）：不屬於擁有者或群組的使用者，則適用此權限設定。也就是說，如果你不是檔案擁有者、也沒和擁有者在同一群組，你可以對檔案做什麼？系統管理者也許可以規定：你連看都看不到。<br /></li>
</ul>

<p>
Linux如何做到上面這些限制？就是利用控制檔案的權限。在Linux裡，你可以使用 ls -l 指令來查看所有檔案的權限，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>-rwxr-xr--  <span style="color: #da8548; font-weight: bold;">1</span> user group  <span style="color: #da8548; font-weight: bold;">1024</span> Feb <span style="color: #da8548; font-weight: bold;">10</span> 12:34 example.txt
</pre>
</div>
<p>
這個權限字串可拆解為：<br />
</p>
<ul class="org-ul">
<li>-(最前面的-)：表示這是一個一般檔案（若為目錄則顯示 d）。<br /></li>
<li>rwx（擁有者權限）：擁有者可以讀取（r）、寫入（w）和執行（x）。<br /></li>
<li>r-x（群組權限）：群組成員可以讀取（r）和執行（x），但不能寫入。<br /></li>
<li>r&#x2013;（其他使用者權限）：其他使用者只能讀取（r），但無法寫入或執行。<br /></li>
</ul>
</div>
<div id="outline-container-org9c6dae4" class="outline-4">
<h4 id="org9c6dae4"><span class="section-number-4">1.2.1.</span> 權限數字表示法</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
除了字母表示法，權限也可以用數字來表示：<br />
</p>
<ul class="org-ul">
<li>r（讀取）= 4<br /></li>
<li>w（寫入）= 2<br /></li>
<li>x（執行）= 1<br /></li>
</ul>

<p>
權限的數值是這三個值的總和，例如：<br />
</p>
<ul class="org-ul">
<li>rwx = 4 + 2 + 1 = 7<br /></li>
<li>rw- = 4 + 2 = 6<br /></li>
<li>r&#x2013; = 4 = 4<br /></li>
</ul>

<p>
因此，權限 -rwxr-xr&#x2013; 也可以用 chmod 754 example.txt 來設定。<br />
</p>
</div>
</div>
<div id="outline-container-org2516757" class="outline-4">
<h4 id="org2516757"><span class="section-number-4">1.2.2.</span> 變更權限</h4>
<div class="outline-text-4" id="text-1-2-2">
</div>
<div id="outline-container-org23c9244" class="outline-5">
<h5 id="org23c9244">變更檔案擁有者</h5>
<div class="outline-text-5" id="text-org23c9244">
<p>
系統管理員可以使用 chown 指令來變更檔案擁有者：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #ECBE7B;">sudo</span> <span style="color: #ECBE7B;">chown</span> newuser example.txt
</pre>
</div>
<p>
前面的sudo意思是使用系統最高權限來做某件事的意思，能在最前面加入sudo表示你是系統的管理員。<br />
</p>


<p>
也可以同時變更擁有者和群組：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #ECBE7B;">sudo</span> <span style="color: #ECBE7B;">chown</span> newuser:newgroup example.txt
</pre>
</div>
</div>
</div>
<div id="outline-container-org5025523" class="outline-5">
<h5 id="org5025523">變更檔案權限</h5>
<div class="outline-text-5" id="text-org5025523">
<p>
使用 chmod 指令可以變更權限：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #ECBE7B;">chmod</span> <span style="color: #da8548; font-weight: bold;">755</span> example.txt
</pre>
</div>
<p>
這表示：<br />
</p>
<ul class="org-ul">
<li>擁有者有 rwx（7）<br /></li>
<li>群組有 r-x（5）<br /></li>
<li>其他人有 r-x（5）<br /></li>
</ul>

<p>
也可以用符號方式變更：<br />
</p>
<ul class="org-ul">
<li>chmod u+w example.txt   # 給擁有者（u）增加寫入權限<br /></li>
<li>chmod g-r example.txt   # 移除群組（g）的讀取權限<br /></li>
<li>chmod o+x example.txt   # 給其他使用者（o）增加執行權限<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3324012" class="outline-4">
<h4 id="org3324012"><span class="section-number-4">1.2.3.</span> 群組管理</h4>
<div class="outline-text-4" id="text-1-2-3">
</div>
<div id="outline-container-org54500b7" class="outline-5">
<h5 id="org54500b7">建立新群組</h5>
<div class="outline-text-5" id="text-org54500b7">
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #ECBE7B;">sudo</span> groupadd mygroup
</pre>
</div>
</div>
</div>
<div id="outline-container-org5a7d2cd" class="outline-5">
<h5 id="org5a7d2cd">新增使用者到群組</h5>
<div class="outline-text-5" id="text-org5a7d2cd">
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #ECBE7B;">sudo</span> usermod -aG mygroup username
</pre>
</div>
<p>
-aG 參數表示將使用者 username 加入 mygroup 群組。<br />
</p>
</div>
</div>
<div id="outline-container-org3075a51" class="outline-5">
<h5 id="org3075a51">查看使用者的群組</h5>
<div class="outline-text-5" id="text-org3075a51">
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>groups username
</pre>
</div>
<p>
Linux的使用者有兩種基本資料：使用者名稱和所屬群組，系統管理者可以直接分配不同的權限給群組，然後屬於這個群組的使用者就都撞有這個權限，最高的<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org9597eb9" class="outline-3">
<h3 id="org9597eb9"><span class="section-number-3">1.3.</span> 題目1</h3>
<div class="outline-text-3" id="text-1-3">
<p>
檔案資訊<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>-rw-rw-rw- <span style="color: #da8548; font-weight: bold;">1</span> guest1 guest2 <span style="color: #da8548; font-weight: bold;">79</span> Jan <span style="color: #da8548; font-weight: bold;">4</span> 01:51 guest3
</pre>
</div>
<p>
這應該就是用ls -l列出的內容，主要分為四個部分：<br />
</p>
<ul class="org-ul">
<li>第一個字元 -：表示這是一個一般檔案（若是目錄則顯示 d）。<br /></li>
<li><p>
接下來的九個字元：分為三組，每組三個字元，代表不同使用者類別的權限：<br />
</p>
<ul class="org-ul">
<li>rw-（擁有者的權限，guest1）<br />
<ul class="org-ul">
<li>r（讀取 Read）<br /></li>
<li>w（寫入 Write）<br /></li>
<li>-（沒有執行權限 Execute）<br /></li>
</ul></li>
<li>rw-（群組的權限，guest2）<br />
<ul class="org-ul">
<li>r（讀取）<br /></li>
<li>w（寫入）<br /></li>
<li>-（沒有執行權限）<br /></li>
</ul></li>
<li>rw-（其他使用者的權限，Others）<br />
<ul class="org-ul">
<li>r（讀取）<br /></li>
<li>w（寫入）<br /></li>
<li>-（沒有執行權限）<br /></li>
</ul></li>
</ul>

<p>
➡ 總結：該檔案對所有使用者（擁有者、群組和其他人）都開放讀寫 (rw-)，但不允許執行 (-)。(能讀寫和能執行是兩回事)<br />
</p></li>
<li>1（硬連結數量）<br />
<ul class="org-ul">
<li>這個數字表示該檔案的 硬連結（Hard Link） 數量，通常一般檔案的值是 1。<br /></li>
<li>如果有其他檔案指向這個檔案的 inode（即建立了硬連結），這個數字會增加。<br /></li>
<li>這裡的hard link是相對於soft link, 你可以暫時把它想成是windows裡的捷徑，意思是有多少個捷徑指向這個檔案<br /></li>
</ul></li>

<li>guest1（檔案擁有者）<br />
這個檔案的擁有者（Owner）是 guest1，通常是建立該檔案的使用者。<br /></li>
<li>guest2（檔案群組）&#x2014;&gt;(a)的答案<br />
這個檔案的群組（Group）是 guest2，這表示該群組的成員也可以根據群組權限存取這個檔案。<br /></li>
<li>79（檔案大小，單位：Bytes）<br />
<ul class="org-ul">
<li>這個檔案的大小是 79 Bytes（字節）。<br /></li>
<li>若是目錄，這個數字通常表示目錄資訊的大小，而不是實際存放的檔案總大小。<br /></li>
</ul></li>
<li>Jan 4 01:51（最後修改時間）<br />
<ul class="org-ul">
<li>這是該檔案的最後修改時間（Last Modified Time）。<br /></li>
<li>Jan 4 表示最後一次修改發生在 1 月 4 日。<br /></li>
<li>01:51 表示最後修改的時間為凌晨 1 點 51 分。<br /></li>
<li>如果這個檔案是 去年或更久之前修改的，年份會顯示在 01:51 位置，而非時間。<br /></li>
</ul></li>
<li>guest3（檔案名稱）<br />
<ul class="org-ul">
<li>這是該檔案的名稱，叫做 guest3。<br /></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgbadddc2" class="outline-4">
<h4 id="orgbadddc2"><span class="section-number-4">1.3.1.</span> (a) 檔案所屬群組</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
應該是guest2<br />
</p>
</div>
</div>
<div id="outline-container-orgcacc921" class="outline-4">
<h4 id="orgcacc921"><span class="section-number-4">1.3.2.</span> (b) 檔案型態</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
我在猜它是在問這是哪種類型的檔案，應該由最前面的字母判斷，Linux有以下幾種可能的檔案類型<br />
</p>
<ol class="org-ol">
<li>- 普通檔案（Regular file）<br /></li>
<li>d 目錄（Directory）<br /></li>
<li>l 符號連結（Symbolic link）<br /></li>
<li>b 區塊裝置檔案（Block device file，如硬碟）<br /></li>
<li>c 字元裝置檔案（Character device file，如鍵盤、終端機）<br /></li>
<li>p 命名管道（Named pipe）<br /></li>
<li>s Socket 檔案（用於網路通訊）<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org12d7f2b" class="outline-4">
<h4 id="org12d7f2b"><span class="section-number-4">1.3.3.</span> (c) 執行chmod 755後的檔案屬性</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
執行 ls -l guest3 之後，新的輸出會是：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>-rwxr-xr-x <span style="color: #da8548; font-weight: bold;">1</span> guest1 guest2 <span style="color: #da8548; font-weight: bold;">79</span> Jan <span style="color: #da8548; font-weight: bold;">4</span> 01:51 guest3
</pre>
</div>

<p>
變更後的解析<br />
</p>
<ol class="org-ol">
<li>檔案型態<br />
第一個字元 -：表示這仍然是一個 普通檔案（Regular file）。<br /></li>
<li>權限（-rwxr-xr-x）<br />
原本的權限是 -rw-rw-rw-（所有人都能讀寫），現在變成了 -rwxr-xr-x，表示：<br />
<ul class="org-ul">
<li>rwx（擁有者 guest1）：<br />
<ul class="org-ul">
<li>r（讀取）<br /></li>
<li>w（寫入）<br /></li>
<li>x（執行）<br /></li>
<li>→ 擁有者現在可以讀取、寫入和執行該檔案。<br /></li>
</ul></li>
<li>r-x（群組 guest2）：<br />
<ul class="org-ul">
<li>r（讀取）<br /></li>
<li>-（沒有寫入權限）<br /></li>
<li>x（執行）<br /></li>
<li>→ 群組成員可以讀取和執行該檔案，但無法修改內容。<br /></li>
</ul></li>
<li>r-x（其他使用者 others）：<br />
<ul class="org-ul">
<li>r（讀取）<br /></li>
<li>-（沒有寫入權限）<br /></li>
<li>x（執行）<br /></li>
<li>→ 其他所有使用者可以讀取和執行，但無法修改內容。<br /></li>
</ul></li>
</ul></li>
<li>其他資訊<br />
<ul class="org-ul">
<li>硬連結數量 1：仍然是 1（未變）。<br /></li>
<li>擁有者 guest1：未變。<br /></li>
<li>群組 guest2：未變。<br /></li>
<li>檔案大小 79 bytes：未變。<br /></li>
<li>最後修改時間 Jan 4 01:51：未變。<br /></li>
<li>檔案名稱 guest3：未變。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgda0c753" class="outline-2">
<h2 id="orgda0c753"><span class="section-number-2">2.</span> 伺服器管理:crontab</h2>
<div class="outline-text-2" id="text-2">
<p>
在 Linux 系統中，crontab（Cron Table）是一種允許系統自動於特定時間執行特定的指令或腳本。這對於系統維護、備份、掃毒、記錄清理等任務非常有用。<br />
</p>

<p>
cron 是 Linux 內建的排程工具，而 crontab 則是每個使用者的排程表，記錄了使用者設置的定時任務。也就是說，如果你執行cron，它其實是去讀/etc/crontab這個設定檔，根據裡面的設定來工作<br />
</p>
</div>
<div id="outline-container-org565dd70" class="outline-3">
<h3 id="org565dd70"><span class="section-number-3">2.1.</span> crontab</h3>
<div class="outline-text-3" id="text-2-1">
<p>
crontab有兩種類型<br />
</p>
</div>
<div id="outline-container-org4320e54" class="outline-4">
<h4 id="org4320e54"><span class="section-number-4">2.1.1.</span> crontab 設定檔位置</h4>
<div class="outline-text-4" id="text-2-1-1">
</div>
<div id="outline-container-org1b1c5eb" class="outline-5">
<h5 id="org1b1c5eb">系統級的 cron 設定</h5>
<div class="outline-text-5" id="text-org1b1c5eb">
<ul class="org-ul">
<li>系統管理員可以透過 /etc/crontab 設定系統層級的定時任務。<br /></li>
<li>這個檔案允許指定 使用者帳號 來執行任務。<br /></li>
</ul>

<p>
範例 /etc/crontab 內容：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #dcaeea;">SHELL</span>=/bin/bash
<span class="linenr">2: </span><span style="color: #dcaeea;">PATH</span>=/sbin:/bin:/usr/sbin:/usr/bin
<span class="linenr">3: </span><span style="color: #dcaeea;">MAILTO</span>=root
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">3</span> * * * root /usr/local/bin/daily-task.sh
<span class="linenr">6: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#27599;&#26085;&#20940;&#26216; 3 &#40670;&#22519;&#34892; `/usr/local/bin/daily-task.sh`</span>
</pre>
</div>
<ul class="org-ul">
<li>這段 crontab 代表 每天凌晨 3 點 以 root 使用者執行 daily-task.sh。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org25416b6" class="outline-5">
<h5 id="org25416b6">個人使用者的 crontab 設定</h5>
<div class="outline-text-5" id="text-org25416b6">
<ul class="org-ul">
<li>每個使用者都可以透過 crontab -e 編輯自己的定時任務，這些設定會存放在 <i>var/spool/cron/crontabs</i> 目錄下，並由 cron 服務自動執行。<br /></li>
<li>這些個人排程 不需要 指定使用者名稱，因為它們是以當前使用者身份執行的。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org57ce079" class="outline-4">
<h4 id="org57ce079"><span class="section-number-4">2.1.2.</span> 如何使用 crontab</h4>
<div class="outline-text-4" id="text-2-1-2">
</div>
<div id="outline-container-org5affa1f" class="outline-5">
<h5 id="org5affa1f">編輯 crontab</h5>
<div class="outline-text-5" id="text-org5affa1f">
<p>
要設定或修改定時任務，使用：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>crontab -e
</pre>
</div>
<p>
這會開啟當前使用者的 crontab 設定檔（通常使用 vi 或 nano 編輯器）。<br />
</p>
</div>
</div>
<div id="outline-container-orgb966844" class="outline-5">
<h5 id="orgb966844">檢視目前的 crontab 設定</h5>
<div class="outline-text-5" id="text-orgb966844">
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>crontab -l
</pre>
</div>
<p>
這會顯示當前使用者的所有定時任務。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgcd62f17" class="outline-4">
<h4 id="orgcd62f17"><span class="section-number-4">2.1.3.</span> crontab 時間格式</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
crontab 的格式為 五個時間欄位 + 要執行的指令：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>&#20998;&#37912; &#23567;&#26178; &#26085; &#26376; &#26143;&#26399; &#25351;&#20196;
</pre>
</div>
<p>
每個欄位的數值範圍：<br />
</p>
<ul class="org-ul">
<li>分鐘（0 - 59）<br /></li>
<li>小時（0 - 23）<br /></li>
<li>日期（1 - 31）<br /></li>
<li>月份（1 - 12）<br /></li>
<li>星期（0 - 7，0 或 7 代表星期日）<br /></li>
<li>指令（要執行的命令或腳本的路徑）<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf796c8b" class="outline-4">
<h4 id="orgf796c8b"><span class="section-number-4">2.1.4.</span> crontab 排程範例</h4>
<div class="outline-text-4" id="text-2-1-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">任務</th>
<th scope="col" class="org-left">crontab 設定</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">每天凌晨 2:30 執行 /backup.sh</td>
<td class="org-left">30 2 * * * /backup.sh</td>
</tr>

<tr>
<td class="org-left">每週一凌晨 1:00 執行 /clean_temp.sh</td>
<td class="org-left">0 1 * * 1 /clean_temp.sh</td>
</tr>

<tr>
<td class="org-left">每 5 分鐘執行 /monitor.sh</td>
<td class="org-left">*/5 * * * * /monitor.sh</td>
</tr>

<tr>
<td class="org-left">每月 1 號凌晨 3:00 執行 /monthly_report.sh</td>
<td class="org-left">0 3 1 * * /monthly_report.sh</td>
</tr>

<tr>
<td class="org-left">只在 1 月 1 日執行 /new_year_task.sh</td>
<td class="org-left">0 0 1 1 * /new_year_task.sh</td>
</tr>
</tbody>
</table>

<p>
特殊符號<br />
</p>
<ul class="org-ul">
<li>*：代表「任何時間」，例如 * * * * * 表示「每分鐘都執行」。<br /></li>
<li>/：代表「每隔一段時間」，例如 */10 * * * * 表示「每 10 分鐘執行一次」。<br /></li>
<li>-：表示「範圍」，例如 0-5 10 * * * 表示「從 10:00 到 10:05，每分鐘執行一次」。<br /></li>
<li>,：代表「多個指定時間」，例如 0,15,30,45 * * * * 表示「每小時的 0、15、30、45 分執行」。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org825174b" class="outline-3">
<h3 id="org825174b"><span class="section-number-3">2.2.</span> 定期備份</h3>
<div class="outline-text-3" id="text-2-2">
<p>
預定在每週六凌晨2時以root身份執行bash /backup.sh，要如何編輯/etc/crontab<br />
</p>
</div>
<div id="outline-container-org07c7b66" class="outline-4">
<h4 id="org07c7b66"><span class="section-number-4">2.2.1.</span> 解</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">2</span> * * <span style="color: #da8548; font-weight: bold;">6</span> root bash /backup.sh
</pre>
</div>
<p>
解析這條 cron 規則：<br />
</p>
<ul class="org-ul">
<li>0 → 分鐘（0 分）<br /></li>
<li>2 → 小時（2 點）<br /></li>
<li>* → 日期（每天）<br /></li>
<li>* → 月份（每月）<br /></li>
<li>6 → 星期六（0 或 7 表示星期日）<br /></li>
<li>root → 以 root 身份執行<br /></li>
<li>bash /backup.sh → 執行 backup.sh 腳本<br /></li>
</ul>

<p>
前面的bash（Bourne Again SHell）是一種 指令直譯器（Shell），用來讓使用者與 Linux 作業系統互動。它是 GNU 計畫開發的 sh（Bourne Shell）的改進版，是目前大多數 Linux 發行版的預設 Shell。<br />
Bash 的主要功能<br />
</p>
<ul class="org-ul">
<li>執行指令（如 ls, cd, cp, rm）<br /></li>
<li>變數與環境管理<br /></li>
<li>程式控制（條件判斷、迴圈）<br /></li>
<li>管道與重導向<br /></li>
<li>Shell 腳本編寫（Automation &amp; Scripting）<br /></li>
</ul>

<p>
你可以把它看成Windows裡的shell，就是你打開終端機看到那個c:&gt;，你可以在終端機裡輸入dir之類的指令，那就檔案於windows裡的bash<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org738563a" class="outline-3">
<h3 id="org738563a"><span class="section-number-3">2.3.</span> 定期更新https證書</h3>
<div class="outline-text-3" id="text-2-3">
<p>
架網站須每偶數月的10號晚間10時30分以root身份輸入certbot renew以更新htts證書，如何編輯/etc/crontab<br />
</p>
</div>
<div id="outline-container-orgc6f2675" class="outline-4">
<h4 id="orgc6f2675"><span class="section-number-4">2.3.1.</span> 解</h4>
<div class="outline-text-4" id="text-2-3-1">
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #da8548; font-weight: bold;">30</span> <span style="color: #da8548; font-weight: bold;">22</span> <span style="color: #da8548; font-weight: bold;">10</span> 2,4,6,8,10,12 * root certbot renew
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">欄位</th>
<th scope="col" class="org-left">設定值</th>
<th scope="col" class="org-left">意義</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">分鐘（0 - 59）</td>
<td class="org-left">30</td>
<td class="org-left">在 30 分 執行</td>
</tr>

<tr>
<td class="org-left">小時（0 - 23）</td>
<td class="org-left">22</td>
<td class="org-left">在 22 點（晚間 10 點） 執行</td>
</tr>

<tr>
<td class="org-left">日期（1 - 31）</td>
<td class="org-left">10</td>
<td class="org-left">每月 10 號 執行</td>
</tr>

<tr>
<td class="org-left">月份（1 - 12）</td>
<td class="org-left">2,4,6,8,10,12</td>
<td class="org-left">只在 偶數月（2、4、6、8、10、12 月） 執行</td>
</tr>

<tr>
<td class="org-left">星期（0 - 7，0 或 7 代表星期日）</td>
<td class="org-left">*</td>
<td class="org-left">不限制星期</td>
</tr>

<tr>
<td class="org-left">使用者</td>
<td class="org-left">root</td>
<td class="org-left">以 root 身份執行</td>
</tr>

<tr>
<td class="org-left">指令</td>
<td class="org-left">certbot renew</td>
<td class="org-left">執行 certbot renew 更新 SSL 證書</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-orgaeb3176" class="outline-5">
<h5 id="orgaeb3176">Let&rsquo;s Encrypt</h5>
<div class="outline-text-5" id="text-orgaeb3176">
<p>
指令裡的certbot是Let&rsquo;s Encrypt提供的一個更新憑證指令，Let&rsquo;s Encrypt是一個 免費、自動化、開放 的 SSL/TLS 憑證（Certificate Authority, CA） 發行機構。它提供免費的 HTTPS 憑證，讓網站可以透過安全的 HTTPS 協議來加密資料，提升網站安全性。很多自己架網站的人都會用這個免費服務，有了這個東西，你的網站才會支援https，另一種選擇是花錢買，蠻貴的。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org980b462" class="outline-2">
<h2 id="org980b462"><span class="section-number-2">3.</span> 成大113計概</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgd9793e8" class="outline-3">
<h3 id="orgd9793e8"><span class="section-number-3">3.1.</span> A-I <code>[40%]</code> Multiple choice questions: (choose only ONE answer for a question; 4% for each question)</h3>
</div>
<div id="outline-container-org747fd54" class="outline-3">
<h3 id="org747fd54"><span class="section-number-3">3.2.</span> (1)</h3>
<div class="outline-text-3" id="text-3-2">
<p>
A framework is a collection of functions or modules that you can call from your code which dictates the<br />
flow of control in your application.<br />
</p>
<ol class="org-ol">
<li>True<br /></li>
<li>|False<br /></li>
</ol>
</div>
<div id="outline-container-org1b9238a" class="outline-4">
<h4 id="org1b9238a"><span class="section-number-4">3.2.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
答案：✅ a. True<br />
</p>
</div>
</div>
<div id="outline-container-org51807ec" class="outline-4">
<h4 id="org51807ec"><span class="section-number-4">3.2.2.</span> 詳解：</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
框架（Framework）:是一組可重複使用的程式碼結構，通常由多個模組（Modules）或函式（Functions）組成，並定義了應用程式的基本結構與流程控制方式。開發者可以在框架提供的結構內擴充功能，但主要的控制流程是由框架決定的，這與一般的函式庫（Library） 有所不同。<br />
</p>
</div>
<div id="outline-container-org4c38915" class="outline-5">
<h5 id="org4c38915">📌 框架與函式庫的區別</h5>
<div class="outline-text-5" id="text-org4c38915">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">框架（Framework）</th>
<th scope="col" class="org-left">函式庫（Library）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">控制反轉（Inversion of Control, IoC）</td>
<td class="org-left">框架控制應用程式的執行流程，開發者只需撰寫特定部分的程式碼，例如 Django、Spring</td>
<td class="org-left">開發者自行控制應用程式流程，函式庫只提供功能，例如 NumPy、Pandas</td>
</tr>

<tr>
<td class="org-left">擴展性</td>
<td class="org-left">提供明確的架構，開發者需依照框架規範撰寫程式</td>
<td class="org-left">單純提供工具函式，開發者可自由選擇如何使用</td>
</tr>

<tr>
<td class="org-left">學習成本</td>
<td class="org-left">通常較高，需了解框架規範</td>
<td class="org-left">較低，只需學習特定函式或類別</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org25d5226" class="outline-5">
<h5 id="org25d5226">📌 例子</h5>
<div class="outline-text-5" id="text-org25d5226">
<ul class="org-ul">
<li>框架（Framework）<br />
<ul class="org-ul">
<li>Django（Python 網頁開發框架）<br /></li>
<li>Spring（Java 企業級應用框架）<br /></li>
<li>React（JavaScript 前端 UI 框架）<br /></li>
</ul></li>
<li>函式庫（Library）<br />
<ul class="org-ul">
<li>NumPy（Python 科學計算函式庫）<br /></li>
<li>jQuery（JavaScript 操作 DOM 的函式庫）<br /></li>
<li>TensorFlow（機器學習函式庫）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org55fff48" class="outline-4">
<h4 id="org55fff48"><span class="section-number-4">3.2.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-2-3">
</div>
<div id="outline-container-org8e075af" class="outline-5">
<h5 id="org8e075af">1. 軟體開發方法學</h5>
<div class="outline-text-5" id="text-org8e075af">
<p>
1）瀑布模型（Waterfall Model）<br />
</p>
<ul class="org-ul">
<li>按照需求分析、設計、開發、測試、部署等線性階段進行，每個階段完成後才進入下一階段。<br /></li>
<li>優點：清楚的結構，適合需求穩定的專案。<br /></li>
<li>缺點：需求變更時成本高。<br /></li>
</ul>
<p>
2）敏捷開發（Agile Development）<br />
</p>
<ul class="org-ul">
<li>透過迭代（Iteration） 方式進行，每次開發小部分功能，並快速交付。<br /></li>
<li>常見方法：<br />
<ul class="org-ul">
<li>Scrum（短衝衝刺開發，每次迭代 2~4 週）<br /></li>
<li>Kanban（看板式開發，強調工作流可視化）<br /></li>
<li>Extreme Programming（XP，強調測試驅動開發）<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org22d112d" class="outline-5">
<h5 id="org22d112d">2. 軟體架構（Software Architecture）</h5>
<div class="outline-text-5" id="text-org22d112d">
<p>
1）單體架構（Monolithic Architecture）<br />
</p>
<ul class="org-ul">
<li>傳統的單體應用程式，所有功能都在同一個系統內。<br /></li>
<li>優點：開發與部署簡單。<br /></li>
<li>缺點：難以擴展，維護成本高。<br /></li>
</ul>
<p>
2）微服務架構（Microservices Architecture）<br />
</p>
<ul class="org-ul">
<li>系統被拆分成多個獨立的服務，每個服務負責單一職責。<br /></li>
<li>優點：擴展性高，可獨立部署。<br /></li>
<li>缺點：系統變得複雜，需要 API 管理與服務協調。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org024d309" class="outline-5">
<h5 id="org024d309">3. 物件導向程式設計（OOP）</h5>
<div class="outline-text-5" id="text-org024d309">
<p>
OOP 的四大特性<br />
</p>
<ol class="org-ol">
<li>封裝（Encapsulation）：將資料與方法封裝在類別（Class）內，保護內部狀態。<br /></li>
<li>繼承（Inheritance）：子類別（Subclass）可以繼承父類別（Superclass）的屬性和方法，減少程式碼重複。<br /></li>
<li>多型（Polymorphism）：相同方法可有不同實作，例如函式重載（Overloading）與函式覆寫（Overriding）。<br /></li>
<li>抽象（Abstraction）：定義介面（Interface），讓子類別自行實作。<br /></li>
<li>設計模式（Design Patterns）<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org3eae4fe" class="outline-4">
<h4 id="org3eae4fe"><span class="section-number-4">3.2.4.</span> 設計模式是解決程式設計問題的標準方法，常見類型如下：</h4>
<div class="outline-text-4" id="text-3-2-4">
<ol class="org-ol">
<li>創建型模式（Creational Patterns）<br />
<ul class="org-ul">
<li>單例模式（Singleton Pattern）： 確保類別只有一個實例，例如資料庫連線池。<br /></li>
<li>工廠模式（Factory Pattern）： 透過工廠方法建立物件，而不是直接使用 new。<br /></li>
</ul></li>
<li>結構型模式（Structural Patterns）<br />
<ul class="org-ul">
<li>裝飾者模式（Decorator Pattern）： 動態擴展物件功能，例如 Python 的 @decorator。<br /></li>
<li>代理模式（Proxy Pattern）： 控制對物件的訪問，例如網路代理伺服器。<br /></li>
</ul></li>
<li>行為型模式（Behavioral Patterns）<br />
<ul class="org-ul">
<li>觀察者模式（Observer Pattern）： 一個物件狀態改變時，通知所有觀察者，例如事件監聽機制。<br /></li>
<li>策略模式（Strategy Pattern）： 根據不同情境選擇不同的行為，例如支付方式選擇（信用卡、PayPal）。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org323c002" class="outline-4">
<h4 id="org323c002"><span class="section-number-4">3.2.5.</span> 版本控制（Git）: Git指令可以不用背，但你至少要知道Github在做什麼的</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
（1）Git 的基本指令<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">git init</td>
<td class="org-left">初始化 Git 儲存庫</td>
</tr>

<tr>
<td class="org-left">git clone</td>
<td class="org-left">複製遠端儲存庫</td>
</tr>

<tr>
<td class="org-left">git add</td>
<td class="org-left">將變更加入暫存區</td>
</tr>

<tr>
<td class="org-left">git commit -m &ldquo;訊息&rdquo;</td>
<td class="org-left">提交變更</td>
</tr>

<tr>
<td class="org-left">git push</td>
<td class="org-left">推送變更到遠端</td>
</tr>

<tr>
<td class="org-left">git pull</td>
<td class="org-left">拉取遠端變更</td>
</tr>

<tr>
<td class="org-left">git branch</td>
<td class="org-left">列出分支</td>
</tr>

<tr>
<td class="org-left">git merge</td>
<td class="org-left">合併分支</td>
</tr>
</tbody>
</table>
<p>
（2）分支策略<br />
</p>
<ul class="org-ul">
<li>Git Flow： 主要有 master、develop、feature、release、hotfix 分支。<br /></li>
<li>GitHub Flow： 只使用 main 和 feature 分支。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orged86d1a" class="outline-4">
<h4 id="orged86d1a"><span class="section-number-4">3.2.6.</span> 作業系統與程式開發</h4>
<div class="outline-text-4" id="text-3-2-6">
</div>
<div id="outline-container-org795dc67" class="outline-5">
<h5 id="org795dc67">記憶體管理</h5>
<div class="outline-text-5" id="text-org795dc67">
<ul class="org-ul">
<li>堆區（Heap）： 用於動態記憶體分配，如 malloc()（C）或 new（C++）。<br /></li>
<li>堆疊（Stack）： 儲存函式呼叫的區域變數。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1674771" class="outline-5">
<h5 id="org1674771">行程與執行緒</h5>
<div class="outline-text-5" id="text-org1674771">
<ul class="org-ul">
<li>行程（Process）： 獨立執行的應用程式，擁有自己的記憶體空間。<br /></li>
<li>執行緒（Thread）： 行程內的輕量級執行單位，共享記憶體。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgca3ce8b" class="outline-4">
<h4 id="orgca3ce8b"><span class="section-number-4">3.2.7.</span> 前後端技術</h4>
<div class="outline-text-4" id="text-3-2-7">
</div>
<div id="outline-container-org2a2209d" class="outline-5">
<h5 id="org2a2209d">前端技術</h5>
<div class="outline-text-5" id="text-org2a2209d">
<ul class="org-ul">
<li>HTML、CSS、JavaScript<br /></li>
<li>前端框架：React、Vue.js、Angular<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org02d27ba" class="outline-5">
<h5 id="org02d27ba">後端技術</h5>
<div class="outline-text-5" id="text-org02d27ba">
<ul class="org-ul">
<li>Django（Python）<br /></li>
<li>Spring Boot（Java）<br /></li>
<li>Express.js（Node.js）<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org0508fa1" class="outline-3">
<h3 id="org0508fa1"><span class="section-number-3">3.3.</span> (2)</h3>
<div class="outline-text-3" id="text-3-3">
<p>
A system analyst depicts the static view of an information system with<br />
</p>
<ol class="org-ol">
<li>use-case models<br /></li>
<li>structural models<br /></li>
<li>behavioral models<br /></li>
<li>state chart diagrams<br /></li>
</ol>
</div>
<div id="outline-container-orge091eaa" class="outline-4">
<h4 id="orge091eaa"><span class="section-number-4">3.3.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
答案：✅ b. Structural Models（結構模型）<br />
</p>
</div>
</div>
<div id="outline-container-orga8c42a3" class="outline-4">
<h4 id="orga8c42a3"><span class="section-number-4">3.3.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-3-2">
</div>
<div id="outline-container-org2676a0d" class="outline-5">
<h5 id="org2676a0d">📌 靜態視圖（Static View）</h5>
<div class="outline-text-5" id="text-org2676a0d">
<p>
在資訊系統分析與設計中，靜態視圖 描述的是系統中物件（Objects）、類別（Classes）、關係（Relationships）與結構（Structure），而不是系統的動態行為。它側重於系統的組成元素及其關係，例如類別與屬性、關聯、繼承結構等。<br />
</p>
</div>
</div>
<div id="outline-container-org978f813" class="outline-5">
<h5 id="org978f813">📌 結構模型（Structural Model）</h5>
<div class="outline-text-5" id="text-org978f813">
<p>
結構模型是專門用來表示系統的靜態視圖，它通常由 UML（統一建模語言） 中的類別圖（Class Diagram）、物件圖（Object Diagram）和組件圖（Component Diagram） 等組成。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">模型類型</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">類別圖（Class Diagram）</td>
<td class="org-left">描述系統中的類別、屬性、方法及它們之間的關係（例如繼承、關聯）。</td>
</tr>

<tr>
<td class="org-left">物件圖（Object Diagram）</td>
<td class="org-left">類似類別圖，但側重於某一特定時間點的具體物件實例。</td>
</tr>

<tr>
<td class="org-left">組件圖（Component Diagram）</td>
<td class="org-left">描述系統的模組化結構，顯示各個組件之間的相互依賴關係。</td>
</tr>
</tbody>
</table>
<p>
這些結構模型都屬於靜態建模，因此正確答案為 b. Structural Models（結構模型）。<br />
</p>
</div>
</div>
<div id="outline-container-org51333b2" class="outline-5">
<h5 id="org51333b2">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-org51333b2">
<ol class="org-ol">
<li>Use-case models（用例模型）<br />
<ul class="org-ul">
<li>用例模型 用於描述系統的 功能需求，關注系統如何與外部使用者或其他系統互動。<br /></li>
<li>主要使用 用例圖（Use Case Diagram） 來顯示不同使用者（Actors）與系統的互動關係。<br /></li>
<li>屬於動態視圖的一部分，因此不是本題的正確答案。<br /></li>
</ul></li>
<li><p>
Behavioral models（行為模型）<br />
行為模型 描述系統的動態行為，即系統如何隨時間變化。<br />
主要包含：<br />
</p>
<ul class="org-ul">
<li>活動圖（Activity Diagram）：描述業務流程。<br /></li>
<li>序列圖（Sequence Diagram）：描述物件之間的訊息交換。<br /></li>
<li>協作圖（Collaboration Diagram）：顯示物件如何協同工作。<br /></li>
</ul>
<p>
屬於動態視圖，因此不是正確答案。<br />
</p></li>
<li>State chart diagrams（狀態圖）<br />
<ul class="org-ul">
<li>狀態圖（State Chart Diagram） 描述系統或物件的狀態變化過程，適用於需要管理狀態的應用（如 ATM 交易流程）。<br /></li>
<li>主要用於 行為建模（Behavioral Modeling），屬於 動態視圖，所以不是正確答案。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org308eab4" class="outline-4">
<h4 id="org308eab4"><span class="section-number-4">3.3.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-3-3">
</div>
<div id="outline-container-orgc0cb43e" class="outline-5">
<h5 id="orgc0cb43e">1. 系統開發生命週期（SDLC, Software Development Life Cycle）</h5>
<div class="outline-text-5" id="text-orgc0cb43e">
<p>
系統分析師（System Analyst）負責系統開發過程中的需求分析、設計與建模，以下是 SDLC 主要階段：<br />
</p>
<ul class="org-ul">
<li>需求分析（Requirement Analysis）<br />
<ul class="org-ul">
<li>確定系統需求，例如功能需求、非功能需求（效能、安全性）。<br /></li>
<li>建立用例模型（Use Case Model） 描述使用者需求。<br /></li>
</ul></li>
<li>系統設計（System Design）<br />
<ul class="org-ul">
<li>進行系統架構設計，通常包括：<br />
<ul class="org-ul">
<li>靜態視圖（Static View）（結構模型）<br /></li>
<li>動態視圖（Dynamic View）（行為模型）<br /></li>
</ul></li>
<li>主要使用 UML 類別圖、物件圖、組件圖 來描述靜態結構。<br /></li>
</ul></li>
<li>系統開發（Implementation）<br />
<ul class="org-ul">
<li>依據設計的架構撰寫程式碼，並確保其符合設計規範。<br /></li>
</ul></li>
<li>測試與驗證（Testing &amp; Validation）<br />
<ul class="org-ul">
<li>透過單元測試、整合測試、系統測試來驗證系統功能。<br /></li>
</ul></li>
<li>部署與維護（Deployment &amp; Maintenance）<br />
<ul class="org-ul">
<li>系統上線後的優化與錯誤修復。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd2c1552" class="outline-5">
<h5 id="orgd2c1552">2. UML（Unified Modeling Language，統一建模語言）</h5>
<div class="outline-text-5" id="text-orgd2c1552">
<p>
UML 是系統分析師在系統建模時最常用的工具，主要分為 靜態模型與動態模型。<br />
</p>
<ol class="org-ol">
<li>靜態模型（Static Models）<br />
<ul class="org-ul">
<li>類別圖（Class Diagram）：描述系統的類別、屬性、方法與關係。<br /></li>
<li>物件圖（Object Diagram）：顯示特定時間點的物件實例。<br /></li>
<li>組件圖（Component Diagram）：顯示系統的模組化結構。<br /></li>
</ul></li>
<li>動態模型（Dynamic Models）<br />
<ul class="org-ul">
<li>用例圖（Use Case Diagram）：描述使用者與系統的互動。<br /></li>
<li>活動圖（Activity Diagram）：描述業務流程。<br /></li>
<li>狀態圖（State Chart Diagram）：描述物件的狀態變化。<br /></li>
<li>序列圖（Sequence Diagram）：顯示物件之間的訊息交換。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgf669148" class="outline-5">
<h5 id="orgf669148">3. 面向物件設計（OOD, Object-Oriented Design）</h5>
<div class="outline-text-5" id="text-orgf669148">
<p>
在面向物件系統分析與設計（OOAD）中，靜態模型與動態模型的結合是關鍵：<br />
</p>
<ul class="org-ul">
<li>靜態視圖（Static View） → 面向物件分析（OOA）：<br />
<ul class="org-ul">
<li>使用 類別圖 來識別系統的類別與關係。<br /></li>
</ul></li>
<li>動態視圖（Dynamic View） → 面向物件設計（OOD）：<br />
<ul class="org-ul">
<li>使用 狀態圖、序列圖 來設計系統行為。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd48da9a" class="outline-5">
<h5 id="orgd48da9a">4. 系統建模工具</h5>
<div class="outline-text-5" id="text-orgd48da9a">
<p>
常見的 UML 建模工具：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">工具名稱</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">StarUML</td>
<td class="org-left">開源 UML 建模工具</td>
</tr>

<tr>
<td class="org-left">Enterprise Architect</td>
<td class="org-left">專業 UML 建模工具，支援大型專案</td>
</tr>

<tr>
<td class="org-left">Visual Paradigm</td>
<td class="org-left">支援 UML 與業務流程建模（BPMN）</td>
</tr>

<tr>
<td class="org-left">IBM Rational Rose</td>
<td class="org-left">早期 UML 設計工具，現已逐漸被取代</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org1a65546" class="outline-5">
<h5 id="org1a65546">5. 資訊系統建模的應用領域</h5>
<div class="outline-text-5" id="text-org1a65546">
<p>
系統建模不僅用於軟體開發，也可應用於 企業流程管理（BPM） 和 數據庫設計。<br />
</p>
<ul class="org-ul">
<li>ERP 系統建模：使用 UML 設計企業內部資訊系統。<br /></li>
<li>資料庫設計（Database Design）：透過 ER 圖（Entity-Relationship Diagram）來設計數據結構。<br /></li>
<li>商業流程管理（BPMN）：使用 BPMN 模型來設計業務流程。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf5f6994" class="outline-5">
<h5 id="orgf5f6994">📌 總結</h5>
<div class="outline-text-5" id="text-orgf5f6994">
<ul class="org-ul">
<li>靜態視圖（Static View） 用於描述系統的結構與關係，通常使用 結構模型（Structural Models） 來表示，例如 類別圖、物件圖、組件圖。<br /></li>
<li>系統分析師（System Analyst） 需要使用 UML 建模 來描述系統的靜態與動態行為。<br /></li>
<li>本題的正確答案是： ✅ b. Structural Models（結構模型），因為它專門用於描述系統的靜態結構。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfab3176" class="outline-3">
<h3 id="orgfab3176"><span class="section-number-3">3.4.</span> (3)</h3>
<div class="outline-text-3" id="text-3-4">
<p>
<span class="underline"><span class="underline">__</span></span> means having the ability to call the same method on different objects, which can be interpreted<br />
differently by different objects.<br />
</p>
<ol class="org-ol">
<li>Encapsulation<br /></li>
<li>Inheritance<br /></li>
<li>Coupling<br /></li>
<li>Polymorphism<br /></li>
</ol>
</div>
<div id="outline-container-org2d3c491" class="outline-4">
<h4 id="org2d3c491"><span class="section-number-4">3.4.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
答案：✅ d. Polymorphism（多型）<br />
</p>
</div>
</div>
<div id="outline-container-orgaa1868e" class="outline-4">
<h4 id="orgaa1868e"><span class="section-number-4">3.4.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-4-2">
</div>
<div id="outline-container-orgfda4223" class="outline-5">
<h5 id="orgfda4223">📌 多型（Polymorphism）</h5>
<div class="outline-text-5" id="text-orgfda4223">
<p>
多型是物件導向程式設計（OOP）的核心概念之一，指的是相同的方法在不同的物件上可以有不同的行為。這使得程式更具彈性與擴展性，因為相同的介面可以被不同類別實作。<br />
</p>
</div>
</div>
<div id="outline-container-orgacac6c6" class="outline-5">
<h5 id="orgacac6c6">📌 兩種主要的多型類型</h5>
<div class="outline-text-5" id="text-orgacac6c6">
<p>
編譯時多型（Compile-time Polymorphism）<br />
</p>
<ul class="org-ul">
<li>方法重載（Method Overloading）：在同一個類別中，可以有多個名稱相同但參數不同的方法。<br /></li>
<li>範例（Java）：<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">class</span> MathUtil {
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">add</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> b) {
<span class="linenr">3: </span>        <span style="color: #51afef;">return</span> a + b;
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>    <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">add</span>(<span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">double</span> b) {
<span class="linenr">6: </span>        <span style="color: #51afef;">return</span> a + b;
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>}
</pre>
</div>

<p>
這裡的 add() 方法有兩個版本，根據傳入的參數類型自動選擇適合的方法。<br />
</p>

<p>
執行時多型（Runtime Polymorphism）<br />
</p>

<p>
方法覆寫（Method Overriding）：子類別可以重新定義父類別的方法。<br />
範例（Python）：<br />
#+begin_src python -r -n :results output :exports both<br />
    class Animal:<br />
        def make_sound(self):<br />
            pass<br />
 class Dog(Animal):<br />
        def make_sound(self):<br />
            return &ldquo;Woof!&rdquo;<br />
 class Cat(Animal):<br />
        def make_sound(self):<br />
            return &ldquo;Meow!&rdquo;<br />
 animals = [Dog(), Cat()]<br />
    for animal in animals:<br />
        print(animal.make_sound())  # 依據物件類型呼叫不同的 make_sound 方法<br />
nd_src<br />
</p>
</div>
</div>
<div id="outline-container-orgf1bb77b" class="outline-5">
<h5 id="orgf1bb77b">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-orgf1bb77b">
<ol class="org-ol">
<li>Encapsulation（封裝）<br />
<ul class="org-ul">
<li>透過 private、protected、public 控制存取權限，確保資料不被任意修改。<br /></li>
<li>錯誤，因為封裝主要與資料保護有關，與方法的多型行為無關。<br /></li>
</ul></li>
<li>Inheritance（繼承）<br />
<ul class="org-ul">
<li>子類別繼承父類別的屬性和方法，實現程式碼重用。<br /></li>
<li>錯誤，因為繼承只是讓子類別獲得父類別的屬性與行為，並不能解釋相同方法的不同行為。<br /></li>
</ul></li>
<li>Coupling（耦合）<br />
<ul class="org-ul">
<li>模組或類別之間的依賴程度，高耦合意味著系統的維護難度增加。<br /></li>
<li>錯誤，因為多型與降低耦合有關，但它本身不是描述物件如何表現不同行為的概念。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org6606236" class="outline-5">
<h5 id="org6606236">📌 依近10年命題格式，參考新興技術，設計一份今年的考題</h5>
<div class="outline-text-5" id="text-org6606236">
<ol class="org-ol">
<li>在物件導向程式設計中，當一個類別的方法可以根據不同的子類別對象表現出不同的行為時，這種特性稱為：<br />
<ol class="org-ol">
<li>Abstraction（抽象）<br /></li>
<li>Polymorphism（多型）<br /></li>
<li>Encapsulation（封裝）<br /></li>
<li>Dependency Injection（相依性注入）<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：b. Polymorphism（多型）<br />
</p>

<ol class="org-ol">
<li>近年來 AI 影像辨識技術（如 YOLO、ViT）需要處理大量圖像數據，這通常使用哪種機器學習架構？<br />
<ol class="org-ol">
<li>CNN（卷積神經網路）<br /></li>
<li>RNN（循環神經網路）<br /></li>
<li>KNN（最近鄰演算法）<br /></li>
<li>Decision Tree（決策樹）<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：a. CNN（卷積神經網路）<br />
</p>

<ol class="org-ol">
<li>在 Kubernetes（K8s）環境中，哪個元件負責管理容器的生命周期？<br />
<ol class="org-ol">
<li>Pod<br /></li>
<li>Node<br /></li>
<li>Kubelet<br /></li>
<li>Ingress<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：c. Kubelet<br />
</p>

<ol class="org-ol">
<li>在區塊鏈技術中，哪種機制最常用來確保交易安全性與共識機制？<br />
<ol class="org-ol">
<li>Proof of Work（PoW）<br /></li>
<li>Proof of Authority（PoA）<br /></li>
<li>Proof of Stake（PoS）<br /></li>
<li>Byzantine Fault Tolerance（BFT）<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：a. Proof of Work（PoW）（例如比特幣）<br />
</p>

<ol class="org-ol">
<li>在 Web3.0 應用程式中，去中心化應用（DApp）通常使用什麼技術來運行智能合約？<br />
<ol class="org-ol">
<li>Solidity<br /></li>
<li>TypeScript<br /></li>
<li>Python<br /></li>
<li>C++<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：a. Solidity（以太坊智能合約的主要語言）<br />
</p>

<ol class="org-ol">
<li>在現代網路安全攻擊中，哪種攻擊方法主要透過社交工程來獲取機密資訊？<br />
<ol class="org-ol">
<li>SQL Injection<br /></li>
<li>Phishing（網路釣魚）<br /></li>
<li>Man-in-the-Middle Attack（中間人攻擊）<br /></li>
<li>Ransomware（勒索軟體）<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：b. Phishing（網路釣魚）<br />
</p>

<ol class="org-ol">
<li>在資料科學中，哪種方法最適合用來處理高維度資料降維？<br />
<ol class="org-ol">
<li>PCA（主成分分析）<br /></li>
<li>K-Means（K均值聚類）<br /></li>
<li>Apriori（關聯規則演算法）<br /></li>
<li>BFS（廣度優先搜尋）<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：a. PCA（主成分分析）<br />
</p>

<ol class="org-ol">
<li>在作業系統中，哪種排程演算法最能確保即時系統的效能？<br />
<ol class="org-ol">
<li>FCFS（先來先服務）<br /></li>
<li>Round Robin（時間片輪轉）<br /></li>
<li>Shortest Job Next（最短作業優先）<br /></li>
<li>Priority Scheduling（優先權排程）<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：d. Priority Scheduling（優先權排程）<br />
</p>

<ol class="org-ol">
<li>在 Docker 容器技術中，哪個指令用來建立新的容器？<br />
<ol class="org-ol">
<li>docker pull<br /></li>
<li>docker run<br /></li>
<li>docker build<br /></li>
<li>docker commit<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：b. docker run<br />
</p>

<ol class="org-ol">
<li>在機器學習模型的訓練過程中，使用 Dropout 的主要目的是什麼？<br />
<ol class="org-ol">
<li>增加模型計算效能<br /></li>
<li>減少過擬合（Overfitting）<br /></li>
<li>提高訓練速度<br /></li>
<li>減少參數數量<br /></li>
</ol></li>
</ol>
<p>
✅ 答案：b. 減少過擬合（Overfitting）<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org3f9b46b" class="outline-3">
<h3 id="org3f9b46b"><span class="section-number-3">3.5.</span> (4)</h3>
<div class="outline-text-3" id="text-3-5">
<p>
What are the two types of coupling in object-oriented systems?<br />
</p>
<ol class="org-ol">
<li>interaction, data<br /></li>
<li>data, inheritance<br /></li>
<li>interaction, inheritance<br /></li>
<li>inheritance, polymorphism<br /></li>
</ol>
</div>
<div id="outline-container-org7454542" class="outline-4">
<h4 id="org7454542"><span class="section-number-4">3.5.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
答案：✅ a. interaction, data（互動耦合、資料耦合）<br />
</p>
</div>
</div>
<div id="outline-container-org6c2f849" class="outline-4">
<h4 id="org6c2f849"><span class="section-number-4">3.5.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-5-2">
</div>
<div id="outline-container-org214dc1a" class="outline-5">
<h5 id="org214dc1a">📌 耦合（Coupling）</h5>
<div class="outline-text-5" id="text-org214dc1a">
<p>
在物件導向設計（OOD）中，耦合 指的是模組（Module）或類別（Class）之間的依賴程度。<br />
</p>
<ul class="org-ul">
<li>高耦合（High Coupling）：表示系統的組件緊密依賴，維護和擴展困難。<br /></li>
<li>低耦合（Low Coupling）：表示組件之間的關聯較少，有助於提高可維護性和可擴展性。<br /></li>
</ul>
<p>
耦合類型主要分為：<br />
</p>
<ul class="org-ul">
<li>互動耦合（Interaction Coupling）：指物件之間的相互關聯程度，通常涉及訊息傳遞（Method Calls）。<br /></li>
<li>資料耦合（Data Coupling）：指物件共享的資料程度，數據越少則耦合度越低。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd48aedc" class="outline-5">
<h5 id="orgd48aedc">📌 兩種主要的耦合類型</h5>
<div class="outline-text-5" id="text-orgd48aedc">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">耦合類型</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">互動耦合（Interaction Coupling）</td>
<td class="org-left">物件之間透過方法呼叫來互動</td>
<td class="org-left">適度的互動耦合是正常的，但過度互動會導致系統緊密相依</td>
</tr>

<tr>
<td class="org-left">資料耦合（Data Coupling）</td>
<td class="org-left">物件之間共享數據的方式</td>
<td class="org-left">數據共享應保持最小，以降低模組之間的相依性</td>
</tr>
</tbody>
</table>
<p>
例子<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2bdeef6"></a>✅ 良好的互動耦合<br />
<div class="outline-text-6" id="text-org2bdeef6">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Car</span>:
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">def</span> __init__(self, engine):
<span class="linenr"> 3: </span>        self.engine = engine
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    def start(self):
<span class="linenr"> 6: </span>        self.engine.run()
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Engine</span>:
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">def</span> run(self):
<span class="linenr">10: </span>        print(<span style="color: #98be65;">"Engine is running"</span>)
<span class="linenr">11: </span>
<span class="linenr">12: </span>engine = Engine()
<span class="linenr">13: </span>car = Car(engine)
<span class="linenr">14: </span>car.start()
</pre>
</div>
<p>
車（Car）與引擎（Engine）透過方法互動，維持合理的耦合關係。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9491472" class="outline-5">
<h5 id="org9491472">❌ 過高的資料耦合</h5>
<div class="outline-text-5" id="text-org9491472">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Data</span>:
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">shared_data</span> = <span style="color: #98be65;">"Global State"</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #51afef;">class</span> ComponentA:
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">def</span> print_data(self):
<span class="linenr"> 6: </span>        print(Data.shared_data)
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">ComponentB</span>:
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">def</span> modify_data(self, new_data):
<span class="linenr">10: </span>        Data.shared_data = new_data
<span class="linenr">11: </span>
<span class="linenr">12: </span>a = ComponentA()
<span class="linenr">13: </span>b = ComponentB()
<span class="linenr">14: </span>b.modify_data(<span style="color: #98be65;">"Changed Data"</span>)
<span class="linenr">15: </span>a.print_data()  # Output: Changed Data
<span class="linenr">16: </span>
</pre>
</div>
<p>
所有模組都直接存取共享變數 Data.shared_data，增加系統的耦合性與錯誤風險。<br />
</p>
</div>
</div>
<div id="outline-container-org56f96ee" class="outline-5">
<h5 id="org56f96ee">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-org56f96ee">
<ol class="org-ol">
<li>data, inheritance（資料耦合、繼承） ❌<br />
資料耦合是正確的，但繼承（Inheritance）不是耦合類型，而是 OOP 的一種機制。<br /></li>
<li>interaction, inheritance（互動耦合、繼承） ❌<br />
互動耦合是正確的，但繼承並不屬於耦合類型。<br /></li>
<li>inheritance, polymorphism（繼承、多型） ❌<br />
繼承（Inheritance）和多型（Polymorphism）是 OOP 的概念，而不是耦合類型。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org10e2961" class="outline-4">
<h4 id="org10e2961"><span class="section-number-4">3.5.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-5-3">
</div>
<div id="outline-container-org940ee1e" class="outline-5">
<h5 id="org940ee1e">1. 物件導向程式設計（OOP）核心概念</h5>
<div class="outline-text-5" id="text-org940ee1e">
<p>
物件導向的四大特性：<br />
封裝（Encapsulation） - 保護內部資料，降低耦合。<br />
繼承（Inheritance） - 允許子類別重用父類別的功能。<br />
多型（Polymorphism） - 相同方法可在不同類別中表現不同行為。<br />
抽象（Abstraction） - 只暴露必要的細節，減少不必要的依賴。<br />
</p>
</div>
</div>
<div id="outline-container-org9523164" class="outline-5">
<h5 id="org9523164">2. 耦合與內聚（Cohesion）</h5>
<div class="outline-text-5" id="text-org9523164">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">概念</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">耦合（Coupling）</td>
<td class="org-left">類別或模組之間的相依性</td>
<td class="org-left">高耦合降低系統靈活性</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">內聚（Cohesion）</td>
<td class="org-left">類別或模組內部功能的相關性</td>
<td class="org-left">高內聚增加系統可維護性</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
良好的設計應該低耦合、高內聚！<br />
</p>
</div>
</div>
<div id="outline-container-orgcf42a97" class="outline-5">
<h5 id="orgcf42a97">3. 其他耦合類型</h5>
<div class="outline-text-5" id="text-orgcf42a97">
<p>
除了互動耦合與資料耦合，其他常見耦合類型：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">類型</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">耦合強度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">內容耦合（Content Coupling）</td>
<td class="org-left">一個模組直接修改或存取另一個模組的內部變數</td>
<td class="org-left">🚨最糟糕</td>
</tr>

<tr>
<td class="org-left">公共耦合（Common Coupling）</td>
<td class="org-left">多個模組共用全域變數</td>
<td class="org-left">❌ 應避免</td>
</tr>

<tr>
<td class="org-left">控制耦合（Control Coupling）</td>
<td class="org-left">一個模組影響另一個模組的流程控制</td>
<td class="org-left">⚠ 應減少</td>
</tr>

<tr>
<td class="org-left">標記耦合（Stamp Coupling）</td>
<td class="org-left">模組之間傳遞結構化數據</td>
<td class="org-left">✅ 較好</td>
</tr>

<tr>
<td class="org-left">無耦合（No Coupling）</td>
<td class="org-left">模組之間完全獨立</td>
<td class="org-left">🔥 最佳情況</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgcc8bd16" class="outline-5">
<h5 id="orgcc8bd16">4. 減少耦合的方法</h5>
<div class="outline-text-5" id="text-orgcc8bd16">
<ul class="org-ul">
<li>使用介面（Interface）或抽象類別 來降低相依性。<br /></li>
<li>避免全域變數，使用方法傳遞參數代替。<br /></li>
<li>設計鬆耦合架構（如 MVC 模式）。<br /></li>
<li>依賴注入（Dependency Injection, DI），讓物件不直接依賴特定類別。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org18bc3ab" class="outline-5">
<h5 id="org18bc3ab">5. 耦合在現代技術中的應用</h5>
<div class="outline-text-5" id="text-org18bc3ab">
<ol class="org-ol">
<li>微服務架構（Microservices Architecture）<br />
<ul class="org-ul">
<li>低耦合、高內聚 的設計，透過 API 進行通訊，確保各個微服務獨立運行。<br /></li>
<li>例如：Amazon、Netflix 使用微服務架構來提升系統擴展性。<br /></li>
</ul></li>
<li>前後端分離（Frontend-Backend Decoupling）<br />
<ul class="org-ul">
<li>透過 REST API 或 GraphQL 讓前端與後端低耦合，提升開發靈活性。<br /></li>
<li>例如：React + Flask 組合，前端與後端透過 API 互動，互不影響。<br /></li>
</ul></li>
</ol>
<p>
1, 雲端架構與 Serverless<br />
</p>
<ul class="org-ul">
<li>AWS Lambda、Google Cloud Functions 等無伺服器架構允許獨立運行函數，減少系統耦合。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7282e52" class="outline-5">
<h5 id="org7282e52">📌 總結</h5>
<div class="outline-text-5" id="text-org7282e52">
<ul class="org-ul">
<li>耦合（Coupling） 代表物件之間的相依程度，應該降低耦合，提高內聚。<br /></li>
<li>主要有 互動耦合（Interaction Coupling）與資料耦合（Data Coupling），它們描述了物件之間的方法與數據的依賴方式。<br /></li>
<li>本題正確答案為： ✅ a. interaction, data（互動耦合、資料耦合）。<br /></li>
<li>在軟體工程與現代架構（如微服務、雲端）中，設計低耦合系統是提升維護性與可擴展性的關鍵。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org72b5b98" class="outline-3">
<h3 id="org72b5b98"><span class="section-number-3">3.6.</span> (5)</h3>
<div class="outline-text-3" id="text-3-6">
<p>
<span class="underline"><span class="underline">_</span></span> is a specific methodology that maps out when and how to use the various Unified Modeling<br />
Language (UML) techniques for object-oriented analysis and design<br />
</p>
<ol class="org-ol">
<li>Prototyping<br /></li>
<li>Waterfall<br /></li>
<li>Scrum<br /></li>
<li>Unified Process<br /></li>
</ol>
</div>
<div id="outline-container-org2b1f73d" class="outline-4">
<h4 id="org2b1f73d"><span class="section-number-4">3.6.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
答案：✅ d. Unified Process（統一流程，UP）<br />
</p>
</div>
</div>
<div id="outline-container-org90d9af6" class="outline-4">
<h4 id="org90d9af6"><span class="section-number-4">3.6.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-6-2">
</div>
<div id="outline-container-org666f76e" class="outline-5">
<h5 id="org666f76e">📌 統一流程（Unified Process, UP）</h5>
<div class="outline-text-5" id="text-org666f76e">
<p>
統一流程（UP） 是一種基於 UML（統一建模語言） 的物件導向軟體開發方法學。它提供了一個結構化的方法，來規範 何時、如何使用 UML 技術來進行物件導向分析與設計（OOAD）。<br />
</p>

<p>
統一流程的核心特點：<br />
</p>
<ul class="org-ul">
<li>以模型為中心（Model-Driven）<br />
<ul class="org-ul">
<li>使用 UML 進行系統分析與設計。<br /></li>
<li>包括**用例圖（Use Case Diagram）、類別圖（Class Diagram）、活動圖（Activity Diagram）、狀態圖（State Diagram）**等。<br /></li>
</ul></li>
<li>以迭代為基礎（Iterative and Incremental）<br />
<ul class="org-ul">
<li>不像傳統的瀑布模型（Waterfall）一次性完成所有階段，UP 採取 漸進式開發，允許在多個迭代中逐步完善系統。<br /></li>
</ul></li>
<li>風險導向（Risk-Driven）<br />
<ul class="org-ul">
<li>優先解決高風險的設計與技術問題，減少專案後期的變更成本。<br /></li>
</ul></li>
<li>以架構為基礎（Architecture-Centric）<br />
<ul class="org-ul">
<li>強調軟體架構，確保系統具有良好的可維護性與擴展性。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org29f65d6" class="outline-5">
<h5 id="org29f65d6">📌 統一流程（UP）四個主要階段</h5>
<div class="outline-text-5" id="text-org29f65d6">
<ol class="org-ol">
<li>初始階段（Inception Phase）<br />
<ul class="org-ul">
<li>確定專案範圍與目標<br /></li>
<li>定義主要需求與風險<br /></li>
<li>建立用例圖（Use Case Diagram），幫助理解系統需求<br /></li>
<li>產出：<br />
<ul class="org-ul">
<li>初步的商業案例（Business Case）<br /></li>
<li>初步的需求規格（Requirement Specification）<br /></li>
</ul></li>
</ul></li>
<li>精煉階段（Elaboration Phase）<br />
<ul class="org-ul">
<li>進一步分析需求與系統架構<br /></li>
<li>確定系統的關鍵技術挑戰與解決方案<br /></li>
<li>產出：<br />
<ul class="org-ul">
<li>類別圖（Class Diagram）<br /></li>
<li>活動圖（Activity Diagram）<br /></li>
<li>序列圖（Sequence Diagram）<br /></li>
<li>早期的系統原型（Prototype）<br /></li>
</ul></li>
</ul></li>
<li>建構階段（Construction Phase）<br />
<ul class="org-ul">
<li>系統實際開發<br /></li>
<li>持續測試與整合<br /></li>
<li>產出：<br />
<ul class="org-ul">
<li>可執行的軟體版本<br /></li>
<li>系統測試報告<br /></li>
<li>最終 UML 模型<br /></li>
</ul></li>
</ul></li>
<li>移交階段（Transition Phase）<br />
<ul class="org-ul">
<li>進行最終測試與優化<br /></li>
<li>系統部署與維護<br /></li>
<li>培訓使用者與技術團隊<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org30bf7b0" class="outline-5">
<h5 id="org30bf7b0">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-org30bf7b0">
<ol class="org-ol">
<li>Prototyping（原型法） ❌<br />
<ul class="org-ul">
<li>主要用於快速建立系統雛型，並不是特定的 UML 方法論。<br /></li>
<li>強調快速試作，但不像 UP 有完整的開發流程。<br /></li>
</ul></li>
<li>Waterfall（瀑布模型） ❌<br />
<ul class="org-ul">
<li>線性開發流程，從需求分析到設計、開發、測試一次完成，不支援迭代開發。<br /></li>
<li>不適合變更頻繁的專案，與 UML 的物件導向方法不完全匹配。<br /></li>
</ul></li>
<li>Scrum（敏捷開發方法） ❌<br />
<ul class="org-ul">
<li>敏捷開發（Agile Development）的一種框架，強調小組協作與短期衝刺（Sprint）。<br /></li>
<li>Scrum 沒有明確規範 UML 的使用方式，與 UP 在設計細節上的規範不同。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgd260631" class="outline-4">
<h4 id="orgd260631"><span class="section-number-4">3.6.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-6-3">
<ol class="org-ol">
<li>軟體開發方法學<br /></li>
</ol>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法論</th>
<th scope="col" class="org-left">特色</th>
<th scope="col" class="org-left">適用場景</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">瀑布模型（Waterfall Model）</td>
<td class="org-left">線性、階段性開發</td>
<td class="org-left">需求穩定、不易變更的專案</td>
</tr>

<tr>
<td class="org-left">統一流程（Unified Process, UP）</td>
<td class="org-left">以 UML 為核心、迭代開發</td>
<td class="org-left">物件導向、大型軟體專案</td>
</tr>

<tr>
<td class="org-left">敏捷開發（Agile Development）</td>
<td class="org-left">快速迭代、適應變更</td>
<td class="org-left">需求變動頻繁的專案</td>
</tr>

<tr>
<td class="org-left">極限編程（Extreme Programming, XP）</td>
<td class="org-left">測試驅動、持續整合</td>
<td class="org-left">小型開發團隊</td>
</tr>

<tr>
<td class="org-left">Scrum</td>
<td class="org-left">短期衝刺、任務拆解</td>
<td class="org-left">敏捷開發專案</td>
</tr>
</tbody>
</table>
<ol class="org-ol">
<li>UML（Unified Modeling Language）<br /></li>
</ol>
<p>
UML 是軟體開發的標準建模語言，統一流程（UP）廣泛使用 UML 來進行分析與設計。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">UML 圖表</th>
<th scope="col" class="org-left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">用例圖（Use Case Diagram）</td>
<td class="org-left">定義系統的功能需求</td>
</tr>

<tr>
<td class="org-left">類別圖（Class Diagram）</td>
<td class="org-left">描述系統的靜態結構</td>
</tr>

<tr>
<td class="org-left">序列圖（Sequence Diagram）</td>
<td class="org-left">顯示物件之間的交互順序</td>
</tr>

<tr>
<td class="org-left">活動圖（Activity Diagram）</td>
<td class="org-left">描述業務流程</td>
</tr>

<tr>
<td class="org-left">狀態圖（State Diagram）</td>
<td class="org-left">描述物件的狀態變化</td>
</tr>

<tr>
<td class="org-left">組件圖（Component Diagram）</td>
<td class="org-left">描述系統模組化結構</td>
</tr>
</tbody>
</table>
<ol class="org-ol">
<li>統一流程（UP） vs. 敏捷開發（Agile）<br /></li>
</ol>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">統一流程（UP）</th>
<th scope="col" class="org-left">敏捷開發（Agile）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">開發方式</td>
<td class="org-left">迭代式開發</td>
<td class="org-left">迭代式開發</td>
</tr>

<tr>
<td class="org-left">核心概念</td>
<td class="org-left">以 UML 為核心，架構導向</td>
<td class="org-left">以人為核心，適應變更</td>
</tr>

<tr>
<td class="org-left">文件需求</td>
<td class="org-left">強調完整文件</td>
<td class="org-left">文件需求較少</td>
</tr>

<tr>
<td class="org-left">適用專案</td>
<td class="org-left">大型專案，架構設計複雜</td>
<td class="org-left">變動快的小型專案</td>
</tr>
</tbody>
</table>
<ol class="org-ol">
<li>近年新興技術中的 UML 應用<br /></li>
</ol>
<p>
微服務架構（Microservices Architecture）<br />
</p>
<ul class="org-ul">
<li>使用 UML 的 組件圖（Component Diagram） 來規劃微服務系統的關係。<br /></li>
<li>例如：Netflix、Amazon 採用微服務架構來拆分大型系統。<br /></li>
</ul>
<p>
雲端運算（Cloud Computing）<br />
</p>
<ul class="org-ul">
<li>使用 UML 部署圖（Deployment Diagram） 來描述雲端資源如何分佈與互動。<br /></li>
<li>例如：AWS、Azure 架構設計。<br /></li>
</ul>
<p>
AI 與大數據系統<br />
</p>
<ul class="org-ul">
<li>數據流程的 UML 建模（例如 活動圖）可幫助 AI 項目理解數據流轉過程。<br /></li>
</ul>
</div>
<div id="outline-container-orga9a01d4" class="outline-5">
<h5 id="orga9a01d4">📌 總結</h5>
<div class="outline-text-5" id="text-orga9a01d4">
<ul class="org-ul">
<li>統一流程（Unified Process, UP） 是專門針對 UML 的方法論，提供了一套完整的軟體開發框架。<br /></li>
<li>UP 的特點：基於 UML 建模、迭代開發、架構驅動。<br /></li>
<li>與其他方法的比較：UP 強調 軟體架構與風險管理，與 Scrum、敏捷開發等方法有所不同。<br /></li>
<li>UML 的重要性：在現代軟體開發（微服務、雲端、AI）仍然廣泛應用。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org1a6d20f" class="outline-3">
<h3 id="org1a6d20f"><span class="section-number-3">3.7.</span> (6)</h3>
<div class="outline-text-3" id="text-3-7">
<p>
It is impossible for a super class to invoke functions in its subclasses<br />
</p>
<ol class="org-ol">
<li>True<br /></li>
<li>False<br /></li>
</ol>
</div>
<div id="outline-container-orga06d6cd" class="outline-4">
<h4 id="orga06d6cd"><span class="section-number-4">3.7.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
答案：✅ b. False（錯誤）<br />
</p>
</div>
</div>
<div id="outline-container-orgb46fa69" class="outline-4">
<h4 id="orgb46fa69"><span class="section-number-4">3.7.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-7-2">
<p>
在物件導向程式設計（OOP）中，超類別（Super Class） 是可以透過多型（Polymorphism）或動態繫結（Dynamic Binding）來呼叫子類別（Sub Class）的函式，因此「超類別無法呼叫子類別的方法」這個敘述是不正確的。<br />
</p>
</div>
<div id="outline-container-org9e61b2b" class="outline-5">
<h5 id="org9e61b2b">📌 為什麼超類別可以調用子類別的方法？</h5>
<div class="outline-text-5" id="text-org9e61b2b">
<ul class="org-ul">
<li>透過覆寫（Overriding）實現動態繫結: 當子類別覆寫（Override）了父類別的方法，父類別的指標或參考可以在執行時動態調用子類別的實作。<br /></li>
<li>利用虛擬函數（Virtual Function）: 在 C++、Java、Python 等語言中，當超類別的方法被標記為 virtual（C++）或被動態繫結（Java、Python），它就可以在執行時決定要呼叫哪個子類別的方法。<br /></li>
<li>使用回呼（Callback）機制: 父類別可以接受子類別的物件，然後在適當的時候調用子類別的方法。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf8ac834" class="outline-5">
<h5 id="orgf8ac834">📌 例子</h5>
<div class="outline-text-5" id="text-orgf8ac834">
</div>
<ul class="org-ul">
<li><a id="org2cbc5d6"></a>✅ 1. Java 動態繫結<br />
<div class="outline-text-6" id="text-org2cbc5d6">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> SuperClass {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">display</span>() {
<span class="linenr"> 3: </span>        System.out.println(<span style="color: #98be65;">"SuperClass method"</span>);
<span class="linenr"> 4: </span>    }
<span class="linenr"> 5: </span>}
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">class</span> SubClass <span style="color: #51afef;">extends</span> SuperClass {
<span class="linenr"> 8: </span>    @Override
<span class="linenr"> 9: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">display</span>() {
<span class="linenr">10: </span>        System.out.println(<span style="color: #98be65;">"SubClass method"</span>);
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>}
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> Test {
<span class="linenr">15: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">16: </span>        SuperClass obj = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">SubClass</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21521;&#19978;&#36681;&#22411;</span>
<span class="linenr">17: </span>        obj.display(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21628;&#21483;&#23376;&#39006;&#21029;&#30340;&#26041;&#27861;</span>
<span class="linenr">18: </span>    }
<span class="linenr">19: </span>}
</pre>
</div>
<p>
輸出：<br />
</p>

<p>
SubClass method<br />
🔹 Java 透過動態繫結，讓父類別的參考 obj 呼叫 SubClass 的 display() 方法。<br />
</p>
</div>
</li>
<li><a id="org72cc012"></a>✅ 2. Python 動態方法調用<br />
<div class="outline-text-6" id="text-org72cc012">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">SuperClass</span>:
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">def</span> display(self):
<span class="linenr"> 3: </span>        print(<span style="color: #98be65;">"SuperClass method"</span>)
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">SubClass</span>(<span style="color: #ECBE7B;">SuperClass</span>):
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">display</span>(self):
<span class="linenr"> 7: </span>        print(<span style="color: #98be65;">"SubClass method"</span>)
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>obj = SubClass()  # &#29238;&#39006;&#21029;&#30340;&#21443;&#32771;&#25351;&#21521;&#23376;&#39006;&#21029;
<span class="linenr">10: </span>obj.display()  # &#21628;&#21483;&#23376;&#39006;&#21029;&#30340;&#26041;&#27861;
</pre>
</div>

<p>
輸出：<br />
</p>

<p>
SubClass method<br />
</p>

<p>
🔹 Python 會自動進行動態繫結，因此 display() 會執行子類別的方法。<br />
</p>
</div>
</li>
<li><a id="orgca86a0c"></a>✅ 3. C++ 使用 virtual 關鍵字<br />
<div class="outline-text-6" id="text-orgca86a0c">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">SuperClass</span> {
<span class="linenr"> 5: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 6: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">display</span>() { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992; virtual&#65292;&#21855;&#29992;&#21205;&#24907;&#32363;&#32080;</span>
<span class="linenr"> 7: </span>        cout &lt;&lt; <span style="color: #98be65;">"SuperClass method"</span> &lt;&lt; endl;
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>};
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">SubClass</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">SuperClass</span> {
<span class="linenr">12: </span><span style="color: #51afef;">public</span>:
<span class="linenr">13: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">display</span>() <span style="color: #51afef;">override</span> { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35206;&#23531;&#29238;&#39006;&#21029;&#30340;&#26041;&#27861;</span>
<span class="linenr">14: </span>        cout &lt;&lt; <span style="color: #98be65;">"SubClass method"</span> &lt;&lt; endl;
<span class="linenr">15: </span>    }
<span class="linenr">16: </span>};
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">19: </span>    <span style="color: #ECBE7B;">SuperClass</span>* <span style="color: #dcaeea;">obj</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">SubClass</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21521;&#19978;&#36681;&#22411;</span>
<span class="linenr">20: </span>    obj-&gt;display(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21628;&#21483;&#23376;&#39006;&#21029;&#30340;&#26041;&#27861;</span>
<span class="linenr">21: </span>    <span style="color: #51afef;">delete</span> obj;
<span class="linenr">22: </span>}
</pre>
</div>

<p>
輸出：<br />
</p>

<p>
SubClass method<br />
</p>

<p>
🔹 C++ 透過 virtual 來確保動態繫結，讓超類別可以調用子類別的方法。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org95a1a22" class="outline-4">
<h4 id="org95a1a22"><span class="section-number-4">3.7.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-7-3">
</div>
<div id="outline-container-org8f11821" class="outline-5">
<h5 id="org8f11821">1. 物件導向程式設計（OOP）核心概念</h5>
<div class="outline-text-5" id="text-org8f11821">
<p>
物件導向的四大特性：<br />
</p>
<ul class="org-ul">
<li>封裝（Encapsulation） - 透過存取修飾詞保護類別內部的資料。<br /></li>
<li>繼承（Inheritance） - 子類別可以重用父類別的屬性與方法。<br /></li>
<li>多型（Polymorphism） - 相同方法在不同類別中可表現出不同行為。<br /></li>
<li>抽象（Abstraction） - 只暴露必要的細節，減少不必要的依賴。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2d08f2c" class="outline-5">
<h5 id="org2d08f2c">2. 動態繫結（Dynamic Binding）</h5>
<div class="outline-text-5" id="text-org2d08f2c">
<p>
動態繫結是 在執行期決定要調用哪個方法，主要透過**方法覆寫（Method Overriding）**來實現。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">語言</th>
<th scope="col" class="org-left">動態繫結機制</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Java</td>
<td class="org-left">透過 @Override 自動支援多型</td>
</tr>

<tr>
<td class="org-left">Python</td>
<td class="org-left">所有方法預設支援動態繫結</td>
</tr>

<tr>
<td class="org-left">C++</td>
<td class="org-left">需要使用 virtual 關鍵字</td>
</tr>

<tr>
<td class="org-left">C#</td>
<td class="org-left">需要使用 virtual 和 override</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orge4f4fa8" class="outline-5">
<h5 id="orge4f4fa8">3. 方法覆寫（Method Overriding）與方法重載（Method Overloading）</h5>
<div class="outline-text-5" id="text-orge4f4fa8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">方法覆寫（Overriding）</th>
<th scope="col" class="org-left">方法重載（Overloading）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">作用範圍</td>
<td class="org-left">父類別與子類別</td>
<td class="org-left">同一個類別內部</td>
</tr>

<tr>
<td class="org-left">方法名稱</td>
<td class="org-left">相同</td>
<td class="org-left">相同</td>
</tr>

<tr>
<td class="org-left">參數列表</td>
<td class="org-left">完全相同</td>
<td class="org-left">不同（參數數量或類型不同）</td>
</tr>

<tr>
<td class="org-left">回傳類型</td>
<td class="org-left">可以相同或為協變返回類型（covariant return type）</td>
<td class="org-left">可以不同</td>
</tr>

<tr>
<td class="org-left">使用場景</td>
<td class="org-left">允許子類別改寫父類別的方法行為</td>
<td class="org-left">允許相同方法名稱但不同參數類型的使用</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgb70db48" class="outline-5">
<h5 id="orgb70db48">4. 向上轉型（Upcasting）與向下轉型（Downcasting）</h5>
<div class="outline-text-5" id="text-orgb70db48">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">轉型類型</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">語言支援</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">向上轉型（Upcasting）</td>
<td class="org-left">子類別對象賦值給父類別變數</td>
<td class="org-left">Java, C++, Python</td>
</tr>

<tr>
<td class="org-left">向下轉型（Downcasting）</td>
<td class="org-left">父類別變數強制轉型回子類別</td>
<td class="org-left">需要強制轉型（C++, Java）</td>
</tr>
</tbody>
</table>
<p>
向上轉型範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">SuperClass</span> <span style="color: #dcaeea;">obj</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">SubClass</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21512;&#27861;&#65288;&#21521;&#19978;&#36681;&#22411;&#65289;</span>
<span class="linenr">2: </span>obj.display(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35519;&#29992;&#23376;&#39006;&#21029;&#30340;&#26041;&#27861;</span>
</pre>
</div>
<p>
向下轉型範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">SubClass</span> <span style="color: #dcaeea;">obj2</span> = (<span style="color: #ECBE7B;">SubClass</span>) obj; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38656;&#35201;&#24375;&#21046;&#36681;&#22411;</span>
<span class="linenr">2: </span>obj2.display();
</pre>
</div>
</div>
</div>
<div id="outline-container-org9bf7019" class="outline-5">
<h5 id="org9bf7019">📌 總結</h5>
<div class="outline-text-5" id="text-org9bf7019">
<p>
-超類別（Super Class）可以透過多型（Polymorphism）與動態繫結（Dynamic Binding）來呼叫子類別的方法，所以「超類別無法調用子類別的方法」這個敘述是錯誤的。<br />
-主要機制：<br />
</p>
<ul class="org-ul">
<li>方法覆寫（Overriding） 讓子類別重新定義父類別的方法。<br /></li>
<li>向上轉型（Upcasting） 讓父類別的變數可以存取子類別的行為。<br /></li>
<li>動態繫結（Dynamic Binding） 在執行期決定要呼叫子類別的方法。<br /></li>
<li>虛擬函數（Virtual Function，C++） 允許父類別指標指向子類別並執行覆寫的方法。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org25ae3f8" class="outline-3">
<h3 id="org25ae3f8"><span class="section-number-3">3.8.</span> (7)</h3>
<div class="outline-text-3" id="text-3-8">
<p>
A component is a self-contained, encapsulated piece of software that can be plugged into a system to<br />
provide a specific set of required functionalities.<br />
</p>
<ol class="org-ol">
<li>True<br /></li>
<li>False<br /></li>
</ol>
</div>
<div id="outline-container-org7464702" class="outline-4">
<h4 id="org7464702"><span class="section-number-4">3.8.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-8-1">
<p>
答案：✅ a. True（正確）<br />
</p>
</div>
</div>
<div id="outline-container-org4cbfd8b" class="outline-4">
<h4 id="org4cbfd8b"><span class="section-number-4">3.8.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-8-2">
</div>
<div id="outline-container-org3742190" class="outline-5">
<h5 id="org3742190">📌 軟體元件（Component）</h5>
<div class="outline-text-5" id="text-org3742190">
<p>
元件（Component） 是一個獨立、封裝良好的軟體單元，能夠被插入系統中以提供特定的功能。這樣的設計提高了可重用性（Reusability）、模組化（Modularity）與可維護性（Maintainability）。<br />
</p>
</div>
</div>
<div id="outline-container-orgbd991af" class="outline-5">
<h5 id="orgbd991af">📌 主要特點</h5>
<div class="outline-text-5" id="text-orgbd991af">
<ul class="org-ul">
<li>獨立性（Independence）:元件通常是獨立開發與測試的，不依賴於特定的系統或應用程式。<br /></li>
<li>封裝性（Encapsulation）:元件對外只暴露必要的功能，內部實作細節對使用者隱藏，符合物件導向的封裝原則。<br /></li>
<li>可插拔（Plug-and-Play）:元件可以被不同的系統或應用程式使用，只需滿足相應的介面規範（Interface）。<br /></li>
<li>可重用性（Reusability）:相同的元件可以在不同專案或環境中多次使用，減少重複開發成本。<br /></li>
<li>標準化介面（Standardized Interface）:元件通常使用標準介面（如 API 或 Web Service），使得不同開發者可以輕鬆地集成它們。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf199b0e" class="outline-5">
<h5 id="orgf199b0e">📌 例子</h5>
<div class="outline-text-5" id="text-orgf199b0e">
</div>
<ul class="org-ul">
<li><a id="org89275ad"></a>✅ 1. Java Bean（Java 元件技術）<br />
<div class="outline-text-6" id="text-org89275ad">
<p>
Java Bean 是 Java 平台上的元件技術，可被不同應用程式重用：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> Calculator {
<span class="linenr">2: </span>    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">add</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> b) {
<span class="linenr">3: </span>        <span style="color: #51afef;">return</span> a + b;
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>}
</pre>
</div>
<p>
這個 Calculator 類別是一個可重用的計算元件，可以在不同的 Java 應用中使用。<br />
</p>
</div>
</li>
<li><a id="org0e65003"></a>✅ 2. Web Service 元件<br />
<div class="outline-text-6" id="text-org0e65003">
<p>
一個 RESTful API 也是一種元件，提供可重用的功能：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">from</span> flask <span style="color: #51afef;">import</span> Flask, jsonify
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #dcaeea;">app</span> = Flask(<span style="color: #c678dd;">__name__</span>)
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #ECBE7B;">@app.route</span>(<span style="color: #98be65;">'/add/&lt;int:a&gt;/&lt;int:b&gt;'</span>)
<span class="linenr"> 6: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">add</span>(a, b):
<span class="linenr"> 7: </span>    <span style="color: #51afef;">return</span> jsonify({<span style="color: #98be65;">'result'</span>: a + b})
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #51afef;">if</span> <span style="color: #c678dd;">__name__</span> == <span style="color: #98be65;">'__main__'</span>:
<span class="linenr">10: </span>    app.run()
</pre>
</div>
<p>
這是一個計算加法的 Web API 元件，可以被不同的應用程式請求來使用。<br />
</p>
</div>
</li>
<li><a id="orgb01ebb3"></a>✅ 3. 微服務（Microservices）<br />
<div class="outline-text-6" id="text-orgb01ebb3">
<p>
在現代微服務架構中，每個微服務就是一個獨立的元件，例如：<br />
</p>
<ul class="org-ul">
<li>身份驗證服務（Authentication Service）<br /></li>
<li>支付服務（Payment Service）<br /></li>
<li>推薦系統（Recommendation System）<br /></li>
</ul>
<p>
這些服務可以彼此獨立開發、測試與部署，符合元件化設計原則。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf93de4e" class="outline-4">
<h4 id="orgf93de4e"><span class="section-number-4">3.8.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-8-3">
</div>
<div id="outline-container-org02e93aa" class="outline-5">
<h5 id="org02e93aa">1. 軟體架構中的元件（Component in Software Architecture）</h5>
<div class="outline-text-5" id="text-org02e93aa">
<p>
在現代軟體開發中，元件通常是系統架構的一部分，例如：<br />
</p>
<ul class="org-ul">
<li>單體應用架構（Monolithic Architecture）：系統所有功能整合在一個大型應用程式中。<br /></li>
<li>微服務架構（Microservices Architecture）：每個元件獨立運行，透過 API 進行通訊。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org80b5fdd" class="outline-5">
<h5 id="org80b5fdd">2. UML 組件圖（Component Diagram）</h5>
<div class="outline-text-5" id="text-org80b5fdd">
<p>
在 UML（統一建模語言）中，組件圖（Component Diagram） 用來描述系統中的元件及其依賴關係：<br />
</p>
<ul class="org-ul">
<li>元件（Component）：獨立模組，提供特定功能。<br /></li>
<li>介面（Interface）：元件對外暴露的操作方法。<br /></li>
<li>依賴關係（Dependency）：描述元件之間的相互作用。<br /></li>
</ul>

<p>
UML 組件圖範例<br />
</p>
<pre class="example" id="org2676d5c">
+-----------------+
|    WebApp      |
+-----------------+
       |
       |  使用 API
       v
+-----------------+
|    PaymentService    |
+-----------------+
</pre>
<p>
🔹 WebApp（應用程式）依賴於 PaymentService（支付服務元件）。<br />
</p>
</div>
</div>
<div id="outline-container-org09d36ba" class="outline-5">
<h5 id="org09d36ba">3. 物件導向程式設計（OOP）與元件</h5>
<div class="outline-text-5" id="text-org09d36ba">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">概念</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">封裝（Encapsulation）</td>
<td class="org-left">限制元件內部細節的訪問，提高安全性</td>
</tr>

<tr>
<td class="org-left">繼承（Inheritance）</td>
<td class="org-left">允許元件共享通用行為，提高可重用性</td>
</tr>

<tr>
<td class="org-left">多型（Polymorphism）</td>
<td class="org-left">允許元件以不同方式實作相同的介面</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgd44ae0f" class="outline-5">
<h5 id="orgd44ae0f">4. 軟體元件技術</h5>
<div class="outline-text-5" id="text-orgd44ae0f">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">技術</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">JavaBeans</td>
<td class="org-left">Java 物件元件，可重用於不同應用</td>
</tr>

<tr>
<td class="org-left">ActiveX</td>
<td class="org-left">微軟的元件技術</td>
</tr>

<tr>
<td class="org-left">Web Services</td>
<td class="org-left">基於 HTTP 的 API（如 REST、SOAP）</td>
</tr>

<tr>
<td class="org-left">Docker 容器</td>
<td class="org-left">用於封裝和部署獨立的元件</td>
</tr>
</tbody>
</table>
<ol class="org-ol">
<li>元件在現代開發中的應用<br /></li>
<li>微服務架構（Microservices）<br />
<ul class="org-ul">
<li>例如 Netflix、Amazon 使用微服務來拆分大型應用，每個服務作為獨立元件。<br /></li>
</ul></li>
<li>雲端運算（Cloud Computing）<br />
<ul class="org-ul">
<li>AWS Lambda、Google Cloud Functions 允許開發者以元件方式開發伺服器無關的函數。<br /></li>
</ul></li>
<li>前後端分離（Frontend-Backend Decoupling）<br />
<ul class="org-ul">
<li>透過 API 讓前端與後端獨立，提升開發效率。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org7e8a274" class="outline-5">
<h5 id="org7e8a274">📌 總結</h5>
<div class="outline-text-5" id="text-org7e8a274">
<ul class="org-ul">
<li>元件（Component） 是獨立、封裝良好的軟體單元，能夠被插入系統中來提供特定功能。<br /></li>
<li>特點：獨立性、封裝性、可插拔性、可重用性、標準介面。<br /></li>
<li>應用：<br />
<ul class="org-ul">
<li>Java Beans、Web API、微服務、Docker 容器等。<br /></li>
<li>UML 組件圖（Component Diagram） 可用來建模元件關係。<br /></li>
</ul></li>
<li>在現代開發中的重要性：<br />
<ul class="org-ul">
<li>微服務（Microservices）<br /></li>
<li>雲端運算（Cloud Computing）<br /></li>
<li>前後端分離（Frontend-Backend Decoupling）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgebfdbf4" class="outline-3">
<h3 id="orgebfdbf4"><span class="section-number-3">3.9.</span> (8)</h3>
<div class="outline-text-3" id="text-3-9">
<p>
Which is true regarding RSA algorithm?<br />
</p>
<ol class="org-ol">
<li>Encryption and decryption must use the same key<br /></li>
<li>Encryption using the public key of a user can be regarded as a digital signature<br /></li>
<li>RSA is faster than traditional block ciphers algorithms such as DES<br /></li>
<li>RSA could be vulnerable to chosen ciphertext attack<br /></li>
</ol>
</div>
<div id="outline-container-org4c364cb" class="outline-4">
<h4 id="org4c364cb"><span class="section-number-4">3.9.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-9-1">
<p>
答案：✅ d. RSA could be vulnerable to chosen ciphertext attack（RSA 可能容易受到選擇密文攻擊）<br />
</p>
</div>
</div>
<div id="outline-container-orgbd1530d" class="outline-4">
<h4 id="orgbd1530d"><span class="section-number-4">3.9.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-9-2">
</div>
<div id="outline-container-orgacb779c" class="outline-5">
<h5 id="orgacb779c">📌 RSA（Rivest–Shamir–Adleman）演算法</h5>
<div class="outline-text-5" id="text-orgacb779c">
<p>
RSA 是一種非對稱加密（Asymmetric Encryption）演算法，主要用於資料加密與數位簽章。其安全性基於 大數質因數分解的困難性，目前仍是現代密碼學中最常用的公鑰加密技術之一。<br />
</p>
</div>
</div>
<div id="outline-container-orgec9b5af" class="outline-5">
<h5 id="orgec9b5af">📌 為什麼 RSA 可能受到選擇密文攻擊（CCA）？</h5>
<div class="outline-text-5" id="text-orgec9b5af">
<p>
選擇密文攻擊（Chosen Ciphertext Attack, CCA） 指的是攻擊者可以選擇某些密文並取得對應的解密結果，然後利用這些資訊推測其他密文的明文。<br />
</p>
<ul class="org-ul">
<li>RSA 使用純粹的數學運算（模指數運算）來加解密，在未使用適當的填充技術（Padding Scheme） 時，容易受到 CCA 攻擊。<br /></li>
<li>Bleichenbacher 攻擊（1998） 發現 使用 RSA PKCS#1 v1.5 填充的系統容易受到 CCA 攻擊。<br /></li>
<li>解決方案：<br />
<ul class="org-ul">
<li>使用安全填充（Padding Scheme），如 RSA-OAEP（Optimal Asymmetric Encryption Padding）。<br /></li>
<li>使用混合加密（Hybrid Encryption），將 RSA 用於金鑰交換，而不直接加密訊息。<br /></li>
</ul></li>
</ul>
<p>
✅ 因此，選項 d. 是正確答案。<br />
</p>
</div>
</div>
<div id="outline-container-orgfa2eb52" class="outline-5">
<h5 id="orgfa2eb52">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-orgfa2eb52">
</div>
<ul class="org-ul">
<li><a id="org7efaaec"></a>❌ a. Encryption and decryption must use the same key（加密與解密必須使用相同金鑰）<br />
<div class="outline-text-6" id="text-org7efaaec">
<ul class="org-ul">
<li>錯誤！ 這是對稱加密（如 AES、DES）的特性，而非對 RSA 的描述。<br /></li>
<li>RSA 是非對稱加密（Asymmetric Encryption）：<br />
<ul class="org-ul">
<li>使用公開金鑰（Public Key） 進行加密。<br /></li>
<li>使用私密金鑰（Private Key） 進行解密。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org3307aae"></a>❌ b. Encryption using the public key of a user can be regarded as a digital signature<br />
<div class="outline-text-6" id="text-org3307aae">
<ul class="org-ul">
<li>錯誤！ 數位簽章（Digital Signature）與加密不同：<br />
<ul class="org-ul">
<li>數位簽章的流程：<br />
<ul class="org-ul">
<li>使用私鑰（Private Key） 進行簽章。<br /></li>
<li>使用公鑰（Public Key） 進行驗證。<br /></li>
</ul></li>
<li>加密的流程：<br />
<ul class="org-ul">
<li>使用公鑰（Public Key） 進行加密。<br /></li>
<li>使用私鑰（Private Key） 進行解密。<br /></li>
</ul></li>
</ul></li>
<li>數位簽章需要使用私鑰簽署，而非公鑰，所以此敘述錯誤。<br /></li>
</ul>
</div>
</li>
<li><a id="org8dc8c51"></a>❌ c. RSA is faster than traditional block ciphers algorithms such as DES（RSA 比傳統區塊密碼如 DES 更快）<br />
<div class="outline-text-6" id="text-org8dc8c51">
<ul class="org-ul">
<li>錯誤！<br />
<ul class="org-ul">
<li>RSA 的運算速度遠比 DES、AES 慢，因為 RSA 需要執行大數指數運算（模指數運算），而這在 CPU 上非常耗時。<br /></li>
<li>傳統區塊加密（如 DES、AES）使用對稱金鑰加密，速度快得多，可達數百 Mbps 或 Gbps。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org91d8a0c" class="outline-5">
<h5 id="org91d8a0c">📚 與該主題相關的完整計概知識</h5>
<div class="outline-text-5" id="text-org91d8a0c">
</div>
<ul class="org-ul">
<li><a id="orga755ae5"></a>1. 對稱加密 vs. 非對稱加密<br />
<div class="outline-text-6" id="text-orga755ae5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">加密類型</th>
<th scope="col" class="org-left">特點</th>
<th scope="col" class="org-left">演算法範例</th>
<th scope="col" class="org-left">優缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">對稱加密（Symmetric Encryption）</td>
<td class="org-left">使用相同金鑰加密與解密</td>
<td class="org-left">AES、DES、3DES</td>
<td class="org-left">速度快，但需安全交換金鑰</td>
</tr>

<tr>
<td class="org-left">非對稱加密（Asymmetric Encryption）</td>
<td class="org-left">使用公鑰加密，私鑰解密</td>
<td class="org-left">RSA、ECC、ElGamal</td>
<td class="org-left">速度較慢，但不需共享金鑰</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgbcd578d"></a>2. RSA 加密與簽章<br />
<div class="outline-text-6" id="text-orgbcd578d">
<ul class="org-ul">
<li>✅ RSA 加密<br />
Alice (發送者) → 使用 Bob 的公鑰加密 → 傳送加密訊息 → Bob（接收者）使用私鑰解密<br /></li>
<li>✅ RSA 數位簽章<br />
Alice（發送者）使用私鑰簽名 → Bob（接收者）使用 Alice 的公鑰驗證簽名<br /></li>
</ul>
<p>
🔹 數位簽章確保訊息的完整性與身份驗證，但不能保密訊息內容。<br />
</p>
</div>
</li>
<li><a id="org7109970"></a>3. 主要的加密攻擊（Cryptographic Attacks）<br />
<div class="outline-text-6" id="text-org7109970">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">攻擊類型</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">RSA 是否易受攻擊？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">暴力破解（Brute Force）</td>
<td class="org-left">嘗試所有可能的密鑰組合</td>
<td class="org-left">不易，因為 RSA 依賴大質數分解</td>
</tr>

<tr>
<td class="org-left">中間人攻擊（MITM）</td>
<td class="org-left">竊取交換的金鑰或訊息</td>
<td class="org-left">易受攻擊，若未使用 TLS 或數位簽章</td>
</tr>

<tr>
<td class="org-left">選擇密文攻擊（CCA）</td>
<td class="org-left">攻擊者操控密文，獲取對應的解密結果</td>
<td class="org-left">容易，若未使用 RSA-OAEP</td>
</tr>

<tr>
<td class="org-left">量子電腦攻擊</td>
<td class="org-left">Shor 演算法可快速分解大數</td>
<td class="org-left">未來 RSA 可能無法安全</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org0625a74"></a>4. RSA 與現代密碼學的應用<br />
<div class="outline-text-6" id="text-org0625a74">
<ul class="org-ul">
<li>HTTPS / TLS<br />
<ul class="org-ul">
<li>網頁傳輸安全協定（HTTPS）中，RSA 被用來交換對稱金鑰。<br /></li>
</ul></li>
<li>數位憑證（Digital Certificates）<br />
<ul class="org-ul">
<li>SSL/TLS 憑證使用 RSA 進行驗證，確保網站身份真實。<br /></li>
</ul></li>
<li>區塊鏈與加密貨幣<br />
<ul class="org-ul">
<li>比特幣、以太坊等加密貨幣使用 橢圓曲線密碼學（ECC），因為 ECC 比 RSA 更快，但仍與 RSA 屬於非對稱加密技術。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org3aabfe1"></a>📌 總結<br />
<div class="outline-text-6" id="text-org3aabfe1">
<ul class="org-ul">
<li>RSA 是一種非對稱加密演算法，使用公鑰加密、私鑰解密。<br /></li>
<li>RSA 可能容易受到選擇密文攻擊（CCA），如果沒有使用適當的填充機制，如 RSA-OAEP，因此： ✅ 正確答案為 d. RSA could be vulnerable to chosen ciphertext attack。<br /></li>
<li>其他選項錯誤的原因：<br />
<ol class="org-ol">
<li>RSA 使用非對稱金鑰，而不是相同金鑰（錯）。<br /></li>
<li>RSA 數位簽章是用私鑰簽署，而非公鑰（錯）。<br /></li>
<li>RSA 運算比對稱加密（AES、DES）慢（錯）。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga6e06cd" class="outline-3">
<h3 id="orga6e06cd"><span class="section-number-3">3.10.</span> (9)</h3>
<div class="outline-text-3" id="text-3-10">
<p>
Which is true regarding DES?<br />
</p>
<ol class="org-ol">
<li>Double DES is much more secure than single DES<br /></li>
<li>DES has a key length of 512 bits<br /></li>
<li>A data block with a size less than 64 bits cannot be encrypted using DES<br /></li>
<li>DES can be used to implement a stream cipher<br /></li>
</ol>
</div>
<div id="outline-container-org1a3a699" class="outline-4">
<h4 id="org1a3a699"><span class="section-number-4">3.10.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-10-1">
<p>
答案：✅ c. A data block with a size less than 64 bits cannot be encrypted using DES<br />
（DES 無法直接加密小於 64 位元的數據區塊）<br />
</p>
</div>
</div>
<div id="outline-container-org5e94b09" class="outline-4">
<h4 id="org5e94b09"><span class="section-number-4">3.10.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-10-2">
</div>
<div id="outline-container-org92146cc" class="outline-5">
<h5 id="org92146cc">📌 DES（Data Encryption Standard，資料加密標準）</h5>
<div class="outline-text-5" id="text-org92146cc">
<p>
DES 是 對稱加密演算法（Symmetric Encryption Algorithm），由 IBM 在 1970 年代開發，後來被美國國家標準技術研究院（NIST）採納為加密標準（FIPS PUB 46）。<br />
</p>
<ul class="org-ul">
<li>區塊加密（Block Cipher）： DES 以**64 位元（8 個字節）**為一個區塊進行加密。<br /></li>
<li>金鑰長度（Key Length）： 56 位元（實際為 64 位元，其中 8 位元為奇偶校驗位）。<br /></li>
<li>加密模式（Modes of Operation）： 例如 ECB（電子代碼簿模式）、CBC（密碼分組連鎖模式）。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0a5d74d" class="outline-5">
<h5 id="org0a5d74d">📌 為什麼 DES 不能直接加密小於 64 位元的數據？</h5>
<div class="outline-text-5" id="text-org0a5d74d">
<ul class="org-ul">
<li>DES 是區塊加密（Block Cipher），它的基本運算單位是 64 位元（8 字節）。<br /></li>
<li>如果數據長度小於 64 位元，需要填充（Padding）：<br />
<ul class="org-ul">
<li>常見填充方式：<br />
<ul class="org-ul">
<li>PKCS#5 / PKCS#7 Padding<br /></li>
<li>Zero Padding<br /></li>
<li>ISO/IEC 7816-4 Padding<br /></li>
</ul></li>
</ul></li>
</ul>
<p>
✅ 因此，正確答案是 c. DES 無法直接加密小於 64 位元的數據區塊，而是需要填充後再進行加密。<br />
</p>
</div>
</div>
<div id="outline-container-orga33b401" class="outline-5">
<h5 id="orga33b401">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-orga33b401">
</div>
<ul class="org-ul">
<li><a id="org4ccfb0f"></a>❌ a. Double DES is much more secure than single DES（雙重 DES 比單一 DES 安全得多）<br />
<div class="outline-text-6" id="text-org4ccfb0f">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>Double DES（2DES） 是將 DES 加密兩次：<br />
<ul class="org-ul">
<li>C = E(K2, E(K1, P))，先用 K1 加密，再用 K2 加密。<br /></li>
</ul></li>
<li>問題：遭受「中間相遇攻擊（Meet-in-the-Middle Attack）」<br />
<ul class="org-ul">
<li>2DES 的安全性 並不等於 112 位元，而是約等於 2^56，僅比單一 DES 稍強。<br /></li>
<li>因此，Triple DES（3DES） 才成為標準，而不是 2DES。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org06e0f9e"></a>❌ b. DES has a key length of 512 bits（DES 的金鑰長度為 512 位元）<br />
<div class="outline-text-6" id="text-org06e0f9e">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>DES 金鑰長度為 56 位元（7 字節），實際使用 64 位元，其中 8 位元是奇偶校驗位，所以有效金鑰長度是 56 位元。<br /></li>
<li>512 位元的金鑰長度屬於現代加密標準（如 RSA 或 AES），但不是 DES 的規範。<br /></li>
</ul>
</div>
</li>
<li><a id="org763b867"></a>❌ d. DES can be used to implement a stream cipher（DES 可用於實作串流加密）<br />
<div class="outline-text-6" id="text-org763b867">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>DES 是區塊加密（Block Cipher），不是串流加密（Stream Cipher）。<br /></li>
<li>串流加密（Stream Cipher）特點：<br />
<ul class="org-ul">
<li>逐位元或逐字節加密<br /></li>
<li>例如 RC4（Rivest Cipher 4）、ChaCha20<br /></li>
</ul></li>
<li>但 DES 可以與 CTR（計數器模式）結合，使其表現類似串流加密，但它本質上仍然是區塊加密。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgfe7eeae" class="outline-4">
<h4 id="orgfe7eeae"><span class="section-number-4">3.10.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-10-3">
</div>
<div id="outline-container-org4e30d74" class="outline-5">
<h5 id="org4e30d74">1. 區塊加密（Block Cipher） vs. 串流加密（Stream Cipher）</h5>
<div class="outline-text-5" id="text-org4e30d74">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">類型</th>
<th scope="col" class="org-left">加密方式</th>
<th scope="col" class="org-left">範例演算法</th>
<th scope="col" class="org-left">適用場景</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">區塊加密（Block Cipher）</td>
<td class="org-left">以固定大小（如 64 或 128 位元）為單位加密</td>
<td class="org-left">DES、3DES、AES</td>
<td class="org-left">文件加密、數據儲存</td>
</tr>

<tr>
<td class="org-left">串流加密（Stream Cipher）</td>
<td class="org-left">逐字節或逐位元加密</td>
<td class="org-left">RC4、ChaCha20</td>
<td class="org-left">即時通訊、無線網路加密（WPA）</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgedf1b43" class="outline-5">
<h5 id="orgedf1b43">2. DES 的加密模式（Modes of Operation）</h5>
<div class="outline-text-5" id="text-orgedf1b43">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">模式</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">適用場景</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ECB（Electronic Codebook）</td>
<td class="org-left">每個 64-bit 區塊獨立加密，無關聯</td>
<td class="org-left">不安全，不適合機密資料</td>
</tr>

<tr>
<td class="org-left">CBC（Cipher Block Chaining）</td>
<td class="org-left">透過 XOR 連鎖加密，每個區塊依賴前一個區塊</td>
<td class="org-left">適用於文件加密</td>
</tr>

<tr>
<td class="org-left">CFB（Cipher Feedback）</td>
<td class="org-left">使 DES 表現為串流加密</td>
<td class="org-left">適合即時加密</td>
</tr>

<tr>
<td class="org-left">OFB（Output Feedback）</td>
<td class="org-left">類似 CFB，但不依賴密文</td>
<td class="org-left">適用於錯誤敏感環境</td>
</tr>

<tr>
<td class="org-left">CTR（Counter Mode）</td>
<td class="org-left">透過計數器模式讓 DES 可並行加密</td>
<td class="org-left">適合高效能加密</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org5048830" class="outline-5">
<h5 id="org5048830">3. DES 的替代方案</h5>
<div class="outline-text-5" id="text-org5048830">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">演算法</th>
<th scope="col" class="org-left">金鑰長度</th>
<th scope="col" class="org-left">區塊大小</th>
<th scope="col" class="org-left">安全性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DES</td>
<td class="org-left">56 位元</td>
<td class="org-left">64 位元</td>
<td class="org-left">已被破解，不安全</td>
</tr>

<tr>
<td class="org-left">3DES</td>
<td class="org-left">112 或 168 位元</td>
<td class="org-left">64 位元</td>
<td class="org-left">安全性較高，但速度慢</td>
</tr>

<tr>
<td class="org-left">AES（Advanced Encryption Standard）</td>
<td class="org-left">128、192、256 位元</td>
<td class="org-left">128 位元</td>
<td class="org-left">現代標準，加密速度快</td>
</tr>
</tbody>
</table>
<p>
🔹 AES 目前已完全取代 DES，成為現代加密的標準。<br />
</p>
</div>
</div>
<div id="outline-container-org9ecabe0" class="outline-5">
<h5 id="org9ecabe0">4. DES 的安全性問題</h5>
<div class="outline-text-5" id="text-org9ecabe0">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">攻擊類型</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">暴力破解（Brute Force Attack）</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">嘗試所有可能的密鑰組合</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">DES 的 56 位元金鑰太短，易被暴力破解</td>
</tr>

<tr>
<td class="org-left">中間相遇攻擊（Meet-in-the-Middle Attack）</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">攻擊 Double DES（2DES）</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">使 2DES 的安全性僅為 2^56，而非 2^112</td>
</tr>

<tr>
<td class="org-left">差分密碼分析（Differential Cryptanalysis）</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">分析密文與明文差異來破解金鑰</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">DES 在設計時已考慮防禦，但仍有風險</td>
</tr>

<tr>
<td class="org-left">線性密碼分析（Linear Cryptanalysis）</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">使用線性逼近方法來恢復密鑰</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">DES 仍然有被攻擊的可能性</td>
</tr>
</tbody>
</table>
<p>
🔹 現今標準 AES 使用 128 位元以上的金鑰，已防禦此類攻擊。<br />
</p>
</div>
</div>
<div id="outline-container-orgf2b34ea" class="outline-5">
<h5 id="orgf2b34ea">📌 總結</h5>
<div class="outline-text-5" id="text-orgf2b34ea">
<ul class="org-ul">
<li>DES 是區塊加密（Block Cipher），以 64 位元為單位加密。<br /></li>
<li>小於 64 位元的數據必須填充（Padding）才能被 DES 加密，因此： ✅ 正確答案為 c. A data block with a size less than 64 bits cannot be encrypted using DES。<br /></li>
<li>其他選項錯誤的原因：<br />
<ol class="org-ol">
<li>Double DES 容易被「中間相遇攻擊」破解（錯）。<br /></li>
<li>DES 金鑰長度為 56 位元，而不是 512 位元（錯）。<br /></li>
<li>DES 是區塊加密，不是串流加密（錯）。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orge6b3d29" class="outline-3">
<h3 id="orge6b3d29"><span class="section-number-3">3.11.</span> (10)</h3>
<div class="outline-text-3" id="text-3-11">
<p>
Which is false regarding secure hash functions?<br />
</p>
<ol class="org-ol">
<li>Secure hash functions play a crucial role in the context of digital currency.<br /></li>
<li>It is possible that two different data blocks are mapped to the same hash code by a secure hash<br /></li>
</ol>
<p>
function.<br />
</p>
<ol class="org-ol">
<li>Hash codes generated by secure hash functions require no additional protection when employed<br /></li>
</ol>
<p>
as a message authentication code.<br />
</p>
<ol class="org-ol">
<li>Secure hash functions can be used to create a one-way password file<br /></li>
</ol>
</div>
<div id="outline-container-org302460f" class="outline-4">
<h4 id="org302460f"><span class="section-number-4">3.11.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-11-1">
<p>
答案：<br />
</p>

<p>
✅ c. Hash codes generated by secure hash functions require no additional protection when employed as a message authentication code.<br />
（安全雜湊函數產生的雜湊碼在用作訊息驗證碼（MAC）時不需要額外保護 —— 錯誤！）<br />
</p>
</div>
</div>
<div id="outline-container-org7f092c7" class="outline-4">
<h4 id="org7f092c7"><span class="section-number-4">3.11.2.</span> 📖 詳解：</h4>
<div class="outline-text-4" id="text-3-11-2">
</div>
<div id="outline-container-orge55fceb" class="outline-5">
<h5 id="orge55fceb">📌 安全雜湊函數（Secure Hash Function, SHF）</h5>
<div class="outline-text-5" id="text-orge55fceb">
<p>
安全雜湊函數（Secure Hash Function, SHF） 是一種單向函數（One-way Function），其主要目的是將任意長度的輸入轉換為固定長度的輸出（雜湊值，Hash Code），並且應該滿足以下特性：<br />
</p>
<ul class="org-ul">
<li>單向性（Preimage Resistance）：<br />
<ul class="org-ul">
<li>給定雜湊值 H(m)，幾乎不可能找到原始輸入 m。<br /></li>
</ul></li>
<li>抗碰撞性（Collision Resistance）：<br />
<ul class="org-ul">
<li>幾乎不可能找到兩個不同的輸入 m1 ≠ m2，使得 H(m1) = H(m2)。<br /></li>
</ul></li>
<li>抗第二原像性（Second Preimage Resistance）：<br />
<ul class="org-ul">
<li>給定某個輸入 m1，幾乎不可能找到 m2 ≠ m1 使得 H(m1) = H(m2)。<br /></li>
</ul></li>
</ul>

<p>
常見的安全雜湊函數：<br />
</p>
<ul class="org-ul">
<li>SHA-2（SHA-256, SHA-512）：目前常用的安全標準<br /></li>
<li>SHA-3（Keccak）：新一代標準<br /></li>
<li>MD5、SHA-1：已被證明不安全，容易發生碰撞攻擊（Collision Attack）<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4c176d1" class="outline-5">
<h5 id="org4c176d1">📌 為什麼選項 c 是錯誤的？</h5>
<div class="outline-text-5" id="text-org4c176d1">
<p>
雜湊函數（Hash Function）本身不能直接作為訊息驗證碼（Message Authentication Code, MAC）<br />
</p>
<ul class="org-ul">
<li>安全雜湊函數的雜湊值（Hash Code）不能保證消息的真實性，因為它是公開的，容易被攻擊者偽造。<br /></li>
<li>HMAC（Hashed Message Authentication Code） 透過額外的密鑰（Secret Key），確保只有擁有密鑰的一方才能驗證訊息的完整性。<br /></li>
</ul>

<p>
✅ 正確的 MAC 設計：HMAC<br />
</p>
<ul class="org-ul">
<li>HMAC（Hashed Message Authentication Code）是一種基於密鑰的雜湊函數，通常使用 SHA-256 或 SHA-512：<br /></li>
<li>HMAC(K, m) = H( (K ⊕ opad) ∥ H( (K ⊕ ipad) ∥ m ) )<br /></li>
<li>其中：<br />
<ul class="org-ul">
<li>K：密鑰<br /></li>
<li>m：訊息<br /></li>
<li>H()：安全雜湊函數（如 SHA-256）<br /></li>
<li>opad, ipad：填充常數<br /></li>
</ul></li>
</ul>

<p>
如果直接使用雜湊函數來驗證訊息完整性，攻擊者可以進行「長度擴展攻擊（Length Extension Attack）」來偽造訊息。<br />
</p>

<p>
因此，選項 c 是錯誤的！<br />
</p>
</div>
</div>
<div id="outline-container-orgf140a9e" class="outline-5">
<h5 id="orgf140a9e">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-orgf140a9e">
</div>
<ul class="org-ul">
<li><a id="org3d54e50"></a>✅ a. Secure hash functions play a crucial role in the context of digital currency.<br />
<div class="outline-text-6" id="text-org3d54e50">
<p>
（安全雜湊函數在數位貨幣中扮演關鍵角色）<br />
</p>

<ul class="org-ul">
<li>正確！<br /></li>
<li>在 區塊鏈技術（Blockchain） 中，雜湊函數用於：<br />
<ul class="org-ul">
<li>交易驗證（Transaction Validation）：使用 SHA-256 來產生區塊雜湊值。<br /></li>
<li>PoW（工作量證明）機制：如比特幣的 SHA-256 雜湊計算。<br /></li>
<li>數位簽章與錢包地址產生：例如 Bitcoin Address 使用 SHA-256 + RIPEMD-160 雜湊。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org7fedfc7"></a>✅ b. It is possible that two different data blocks are mapped to the same hash code by a secure hash function.<br />
<div class="outline-text-6" id="text-org7fedfc7">
<p>
（可能有兩個不同的數據區塊被映射到相同的雜湊碼）<br />
</p>

<ul class="org-ul">
<li>正確！<br /></li>
<li>根據鴿籠原理（Pigeonhole Principle）：<br />
<ul class="org-ul">
<li>假設 SHA-256 的輸出長度是 256 位元，但輸入可能是無限長的數據。<br /></li>
<li>數據總數（無限） &gt; 雜湊值的可能組合（2^256）<br /></li>
<li>理論上一定存在碰撞（Collision），但碰撞的機率極低。<br /></li>
</ul></li>
<li>SHA-1 和 MD5 已經被證明存在碰撞攻擊，但 SHA-256 和 SHA-3 仍然安全。<br /></li>
</ul>
</div>
</li>
<li><a id="orgedb8178"></a>✅ d. Secure hash functions can be used to create a one-way password file.<br />
<div class="outline-text-6" id="text-orgedb8178">
<p>
（安全雜湊函數可用於建立單向密碼檔案）<br />
</p>

<ul class="org-ul">
<li>正確！<br /></li>
<li>密碼應該以「雜湊值」的方式存儲，而不是明文存儲！<br /></li>
<li>常見的密碼雜湊技術：<br />
<ul class="org-ul">
<li>PBKDF2（Password-Based Key Derivation Function 2）<br /></li>
<li>bcrypt<br /></li>
<li>scrypt<br /></li>
</ul></li>
<li>這些方法會加入「鹽值（Salt）」來避免字典攻擊（Dictionary Attack）與彩虹表攻擊（Rainbow Table Attack）。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org172296d" class="outline-4">
<h4 id="org172296d"><span class="section-number-4">3.11.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-11-3">
</div>
<div id="outline-container-org20abdd4" class="outline-5">
<h5 id="org20abdd4">1. 常見的安全雜湊函數</h5>
<div class="outline-text-5" id="text-org20abdd4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">演算法</th>
<th scope="col" class="org-left">輸出長度</th>
<th scope="col" class="org-left">安全性</th>
<th scope="col" class="org-left">應用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">MD5</td>
<td class="org-left">128 位元</td>
<td class="org-left">已破解（不安全）</td>
<td class="org-left">不應用於安全場景</td>
</tr>

<tr>
<td class="org-left">SHA-1</td>
<td class="org-left">160 位元</td>
<td class="org-left">已破解（不安全）</td>
<td class="org-left">早期數位簽章（已淘汰）</td>
</tr>

<tr>
<td class="org-left">SHA-256</td>
<td class="org-left">256 位元</td>
<td class="org-left">安全（推薦）</td>
<td class="org-left">區塊鏈、TLS、密碼存儲</td>
</tr>

<tr>
<td class="org-left">SHA-512</td>
<td class="org-left">512 位元</td>
<td class="org-left">安全（高安全性）</td>
<td class="org-left">加密通訊</td>
</tr>

<tr>
<td class="org-left">SHA-3（Keccak）</td>
<td class="org-left">224, 256, 384, 512 位元</td>
<td class="org-left">安全（新標準）</td>
<td class="org-left">高安全性應用</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org8b176ef" class="outline-5">
<h5 id="org8b176ef">2. 安全雜湊函數的應用</h5>
<div class="outline-text-5" id="text-org8b176ef">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">應用領域</th>
<th scope="col" class="org-left">雜湊函數用途</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">密碼儲存（Password Storage）</td>
<td class="org-left">使用 PBKDF2、bcrypt、scrypt 雜湊密碼</td>
</tr>

<tr>
<td class="org-left">數位簽章（Digital Signature）</td>
<td class="org-left">先對訊息雜湊，再用私鑰簽名</td>
</tr>

<tr>
<td class="org-left">區塊鏈（Blockchain）</td>
<td class="org-left">交易驗證、哈希指針、PoW 機制</td>
</tr>

<tr>
<td class="org-left">訊息驗證（MAC / HMAC）</td>
<td class="org-left">使用 HMAC 來驗證訊息完整性</td>
</tr>

<tr>
<td class="org-left">檔案完整性驗證（File Integrity Check）</td>
<td class="org-left">使用 SHA-256 驗證下載檔案是否被篡改</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org2a9e02e" class="outline-5">
<h5 id="org2a9e02e">3. 雜湊函數的攻擊方式</h5>
<div class="outline-text-5" id="text-org2a9e02e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">攻擊類型</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">碰撞攻擊（Collision Attack）</td>
<td class="org-left">找到兩個不同的輸入，產生相同的雜湊值</td>
<td class="org-left">MD5、SHA-1 已被破解</td>
</tr>

<tr>
<td class="org-left">長度擴展攻擊（Length Extension Attack）</td>
<td class="org-left">透過已知的雜湊值構造新訊息</td>
<td class="org-left">需使用 HMAC 避免</td>
</tr>

<tr>
<td class="org-left">字典攻擊（Dictionary Attack）</td>
<td class="org-left">使用預計密碼列表來破解雜湊值</td>
<td class="org-left">需加入 Salt 避免</td>
</tr>

<tr>
<td class="org-left">彩虹表攻擊（Rainbow Table Attack）</td>
<td class="org-left">事先計算大量雜湊值來破解密碼</td>
<td class="org-left">使用 bcrypt/scrypt 避免</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orge5a8ccb" class="outline-5">
<h5 id="orge5a8ccb">📌 總結</h5>
<div class="outline-text-5" id="text-orge5a8ccb">
<ul class="org-ul">
<li>安全雜湊函數主要用於數位貨幣、密碼儲存、數位簽章等領域。<br /></li>
<li>直接使用雜湊函數作為 MAC 是不安全的，應使用 HMAC，因此： ✅ 正確答案為 c（錯誤敘述）。<br /></li>
<li>雜湊函數仍然是現代資訊安全的關鍵技術，研究所考試與實務應用都很重要！🚀📚<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc5c6991" class="outline-3">
<h3 id="orgc5c6991"><span class="section-number-3">3.12.</span> A-2 <code>[5%]</code></h3>
<div class="outline-text-3" id="text-3-12">
<p>
Explain the adapter design pattern and give an example of its use.<br />
</p>
</div>
<div id="outline-container-org1f8eb91" class="outline-4">
<h4 id="org1f8eb91"><span class="section-number-4">3.12.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-12-1">
<p>
Adapter 設計模式（適配器模式）<br />
</p>
</div>
<div id="outline-container-orgadba99a" class="outline-5">
<h5 id="orgadba99a">📌 1. Adapter 設計模式簡介</h5>
<div class="outline-text-5" id="text-orgadba99a">
<p>
Adapter（適配器模式） 是 結構型設計模式（Structural Design Pattern），主要用於讓兩個不相容的介面能夠一起工作。<br />
</p>

<p>
🔹 作用：<br />
</p>
<ul class="org-ul">
<li>允許舊系統與新系統兼容，無需修改原始程式碼。<br /></li>
<li>提供 統一的介面，讓使用者可以統一調用不同類別的功能。<br /></li>
</ul>

<p>
🔹 類似於「轉接頭」的概念<br />
</p>
<ul class="org-ul">
<li>現實例子：<br />
<ul class="org-ul">
<li>HDMI 轉 VGA 轉接頭<br /></li>
<li>Type-C 轉 USB 轉接器<br /></li>
<li>國際電源插座轉換器<br /></li>
</ul></li>
</ul>

<p>
🔹 常見應用場景：<br />
</p>
<ul class="org-ul">
<li>整合舊系統與新系統<br /></li>
<li>第三方 API 轉接<br /></li>
<li>不同類型的資料轉換<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge53581d" class="outline-5">
<h5 id="orge53581d">📌 2. Adapter 設計模式的結構</h5>
<div class="outline-text-5" id="text-orge53581d">
<p>
適配器模式通常有三個主要角色：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">角色</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Target（目標介面）</td>
<td class="org-left">定義客戶端希望使用的標準介面</td>
</tr>

<tr>
<td class="org-left">Adaptee（被適配者）</td>
<td class="org-left">需要適配的現有類別（不兼容的類別）</td>
</tr>

<tr>
<td class="org-left">Adapter（適配器）</td>
<td class="org-left">將 Adaptee 轉換為 Target，使其能與 Client 一起使用</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org9c24e04" class="outline-5">
<h5 id="org9c24e04">📌 3.  Adapter 模式的實作</h5>
<div class="outline-text-5" id="text-org9c24e04">
<p>
範例：將 OldSystem 轉換為 NewSystem<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;"># &#23450;&#32681;&#26032;&#31995;&#32113;&#30340;&#27161;&#28310;&#20171;&#38754;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">NewSystem</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">def</span> request(self):
<span class="linenr"> 4: </span>        pass
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef; font-weight: bold;"># &#33290;&#31995;&#32113;</span>&#65288;&#19981;&#20860;&#23481;&#30340;&#39006;&#21029;&#65289;
<span class="linenr"> 7: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">OldSystem</span>:
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">def</span> specific_request(self):
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> <span style="color: #98be65;">"Old System Output"</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #51afef; font-weight: bold;"># &#36969;&#37197;&#22120;</span>&#65306;&#32380;&#25215;&#33290;&#31995;&#32113;&#65292;&#20006;&#36681;&#25563;&#28858;&#26032;&#31995;&#32113;&#30340;&#20171;&#38754;
<span class="linenr">12: </span><span style="color: #51afef;">class</span> Adapter(NewSystem, OldSystem):
<span class="linenr">13: </span>    <span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">request</span>(self):
<span class="linenr">14: </span>        <span style="color: #51afef;">return</span> self.specific_request()  # &#36681;&#25563;&#26041;&#27861;&#21517;&#31281;
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #51afef; font-weight: bold;"># &#23458;&#25142;&#31471;&#31243;&#24335;&#30908;</span>
<span class="linenr">17: </span>client = Adapter()
<span class="linenr">18: </span>print(client.request())  # <span style="color: #98be65;">"Old System Output"</span>
</pre>
</div>

<p>
✅ 重點：<br />
</p>
<ul class="org-ul">
<li>Adapter 繼承 OldSystem，並實作 NewSystem 介面。<br /></li>
<li>request() 內部呼叫 specific_request()，轉換舊系統的方法名稱。<br /></li>
</ul>

<p>
✅ 例子 2：物件適配器（Object Adapter，使用組合）<br />
</p>

<p>
範例：第三方 API 適配<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#26032;&#31995;&#32113;&#27161;&#28310;&#20171;&#38754;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">PaymentProcessor</span>:
<span class="linenr"> 3: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">pay</span>(<span style="color: #51afef;">self</span>, amount):
<span class="linenr"> 4: </span>        <span style="color: #51afef;">pass</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#33290;&#31995;&#32113;&#65288;&#31532;&#19977;&#26041; API&#65289;</span>
<span class="linenr"> 7: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">PayPal</span>:
<span class="linenr"> 8: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">send_payment</span>(<span style="color: #51afef;">self</span>, amount):
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> f<span style="color: #98be65;">"Paid </span>{amount}<span style="color: #98be65;"> using PayPal"</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#36969;&#37197;&#22120;&#65306;&#21253;&#35037;&#33290;&#31995;&#32113; API&#65292;&#20351;&#20854;&#31526;&#21512;&#26032;&#31995;&#32113;&#27161;&#28310;</span>
<span class="linenr">12: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">PayPalAdapter</span>(PaymentProcessor):
<span class="linenr">13: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__init__</span>(<span style="color: #51afef;">self</span>, paypal):
<span class="linenr">14: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">paypal</span> = paypal
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">pay</span>(<span style="color: #51afef;">self</span>, amount):
<span class="linenr">17: </span>        <span style="color: #51afef;">return</span> <span style="color: #51afef;">self</span>.paypal.send_payment(amount)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#36681;&#25563;&#26041;&#27861;&#21517;&#31281;</span>
<span class="linenr">18: </span>
<span class="linenr">19: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#23458;&#25142;&#31471;&#31243;&#24335;&#30908;</span>
<span class="linenr">20: </span><span style="color: #dcaeea;">paypal</span> = PayPalAdapter(PayPal())
<span class="linenr">21: </span><span style="color: #c678dd;">print</span>(paypal.pay(<span style="color: #da8548; font-weight: bold;">100</span>))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">"Paid 100 using PayPal"</span>
</pre>
</div>

<p>
✅ 重點：<br />
</p>
<ul class="org-ul">
<li>Adapter 組合（Composition） PayPal 物件，並轉換介面。<br /></li>
<li>客戶端只需要調用 pay()，而不需要知道 PayPal 內部的 send_payment()。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgcbd2faa" class="outline-5">
<h5 id="orgcbd2faa">📌 4. Adapter 模式的優缺點</h5>
<div class="outline-text-5" id="text-orgcbd2faa">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">優點</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">提升相容性：讓舊系統與新系統兼容</td>
<td class="org-left">可能增加程式碼複雜度</td>
</tr>

<tr>
<td class="org-left">不需要修改舊系統程式碼</td>
<td class="org-left">可能導致效能開銷（特別是在頻繁適配的情況下）</td>
</tr>

<tr>
<td class="org-left">符合開放封閉原則（OCP）</td>
<td class="org-left">過度使用會降低程式的可讀性</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgc899d56" class="outline-4">
<h4 id="orgc899d56"><span class="section-number-4">3.12.2.</span> 📚 與 Adapter 模式相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-12-2">
</div>
<div id="outline-container-orga8cc837" class="outline-5">
<h5 id="orga8cc837">1. 設計模式（Design Patterns）</h5>
<div class="outline-text-5" id="text-orga8cc837">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Adapter 屬於 結構型設計模式（Structural Design Patterns），其他類似的設計模式包括：</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">設計模式</td>
<td class="org-left">用途</td>
</tr>

<tr>
<td class="org-left">Adapter（適配器模式）</td>
<td class="org-left">讓不相容的介面可以一起使用</td>
</tr>

<tr>
<td class="org-left">Bridge（橋接模式）</td>
<td class="org-left">分離抽象與實作，使其可獨立變更</td>
</tr>

<tr>
<td class="org-left">Decorator（裝飾者模式）</td>
<td class="org-left">動態擴充類別的功能</td>
</tr>

<tr>
<td class="org-left">Facade（外觀模式）</td>
<td class="org-left">提供簡化的統一介面，封裝複雜的系統</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org8b85303" class="outline-5">
<h5 id="org8b85303">2. 依賴倒置原則（DIP, Dependency Inversion Principle）</h5>
<div class="outline-text-5" id="text-org8b85303">
<p>
適配器模式遵循 依賴倒置原則（DIP），即：<br />
</p>
<ul class="org-ul">
<li>高層模組不應該依賴低層模組，而是應該依賴抽象（介面）。<br /></li>
<li>透過 Adapter，客戶端只需要依賴 Target 介面，而不需要知道具體的 Adaptee 類別。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge9e7fef" class="outline-5">
<h5 id="orge9e7fef">3. 物件導向原則（OOP Principles）</h5>
<div class="outline-text-5" id="text-orge9e7fef">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">原則</th>
<th scope="col" class="org-left">適配器模式的應用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">單一職責原則（SRP）</td>
<td class="org-left">Adapter 負責轉換介面，而不是修改 Adaptee</td>
</tr>

<tr>
<td class="org-left">開放封閉原則（OCP）</td>
<td class="org-left">Adapter 擴展 Adaptee，而不修改其內部程式碼</td>
</tr>

<tr>
<td class="org-left">里氏替換原則（LSP）</td>
<td class="org-left">Adapter 可以被 Target 取代</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org6185ce1" class="outline-5">
<h5 id="org6185ce1">4. Adapter 模式在現代技術中的應用</h5>
<div class="outline-text-5" id="text-org6185ce1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">應用領域</th>
<th scope="col" class="org-left">Adapter 模式的用途</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">資料庫驅動（Database Drivers）</td>
<td class="org-left">例如 JDBC 驅動程式適配不同的資料庫（MySQL、PostgreSQL）</td>
</tr>

<tr>
<td class="org-left">API Gateway</td>
<td class="org-left">轉換不同的 API 介面（例如 REST API ⇄ SOAP API）</td>
</tr>

<tr>
<td class="org-left">前後端分離架構</td>
<td class="org-left">使用 Adapter 轉換 JSON / XML 資料格式</td>
</tr>

<tr>
<td class="org-left">Android 開發</td>
<td class="org-left">RecyclerView.Adapter 負責數據與 UI 的適配</td>
</tr>

<tr>
<td class="org-left">舊系統整合</td>
<td class="org-left">讓舊系統的 API 適配新的微服務架構</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org416bf42" class="outline-5">
<h5 id="org416bf42">📌 總結</h5>
<div class="outline-text-5" id="text-org416bf42">
<ul class="org-ul">
<li>Adapter（適配器模式） 用於讓不相容的類別可以一起運作，是 結構型設計模式 的一部分。<br /></li>
<li>主要應用場景：<br />
<ul class="org-ul">
<li>舊系統與新系統整合<br /></li>
<li>第三方 API 適配<br /></li>
<li>不同資料格式的轉換<br /></li>
</ul></li>
<li>兩種實作方式：<br />
<ul class="org-ul">
<li>類別適配器（繼承方式）<br /></li>
<li>物件適配器（組合方式）<br /></li>
</ul></li>
<li>與其他設計模式的關聯：<br />
<ul class="org-ul">
<li>與 Bridge 不同，Adapter 解決的是現有系統的相容性問題。<br /></li>
<li>與 Decorator 不同，Adapter 主要用於轉換介面，而不是擴充功能。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7bf86f5" class="outline-3">
<h3 id="org7bf86f5"><span class="section-number-3">3.13.</span> A-3 <code>[5%]</code></h3>
<div class="outline-text-3" id="text-3-13">
<p>
What is cohesion? Is it a desirable quality in software design?<br />
</p>
</div>
<div id="outline-container-orgea9b560" class="outline-4">
<h4 id="orgea9b560"><span class="section-number-4">3.13.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-13-1">
<p>
內聚性（Cohesion）與軟體設計<br />
</p>
</div>
<div id="outline-container-orgaf84d5c" class="outline-5">
<h5 id="orgaf84d5c">📌 什麼是 Cohesion（內聚性）？</h5>
<div class="outline-text-5" id="text-orgaf84d5c">
<p>
內聚性（Cohesion） 是指程式碼中的模組（Module）或類別（Class）內部各個元素（函式、變數）彼此之間的關聯程度。<br />
</p>
<ul class="org-ul">
<li>高內聚（High Cohesion）：<br />
<ul class="org-ul">
<li>模組的職責單一且專注，所有函式都與主要功能緊密相關。<br /></li>
<li>優點：<br />
<ul class="org-ul">
<li>增強可維護性（Maintainability）。<br /></li>
<li>促進程式碼的可讀性（Readability）。<br /></li>
<li>減少模組間的相依性（Dependency），提高可重用性（Reusability）。<br /></li>
</ul></li>
</ul></li>
<li>低內聚（Low Cohesion）：<br />
<ul class="org-ul">
<li>模組內部的函式和變數彼此關聯性低，可能涵蓋多個不同的功能。<br /></li>
<li>缺點：<br />
<ul class="org-ul">
<li>使得程式碼難以理解與測試。<br /></li>
<li>變更模組時，可能會影響到不相關的功能。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb8f2c8f" class="outline-5">
<h5 id="orgb8f2c8f">📌 內聚性是軟體設計中的理想特性嗎？</h5>
<div class="outline-text-5" id="text-orgb8f2c8f">
<p>
✅ 是的！高內聚是軟體設計中的理想特性！<br />
</p>
<ul class="org-ul">
<li>高內聚的模組 更容易測試、維護、重用，並降低錯誤發生的機率。<br /></li>
<li>低內聚的模組 可能會影響系統的擴展性，因為它會同時影響許多不相關的功能。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga7711d2" class="outline-5">
<h5 id="orga7711d2">📌 內聚性的種類（Cohesion Types）</h5>
<div class="outline-text-5" id="text-orga7711d2">
<p>
從低內聚到高內聚，內聚性可以分為以下幾種：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">內聚性類型</th>
<th scope="col" class="org-left">描述	範例	評價</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">偶然性內聚（Coincidental Cohesion）	函式之間毫無關聯，只是被放在同一個模組內	一個模組包含「資料庫連線」+「UI 更新」	🚨 最糟糕（最低內聚）</td>
</tr>

<tr>
<td class="org-left">邏輯性內聚（Logical Cohesion）	依據相似邏輯分組，但彼此功能獨立	processData() 同時處理 XML 和 JSON	⚠️ 不佳（內聚度低）</td>
</tr>

<tr>
<td class="org-left">時間性內聚（Temporal Cohesion）	依據執行時間的先後順序來分組	init() 函式內同時執行「開啟檔案」+「載入設定」	⚠️ 一般（仍可改進）</td>
</tr>

<tr>
<td class="org-left">程序性內聚（Procedural Cohesion）	一組函式執行相同的程序步驟，但彼此無關	readFile() 內部呼叫 parseFile() 和 printToScreen()	⚠️ 尚可（有改善空間）</td>
</tr>

<tr>
<td class="org-left">通訊性內聚（Communicational Cohesion）	所有函式都在操作相同的資料	calculateStats() 計算統計數據並存入資料庫	✅ 良好</td>
</tr>

<tr>
<td class="org-left">功能性內聚（Functional Cohesion）	模組內所有函式只負責單一功能	calculateTax() 只計算稅額，不處理輸出	🔥 最佳（高內聚）</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org26adcd9" class="outline-5">
<h5 id="org26adcd9">📌 內聚性與耦合性（Cohesion vs. Coupling）</h5>
<div class="outline-text-5" id="text-org26adcd9">
<p>
內聚性與耦合性是軟體設計中的兩個關鍵概念：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">概念</td>
<td class="org-left">描述</td>
<td class="org-left">設計建議</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">內聚性（Cohesion）</td>
<td class="org-left">模組內部元素的相關性</td>
<td class="org-left">應該提高（High Cohesion）</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">耦合性（Coupling）</td>
<td class="org-left">模組之間的相依程度</td>
<td class="org-left">應該降低（Low Coupling）</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
✅ 最佳設計應該「高內聚、低耦合」：<br />
</p>
<ul class="org-ul">
<li>高內聚：模組內的函式彼此緊密相關，確保單一職責。<br /></li>
<li>低耦合：模組間彼此獨立，減少相依性，方便變更。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb9f9ea0" class="outline-5">
<h5 id="orgb9f9ea0">📌 內聚性的實作範例</h5>
<div class="outline-text-5" id="text-orgb9f9ea0">
<p>
❌ 低內聚範例（Bad Example）<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Utility</span>:
<span class="linenr"> 2: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">read_file</span>(<span style="color: #51afef;">self</span>, filename):
<span class="linenr"> 3: </span>        <span style="color: #51afef;">with</span> <span style="color: #c678dd;">open</span>(filename, <span style="color: #98be65;">'r'</span>) <span style="color: #51afef;">as</span> <span style="color: #c678dd;">file</span>:
<span class="linenr"> 4: </span>            <span style="color: #51afef;">return</span> <span style="color: #c678dd;">file</span>.read()
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">calculate_sum</span>(<span style="color: #51afef;">self</span>, numbers):
<span class="linenr"> 7: </span>        <span style="color: #51afef;">return</span> <span style="color: #c678dd;">sum</span>(numbers)
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">send_email</span>(<span style="color: #51afef;">self</span>, recipient, message):
<span class="linenr">10: </span>        <span style="color: #c678dd;">print</span>(f<span style="color: #98be65;">"Sending email to </span>{recipient}<span style="color: #98be65;">: </span>{message}<span style="color: #98be65;">"</span>)
</pre>
</div>

<p>
🔹 問題：<br />
</p>
<ul class="org-ul">
<li>Utility 類別內有完全不相關的功能（檔案讀取、數學計算、電子郵件）。<br /></li>
<li>這樣的設計內聚性極低，應該將不同功能拆成不同模組。<br /></li>
</ul>

<p>
✅ 高內聚範例（Good Example）<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">FileHandler</span>:
<span class="linenr">2: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">read_file</span>(<span style="color: #51afef;">self</span>, filename):
<span class="linenr">3: </span>        <span style="color: #51afef;">with</span> <span style="color: #c678dd;">open</span>(filename, <span style="color: #98be65;">'r'</span>) <span style="color: #51afef;">as</span> <span style="color: #c678dd;">file</span>:
<span class="linenr">4: </span>            <span style="color: #51afef;">return</span> <span style="color: #c678dd;">file</span>.read()
<span class="linenr">5: </span>
<span class="linenr">6: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">write_file</span>(<span style="color: #51afef;">self</span>, filename, content):
<span class="linenr">7: </span>        <span style="color: #51afef;">with</span> <span style="color: #c678dd;">open</span>(filename, <span style="color: #98be65;">'w'</span>) <span style="color: #51afef;">as</span> <span style="color: #c678dd;">file</span>:
<span class="linenr">8: </span>            <span style="color: #c678dd;">file</span>.write(content)
</pre>
</div>
<p>
🔹 優點：<br />
</p>
<ul class="org-ul">
<li>FileHandler 只負責「檔案處理」，不包含不相關的功能（高內聚）。<br /></li>
<li>單一職責原則（SRP, Single Responsibility Principle），提高可維護性。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6d42d06" class="outline-4">
<h4 id="org6d42d06"><span class="section-number-4">3.13.2.</span> 📚 與 Cohesion 相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-13-2">
</div>
<div id="outline-container-org6dcc249" class="outline-5">
<h5 id="org6dcc249">1. 內聚性與軟體設計原則</h5>
<div class="outline-text-5" id="text-org6dcc249">
<p>
內聚性符合多個軟體設計原則，例如：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">原則</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">內聚性關聯</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">單一職責原則（SRP）</td>
<td class="org-left">每個類別應該只做一件事</td>
<td class="org-left">高內聚有助於單一職責</td>
</tr>

<tr>
<td class="org-left">開放封閉原則（OCP）</td>
<td class="org-left">模組應對擴展開放，對修改封閉</td>
<td class="org-left">高內聚的模組更容易擴展</td>
</tr>

<tr>
<td class="org-left">依賴倒置原則（DIP）</td>
<td class="org-left">高層模組不應依賴低層模組的細節</td>
<td class="org-left">高內聚的模組更容易解耦</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgd12842d" class="outline-5">
<h5 id="orgd12842d">2. 內聚性在設計模式中的應用</h5>
<div class="outline-text-5" id="text-orgd12842d">
<p>
高內聚模組更容易使用設計模式來提高系統可維護性：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">設計模式</th>
<th scope="col" class="org-left">如何幫助提高內聚性？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Singleton（單例模式）</td>
<td class="org-left">確保模組的唯一性，使其負責單一功能</td>
</tr>

<tr>
<td class="org-left">Facade（外觀模式）</td>
<td class="org-left">將多個子系統封裝成單一介面，提高內聚性</td>
</tr>

<tr>
<td class="org-left">Adapter（適配器模式）</td>
<td class="org-left">轉換不同介面，讓模組職責更清晰</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org17ecb89" class="outline-5">
<h5 id="org17ecb89">3. 內聚性與微服務架構（Microservices）</h5>
<div class="outline-text-5" id="text-org17ecb89">
<p>
在微服務架構中：<br />
</p>
<ul class="org-ul">
<li>每個微服務應該高度內聚，只處理一個特定的業務邏輯。<br /></li>
<li>範例：電子商務系統<br />
<ul class="org-ul">
<li>OrderService：只處理訂單<br /></li>
<li>PaymentService：只處理付款<br /></li>
<li>UserService：只處理使用者資訊<br /></li>
</ul></li>
<li>這樣的設計可提高可擴展性與可維護性。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org48afa89" class="outline-5">
<h5 id="org48afa89">📌 總結</h5>
<div class="outline-text-5" id="text-org48afa89">
<ul class="org-ul">
<li>內聚性（Cohesion） 是指模組內部各個功能彼此的關聯性，高內聚是軟體設計中的理想特性。<br /></li>
<li>高內聚優點：<br />
<ul class="org-ul">
<li>提高可讀性、可維護性<br /></li>
<li>減少模組間的相依性<br /></li>
<li>提高程式碼的可重用性<br /></li>
</ul></li>
<li>應用範圍：<br />
<ul class="org-ul">
<li>軟體設計原則（SRP, OCP）<br /></li>
<li>設計模式（Singleton, Facade）<br /></li>
<li>微服務架構（Microservices）<br /></li>
</ul></li>
<li>最佳實踐：<br />
<ul class="org-ul">
<li>高內聚、低耦合<br /></li>
<li>確保模組負責單一職責<br /></li>
<li>避免將不相關功能混在一起<br /></li>
</ul></li>
</ul>

<p>
✅ 理解 Cohesion 是提升軟體品質、設計高可維護系統的關鍵！🚀📚<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1f338db" class="outline-3">
<h3 id="org1f338db"><span class="section-number-3">3.14.</span> B-l (4%)</h3>
<div class="outline-text-3" id="text-3-14">
<p>
In C++, call-by-reference can achieve the security of call-by-value when<br />
</p>
<ol class="org-ol">
<li>The value being passed is small.<br /></li>
<li>The const qualifier is used.<br /></li>
<li>A pointer to the argument is used.<br /></li>
<li>A large argument is passed in order to improve performance.<br /></li>
</ol>
</div>
<div id="outline-container-orgada4c9c" class="outline-4">
<h4 id="orgada4c9c"><span class="section-number-4">3.14.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-14-1">
<p>
答案：✅ b) The const qualifier is used.<br />
（當 const 限定符用於參考傳遞時，call-by-reference 可以達到與 call-by-value 相同的安全性。）<br />
</p>
</div>
</div>
<div id="outline-container-orgb6fab50" class="outline-4">
<h4 id="orgb6fab50"><span class="section-number-4">3.14.2.</span> 📖 詳解</h4>
<div class="outline-text-4" id="text-3-14-2">
<p>
在 C++ 中，函式參數的傳遞方式主要有兩種：<br />
</p>
<ul class="org-ul">
<li>Call-by-Value（值傳遞）<br /></li>
<li>Call-by-Reference（引用傳遞）<br /></li>
</ul>
</div>
<div id="outline-container-org576c9e8" class="outline-5">
<h5 id="org576c9e8">📌 1. 值傳遞（Call-by-Value）</h5>
<div class="outline-text-5" id="text-org576c9e8">
<p>
概念：<br />
</p>
<ul class="org-ul">
<li>傳遞時 建立變數的副本，在函式內部的修改不影響原變數。<br /></li>
<li>安全性較高，但如果傳遞的資料很大（如 std::vector&lt;int&gt;），開銷較大。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">modifyValue</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) {
<span class="linenr">2: </span>    x = <span style="color: #da8548; font-weight: bold;">10</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21482;&#20462;&#25913;&#21103;&#26412;&#65292;&#19981;&#24433;&#38911;&#21407;&#35722;&#25976;</span>
<span class="linenr">3: </span>}
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">6: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5</span>;
<span class="linenr">7: </span>    modifyValue(a);
<span class="linenr">8: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; a;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20173;&#28982;&#36664;&#20986; 5</span>
<span class="linenr">9: </span>}
</pre>
</div>

<p>
✅ 優點：<br />
</p>
<ul class="org-ul">
<li>保證原變數不被修改，確保安全性（Security）。<br /></li>
<li>適合傳遞 小型變數（如 int、char），因為開銷小。<br /></li>
</ul>

<p>
❌ 缺點：<br />
</p>
<ul class="org-ul">
<li>若傳遞大型變數（如 std::vector&lt;int&gt;），會複製整個物件，降低效能（Performance）。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org868bcdf" class="outline-5">
<h5 id="org868bcdf">📌 2. 引用傳遞（Call-by-Reference）</h5>
<div class="outline-text-5" id="text-org868bcdf">
<p>
概念：<br />
</p>
<ul class="org-ul">
<li>參數傳遞的是變數的別名（Alias），在函式內部的修改會影響原變數。<br /></li>
<li>效能較佳（避免額外的複製開銷），但可能導致變數被意外修改，影響安全性。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">modifyReference</span>(<span style="color: #ECBE7B;">int</span> &amp;<span style="color: #dcaeea;">x</span>) {
<span class="linenr">2: </span>    x = <span style="color: #da8548; font-weight: bold;">10</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30452;&#25509;&#20462;&#25913;&#21407;&#35722;&#25976;</span>
<span class="linenr">3: </span>}
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">6: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5</span>;
<span class="linenr">7: </span>    modifyReference(a);
<span class="linenr">8: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; a;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35722;&#25104; 10</span>
<span class="linenr">9: </span>}
</pre>
</div>

<p>
✅ 優點：<br />
</p>
<ul class="org-ul">
<li>效能較高，因為不需要複製變數。<br /></li>
<li>適合大型資料結構（如 std::vector&lt;&gt;、std::string）。<br /></li>
</ul>

<p>
❌ 缺點：<br />
</p>
<ul class="org-ul">
<li>可能導致意外修改，降低程式的安全性。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org94a4a77" class="outline-5">
<h5 id="org94a4a77">📌 3. const 限定符（const Qualifier）</h5>
<div class="outline-text-5" id="text-org94a4a77">
<p>
若要在引用傳遞時達到值傳遞的安全性，可以使用 const 限定符：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">printValue</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">int</span> &amp;<span style="color: #dcaeea;">x</span>) {
<span class="linenr">2: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">x = 10; // &#10060; &#37679;&#35492;&#65306;x &#21463; const &#20445;&#35703;&#65292;&#19981;&#33021;&#34987;&#20462;&#25913;</span>
<span class="linenr">3: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x;
<span class="linenr">4: </span>}
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">7: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5</span>;
<span class="linenr">8: </span>    printValue(a);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a &#20173;&#28982;&#20445;&#25345;&#28858; 5</span>
<span class="linenr">9: </span>}
</pre>
</div>

<p>
為什麼 const 可以達到值傳遞的安全性？<br />
</p>
<ul class="org-ul">
<li>const 保證函式內無法修改傳遞的變數，因此與值傳遞一樣安全。<br /></li>
<li>const 同時保留了引用傳遞的效能優勢（避免拷貝）。<br /></li>
</ul>

<p>
✅ 因此，正確答案為： b) The const qualifier is used.<br />
</p>
</div>
</div>
<div id="outline-container-org305a9d3" class="outline-5">
<h5 id="org305a9d3">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-org305a9d3">
</div>
<ul class="org-ul">
<li><a id="orgb8db57e"></a>❌ a) The value being passed is small.<br />
<div class="outline-text-6" id="text-orgb8db57e">
<p>
（當傳遞的值很小時，call-by-reference 也可以像 call-by-value 一樣安全）<br />
</p>

<p>
錯誤！<br />
</p>
<ul class="org-ul">
<li>小型變數（如 int、char）的值傳遞本身就是最安全的，但這與 call-by-reference 的安全性無關。<br /></li>
<li>即使變數很小，如果是 call-by-reference（如 int &amp;x），函式仍然可以修改原變數。<br /></li>
</ul>
</div>
</li>
<li><a id="org5d79675"></a>❌ c) A pointer to the argument is used.<br />
<div class="outline-text-6" id="text-org5d79675">
<p>
（使用指標傳遞變數）<br />
</p>

<p>
錯誤！<br />
</p>
<ul class="org-ul">
<li>指標傳遞（Call-by-Pointer）與引用傳遞類似，但更不安全，因為：<br />
<ul class="org-ul">
<li>可能發生 空指標（nullptr）存取。<br /></li>
<li>指標可以被改變指向，導致未預期的錯誤。<br /></li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">modifyPointer</span>(<span style="color: #ECBE7B;">int</span> *<span style="color: #dcaeea;">p</span>) {
<span class="linenr">2: </span>    *p = <span style="color: #da8548; font-weight: bold;">10</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20462;&#25913;&#21407;&#35722;&#25976;</span>
<span class="linenr">3: </span>}
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">6: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5</span>;
<span class="linenr">7: </span>    modifyPointer(&amp;a);
<span class="linenr">8: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; a;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35722;&#25104; 10</span>
<span class="linenr">9: </span>}
</pre>
</div>

<p>
✅ 解決方案：使用 const int *p 確保內容不可變更<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">printPointer</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">int</span> *<span style="color: #dcaeea;">p</span>) {
<span class="linenr">2: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">*p = 10; // &#10060; &#37679;&#35492;&#65306;const &#38480;&#21046;&#35722;&#25976;&#19981;&#33021;&#34987;&#20462;&#25913;</span>
<span class="linenr">3: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; *p;
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</li>
<li><a id="orgcd120d7"></a>❌ d) A large argument is passed in order to improve performance.<br />
<div class="outline-text-6" id="text-orgcd120d7">
<p>
（為了效能，對大型變數使用引用傳遞）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br />
<ul class="org-ul">
<li>這是引用傳遞的優勢，但與「安全性」無關。<br /></li>
<li>即使是大型變數（如 std::vector&lt;int&gt;），如果沒有 const，仍然可以被修改，破壞原變數的數據。<br /></li>
</ul></li>
</ul>

<p>
✅ 正確做法：對大型變數使用 const &amp;<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">printVector</span>(<span style="color: #51afef;">const</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; &amp;<span style="color: #dcaeea;">vec</span>) {
<span class="linenr">2: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">vec.push_back(10); // &#10060; &#37679;&#35492;&#65306;vec &#21463; const &#20445;&#35703;</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">num</span> : vec) {
<span class="linenr">4: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; num &lt;&lt; <span style="color: #98be65;">" "</span>;
<span class="linenr">5: </span>    }
<span class="linenr">6: </span>}
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org911b30e" class="outline-4">
<h4 id="org911b30e"><span class="section-number-4">3.14.3.</span> 📚 與該主題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-14-3">
</div>
<div id="outline-container-org8c7e992" class="outline-5">
<h5 id="org8c7e992">1. C++ 主要參數傳遞方式</h5>
<div class="outline-text-5" id="text-org8c7e992">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">傳遞方式</th>
<th scope="col" class="org-left">語法</th>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">優缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">值傳遞（Call-by-Value）</td>
<td class="org-left">void func(int x)</td>
<td class="org-left">副本傳遞</td>
<td class="org-left">安全但效能低（對大數據結構）</td>
</tr>

<tr>
<td class="org-left">引用傳遞（Call-by-Reference）</td>
<td class="org-left">void func(int &amp;x)</td>
<td class="org-left">傳遞別名</td>
<td class="org-left">效能高但可能改變原變數</td>
</tr>

<tr>
<td class="org-left">指標傳遞（Call-by-Pointer）</td>
<td class="org-left">void func(int *p)</td>
<td class="org-left">可操作指標</td>
<td class="org-left">可能發生空指標錯誤</td>
</tr>

<tr>
<td class="org-left">常數引用（Const Reference）</td>
<td class="org-left">void func(const int &amp;x)</td>
<td class="org-left">只讀引用</td>
<td class="org-left">效能高且安全（最佳做法）</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org48f2b6b" class="outline-5">
<h5 id="org48f2b6b">2. const 在 C++ 的其他應用</h5>
<div class="outline-text-5" id="text-org48f2b6b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">語法</th>
<th scope="col" class="org-left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">const int x = 10;</td>
<td class="org-left">定義常數變數</td>
</tr>

<tr>
<td class="org-left">void func(const int &amp;x);</td>
<td class="org-left">保護引用參數，防止修改</td>
</tr>

<tr>
<td class="org-left">const int* p;</td>
<td class="org-left">指標指向的值不可變</td>
</tr>

<tr>
<td class="org-left">int* const p;</td>
<td class="org-left">指標本身不可變</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org710cfe7" class="outline-5">
<h5 id="org710cfe7">3. const 在類別中的應用</h5>
<div class="outline-text-5" id="text-org710cfe7">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr">2: </span><span style="color: #51afef;">public</span>:
<span class="linenr">3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() <span style="color: #51afef;">const</span> {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">const &#25104;&#21729;&#20989;&#24335;</span>
<span class="linenr">4: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"This function cannot modify class members."</span>;
<span class="linenr">5: </span>    }
<span class="linenr">6: </span>};
</pre>
</div>
<p>
✅ 確保 show() 不能修改類別內部的變數，增強安全性！<br />
</p>
</div>
</div>
<div id="outline-container-orge4eb007" class="outline-5">
<h5 id="orge4eb007">📌 總結</h5>
<div class="outline-text-5" id="text-orge4eb007">
<ul class="org-ul">
<li>Call-by-Value（值傳遞） 安全但效能較低（適用於小型變數）。<br /></li>
<li>Call-by-Reference（引用傳遞） 可能修改原變數（適用於大型變數）。<br /></li>
<li>const &amp; 可以保護引用變數，達到 Call-by-Value 的安全性，因此： ✅ 正確答案為：b) The const qualifier is used.<br /></li>
<li>最佳做法：<br />
<ul class="org-ul">
<li>小型變數：使用值傳遞。<br /></li>
<li>大型變數：使用 const &amp;（提升效能，確保安全）。<br /></li>
<li>需要修改參數：使用非 const 的引用。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org718b821" class="outline-3">
<h3 id="org718b821"><span class="section-number-3">3.15.</span> B-2 (4%)</h3>
<div class="outline-text-3" id="text-3-15">
<p>
Recursion is memory-intensive because<br />
</p>
<ol class="org-ol">
<li>It requires large data values.<br /></li>
<li>Many copies of the ftnction code are created.<br /></li>
<li>Recursive functions tend to declare many local variables.<br /></li>
<li>Previous ftnction calls are still open when the function calls itself and the activation records of these previous calls still occupy space on the call stack.<br /></li>
</ol>
</div>
<div id="outline-container-org9987c34" class="outline-4">
<h4 id="org9987c34"><span class="section-number-4">3.15.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-15-1">
<p>
答案：<br />
</p>

<p>
✅ d) Previous function calls are still open when the function calls itself and the activation records of these previous calls still occupy space on the call stack.<br />
（當遞迴函式呼叫自己時，之前的函式調用仍然處於開啟狀態，並且它們的活動記錄（Activation Records） 仍然佔據呼叫堆疊（Call Stack）的空間。）<br />
</p>
</div>
</div>
<div id="outline-container-orgf586bc2" class="outline-4">
<h4 id="orgf586bc2"><span class="section-number-4">3.15.2.</span> 📖 詳解</h4>
<div class="outline-text-4" id="text-3-15-2">
</div>
<div id="outline-container-orgd83fcb6" class="outline-5">
<h5 id="orgd83fcb6">📌 1. 遞迴（Recursion）是什麼？</h5>
<div class="outline-text-5" id="text-orgd83fcb6">
<p>
遞迴（Recursion）是一種函式呼叫自身的程式設計技術，適用於解決具有**自相似性（Self-Similarity）**的問題，例如：<br />
</p>
<ul class="org-ul">
<li>數學問題（如費氏數列、階乘計算）。<br /></li>
<li>資料結構遍歷（如二元樹、圖遍歷）。<br /></li>
<li>分治演算法（Divide and Conquer）（如歸併排序、快速排序）。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgea2ae76" class="outline-5">
<h5 id="orgea2ae76">📌 2. 為什麼遞迴會消耗大量記憶體？</h5>
<div class="outline-text-5" id="text-orgea2ae76">
<p>
遞迴函式的每次呼叫都會在呼叫堆疊（Call Stack） 上分配新的活動記錄（Activation Record），以儲存：<br />
</p>
<ul class="org-ul">
<li>當前函式的參數與局部變數。<br /></li>
<li>返回地址（Return Address），以便遞迴結束後能返回原來的呼叫位置。<br /></li>
</ul>

<p>
如果遞迴層數太深，會導致：<br />
</p>
<ul class="org-ul">
<li>大量堆疊記憶體被佔用（Stack Memory Overhead）。<br /></li>
<li>可能導致堆疊溢位（Stack Overflow），尤其在沒有適當終止條件的情況下。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3d011c1" class="outline-5">
<h5 id="org3d011c1">📌 3. 例子：階乘（Factorial）的遞迴與記憶體消耗</h5>
<div class="outline-text-5" id="text-org3d011c1">
<p>
✅ 遞迴版（可能導致大量記憶體消耗）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">factorial</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">2: </span>    <span style="color: #51afef;">if</span> (n == <span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22522;&#26412;&#26781;&#20214;&#65288;Base Case&#65289;</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">return</span> n * factorial(n - <span style="color: #da8548; font-weight: bold;">1</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36958;&#36852;&#21628;&#21483;</span>
<span class="linenr">4: </span>}
</pre>
</div>

<p>
✅ 階乘計算的呼叫堆疊（當 n=5 時）：<br />
</p>

<p>
factorial(5)<br />
    → factorial(4)<br />
        → factorial(3)<br />
            → factorial(2)<br />
                → factorial(1)<br />
                    → factorial(0) 返回 1<br />
</p>

<ul class="org-ul">
<li>每次遞迴呼叫都會開啟一個新的堆疊幀（Stack Frame），直到 n=0 時才開始回溯（Unwinding）。<br /></li>
<li>如果 n 很大（如 n=10000），則會佔用過多的記憶體並可能導致「堆疊溢位」。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5a7cd4d" class="outline-5">
<h5 id="org5a7cd4d">📌 4. 其他選項解析</h5>
<div class="outline-text-5" id="text-org5a7cd4d">
</div>
<ul class="org-ul">
<li><a id="orgdb18de8"></a>❌ a) It requires large data values.（它需要大的數據值）<br />
<div class="outline-text-6" id="text-orgdb18de8">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>遞迴函式不一定需要處理大數據。即使輸入值很小（如 factorial(5)），遞迴仍然會消耗額外的堆疊記憶體。<br /></li>
<li>問題的關鍵不在於數據大小，而是函式呼叫的層數。<br /></li>
</ul>
</div>
</li>
<li><a id="org45afa6c"></a>❌ b) Many copies of the function code are created.（遞迴會產生許多函式程式碼的副本）<br />
<div class="outline-text-6" id="text-org45afa6c">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>每次遞迴呼叫時，並不會複製函式程式碼，而只是建立新的活動記錄（Activation Record），儲存變數與返回地址。<br /></li>
<li>程式碼本身只會有一份，但函式的執行狀態會在堆疊上分配新的空間。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd4aa77d"></a>❌ c) Recursive functions tend to declare many local variables.（遞迴函式通常會聲明許多局部變數）<br />
<div class="outline-text-6" id="text-orgd4aa77d">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>遞迴函式並不一定會聲明大量局部變數。即使函式內部變數很少，只要遞迴層數夠深，仍然會消耗大量記憶體。<br /></li>
<li>真正導致高記憶體消耗的因素是「未回收的堆疊幀數量」，而非局部變數的數量。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgedde143" class="outline-4">
<h4 id="orgedde143"><span class="section-number-4">3.15.3.</span> 📚 與遞迴相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-15-3">
</div>
<div id="outline-container-org028b039" class="outline-5">
<h5 id="org028b039">1. 遞迴的類型</h5>
<div class="outline-text-5" id="text-org028b039">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">類型</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">範例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">直接遞迴（Direct Recursion）</td>
<td class="org-left">函式自己呼叫自己</td>
<td class="org-left">factorial(n) → factorial(n-1)</td>
</tr>

<tr>
<td class="org-left">間接遞迴（Indirect Recursion）</td>
<td class="org-left">兩個或多個函式彼此呼叫</td>
<td class="org-left">A() → B() → A()</td>
</tr>

<tr>
<td class="org-left">尾遞迴（Tail Recursion）</td>
<td class="org-left">遞迴呼叫發生在最後一行</td>
<td class="org-left">return factorial(n-1) * n;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orga775014" class="outline-5">
<h5 id="orga775014">2. 遞迴 vs. 疊代（Iteration）</h5>
<div class="outline-text-5" id="text-orga775014">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">遞迴（Recursion）</th>
<th scope="col" class="org-left">疊代（Iteration）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">記憶體使用</td>
<td class="org-left">使用呼叫堆疊（較多記憶體）</td>
<td class="org-left">使用 for 或 while，記憶體需求低</td>
</tr>

<tr>
<td class="org-left">效能</td>
<td class="org-left">可能較慢（多次函式呼叫）</td>
<td class="org-left">通常較快（單一循環）</td>
</tr>

<tr>
<td class="org-left">程式碼可讀性</td>
<td class="org-left">可讀性高，適合遞迴結構</td>
<td class="org-left">可能需要手動維護堆疊</td>
</tr>

<tr>
<td class="org-left">應用範例</td>
<td class="org-left">樹遍歷、分治演算法</td>
<td class="org-left">簡單的迴圈計算</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgae8cb5f" class="outline-5">
<h5 id="orgae8cb5f">3. 優化遞迴的技術</h5>
<div class="outline-text-5" id="text-orgae8cb5f">
</div>
<ul class="org-ul">
<li><a id="org2622b7c"></a>✅ (1) 使用尾遞迴（Tail Recursion）<br />
<div class="outline-text-6" id="text-org2622b7c">
<ul class="org-ul">
<li>尾遞迴的函式不會建立新的堆疊幀，而是覆蓋當前的堆疊記錄，減少記憶體使用。<br /></li>
<li>部分編譯器（如 GCC）可自動優化尾遞迴。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">factorial_tail</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">accumulator</span> = <span style="color: #da8548; font-weight: bold;">1</span>) {
<span class="linenr">2: </span>    <span style="color: #51afef;">if</span> (n == <span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #51afef;">return</span> accumulator;
<span class="linenr">3: </span>    <span style="color: #51afef;">return</span> factorial_tail(n - <span style="color: #da8548; font-weight: bold;">1</span>, n * accumulator);
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</li>
<li><a id="org6f32ccc"></a>✅ (2) 改為疊代版本<br />
<div class="outline-text-6" id="text-org6f32ccc">
<p>
避免遞迴造成的堆疊溢位：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">factorial_iterative</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">result</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">3: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">1</span>; i &lt;= n; i++) {
<span class="linenr">4: </span>        result *= i;
<span class="linenr">5: </span>    }
<span class="linenr">6: </span>    <span style="color: #51afef;">return</span> result;
<span class="linenr">7: </span>}
</pre>
</div>

<p>
✅ 此方法可避免過多堆疊使用，提升效能！<br />
</p>
</div>
</li>
<li><a id="orgf6986c1"></a>✅ (3) 記憶化（Memoization，適用於費氏數列等問題）<br />
<div class="outline-text-6" id="text-orgf6986c1">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;vector&gt;</span>
<span class="linenr">2: </span><span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">memo</span>(<span style="color: #da8548; font-weight: bold;">100</span>, -<span style="color: #da8548; font-weight: bold;">1</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21021;&#22987;&#21270;&#20786;&#23384;&#35336;&#31639;&#32080;&#26524;&#30340;&#38499;&#21015;</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fibonacci</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">5: </span>    <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr">6: </span>    <span style="color: #51afef;">if</span> (memo[n] != -<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> memo[n];  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#24050;&#35336;&#31639;&#36942;&#65292;&#30452;&#25509;&#36820;&#22238;</span>
<span class="linenr">7: </span>    <span style="color: #51afef;">return</span> memo[n] = fibonacci(n-<span style="color: #da8548; font-weight: bold;">1</span>) + fibonacci(n-<span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr">8: </span>}
</pre>
</div>

<p>
✅ 避免重複計算，大幅提升效率！<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge445c72" class="outline-5">
<h5 id="orge445c72">📌 總結</h5>
<div class="outline-text-5" id="text-orge445c72">
<ul class="org-ul">
<li>遞迴函式會消耗大量記憶體，因為每次函式呼叫都會在「呼叫堆疊（Call Stack）」上分配新的活動記錄（Activation Record）。<br /></li>
<li>關鍵問題在於遞迴深度過深，導致「堆疊溢位（Stack Overflow）」。<br /></li>
<li>最佳解法：<br />
<ul class="org-ul">
<li>使用尾遞迴（Tail Recursion）<br /></li>
<li>改為疊代（Iteration）<br /></li>
<li>使用記憶化（Memoization）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf657609" class="outline-3">
<h3 id="orgf657609"><span class="section-number-3">3.16.</span> B-3 (4%)</h3>
<div class="outline-text-3" id="text-3-16">
<p>
In C++, comparing pointers and performing pointer arithmetic on them is meaningless unless<br />
</p>
<ol class="org-ol">
<li>They point to elements of the same array.<br /></li>
<li>They point to arrays of the same type.<br /></li>
<li>You are trying to compare and perform pointer arithmetic on the values to which they point.<br /></li>
<li>They point to arrays of equal size.<br /></li>
</ol>
</div>
<div id="outline-container-orge190466" class="outline-4">
<h4 id="orge190466"><span class="section-number-4">3.16.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-16-1">
<p>
✅ a) They point to elements of the same array.<br />
（在 C++ 中，對指標進行比較與指標運算在指標指向同一個陣列的元素時才有意義。）<br />
</p>
</div>
</div>
<div id="outline-container-org216829b" class="outline-4">
<h4 id="org216829b"><span class="section-number-4">3.16.2.</span> 📖 詳解</h4>
<div class="outline-text-4" id="text-3-16-2">
</div>
<div id="outline-container-org1ff623e" class="outline-5">
<h5 id="org1ff623e">📌 1. 指標比較（Pointer Comparison）與指標運算（Pointer Arithmetic）</h5>
<div class="outline-text-5" id="text-org1ff623e">
<p>
在 C++ 中，指標（Pointer）是變數的地址。對指標進行比較或指標運算（如 p1 - p2）時，只有當它們指向同一個陣列（Array）內的元素時，這些操作才有意義。<br />
</p>

<p>
舉例：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr</span>[] = {<span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">20</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">40</span>};
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr[<span style="color: #da8548; font-weight: bold;">1</span>]; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521; arr[1] (20)</span>
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr[<span style="color: #da8548; font-weight: bold;">3</span>]; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521; arr[3] (40)</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27604;&#36611;&#25351;&#27161;</span>
<span class="linenr"> 6: </span><span style="color: #51afef;">if</span> (p1 &lt; p2) {
<span class="linenr"> 7: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"p1 &#22312; p2 &#20043;&#21069;\n"</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21512;&#27861;&#27604;&#36611;</span>
<span class="linenr"> 8: </span>}
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#27161;&#36939;&#31639;</span>
<span class="linenr">11: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">diff</span> = p2 - p1;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21512;&#27861;&#36939;&#31639;&#65292;&#35336;&#31639;&#20841;&#32773;&#20043;&#38291;&#30340;&#20803;&#32032;&#20491;&#25976;</span>
<span class="linenr">12: </span><span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#25351;&#27161;&#30456;&#24046; "</span> &lt;&lt; diff &lt;&lt; <span style="color: #98be65;">" &#20491;&#20803;&#32032;\n"</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2</span>
</pre>
</div>

<p>
✅ **此運算合法，因為 p1 和 p2 皆指向相同陣列 arr 的元素。<br />
</p>

<p>
❌ 但若 p1 和 p2 指向不同的陣列，則結果是未定義行為（Undefined Behavior, UB）。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr1</span>[] = {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>};
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr2</span>[] = {<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">6</span>};
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr1[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr"> 5: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr2[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">if</span> (p1 &lt; p2) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; &#26410;&#23450;&#32681;&#34892;&#28858;&#65288;UB&#65289;</span>
<span class="linenr"> 8: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#27604;&#36611;&#20358;&#33258;&#19981;&#21516;&#38499;&#21015;&#30340;&#25351;&#27161;&#26159;&#19981;&#21512;&#27861;&#30340;\n"</span>;
<span class="linenr"> 9: </span>}
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">diff</span> = p2 - p1;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; &#26410;&#23450;&#32681;&#34892;&#28858;&#65288;UB&#65289;</span>
</pre>
</div>

<p>
🚨 問題：<br />
</p>
<ul class="org-ul">
<li>p1 和 p2 來自不同的陣列，因此不能比較。<br /></li>
<li>指標減法（p2 - p1）的結果無意義。<br /></li>
<li>只有當指標來自同一陣列內時，這些運算才有明確意義。<br /></li>
</ul>

<p>
✅ 因此，正確答案是 a) They point to elements of the same array.<br />
</p>
</div>
</div>
<div id="outline-container-org559c885" class="outline-5">
<h5 id="org559c885">📌 2. 其他選項解析</h5>
<div class="outline-text-5" id="text-org559c885">
</div>
<ul class="org-ul">
<li><a id="org4079e27"></a>❌ b) They point to arrays of the same type.<br />
<div class="outline-text-6" id="text-org4079e27">
<p>
（指標必須指向相同類型的陣列）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br />
<ul class="org-ul">
<li>指標的比較和運算不取決於陣列的類型，而是取決於是否來自同一個陣列。<br /></li>
</ul></li>
<li>即使兩個陣列的型別相同，若它們是不同的陣列，指標運算仍然是未定義行為（UB）。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr1</span>[<span style="color: #da8548; font-weight: bold;">5</span>] = {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">5</span>};
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr2</span>[<span style="color: #da8548; font-weight: bold;">5</span>] = {<span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">9</span>, <span style="color: #da8548; font-weight: bold;">10</span>};
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr1[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr2[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">6: </span>
<span class="linenr">7: </span><span style="color: #51afef;">if</span> (p1 &lt; p2) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; UB&#65292;&#21363;&#20351; `arr1` &#21644; `arr2` &#26159;&#30456;&#21516;&#22411;&#21029;&#30340;&#38499;&#21015;</span>
<span class="linenr">8: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#36889;&#26159;&#19981;&#23433;&#20840;&#30340;&#25351;&#27161;&#27604;&#36611;\n"</span>;
<span class="linenr">9: </span>}
</pre>
</div>

<p>
🚨 錯誤點：<br />
即使 arr1 和 arr2 是相同型別，指標比較 p1 &lt; p2 仍然是未定義行為。<br />
</p>
</div>
</li>
<li><a id="org15fb8cd"></a>❌ c) You are trying to compare and perform pointer arithmetic on the values to which they point.<br />
<div class="outline-text-6" id="text-org15fb8cd">
<p>
（如果比較的是指標指向的值，而非指標本身）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br />
<ul class="org-ul">
<li>這與指標運算無關，因為指標比較涉及的是指標的地址，而非指標指向的值。<br /></li>
</ul></li>
<li>比較指標指向的值（Value Comparison）是合法的，但與指標比較不同！<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr</span>[] = {<span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">20</span>, <span style="color: #da8548; font-weight: bold;">30</span>};
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">3: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr[<span style="color: #da8548; font-weight: bold;">2</span>];
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #51afef;">if</span> (*p1 &lt; *p2) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#27491;&#30906;&#65306;&#27604;&#36611;&#30340;&#26159;&#12300;&#20540;&#12301;</span>
<span class="linenr">6: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"*p1 &#23567;&#26044; *p2\n"</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10 &lt; 30</span>
<span class="linenr">7: </span>}
</pre>
</div>


<p>
✅ 比較 *p1 和 *p2 是合法的，但與「指標比較」不同！<br />
</p>

<p>
🚨 但指標本身 p1 &lt; p2 只有在 p1 和 p2 屬於同一陣列時才有意義。<br />
</p>
</div>
</li>
<li><a id="orgb119fba"></a>❌ d) They point to arrays of equal size.<br />
<div class="outline-text-6" id="text-orgb119fba">
<p>
（指標必須指向大小相等的陣列）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br /></li>
<li>陣列大小並不影響指標比較，關鍵在於它們是否來自同一個陣列。<br /></li>
<li>即使兩個陣列的大小相等，它們的指標比較與指標運算仍然是未定義行為。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr1</span>[<span style="color: #da8548; font-weight: bold;">3</span>] = {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>};
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr2</span>[<span style="color: #da8548; font-weight: bold;">3</span>] = {<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">6</span>};
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr1[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr2[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">6: </span>
<span class="linenr">7: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">diff</span> = p2 - p1;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; &#26410;&#23450;&#32681;&#34892;&#28858;&#65288;UB&#65289;</span>
</pre>
</div>


<p>
🚨 錯誤點：<br />
即使 arr1 和 arr2 大小相等，指標比較與指標運算仍然是不合法的。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3b0f359" class="outline-5">
<h5 id="org3b0f359">📚 與指標比較相關的完整計概知識</h5>
<div class="outline-text-5" id="text-org3b0f359">
</div>
<ul class="org-ul">
<li><a id="orgbff57db"></a>1. 指標比較（Pointer Comparison）<br />
<div class="outline-text-6" id="text-orgbff57db">
<ul class="org-ul">
<li>只有當指標指向同一陣列的元素時，&lt;、&gt;、&lt;=、&gt;= 才有意義。<br /></li>
<li>指向不同陣列的指標進行比較會導致未定義行為（UB）。<br /></li>
</ul>

<p>
✅ 合法比較<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr</span>[] = {<span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">20</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">40</span>};
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">3: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr[<span style="color: #da8548; font-weight: bold;">2</span>];
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #51afef;">if</span> (p1 &lt; p2) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21512;&#27861;&#65292;&#22240;&#28858; p1 &#21644; p2 &#22312;&#30456;&#21516;&#38499;&#21015;&#20839;</span>
<span class="linenr">6: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"p1 &#22312; p2 &#20043;&#21069;\n"</span>;
<span class="linenr">7: </span>}
</pre>
</div>

<p>
🚨 未定義行為（UB）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr1</span>[] = {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>};
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr2</span>[] = {<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">6</span>};
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr1[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr2[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">6: </span>
<span class="linenr">7: </span><span style="color: #51afef;">if</span> (p1 &lt; p2) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; UB&#65292;&#22240;&#28858; p1 &#21644; p2 &#25351;&#21521;&#19981;&#21516;&#38499;&#21015;</span>
<span class="linenr">8: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#36889;&#26159;&#19981;&#23433;&#20840;&#30340;&#27604;&#36611;\n"</span>;
<span class="linenr">9: </span>}
</pre>
</div>
</div>
</li>
<li><a id="org4bdca1d"></a>2. 指標運算（Pointer Arithmetic）<br />
<div class="outline-text-6" id="text-org4bdca1d">
<p>
✅ 合法運算<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr</span>[] = {<span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">20</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">40</span>};
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr[<span style="color: #da8548; font-weight: bold;">1</span>];  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521; 20</span>
<span class="linenr">3: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr[<span style="color: #da8548; font-weight: bold;">3</span>];  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521; 40</span>
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">diff</span> = p2 - p1;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21512;&#27861;&#65292;&#32080;&#26524;&#28858; 2</span>
<span class="linenr">6: </span><span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#25351;&#27161;&#30456;&#24046; "</span> &lt;&lt; diff &lt;&lt; <span style="color: #98be65;">" &#20491;&#20803;&#32032;\n"</span>;
</pre>
</div>

<p>
🚨 未定義行為（UB）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr1</span>[] = {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>};
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr2</span>[] = {<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">6</span>};
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p1</span> = &amp;arr1[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span>* <span style="color: #dcaeea;">p2</span> = &amp;arr2[<span style="color: #da8548; font-weight: bold;">0</span>];
<span class="linenr">6: </span>
<span class="linenr">7: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">diff</span> = p2 - p1;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; UB&#65292;&#22240;&#28858; p1 &#21644; p2 &#20358;&#33258;&#19981;&#21516;&#38499;&#21015;</span>
</pre>
</div>
</div>
</li>
<li><a id="org8b67d7c"></a>📌 總結<br />
<div class="outline-text-6" id="text-org8b67d7c">
<ul class="org-ul">
<li>指標比較（Pointer Comparison）與指標運算（Pointer Arithmetic）只有在指標指向同一個陣列的元素**時才有意義。<br /></li>
<li>若指標來自不同的陣列，則比較與運算皆為「未定義行為（UB）」。<br /></li>
<li>正確答案是 a) They point to elements of the same array.<br /></li>
<li>指標比較適用於遍歷陣列，而指標運算常用於計算索引偏移量（Offset Calculation）。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org97540f1" class="outline-3">
<h3 id="org97540f1"><span class="section-number-3">3.17.</span> B-4 (4%)</h3>
<div class="outline-text-3" id="text-3-17">
<p>
In C++, what does ( *min ) ( numberl, number2, number 3 ) ; mean?<br />
</p>
<ol class="org-ol">
<li>It is the header for function mi n.<br /></li>
<li>It is the prototype for function mi n.<br /></li>
<li>It is a call to the function pointed to by mi n.<br /></li>
<li>It is a declaration of a pointer to a function called mi n.<br /></li>
</ol>
</div>
<div id="outline-container-org144b123" class="outline-4">
<h4 id="org144b123"><span class="section-number-4">3.17.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-17-1">
<p>
答案：<br />
</p>

<p>
✅ c) It is a call to the function pointed to by min.<br />
（這是一個對函式指標 min 指向的函式的調用。）<br />
</p>
</div>
</div>
<div id="outline-container-org563efc8" class="outline-4">
<h4 id="org563efc8"><span class="section-number-4">3.17.2.</span> 📖 詳解</h4>
<div class="outline-text-4" id="text-3-17-2">
</div>
<div id="outline-container-org3aa4e00" class="outline-5">
<h5 id="org3aa4e00">📌 1. ( *min ) ( number1, number2, number3 ) 的含義</h5>
<div class="outline-text-5" id="text-org3aa4e00">
<p>
在 C++ 中，這個語法表示：<br />
</p>

<p>
min 是 一個指向函式的指標（Function Pointer）。<br />
*min 解除引用（Dereference），獲取函式指標指向的函式。<br />
(number1, number2, number3) 表示對該函式進行調用。<br />
</p>
</div>
</div>
<div id="outline-container-org583ec6c" class="outline-5">
<h5 id="org583ec6c">📌 2. 函式指標（Function Pointer）基礎</h5>
<div class="outline-text-5" id="text-org583ec6c">
<p>
在 C++ 中，函式指標用於存取函式的地址，可以動態調用不同的函式。<br />
</p>

<p>
✅ 基本函式指標語法：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23450;&#32681;&#20989;&#24335;</span>
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">add</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) {
<span class="linenr"> 3: </span>    <span style="color: #51afef;">return</span> a + b;
<span class="linenr"> 4: </span>}
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 7: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23450;&#32681;&#20989;&#24335;&#25351;&#27161;&#65292;&#25351;&#21521;&#20855;&#26377;&#30456;&#21516;&#31805;&#21517;&#65288;&#36820;&#22238;&#20540; + &#21443;&#25976;&#39006;&#22411;&#65289;&#30340;&#20989;&#24335;</span>
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">funcPtr</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>) = add;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20841;&#31278;&#21512;&#27861;&#35519;&#29992;&#26041;&#24335;&#65306;</span>
<span class="linenr">11: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; funcPtr(<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>) &lt;&lt; <span style="color: #98be65;">"\n"</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#35519;&#29992;&#20989;&#24335;&#65292;&#36664;&#20986; 7</span>
<span class="linenr">12: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; (*funcPtr)(<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>) &lt;&lt; <span style="color: #98be65;">"\n"</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#35519;&#29992;&#20989;&#24335;&#65292;&#36664;&#20986; 7</span>
<span class="linenr">13: </span>}
</pre>
</div>
<p>
✅ 解釋<br />
</p>

<ul class="org-ul">
<li>int (*funcPtr)(int, int) = add; → funcPtr 是指向函式 add 的指標。<br /></li>
<li>funcPtr(3, 4) 或 (*funcPtr)(3, 4) 皆可調用該函式。<br /></li>
</ul>

<p>
📌 3. (*min)(number1, number2, number3) 例子<br />
</p>

<p>
假設 min 是函式指標，則：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23450;&#32681;&#20989;&#24335;</span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">findMin</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">c</span>) {
<span class="linenr"> 5: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">std</span>::min({a, b, c});
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 9: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23450;&#32681;&#20989;&#24335;&#25351;&#27161;</span>
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">min</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>) = findMin;
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#20989;&#24335;&#25351;&#27161;&#35519;&#29992;&#20989;&#24335;</span>
<span class="linenr">13: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">result</span> = (*min)(<span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">20</span>, <span style="color: #da8548; font-weight: bold;">5</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#35519;&#29992; findMin(10, 20, 5)</span>
<span class="linenr">14: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#26368;&#23567;&#20540;: "</span> &lt;&lt; result &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986; 5</span>
<span class="linenr">15: </span>}
</pre>
</div>

<p>
✅ (*min)(10, 20, 5) 會呼叫 findMin(10, 20, 5)，並回傳 5。<br />
</p>
</div>
</div>
<div id="outline-container-org7db316d" class="outline-5">
<h5 id="org7db316d">📌 其他選項解析</h5>
<div class="outline-text-5" id="text-org7db316d">
</div>
<ul class="org-ul">
<li><a id="org5614843"></a>❌ a) It is the header for function min.<br />
<div class="outline-text-6" id="text-org5614843">
<p>
（這是函式 min 的標頭）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br /></li>
<li>函式標頭應該是函式的宣告，例如：<br /></li>
<li>int min(int a, int b, int c);  // ✅ 正確函式標頭<br /></li>
<li>但 ( *min ) ( number1, number2, number3 ) 是函式調用，而非宣告。<br /></li>
</ul>
</div>
</li>
<li><a id="orgb3cbb30"></a>❌ b) It is the prototype for function min.<br />
<div class="outline-text-6" id="text-orgb3cbb30">
<p>
（這是函式 min 的原型）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br /></li>
<li>函式原型應該是函式的宣告，例如：<br /></li>
<li>int min(int, int, int);  // ✅ 正確函式原型<br /></li>
<li>但 ( *min ) ( number1, number2, number3 ) 是函式調用，不是函式原型。<br /></li>
</ul>
</div>
</li>
<li><a id="org8e26800"></a>❌ d) It is a declaration of a pointer to a function called min.<br />
<div class="outline-text-6" id="text-org8e26800">
<p>
（這是宣告一個指向函式 min 的函式指標）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br /></li>
<li>函式指標的正確宣告應該是：<br /></li>
<li>int (*min)(int, int, int);  // ✅ 正確函式指標宣告<br /></li>
<li>但 ( *min ) ( number1, number2, number3 ) 是函式調用，而不是函式指標宣告。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9870402" class="outline-5">
<h5 id="org9870402">📚 與函式指標相關的完整計概知識</h5>
<div class="outline-text-5" id="text-org9870402">
</div>
<ul class="org-ul">
<li><a id="org52d47b9"></a>1. 函式指標的用途<br />
<div class="outline-text-6" id="text-org52d47b9">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">用途</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">動態選擇函式</td>
<td class="org-left">讓變數可以指向不同的函式，提高程式靈活性</td>
</tr>

<tr>
<td class="org-left">回呼函式（Callback）</td>
<td class="org-left">在 qsort()、std::sort() 等函式中使用</td>
</tr>

<tr>
<td class="org-left">實現函式表（Function Table）</td>
<td class="org-left">適用於狀態機、動態函式調度</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgb99cb04"></a>2. 進階函式指標範例<br />
<ul class="org-ul">
<li><a id="orgfef29eb"></a>✅ (1) 變更函式指標指向不同函式<br />
<div class="outline-text-7" id="text-orgfef29eb">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">add</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) { <span style="color: #51afef;">return</span> a + b; }
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">multiply</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) { <span style="color: #51afef;">return</span> a * b; }
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">operation</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23450;&#32681;&#20989;&#24335;&#25351;&#27161;</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    operation = add;
<span class="linenr">10: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#21152;&#27861;: "</span> &lt;&lt; operation(<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>) &lt;&lt; <span style="color: #98be65;">"\n"</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986; 7</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span>    operation = multiply;
<span class="linenr">13: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#20056;&#27861;: "</span> &lt;&lt; operation(<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>) &lt;&lt; <span style="color: #98be65;">"\n"</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986; 12</span>
<span class="linenr">14: </span>}
</pre>
</div>

<p>
✅ 函式指標 operation 可指向不同函式，提高靈活性！<br />
</p>
</div>
</li>
<li><a id="org79f54b6"></a>✅ (2) 在 std::sort() 中使用函式指標<br />
<div class="outline-text-7" id="text-org79f54b6">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;algorithm&gt;</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">descending</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) {
<span class="linenr"> 5: </span>    <span style="color: #51afef;">return</span> a &gt; b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38477;&#24207;&#25490;&#21015;</span>
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr</span>[] = {<span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">9</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">6</span>};
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #a9a1e1;">std</span>::sort(arr, arr + <span style="color: #da8548; font-weight: bold;">5</span>, descending);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20659;&#20837;&#20989;&#24335;&#25351;&#27161;</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span> : arr) {
<span class="linenr">14: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; n &lt;&lt; <span style="color: #98be65;">" "</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986;: 9 6 5 2 1</span>
<span class="linenr">15: </span>    }
<span class="linenr">16: </span>}
</pre>
</div>

<p>
✅ std::sort() 允許傳入函式指標來自訂排序邏輯！<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgd698ab2" class="outline-5">
<h5 id="orgd698ab2">📌 總結</h5>
<div class="outline-text-5" id="text-orgd698ab2">
<ul class="org-ul">
<li>(*min)(number1, number2, number3) 是對函式指標 min 指向的函式的調用。<br /></li>
<li>函式指標可用於動態選擇函式，提高程式靈活性。<br /></li>
<li>函式指標常用於回呼函式（Callback）與函式表（Function Table）。<br /></li>
<li>正確答案是 c) It is a call to the function pointed to by min.<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7084551" class="outline-3">
<h3 id="org7084551"><span class="section-number-3">3.18.</span> B-5 (4%)</h3>
<div class="outline-text-3" id="text-3-18">
<p>
Which forms of inheritance are is-a relationships in C++?<br />
</p>
<ol class="org-ol">
<li>Only public.<br /></li>
<li>Only public and private.<br /></li>
<li>Only public and protected.<br /></li>
<li>All forms of inheritance are is-a relationships.<br /></li>
</ol>
</div>
<div id="outline-container-org6820f8d" class="outline-4">
<h4 id="org6820f8d"><span class="section-number-4">3.18.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-18-1">
<p>
答案：<br />
</p>

<p>
✅ c) Only public and protected.<br />
（在 C++ 中，只有 public 和 protected 繼承屬於 &ldquo;is-a&rdquo; 關係。）<br />
</p>
</div>
</div>
<div id="outline-container-org76bace8" class="outline-4">
<h4 id="org76bace8"><span class="section-number-4">3.18.2.</span> 📖 詳解</h4>
<div class="outline-text-4" id="text-3-18-2">
</div>
<div id="outline-container-org4500d7f" class="outline-5">
<h5 id="org4500d7f">📌 1. is-a 關係是什麼？</h5>
<div class="outline-text-5" id="text-org4500d7f">
<p>
在物件導向程式設計（OOP）中，&ldquo;is-a&rdquo; 關係表示「某個類別是另一個類別的一種」，通常用於描述類別之間的繼承關係。<br />
</p>

<p>
舉例：<br />
</p>
<ul class="org-ul">
<li>Car 是 Vehicle 的一種（Car is-a Vehicle）<br /></li>
<li>Dog 是 Animal 的一種（Dog is-a Animal）<br /></li>
</ul>

<p>
在 C++ 中，&ldquo;is-a&rdquo; 關係適用於**public 和 protected 繼承**，但不適用於 private 繼承。<br />
</p>
</div>
</div>
<div id="outline-container-org5d43826" class="outline-5">
<h5 id="org5d43826">📌 2. C++ 的三種繼承方式</h5>
<div class="outline-text-5" id="text-org5d43826">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">繼承方式</th>
<th scope="col" class="org-left">語法</th>
<th scope="col" class="org-left">is-a 關係</th>
<th scope="col" class="org-left">存取控制影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Public 繼承</td>
<td class="org-left">class Derived : public Base {}</td>
<td class="org-left">✅ 是 is-a</td>
<td class="org-left">Base 的 public &amp; protected 成員在 Derived 中維持原狀</td>
</tr>

<tr>
<td class="org-left">Protected 繼承</td>
<td class="org-left">class Derived : protected Base {}</td>
<td class="org-left">✅ 是 is-a</td>
<td class="org-left">Base 的 public 變成 protected，protected 保持不變</td>
</tr>

<tr>
<td class="org-left">Private 繼承</td>
<td class="org-left">class Derived : private Base {}</td>
<td class="org-left">❌ 不是 is-a</td>
<td class="org-left">Base 的 public &amp; protected 成員變成 private</td>
</tr>
</tbody>
</table>

<p>
✅ 只有 public 和 protected 繼承維持了 &ldquo;is-a&rdquo; 關係，因此選項 c 是正確答案！<br />
</p>
</div>
</div>
<div id="outline-container-orge8e3d7f" class="outline-5">
<h5 id="orge8e3d7f">📌 3. 為什麼 private 繼承不是 &ldquo;is-a&rdquo; 關係？</h5>
<div class="outline-text-5" id="text-orge8e3d7f">
<p>
當使用 private 繼承時：<br />
</p>
<ul class="org-ul">
<li>Base 類別的 public 和 protected 成員會變成 private，導致 Derived 無法表現出 &ldquo;is-a&rdquo; 的行為。<br /></li>
<li>Derived 無法被當作 Base 來使用，因為 Base 的公有介面不再是 Derived 的公有介面。<br /></li>
</ul>

<p>
範例（private 繼承破壞 is-a）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Base class\n"</span>; }
<span class="linenr"> 4: </span>};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">Base</span> {};
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28204;&#35430; `is-a` &#38364;&#20418;</span>
<span class="linenr"> 9: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">Derived</span> <span style="color: #dcaeea;">d</span>;
<span class="linenr">11: </span>    d.show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; &#37679;&#35492;&#65292;&#22240;&#28858; `show()` &#22312; `Derived` &#35722;&#25104; `private`</span>
<span class="linenr">12: </span>}
</pre>
</div>

<p>
🚨 錯誤：Derived 無法直接存取 Base::show()，所以不是 is-a！<br />
</p>
</div>
</div>
<div id="outline-container-org91764b3" class="outline-5">
<h5 id="org91764b3">📌 4. public vs. protected 繼承</h5>
<div class="outline-text-5" id="text-org91764b3">
<p>
✅ public 繼承：標準 &ldquo;is-a&rdquo; 繼承<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Base class\n"</span>; }
<span class="linenr"> 4: </span>};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base</span> {};
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">Derived</span> <span style="color: #dcaeea;">d</span>;
<span class="linenr">10: </span>    d.show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#27491;&#30906;&#65292;`Derived` &#21487;&#20197;&#20351;&#29992; `Base` &#30340; `public` &#26041;&#27861;</span>
<span class="linenr">11: </span>}
</pre>
</div>

<p>
🔹 Derived 保留 Base 的 public 介面，所以 Derived 是 Base 的一種！<br />
</p>

<p>
✅ protected 繼承：仍然是 &ldquo;is-a&rdquo;，但僅限於 Derived 及其子類<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Base class\n"</span>; }
<span class="linenr"> 4: </span>};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">protected</span> <span style="color: #ECBE7B;">Base</span> {};
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">SubDerived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Derived</span> {
<span class="linenr"> 9: </span><span style="color: #51afef;">public</span>:
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">callBaseShow</span>() { show(); }  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21487;&#20197;&#23384;&#21462;</span>
<span class="linenr">11: </span>};
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">14: </span>    <span style="color: #ECBE7B;">SubDerived</span> <span style="color: #dcaeea;">sd</span>;
<span class="linenr">15: </span>    sd.callBaseShow();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#27491;&#30906;&#65292;&#22240;&#28858; `show()` &#22312; `Derived` &#35722;&#25104; `protected`</span>
<span class="linenr">16: </span>}
</pre>
</div>
<p>
🔹 雖然 Base::show() 變成 protected，但 Derived 仍然可以作為 Base 的子類，所以仍然是 &ldquo;is-a&rdquo;。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga48d055" class="outline-4">
<h4 id="orga48d055"><span class="section-number-4">3.18.3.</span> 📚 與繼承相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-18-3">
</div>
<div id="outline-container-orgf84c19d" class="outline-5">
<h5 id="orgf84c19d">1. is-a vs. has-a 關係</h5>
<div class="outline-text-5" id="text-orgf84c19d">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">概念</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">範例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">is-a（是某種）</td>
<td class="org-left">繼承關係，表示某個類別是另一個類別的一種</td>
<td class="org-left">Car is-a Vehicle（Car : public Vehicle）</td>
</tr>

<tr>
<td class="org-left">has-a（擁有某物）</td>
<td class="org-left">組合（Composition），表示某個類別擁有另一個類別的物件</td>
<td class="org-left">Car has-a Engine（class Car { Engine e; }）</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgbcedf2b" class="outline-5">
<h5 id="orgbcedf2b">2. C++ 繼承的優缺點</h5>
<div class="outline-text-5" id="text-orgbcedf2b">
<p>
✅ 優點<br />
</p>
<ul class="org-ul">
<li>提高程式碼重用性（Code Reusability）<br /></li>
<li>支持多型（Polymorphism）<br /></li>
<li>減少重複程式碼（DRY 原則）<br /></li>
</ul>

<p>
❌ 缺點<br />
</p>
<ul class="org-ul">
<li>過度繼承會降低靈活性<br /></li>
<li>&ldquo;菱形繼承&rdquo; 問題（Diamond Problem），需要使用 virtual 繼承<br /></li>
<li>繼承會造成強耦合（Tightly Coupled Classes）<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5913304" class="outline-5">
<h5 id="org5913304">3. C++ 多重繼承（Multiple Inheritance）</h5>
<div class="outline-text-5" id="text-org5913304">
<p>
C++ 允許類別同時繼承多個基礎類別：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base1</span> { <span style="color: #51afef;">public</span>: <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show1</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Base1\n"</span>; } };
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base2</span> { <span style="color: #51afef;">public</span>: <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show2</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Base2\n"</span>; } };
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base1</span>, <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base2</span> {};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">Derived</span> <span style="color: #dcaeea;">d</span>;
<span class="linenr"> 8: </span>    d.show1();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#20358;&#33258; Base1</span>
<span class="linenr"> 9: </span>    d.show2();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#20358;&#33258; Base2</span>
<span class="linenr">10: </span>}
</pre>
</div>


<p>
✅ 多重繼承允許 Derived 擁有多個父類的功能，但要小心 &ldquo;菱形繼承&rdquo; 問題！<br />
</p>
</div>
</div>
<div id="outline-container-org5f7091f" class="outline-5">
<h5 id="org5f7091f">4. virtual 繼承解決菱形繼承問題</h5>
<div class="outline-text-5" id="text-org5f7091f">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Base class\n"</span>; }
<span class="linenr"> 4: </span>};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived1</span> : <span style="color: #51afef;">virtual</span> <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base</span> {};  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992; virtual &#36991;&#20813;&#33777;&#24418;&#21839;&#38988;</span>
<span class="linenr"> 7: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived2</span> : <span style="color: #51afef;">virtual</span> <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base</span> {};
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">FinalDerived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Derived1</span>, <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Derived2</span> {};
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">12: </span>    <span style="color: #ECBE7B;">FinalDerived</span> <span style="color: #dcaeea;">fd</span>;
<span class="linenr">13: </span>    fd.show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#36991;&#20813;&#22810;&#37325;&#23450;&#32681;&#21839;&#38988;</span>
<span class="linenr">14: </span>}
</pre>
</div>


<p>
✅ virtual 繼承確保 FinalDerived 只會繼承一份 Base。<br />
</p>
</div>
</div>
<div id="outline-container-orgd047717" class="outline-5">
<h5 id="orgd047717">📌 總結</h5>
<div class="outline-text-5" id="text-orgd047717">
<ul class="org-ul">
<li>is-a 關係適用於 public 和 protected 繼承，但不適用於 private 繼承。<br /></li>
<li>public 繼承：完整保留 Base 的 public 介面，標準的 &ldquo;is-a&rdquo; 繼承。<br /></li>
<li>protected 繼承：仍然是 &ldquo;is-a&rdquo;，但只允許子類存取 Base 的 public 成員。<br /></li>
<li>private 繼承：Base 的 public 變成 private，破壞了 &ldquo;is-a&rdquo;。<br /></li>
<li>C++ 允許多重繼承，但可能產生 &ldquo;菱形繼承&rdquo; 問題，需要 virtual 繼承來解決。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org83f1551" class="outline-3">
<h3 id="org83f1551"><span class="section-number-3">3.19.</span> B-6 (4%)</h3>
<div class="outline-text-3" id="text-3-19">
<p>
In C+++, the main difference between a pure virtual ftnction and a virtual function is<br />
</p>
<ol class="org-ol">
<li>The return type.<br /></li>
<li>The location in the class.<br /></li>
<li>The member access specifier.<br /></li>
<li>That a pure virtual ftnction cannot have an implementation.<br /></li>
</ol>
</div>
<div id="outline-container-org23ca1f3" class="outline-4">
<h4 id="org23ca1f3"><span class="section-number-4">3.19.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-19-1">
<p>
答案：<br />
</p>

<p>
✅ d) That a pure virtual function cannot have an implementation.<br />
（純虛擬函式不能有實作。）<br />
</p>
</div>
</div>
<div id="outline-container-org273a161" class="outline-4">
<h4 id="org273a161"><span class="section-number-4">3.19.2.</span> 📖 詳解</h4>
<div class="outline-text-4" id="text-3-19-2">
<p>
在 C++ 中，虛擬函式（Virtual Function） 和 純虛擬函式（Pure Virtual Function） 都是**實現多型（Polymorphism）**的關鍵技術。主要的區別在於：<br />
</p>

<p>
虛擬函式（Virtual Function）可以有實作，子類別可以選擇是否覆寫（override）。<br />
純虛擬函式（Pure Virtual Function）不能有實作，子類別 必須 覆寫（override）。<br />
</p>
</div>
<div id="outline-container-org5408a04" class="outline-5">
<h5 id="org5408a04">📌 1. 虛擬函式（Virtual Function）</h5>
<div class="outline-text-5" id="text-org5408a04">
<p>
✅ 定義：<br />
</p>
<ul class="org-ul">
<li>在基礎類別（Base Class）中使用 virtual 宣告的方法。<br /></li>
<li>可以有預設的實作，子類別可以選擇是否覆寫（Override）。<br /></li>
<li>如果沒有覆寫，則會使用基礎類別的實作。<br /></li>
</ul>

<p>
✅ 例子：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 3: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#34395;&#25836;&#20989;&#24335;&#65292;&#20855;&#26377;&#38928;&#35373;&#23526;&#20316;</span>
<span class="linenr"> 5: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Base class implementation\n"</span>;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>};
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr">10: </span><span style="color: #51afef;">public</span>:
<span class="linenr">11: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() <span style="color: #51afef;">override</span> {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#35206;&#23531;&#34395;&#25836;&#20989;&#24335;</span>
<span class="linenr">12: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Derived class implementation\n"</span>;
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>};
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">17: </span>    <span style="color: #ECBE7B;">Base</span>* <span style="color: #dcaeea;">obj</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Derived</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#22522;&#30990;&#39006;&#21029;&#25351;&#27161;&#25351;&#21521;&#23376;&#39006;&#21029;&#29289;&#20214;</span>
<span class="linenr">18: </span>    obj-&gt;show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#36664;&#20986; "Derived class implementation"&#65288;&#22519;&#34892;&#26178;&#22810;&#22411;&#65289;</span>
<span class="linenr">19: </span>    <span style="color: #51afef;">delete</span> obj;
<span class="linenr">20: </span>}
</pre>
</div>


<p>
✅ show() 具有預設實作，但 Derived 可以覆寫。<br />
</p>
</div>
</div>
<div id="outline-container-orgdc36970" class="outline-5">
<h5 id="orgdc36970">📌 2. 純虛擬函式（Pure Virtual Function）</h5>
<div class="outline-text-5" id="text-orgdc36970">
<p>
✅ 定義：<br />
</p>
<ul class="org-ul">
<li>在基礎類別中以 = 0 宣告的方法。<br /></li>
<li>不能有實作（但 C++ 允許特殊情況下有實作，見下方進階部分）。<br /></li>
<li>子類別 必須 覆寫（Override），否則子類別仍然是抽象類別（Abstract Class）。<br /></li>
<li>含有純虛擬函式的類別為抽象類別，不能直接建立實例（Object）。<br /></li>
</ul>

<p>
✅ 例子：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 3: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() = <span style="color: #da8548; font-weight: bold;">0</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#32020;&#34395;&#25836;&#20989;&#24335;&#65288;&#27794;&#26377;&#38928;&#35373;&#23526;&#20316;&#65289;</span>
<span class="linenr"> 5: </span>};
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 8: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() <span style="color: #51afef;">override</span> {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#23376;&#39006;&#21029;&#24517;&#38920;&#35206;&#23531;</span>
<span class="linenr">10: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Derived class implementation\n"</span>;
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>};
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">15: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Base obj;  // &#10060; &#37679;&#35492;&#65306;&#25277;&#35937;&#39006;&#21029;&#28961;&#27861;&#24314;&#31435;&#29289;&#20214;</span>
<span class="linenr">16: </span>    <span style="color: #ECBE7B;">Base</span>* <span style="color: #dcaeea;">obj</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Derived</span>();
<span class="linenr">17: </span>    obj-&gt;show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#36664;&#20986; "Derived class implementation"</span>
<span class="linenr">18: </span>    <span style="color: #51afef;">delete</span> obj;
<span class="linenr">19: </span>}
</pre>
</div>
<p>
✅ 基礎類別 Base 不能被直接實例化，子類別 Derived 必須覆寫 show()。<br />
</p>
</div>
</div>
<div id="outline-container-org6e0e80c" class="outline-5">
<h5 id="org6e0e80c">📌 3. 虛擬函式 vs. 純虛擬函式</h5>
<div class="outline-text-5" id="text-org6e0e80c">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">虛擬函式（Virtual Function）</th>
<th scope="col" class="org-left">純虛擬函式（Pure Virtual Function）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">語法</td>
<td class="org-left">virtual void show() {}</td>
<td class="org-left">virtual void show() = 0;</td>
</tr>

<tr>
<td class="org-left">是否有預設實作</td>
<td class="org-left">✅ 可以有預設實作</td>
<td class="org-left">❌ 不能有預設實作（但可在基礎類別提供定義）</td>
</tr>

<tr>
<td class="org-left">子類別是否必須覆寫</td>
<td class="org-left">❌ 選擇性覆寫</td>
<td class="org-left">✅ 必須覆寫</td>
</tr>

<tr>
<td class="org-left">基礎類別是否為抽象類別</td>
<td class="org-left">❌ 不是</td>
<td class="org-left">✅ 是抽象類別，不能實例化</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgb38fb1f" class="outline-5">
<h5 id="orgb38fb1f">📌 4. 其他選項解析</h5>
<div class="outline-text-5" id="text-orgb38fb1f">
</div>
<ul class="org-ul">
<li><a id="orgbea9855"></a>❌ a) The return type.（回傳類型）<br />
<div class="outline-text-6" id="text-orgbea9855">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>虛擬函式與純虛擬函式的回傳類型沒有區別，它們的區別在於是否有實作。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr">2: </span><span style="color: #51afef;">public</span>:
<span class="linenr">3: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">getValue</span>() = <span style="color: #da8548; font-weight: bold;">0</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#32020;&#34395;&#25836;&#20989;&#24335;</span>
<span class="linenr">4: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">double</span> <span style="color: #c678dd;">compute</span>() { <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0.0</span>; }  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#19968;&#33324;&#34395;&#25836;&#20989;&#24335;</span>
<span class="linenr">5: </span>};
</pre>
</div>

<p>
🚫 純虛擬函式與一般虛擬函式都可以有不同回傳類型，但這與它們的主要區別無關。<br />
</p>
</div>
</li>
<li><a id="org6c740ed"></a>❌ b) The location in the class.（在類別中的位置）<br />
<div class="outline-text-6" id="text-org6c740ed">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>虛擬函式與純虛擬函式在類別的任何 public、protected 或 private 欄位都可以存在，其位置沒有特殊限制。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr">2: </span><span style="color: #51afef;">private</span>:
<span class="linenr">3: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">privateMethod</span>() = <span style="color: #da8548; font-weight: bold;">0</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21487;&#20197;&#26159; `private`</span>
<span class="linenr">4: </span><span style="color: #51afef;">protected</span>:
<span class="linenr">5: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">protectedMethod</span>() = <span style="color: #da8548; font-weight: bold;">0</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21487;&#20197;&#26159; `protected`</span>
<span class="linenr">6: </span><span style="color: #51afef;">public</span>:
<span class="linenr">7: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">publicMethod</span>() = <span style="color: #da8548; font-weight: bold;">0</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21487;&#20197;&#26159; `public`</span>
<span class="linenr">8: </span>};
</pre>
</div>


<p>
🚫 純虛擬函式不受「類別內部的位置」影響，而是由 = 0 決定。<br />
</p>
</div>
</li>
<li><a id="org5826475"></a>❌ c) The member access specifier.（存取修飾詞）<br />
<div class="outline-text-6" id="text-org5826475">
<ul class="org-ul">
<li>錯誤！<br /></li>
<li>純虛擬函式與一般虛擬函式都可以是 public、protected 或 private。<br /></li>
<li>存取修飾詞（如 public 或 protected）並不是它們的主要區別。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr">2: </span><span style="color: #51afef;">protected</span>:
<span class="linenr">3: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">protectedFunction</span>() = <span style="color: #da8548; font-weight: bold;">0</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#32020;&#34395;&#25836;&#20989;&#24335;&#21487;&#20197;&#26159; protected</span>
<span class="linenr">4: </span>};
</pre>
</div>

<p>
🚫 純虛擬函式與一般虛擬函式都可以是 public、protected 或 private，但這不是它們的區別。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf9944a2" class="outline-5">
<h5 id="orgf9944a2">📌 5. 特殊情況：純虛擬函式也可以有定義</h5>
<div class="outline-text-5" id="text-orgf9944a2">
<p>
雖然純虛擬函式通常不能有實作，但 C++ 允許在類別內聲明為 = 0，並在類別外部提供實作。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 3: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() = <span style="color: #da8548; font-weight: bold;">0</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#32020;&#34395;&#25836;&#20989;&#24335;</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">callShow</span>() {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#26222;&#36890;&#25104;&#21729;&#20989;&#24335;&#21487;&#20197;&#35519;&#29992;&#32020;&#34395;&#25836;&#20989;&#24335;&#30340;&#23450;&#32681;</span>
<span class="linenr"> 7: </span>        show();
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>};
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#22312;&#39006;&#21029;&#22806;&#37096;&#25552;&#20379;&#32020;&#34395;&#25836;&#20989;&#24335;&#30340;&#23450;&#32681;</span>
<span class="linenr">12: </span><span style="color: #ECBE7B;">void</span> <span style="color: #a9a1e1;">Base</span>::<span style="color: #c678dd;">show</span>() {
<span class="linenr">13: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Base class default implementation\n"</span>;
<span class="linenr">14: </span>}
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr">17: </span><span style="color: #51afef;">public</span>:
<span class="linenr">18: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() <span style="color: #51afef;">override</span> {
<span class="linenr">19: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Derived class implementation\n"</span>;
<span class="linenr">20: </span>    }
<span class="linenr">21: </span>};
<span class="linenr">22: </span>
<span class="linenr">23: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">24: </span>    <span style="color: #ECBE7B;">Derived</span> <span style="color: #dcaeea;">d</span>;
<span class="linenr">25: </span>    d.callShow();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#36664;&#20986; "Derived class implementation"</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #ECBE7B;">Base</span>* <span style="color: #dcaeea;">b</span> = &amp;d;
<span class="linenr">28: </span>    b-&gt;<span style="color: #a9a1e1;">Base</span>::show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#36664;&#20986; "Base class default implementation"</span>
<span class="linenr">29: </span>}
</pre>
</div>

<p>
✅ 這是一種特殊情況，在基礎類別提供默認行為，但仍要求子類別覆寫。<br />
</p>
</div>
</div>
<div id="outline-container-org5d4384f" class="outline-5">
<h5 id="org5d4384f">📌 總結</h5>
<div class="outline-text-5" id="text-org5d4384f">
<ul class="org-ul">
<li>純虛擬函式（Pure Virtual Function）<br />
<ul class="org-ul">
<li>virtual void show() = 0;<br /></li>
<li>不能有實作（但可以在類別外部提供定義）。<br /></li>
<li>子類別必須覆寫（Override），否則子類別仍是抽象類別。<br /></li>
<li>基礎類別是抽象類別，不能被實例化。<br /></li>
</ul></li>
<li>虛擬函式（Virtual Function）<br />
<ul class="org-ul">
<li>virtual void show() {}<br /></li>
<li>可以有預設實作，子類別可以選擇是否覆寫。<br /></li>
<li>基礎類別可以被實例化。<br /></li>
</ul></li>
</ul>

<p>
✅ 因此，正確答案是： ✅ d) That a pure virtual function cannot have an implementation.<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb50327b" class="outline-3">
<h3 id="orgb50327b"><span class="section-number-3">3.20.</span> B-7 (4%)</h3>
<div class="outline-text-3" id="text-3-20">
<p>
For a class template in C++, the binary scope resolution operator (::) is needed<br />
</p>
<ol class="org-ol">
<li>Only in the definitions of the member functions defined outside the class.<br /></li>
<li>Only if multiple class-template specializations will be created from this classgemplate.<br /></li>
<li>Both in the prototype and definition of a member function.<br /></li>
<li>In neither the definition nor prototype of member functions.<br /></li>
</ol>
</div>
<div id="outline-container-orgaeb39cd" class="outline-4">
<h4 id="orgaeb39cd"><span class="section-number-4">3.20.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-20-1">
<p>
答案：<br />
</p>

<p>
✅ a) Only in the definitions of the member functions defined outside the class.<br />
（C++ 類別模板中，當成員函式在類別外部定義時，必須使用二元作用域解析運算子 ::。）<br />
</p>
</div>
</div>
<div id="outline-container-orgdf0db8b" class="outline-4">
<h4 id="orgdf0db8b"><span class="section-number-4">3.20.2.</span> 📖 詳解</h4>
<div class="outline-text-4" id="text-3-20-2">
<p>
在 C++ 類別模板（Class Template）中，當成員函式在類別內部聲明但在類別外部定義時，必須使用作用域解析運算子 :: 來指定該函式屬於哪個類別模板。<br />
</p>
</div>
<div id="outline-container-org7e864ff" class="outline-5">
<h5 id="org7e864ff">📌 類別模板中的 :: 作用域解析運算子</h5>
<div class="outline-text-5" id="text-org7e864ff">
<p>
✅ 正確寫法：類別內部定義（不需要 ::）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#39006;&#21029;&#27169;&#26495;</span>
<span class="linenr"> 4: </span><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span class="linenr"> 5: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr"> 6: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#30452;&#25509;&#22312;&#39006;&#21029;&#20839;&#37096;&#23450;&#32681;&#65292;&#19981;&#38656;&#35201; `::`</span>
<span class="linenr"> 8: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Value type: "</span> &lt;&lt; <span style="color: #51afef;">typeid</span>(<span style="color: #ECBE7B;">T</span>).name() &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>};
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">13: </span>    <span style="color: #ECBE7B;">Example</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">obj</span>;
<span class="linenr">14: </span>    obj.show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#36664;&#20986; "Value type: int"</span>
<span class="linenr">15: </span>}
</pre>
</div>

<p>
✅ 當函式定義在類別內部時，不需要 ::，因為編譯器自動識別其作用域。<br />
✅ 正確寫法：類別外部定義（需要 ::）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#39006;&#21029;&#27169;&#26495;</span>
<span class="linenr"> 4: </span><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span class="linenr"> 5: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr"> 6: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#21482;&#22312;&#39006;&#21029;&#20839;&#37096;&#32882;&#26126;&#65292;&#27794;&#26377;&#23450;&#32681;</span>
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#22312;&#39006;&#21029;&#22806;&#37096;&#23450;&#32681;&#26178;&#65292;&#24517;&#38920;&#20351;&#29992; `::`</span>
<span class="linenr">11: </span><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span class="linenr">12: </span><span style="color: #ECBE7B;">void</span> <span style="color: #a9a1e1;">Example</span>&lt;<span style="color: #ECBE7B;">T</span>&gt;::<span style="color: #c678dd;">show</span>() {
<span class="linenr">13: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Value type: "</span> &lt;&lt; <span style="color: #51afef;">typeid</span>(T).name() &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr">14: </span>}
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">17: </span>    <span style="color: #ECBE7B;">Example</span>&lt;<span style="color: #ECBE7B;">double</span>&gt; <span style="color: #dcaeea;">obj</span>;
<span class="linenr">18: </span>    obj.show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#36664;&#20986; "Value type: double"</span>
<span class="linenr">19: </span>}
</pre>
</div>

<p>
✅ 當函式在類別外部定義時，必須使用 :: 來指定該函式屬於 Example&lt;T&gt; 類別模板。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3311219" class="outline-4">
<h4 id="org3311219"><span class="section-number-4">3.20.3.</span> 📌 其他選項解析</h4>
<div class="outline-text-4" id="text-3-20-3">
</div>
<div id="outline-container-orgf10f688" class="outline-5">
<h5 id="orgf10f688">❌ b) Only if multiple class-template specializations will be created from this class template.</h5>
<div class="outline-text-5" id="text-orgf10f688">
<p>
（只有在類別模板的多重特化時才需要 ::）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br /></li>
<li>無論是否有特化（specialization），如果函式是在類別外部定義，仍然必須使用 ::。<br /></li>
<li id="特化僅影響某些特定類型的行為，但不影響">是否必須使用。<br /></li>
</ul>

<p>
🔹 例子：模板特化時仍然需要 ::<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span class="linenr"> 4: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr"> 5: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>();
<span class="linenr"> 7: </span>};
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#36890;&#29992;&#27169;&#26495;&#30340;&#22806;&#37096;&#23450;&#32681;&#20173;&#38656; `::`</span>
<span class="linenr">10: </span><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span class="linenr">11: </span><span style="color: #ECBE7B;">void</span> <span style="color: #a9a1e1;">Example</span>&lt;<span style="color: #ECBE7B;">T</span>&gt;::<span style="color: #c678dd;">show</span>() {
<span class="linenr">12: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"General template: "</span> &lt;&lt; <span style="color: #51afef;">typeid</span>(T).name() &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr">13: </span>}
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#128313; &#29305;&#21270;&#29256;&#26412;&#20173;&#28982;&#38656;&#35201; `::`</span>
<span class="linenr">16: </span><span style="color: #51afef;">template</span> &lt;&gt;
<span class="linenr">17: </span><span style="color: #ECBE7B;">void</span> <span style="color: #a9a1e1;">Example</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;::<span style="color: #c678dd;">show</span>() {
<span class="linenr">18: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Specialized template for int\n"</span>;
<span class="linenr">19: </span>}
<span class="linenr">20: </span>
<span class="linenr">21: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">22: </span>    <span style="color: #ECBE7B;">Example</span>&lt;<span style="color: #ECBE7B;">double</span>&gt; <span style="color: #dcaeea;">obj1</span>;
<span class="linenr">23: </span>    obj1.show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#19968;&#33324;&#27169;&#26495;</span>
<span class="linenr">24: </span>
<span class="linenr">25: </span>    <span style="color: #ECBE7B;">Example</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">obj2</span>;
<span class="linenr">26: </span>    obj2.show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; int &#29305;&#21270;&#29256;&#26412;</span>
<span class="linenr">27: </span>}
</pre>
</div>
<p>
🚫 即使使用特化，仍然需要 :: 來定義函式，因此 b 是錯誤的。<br />
</p>
</div>
</div>
<div id="outline-container-org672b342" class="outline-5">
<h5 id="org672b342">❌ c) Both in the prototype and definition of a member function.</h5>
<div class="outline-text-5" id="text-org672b342">
<p>
（函式在原型和定義都需要 ::）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br /></li>
<li>在類別內部聲明函式時，:: 不需要使用，只在類別外部定義函式時才需要。<br /></li>
</ul>

<p>
🔹 錯誤寫法：在類別內部使用 ::<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span class="linenr">2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr">3: </span><span style="color: #51afef;">public</span>:
<span class="linenr">4: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #a9a1e1;">Example</span>&lt;<span style="color: #ECBE7B;">T</span>&gt;::<span style="color: #c678dd;">show</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; &#37679;&#35492;&#65306;&#22312;&#39006;&#21029;&#20839;&#37096;&#19981;&#38656;&#35201; `::`</span>
<span class="linenr">5: </span>};
</pre>
</div>
<p>
🚫 錯誤：類別內部函式聲明不需要 ::，因此 c 是錯誤的。<br />
</p>
</div>
</div>
<div id="outline-container-org16f46b3" class="outline-5">
<h5 id="org16f46b3">❌ d) In neither the definition nor prototype of member functions.</h5>
<div class="outline-text-5" id="text-org16f46b3">
<p>
（函式的原型與定義都不需要 ::）<br />
</p>

<ul class="org-ul">
<li>錯誤！<br /></li>
<li>在類別內部定義函式時，不需要 ::，但在類別外部定義時，必須使用 ::。<br /></li>
<li>如果不使用 ::，編譯器無法識別該函式屬於哪個模板類別。<br /></li>
</ul>

<p>
🚫 錯誤：類別外部定義函式時，若未使用 ::，則編譯失敗。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr"> 3: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>();
<span class="linenr"> 5: </span>};
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; &#37679;&#35492;&#65306;&#23569;&#20102; `::`&#65292;&#32232;&#35695;&#22120;&#28961;&#27861;&#35672;&#21029;</span>
<span class="linenr"> 8: </span><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span class="linenr"> 9: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() {
<span class="linenr">10: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Wrong syntax!\n"</span>;
<span class="linenr">11: </span>}
</pre>
</div>

<p>
🚫 錯誤：類別外部定義函式時必須使用 ::，因此 d 是錯誤的。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org82fe9a8" class="outline-4">
<h4 id="org82fe9a8"><span class="section-number-4">3.20.4.</span> 📚 與 C++ 類別模板相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-20-4">
</div>
<div id="outline-container-org1131160" class="outline-5">
<h5 id="org1131160">1. C++ 類別模板（Class Template）</h5>
<div class="outline-text-5" id="text-org1131160">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">通用類型</td>
<td class="org-left">使用 template &lt;typename T&gt; 來定義</td>
</tr>

<tr>
<td class="org-left">函式定義</td>
<td class="org-left">類別內部不需要 ::，類別外部需要 ::</td>
</tr>

<tr>
<td class="org-left">特化（Specialization）</td>
<td class="org-left">可為特定類型定義不同行為</td>
</tr>

<tr>
<td class="org-left">可用於 STL</td>
<td class="org-left">vector&lt;T&gt;、map&lt;K, V&gt; 等 STL 容器</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org4cbc588" class="outline-5">
<h5 id="org4cbc588">2. C++ 類別模板與函式模板的比較</h5>
<div class="outline-text-5" id="text-org4cbc588">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">類別模板（Class Template）</th>
<th scope="col" class="org-left">函式模板（Function Template）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">語法</td>
<td class="org-left">template &lt;typename T&gt; class Example {}</td>
<td class="org-left">template &lt;typename T&gt; void func() {}</td>
</tr>

<tr>
<td class="org-left">範圍</td>
<td class="org-left">影響整個類別</td>
<td class="org-left">影響單一函式</td>
</tr>

<tr>
<td class="org-left">特化</td>
<td class="org-left">允許類別特化</td>
<td class="org-left">允許函式特化</td>
</tr>

<tr>
<td class="org-left">:: 需求</td>
<td class="org-left">類別內不需要 ::，類別外部需要</td>
<td class="org-left">不需要 ::</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgf697598" class="outline-5">
<h5 id="orgf697598">3. :: 作用域解析運算子的用途</h5>
<div class="outline-text-5" id="text-orgf697598">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">用途</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">範例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">類別外部定義函式</td>
<td class="org-left">類別模板的成員函式必須使用 :: 定義</td>
<td class="org-left">void Example&lt;T&gt;::show() {}</td>
</tr>

<tr>
<td class="org-left">命名空間解析</td>
<td class="org-left">用於區分不同命名空間</td>
<td class="org-left">std::cout</td>
</tr>

<tr>
<td class="org-left">類別靜態成員存取</td>
<td class="org-left">訪問類別內的靜態變數</td>
<td class="org-left">Example&lt;T&gt;::staticVar</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org2f9d07c" class="outline-5">
<h5 id="org2f9d07c">📌 總結</h5>
<div class="outline-text-5" id="text-org2f9d07c">
<ul class="org-ul">
<li>在 C++ 類別模板中，函式的定義方式決定是否需要 ::：<br />
<dl class="org-dl">
<dt>類別內部定義時，不需要</dt><dd></dd>

<dt>類別外部定義時，必須使用</dt><dd></dd>
</dl></li>
<li>b 是錯誤的，因為不論是否有特化，外部定義仍然需要 ::。<br /></li>
<li>c 是錯誤的，因為原型不需要 ::，只有外部定義需要。<br /></li>
<li>d 是錯誤的，因為類別外部定義時需要 ::。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org03c7c00" class="outline-3">
<h3 id="org03c7c00"><span class="section-number-3">3.21.</span> B-8 (22%)</h3>
<div class="outline-text-3" id="text-3-21">
<p>
Write a program to execute selection sort using pass-by-reference. The objective is to<br />
input a series ofintegers using the function read Fun c and display the sorted integers in ascending<br />
order on the screen. Two requirements are as follows:<br />
</p>
<ol class="org-ol">
<li>The function <b><b>selectionSort</b></b> that sorts the integers should be implemented.<br /></li>
<li>While implementing the program, focus on providing the function declaration for read Func; implementing the function itself is not required.,<br /></li>
</ol>
</div>
<div id="outline-container-orgf085abe" class="outline-4">
<h4 id="orgf085abe"><span class="section-number-4">3.21.1.</span> 解</h4>
<div class="outline-text-4" id="text-3-21-1">
<p>
📌 C++ 選擇排序（Selection Sort）使用「引用傳遞（Pass-by-Reference）」<br />
</p>

<p>
本程式的目標：<br />
</p>
<ul class="org-ul">
<li>使用 selectionSort 函式來排序整數陣列（使用引用傳遞）。<br /></li>
<li>提供 readFunc 的函式宣告，但不實作該函式。<br /></li>
<li>最後將排序後的結果輸出到螢幕上。<br /></li>
</ul>

<p>
✅ C++ 程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;vector&gt;</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20989;&#24335;&#23459;&#21578;</span>
<span class="linenr"> 5: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">readFunc</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21482;&#25552;&#20379;&#23459;&#21578;&#65292;&#19981;&#23526;&#20316;</span>
<span class="linenr"> 6: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">selectionSort</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#24341;&#29992;&#20659;&#36958;</span>
<span class="linenr"> 7: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">display</span>(<span style="color: #51afef;">const</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#39023;&#31034;&#25490;&#24207;&#24460;&#30340;&#32080;&#26524;</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">10: </span>    <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">numbers</span>;
<span class="linenr">11: </span>
<span class="linenr">12: </span>    readFunc(numbers);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35519;&#29992;&#35712;&#21462;&#20989;&#24335;&#65288;&#20551;&#35373;&#26371;&#22635;&#20837;&#25976;&#20540;&#65289;</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span>    selectionSort(numbers);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36914;&#34892;&#36984;&#25799;&#25490;&#24207;</span>
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"&#25490;&#24207;&#24460;&#30340;&#25976;&#23383;&#65306;"</span> &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr">17: </span>    display(numbers);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#39023;&#31034;&#32080;&#26524;</span>
<span class="linenr">18: </span>
<span class="linenr">19: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">20: </span>}
</pre>
</div>


<p>
// ✅ 選擇排序（Selection Sort）實作<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">selectionSort</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>) {
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span> = arr.size();
<span class="linenr"> 3: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n - <span style="color: #da8548; font-weight: bold;">1</span>; i++) {
<span class="linenr"> 4: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">minIndex</span> = i;
<span class="linenr"> 5: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = i + <span style="color: #da8548; font-weight: bold;">1</span>; j &lt; n; j++) {
<span class="linenr"> 6: </span>            <span style="color: #51afef;">if</span> (arr[j] &lt; arr[minIndex]) {
<span class="linenr"> 7: </span>                minIndex = j;
<span class="linenr"> 8: </span>            }
<span class="linenr"> 9: </span>        }
<span class="linenr">10: </span>        <span style="color: #a9a1e1;">std</span>::swap(arr[i], arr[minIndex]);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20132;&#25563;&#26368;&#23567;&#20540;</span>
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>}
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#39023;&#31034;&#25490;&#24207;&#32080;&#26524;</span>
<span class="linenr">15: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">display</span>(<span style="color: #51afef;">const</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>) {
<span class="linenr">16: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">num</span> : arr) {
<span class="linenr">17: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; num &lt;&lt; <span style="color: #98be65;">" "</span>;
<span class="linenr">18: </span>    }
<span class="linenr">19: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr">20: </span>}
</pre>
</div>
</div>
</div>
<div id="outline-container-org868bca5" class="outline-4">
<h4 id="org868bca5"><span class="section-number-4">3.21.2.</span> 📖 詳解</h4>
<div class="outline-text-4" id="text-3-21-2">
</div>
<div id="outline-container-org9343542" class="outline-5">
<h5 id="org9343542">📌 1. 使用「引用傳遞（Pass-by-Reference）」</h5>
<div class="outline-text-5" id="text-org9343542">
<p>
本程式使用 std::vector&lt;int&gt;&amp; （引用傳遞） 來確保：<br />
</p>

<ul class="org-ul">
<li>避免陣列的額外複製，提升效能。<br /></li>
<li>讓 selectionSort 直接修改輸入陣列，而非返回一個新的陣列。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">selectionSort</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>);
</pre>
</div>
<p>
🔹 arr 透過引用（&amp;）傳遞，因此函式內的修改會影響原始變數。<br />
</p>
</div>
</div>
<div id="outline-container-orga15292e" class="outline-5">
<h5 id="orga15292e">📌 2. selectionSort 選擇排序（Selection Sort）</h5>
<div class="outline-text-5" id="text-orga15292e">
<p>
選擇排序的基本原理：<br />
</p>

<ul class="org-ul">
<li>在每輪排序中，找到當前範圍內的最小值，並將其與當前索引 i 交換。<br /></li>
<li>時間複雜度：O(n²)，適用於小型數據集。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">selectionSort</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>) {
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span> = arr.size();
<span class="linenr"> 3: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n - <span style="color: #da8548; font-weight: bold;">1</span>; i++) {
<span class="linenr"> 4: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">minIndex</span> = i;
<span class="linenr"> 5: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = i + <span style="color: #da8548; font-weight: bold;">1</span>; j &lt; n; j++) {
<span class="linenr"> 6: </span>            <span style="color: #51afef;">if</span> (arr[j] &lt; arr[minIndex]) {
<span class="linenr"> 7: </span>                minIndex = j;
<span class="linenr"> 8: </span>            }
<span class="linenr"> 9: </span>        }
<span class="linenr">10: </span>        <span style="color: #a9a1e1;">std</span>::swap(arr[i], arr[minIndex]);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20132;&#25563;&#26368;&#23567;&#20540;</span>
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>}
</pre>
</div>


<p>
🔹 std::swap(arr[i], arr[minIndex]); 用於交換數值，提高可讀性。<br />
</p>
</div>
</div>
<div id="outline-container-org0c6968c" class="outline-5">
<h5 id="org0c6968c">📌 3. readFunc 函式宣告</h5>
<div class="outline-text-5" id="text-org0c6968c">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">readFunc</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>);
</pre>
</div>
<ul class="org-ul">
<li>本程式只提供 readFunc 的宣告，沒有實作。<br /></li>
<li>讀取數據的實作由使用者填補。<br /></li>
</ul>

<p>
📌 4. 顯示排序後的結果<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">display</span>(<span style="color: #51afef;">const</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">arr</span>);
</pre>
</div>
<ul class="org-ul">
<li>使用 const std::vector&lt;int&gt;&amp; 確保不修改輸入數據。<br /></li>
<li>透過 for (int num : arr) 進行迴圈輸出。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd6c0058" class="outline-4">
<h4 id="orgd6c0058"><span class="section-number-4">3.21.3.</span> 📚 與本題相關的完整計概知識</h4>
<div class="outline-text-4" id="text-3-21-3">
</div>
<div id="outline-container-org1c3fa51" class="outline-5">
<h5 id="org1c3fa51">1. 選擇排序（Selection Sort）</h5>
<div class="outline-text-5" id="text-org1c3fa51">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">時間複雜度</td>
<td class="org-left">O(n²)</td>
</tr>

<tr>
<td class="org-left">空間複雜度</td>
<td class="org-left">O(1)（就地排序，不需要額外空間）</td>
</tr>

<tr>
<td class="org-left">適用範圍</td>
<td class="org-left">適合小型數據集</td>
</tr>

<tr>
<td class="org-left">穩定性</td>
<td class="org-left">不穩定（若有相同元素，可能改變相對位置）</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org4083114" class="outline-5">
<h5 id="org4083114">2. C++ 傳遞參數方式比較</h5>
<div class="outline-text-5" id="text-org4083114">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方式</th>
<th scope="col" class="org-left">語法</th>
<th scope="col" class="org-left">特點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">傳值（Pass-by-Value）</td>
<td class="org-left">void func(std::vector&lt;int&gt; arr)</td>
<td class="org-left">產生副本，影響效能</td>
</tr>

<tr>
<td class="org-left">傳參考（Pass-by-Reference）</td>
<td class="org-left">void func(std::vector&lt;int&gt;&amp; arr)</td>
<td class="org-left">✅ 修改原數據，節省記憶體</td>
</tr>

<tr>
<td class="org-left">傳常數參考（Pass-by-Const-Reference）</td>
<td class="org-left">void func(const std::vector&lt;int&gt;&amp; arr)</td>
<td class="org-left">✅ 適用於不修改數據的函式</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org6728486" class="outline-5">
<h5 id="org6728486">3. STL std::sort 的替代方案</h5>
<div class="outline-text-5" id="text-org6728486">
<p>
雖然 selectionSort 具有學習價值，但在 C++ 實務開發中，建議使用 STL：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;algorithm&gt;</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#20351;&#29992; STL &#25490;&#24207;</span>
<span class="linenr">2: </span><span style="color: #a9a1e1;">std</span>::sort(arr.begin(), arr.end());  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(n log n)</span>
<span class="linenr">3: </span>
</pre>
</div>
<ul class="org-ul">
<li>std::sort 採用混合排序（Quicksort + HeapSort + Insertion Sort），比 selectionSort 快得多！<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgbe9fa06" class="outline-5">
<h5 id="orgbe9fa06">📌 總結</h5>
<div class="outline-text-5" id="text-orgbe9fa06">
<ul class="org-ul">
<li>本程式使用「引用傳遞」來實作選擇排序，避免複製數據，提高效能。<br /></li>
<li>selectionSort 直接修改 vector&lt;int&gt;&amp; arr，以原地排序方式運作。<br /></li>
<li>提供 readFunc 的函式宣告，滿足題目需求。<br /></li>
<li>理解 selectionSort 與 std::sort 的差異，掌握 C++ 參數傳遞方式，能有效提升程式設計能力！<br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orga000f87" class="outline-2">
<h2 id="orga000f87"><span class="section-number-2">4.</span> AI相關基本知識</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgf46e80a" class="outline-3">
<h3 id="orgf46e80a"><span class="section-number-3">4.1.</span> 機器學習的基本類型</h3>
<div class="outline-text-3" id="text-4-1">
<p>
機器學習（Machine Learning, ML）主要分為 監督式學習（Supervised Learning）、非監督式學習（Unsupervised Learning） 和 強化學習（Reinforcement Learning） 三大類。以下簡介這三種類型，並提供範例說明。<br />
</p>
</div>
<div id="outline-container-org623a27d" class="outline-4">
<h4 id="org623a27d"><span class="section-number-4">4.1.1.</span> 1. 監督式學習（Supervised Learning）</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
概念：<br />
</p>
<ul class="org-ul">
<li>監督式學習是一種透過已標記（labeled）資料進行學習的機器學習方法。系統學習輸入（features）與輸出（labels）之間的關係，然後對新數據進行預測。<br /></li>
</ul>

<p>
主要應用：<br />
</p>
<ul class="org-ul">
<li>分類（Classification）：預測資料點屬於哪個類別。<br /></li>
<li>回歸（Regression）：預測數值型結果。<br /></li>
</ul>

<p>
範例：<br />
</p>
<ul class="org-ul">
<li>分類問題：<br />
<ul class="org-ul">
<li>垃圾郵件分類：電子郵件系統根據郵件內容來判斷它是垃圾郵件（Spam）或正常郵件（Not Spam）。<br /></li>
<li>手寫數字辨識（MNIST 數據集）：識別圖片中的手寫數字（0-9）。<br /></li>
</ul></li>
<li>回歸問題：<br />
<ul class="org-ul">
<li>房價預測：根據房屋的面積、地點、房齡等特徵來預測房價。<br /></li>
<li>股票價格預測：根據歷史價格、成交量、財報數據等預測未來股價。<br /></li>
</ul></li>
</ul>

<p>
常見演算法：<br />
</p>
<ul class="org-ul">
<li>線性回歸（Linear Regression）<br /></li>
<li>支援向量機（SVM）<br /></li>
<li>決策樹（Decision Tree）<br /></li>
<li>隨機森林（Random Forest）<br /></li>
<li>人工神經網路（ANN）<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgab895fa" class="outline-4">
<h4 id="orgab895fa"><span class="section-number-4">4.1.2.</span> 2. 非監督式學習（Unsupervised Learning）</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
概念：<br />
</p>
<ul class="org-ul">
<li>沒有標籤（unlabeled data），系統需要自行發掘數據中的結構或模式。<br /></li>
<li>主要用於數據探索、降維和模式辨識。<br /></li>
</ul>

<p>
主要應用：<br />
</p>
<ul class="org-ul">
<li>聚類（Clustering）：將類似的數據點歸類到同一組。<br /></li>
<li>降維（Dimensionality Reduction）：壓縮高維數據，以提高運算效率和可視化效果。<br /></li>
</ul>

<p>
範例：<br />
</p>
<ul class="org-ul">
<li>聚類（Clustering）：<br />
<ul class="org-ul">
<li>顧客分群（Customer Segmentation）：根據購買行為、瀏覽記錄等，將顧客分類，例如高價值顧客、忠誠顧客等。<br /></li>
<li>社交網絡分析：根據用戶互動模式將社群用戶分組。<br /></li>
</ul></li>
<li>降維（Dimensionality Reduction）：<br />
<ul class="org-ul">
<li>主成分分析（PCA） 用於數據可視化，如將高維金融數據轉換成 2D 圖像以分析市場趨勢。<br /></li>
<li>t-SNE 用於影像處理，幫助視覺化高維數據的關聯性。<br /></li>
</ul></li>
</ul>

<p>
常見演算法：<br />
</p>
<ul class="org-ul">
<li>K-Means 聚類<br /></li>
<li>DBSCAN（密度聚類）<br /></li>
<li>主成分分析（PCA）<br /></li>
<li>自編碼器（Autoencoder）<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge727203" class="outline-4">
<h4 id="orge727203"><span class="section-number-4">4.1.3.</span> 3. 強化學習（Reinforcement Learning, RL）</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
概念：<br />
</p>
<ul class="org-ul">
<li>強化學習讓智能體（Agent） 透過與環境互動來學習最優行為策略，並根據獎勵（Reward）或懲罰（Penalty）來調整決策。<br /></li>
<li>核心概念：<br />
<ul class="org-ul">
<li>狀態（State, S）：智能體當前的情境。<br /></li>
<li>動作（Action, A）：智能體在某個狀態下可以選擇的行動。<br /></li>
<li>獎勵（Reward, R）：動作的回饋，用於指導學習。<br /></li>
</ul></li>
</ul>

<p>
主要應用：<br />
</p>
<ul class="org-ul">
<li>遊戲 AI：<br />
<ul class="org-ul">
<li>AlphaGo（圍棋 AI）、DQN 在 Atari 遊戲中的應用。<br /></li>
</ul></li>
<li>機器人控制：<br />
<ul class="org-ul">
<li>自主駕駛（Autonomous Driving）：讓 AI 學習如何駕駛車輛，根據環境做出最佳決策。<br /></li>
</ul></li>
<li>交易策略學習：<br />
量化交易（Algorithmic Trading）：AI 根據市場數據調整買賣策略，最大化投資回報。<br /></li>
</ul>

<p>
範例：<br />
</p>
<ul class="org-ul">
<li>自駕車 AI（Autonomous Driving）：<br />
<ul class="org-ul">
<li>AI 學習如何駕駛汽車，當遇到紅燈時減速，遇到障礙物時轉向，以獲得更高的安全性獎勵。<br /></li>
</ul></li>
<li>遊戲 AI（Game AI）：<br />
<ul class="org-ul">
<li>AlphaGo 透過強化學習學會下圍棋，擊敗世界頂級棋手。<br /></li>
</ul></li>
</ul>

<p>
常見演算法：<br />
</p>
<ul class="org-ul">
<li>Q-Learning<br /></li>
<li>深度 Q 網路（Deep Q-Network, DQN）<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0dc2a26" class="outline-4">
<h4 id="org0dc2a26"><span class="section-number-4">4.1.4.</span> 4. 半監督學習（Semi-Supervised Learning）</h4>
<div class="outline-text-4" id="text-4-1-4">
<ul class="org-ul">
<li>介於監督式學習與非監督式學習之間。<br /></li>
<li>主要用於標註資料較少，但未標註資料較多的情境。<br /></li>
<li>應用範例：<br />
<ul class="org-ul">
<li>圖像識別（利用少量標註的圖片來訓練 AI）<br /></li>
<li>自然語言處理（語音識別、翻譯）<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org42206eb" class="outline-4">
<h4 id="org42206eb"><span class="section-number-4">4.1.5.</span> 總結</h4>
<div class="outline-text-4" id="text-4-1-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">機器學習類型</th>
<th scope="col" class="org-left">學習方式</th>
<th scope="col" class="org-left">常見演算法</th>
<th scope="col" class="org-left">應用範例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">監督式學習</td>
<td class="org-left">有標籤數據</td>
<td class="org-left">線性回歸、決策樹、SVM、神經網路</td>
<td class="org-left">股票預測、垃圾郵件分類</td>
</tr>

<tr>
<td class="org-left">非監督式學習</td>
<td class="org-left">無標籤數據</td>
<td class="org-left">K-Means、DBSCAN、PCA、自編碼器</td>
<td class="org-left">客戶分群、降維</td>
</tr>

<tr>
<td class="org-left">強化學習</td>
<td class="org-left">互動學習（獎勵與懲罰）</td>
<td class="org-left">Q-Learning、DQN、PPO</td>
<td class="org-left">自駕車、遊戲 AI</td>
</tr>

<tr>
<td class="org-left">半監督學習</td>
<td class="org-left">部分數據有標籤</td>
<td class="org-left">深度學習模型</td>
<td class="org-left">圖像識別、語音辨識</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org430018c" class="outline-3">
<h3 id="org430018c"><span class="section-number-3">4.2.</span> 什麼是深度學習</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org6a1de6d" class="outline-4">
<h4 id="org6a1de6d"><span class="section-number-4">4.2.1.</span> 1. 什麼是深度學習？</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
深度學習（Deep Learning, DL） 是 機器學習（Machine Learning） 的一個子領域，透過 人工神經網路（Artificial Neural Networks, ANN） 模擬人類大腦的運作方式來進行數據學習與決策。深度學習通常涉及 多層神經網路（Deep Neural Networks, DNN），可以從大量數據中自動學習特徵並進行預測、分類、生成等任務。<br />
</p>
</div>
</div>
<div id="outline-container-orgf1d8970" class="outline-4">
<h4 id="orgf1d8970"><span class="section-number-4">4.2.2.</span> 2. 深度學習與傳統機器學習的差異</h4>
<div class="outline-text-4" id="text-4-2-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">傳統機器學習</th>
<th scope="col" class="org-left">深度學習</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">特徵工程（Feature Engineering）</td>
<td class="org-left">需要專家手動提取特徵</td>
<td class="org-left">自動從數據中學習特徵</td>
</tr>

<tr>
<td class="org-left">模型結構</td>
<td class="org-left">基於決策樹、SVM、線性回歸等</td>
<td class="org-left">基於多層神經網路（DNN, CNN, RNN等）</td>
</tr>

<tr>
<td class="org-left">處理數據類型</td>
<td class="org-left">結構化數據（表格數據）較佳</td>
<td class="org-left">擅長處理非結構化數據（圖像、文本、語音）</td>
</tr>

<tr>
<td class="org-left">數據需求</td>
<td class="org-left">可用較少數據進行學習</td>
<td class="org-left">需要大量數據進行訓練</td>
</tr>

<tr>
<td class="org-left">計算需求</td>
<td class="org-left">運算需求較低，可用 CPU 訓練</td>
<td class="org-left">計算量大，通常使用 GPU 或 TPU 訓練</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org1dab805" class="outline-4">
<h4 id="org1dab805"><span class="section-number-4">4.2.3.</span> 3. 深度學習的核心技術</h4>
<div class="outline-text-4" id="text-4-2-3">
</div>
<div id="outline-container-orgece610e" class="outline-5">
<h5 id="orgece610e">(1) 人工神經網路（Artificial Neural Network, ANN）</h5>
<div class="outline-text-5" id="text-orgece610e">
<ul class="org-ul">
<li>由 輸入層（Input Layer）、隱藏層（Hidden Layers） 和 輸出層（Output Layer） 組成。<br /></li>
<li>透過 權重（Weights） 和 偏差（Biases） 來調整學習過程。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org75d84c9" class="outline-5">
<h5 id="org75d84c9">(2) 反向傳播（Backpropagation）與梯度下降（Gradient Descent）</h5>
<div class="outline-text-5" id="text-org75d84c9">
<ul class="org-ul">
<li>反向傳播（Backpropagation）：計算誤差並調整權重，使模型逐步收斂到最佳狀態。<br /></li>
<li>梯度下降（Gradient Descent）：一種優化演算法，透過最小化損失函數來改進模型。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org43eb3b6" class="outline-5">
<h5 id="org43eb3b6">(3) 激活函數（Activation Functions）</h5>
<div class="outline-text-5" id="text-org43eb3b6">
<ul class="org-ul">
<li>ReLU（Rectified Linear Unit）：適用於深層網路，解決梯度消失問題。<br /></li>
<li>Sigmoid 和 Tanh：適用於簡單模型，但容易造成梯度消失問題。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgbfc3120" class="outline-5">
<h5 id="orgbfc3120">(4) 正則化（Regularization）</h5>
<div class="outline-text-5" id="text-orgbfc3120">
<ul class="org-ul">
<li>Dropout：隨機關閉部分神經元，防止過擬合（Overfitting）。<br /></li>
<li>L1/L2 正則化（Lasso / Ridge）：限制權重的大小，使模型更具泛化能力。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1304202" class="outline-5">
<h5 id="org1304202">4. 深度學習的主要模型</h5>
<div class="outline-text-5" id="text-org1304202">
<ol class="org-ol">
<li>前饋神經網路（Feedforward Neural Network, FNN）<br />
<ul class="org-ul">
<li>最基本的神經網路結構，資訊從輸入層流向輸出層。<br /></li>
</ul></li>
<li>卷積神經網路（Convolutional Neural Network, CNN）<br />
<ul class="org-ul">
<li>應用場景：圖像辨識（Image Classification）、物件偵測（Object Detection）、醫學影像分析。<br /></li>
<li>核心概念：<br />
<ul class="org-ul">
<li>卷積層（Convolutional Layer）：提取圖像特徵（邊緣、紋理）。<br /></li>
<li>池化層（Pooling Layer）：降低維度並保留重要資訊。<br /></li>
<li>全連接層（Fully Connected Layer）：輸出分類結果。<br /></li>
</ul></li>
</ul></li>
<li>循環神經網路（Recurrent Neural Network, RNN）<br />
<ul class="org-ul">
<li>應用場景：自然語言處理（NLP）、時間序列分析（Time Series Analysis）、語音辨識。<br /></li>
<li>核心概念：<br />
<ul class="org-ul">
<li>遞歸結構：具有記憶能力，可處理序列數據。<br /></li>
<li>LSTM（Long Short-Term Memory）與 GRU（Gated Recurrent Unit）：解決長期依賴問題，適用於翻譯、對話等任務。<br /></li>
</ul></li>
</ul></li>
<li>生成對抗網路（Generative Adversarial Network, GAN）<br />
<ul class="org-ul">
<li>應用場景：圖像生成（如 DeepFake）、藝術創作、數據增強。<br /></li>
<li>核心概念：<br />
<ul class="org-ul">
<li>生成器（Generator）：生成假數據。<br /></li>
<li>判別器（Discriminator）：判斷數據真偽，逼迫生成器生成更逼真的數據。<br /></li>
</ul></li>
</ul></li>
<li>變分自動編碼器（Variational Autoencoder, VAE）<br />
<ul class="org-ul">
<li>應用場景：降噪、圖像生成、特徵學習。<br /></li>
<li>核心概念：<br />
<ul class="org-ul">
<li>編碼器（Encoder）：將輸入壓縮成潛在變數（Latent Variable）。<br /></li>
<li>解碼器（Decoder）：從潛在變數還原數據。<br /></li>
</ul></li>
</ul></li>
<li>變換器（Transformer）<br />
<ul class="org-ul">
<li>應用場景：自然語言處理（如 ChatGPT）、機器翻譯（Google Translate）。<br /></li>
<li>核心技術：<br />
<ul class="org-ul">
<li>自注意力機制（Self-Attention）：讓模型理解句子中單詞之間的關係。<br /></li>
<li>位置編碼（Positional Encoding）：解決 RNN 無法有效處理長文本的問題。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org360096f" class="outline-5">
<h5 id="org360096f">5. 深度學習的應用領域</h5>
<div class="outline-text-5" id="text-org360096f">
<ul class="org-ul">
<li>✅ 電腦視覺（Computer Vision）：圖像辨識、目標偵測、人臉識別<br /></li>
<li>✅ 自然語言處理（NLP）：機器翻譯、聊天機器人、情感分析<br /></li>
<li>✅ 自動駕駛（Autonomous Driving）：物件識別、路線規劃<br /></li>
<li>✅ 醫療診斷（Medical Diagnosis）：癌症檢測、醫學影像分析<br /></li>
<li>✅ 金融（Finance）：股票預測、詐欺偵測<br /></li>
<li>✅ 推薦系統（Recommendation Systems）：Netflix、YouTube、Spotify 的內容推薦<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org303d5da" class="outline-3">
<h3 id="org303d5da"><span class="section-number-3">4.3.</span> 什麼是大語言模型</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org9c07f1d" class="outline-4">
<h4 id="org9c07f1d"><span class="section-number-4">4.3.1.</span> 1. 什麼是大語言模型？</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
大語言模型（LLM, Large Language Model） 是一種基於 深度學習（Deep Learning） 的 自然語言處理（NLP, Natural Language Processing） 模型，能夠理解、生成和處理人類語言。這些模型通常擁有 數十億到數千億 個參數，並透過 大規模文本數據 訓練，使其具備語言理解與生成能力。<br />
</p>
</div>
</div>
<div id="outline-container-org280fea6" class="outline-4">
<h4 id="org280fea6"><span class="section-number-4">4.3.2.</span> 2. 大語言模型的核心技術</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
大語言模型的基礎是 Transformer 架構，其核心技術包括：<br />
</p>
<ul class="org-ul">
<li>自注意力機制（Self-Attention Mechanism）：用於捕捉句子內不同詞語之間的關聯性，使模型能夠考慮長距離的語境。<br /></li>
<li>詞嵌入（Word Embedding）：將單詞轉換為數學向量，讓模型能夠計算單詞間的相似性。<br /></li>
<li>自回歸（Autoregressive）與自編碼（Autoencoding）技術：<br />
<ul class="org-ul">
<li>自回歸模型（如 GPT）：依序預測下一個詞彙，適用於文本生成。<br /></li>
<li>自編碼模型（如 BERT）：同時考慮前後文，適用於文本理解。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6f94cae" class="outline-4">
<h4 id="org6f94cae"><span class="section-number-4">4.3.3.</span> 3. 大語言模型的訓練流程</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
大語言模型的訓練通常分為 兩個階段：<br />
</p>
</div>
<div id="outline-container-orge603d4b" class="outline-5">
<h5 id="orge603d4b">(1) 預訓練（Pre-training）</h5>
<div class="outline-text-5" id="text-orge603d4b">
<ul class="org-ul">
<li>在 大量無標註文本數據（如維基百科、書籍、新聞、網路文章）上進行訓練。<br /></li>
<li>主要目標是學習語言結構與模式，透過 自監督學習（Self-supervised Learning） 來學會填空或預測下一個單詞。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>GPT 模型：「今天的天氣很 ___」，AI 預測「好 / 糟 / 冷」等詞彙。<br /></li>
<li>BERT 模型：「我 <span class="underline">_</span> 學習 AI」，AI 嘗試填補空格（Masked Language Model）。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd8dbef2" class="outline-5">
<h5 id="orgd8dbef2">(2) 微調（Fine-tuning）</h5>
<div class="outline-text-5" id="text-orgd8dbef2">
<ul class="org-ul">
<li>在特定任務數據集（如對話、翻譯、醫療、法律等）上進行調整，使 AI 能更準確地完成目標任務。<br /></li>
<li>可能使用 人類回饋強化學習（RLHF, Reinforcement Learning from Human Feedback），透過標註數據來優化回應品質。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org99c1e38" class="outline-4">
<h4 id="org99c1e38"><span class="section-number-4">4.3.4.</span> 4. 常見的大語言模型</h4>
<div class="outline-text-4" id="text-4-3-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">模型名稱</th>
<th scope="col" class="org-left">開發公司</th>
<th scope="col" class="org-left">特點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GPT-3.5 / GPT-4</td>
<td class="org-left">OpenAI</td>
<td class="org-left">生成式 AI，對話與文本生成能力強</td>
</tr>

<tr>
<td class="org-left">BERT（Bidirectional Encoder Representations from Transformers）</td>
<td class="org-left">Google</td>
<td class="org-left">雙向理解語言，適合問答與分類</td>
</tr>

<tr>
<td class="org-left">T5（Text-to-Text Transfer Transformer）</td>
<td class="org-left">Google</td>
<td class="org-left">可用於翻譯、摘要、分類等多種 NLP 任務</td>
</tr>

<tr>
<td class="org-left">LLaMA（Large Language Model Meta AI）</td>
<td class="org-left">Meta（Facebook）</td>
<td class="org-left">開源大語言模型，較節省計算資源</td>
</tr>

<tr>
<td class="org-left">PaLM（Pathways Language Model）</td>
<td class="org-left">Google</td>
<td class="org-left">針對多模態（文字、圖像、程式碼）優化</td>
</tr>

<tr>
<td class="org-left">Claude</td>
<td class="org-left">Anthropic</td>
<td class="org-left">強調安全性、對話能力與長文本處理</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org1e7b739" class="outline-4">
<h4 id="org1e7b739"><span class="section-number-4">4.3.5.</span> 5. 大語言模型的應用</h4>
<div class="outline-text-4" id="text-4-3-5">
<ul class="org-ul">
<li>✅ 自然語言處理（NLP）：語音助手、聊天機器人（Chatbot）<br /></li>
<li>✅ 文本生成：自動寫作、新聞摘要、創意寫作<br /></li>
<li>✅ 翻譯與語言理解：即時翻譯、語言學習<br /></li>
<li>✅ 程式輔助：自動補全程式碼、偵測錯誤（如 GitHub Copilot）<br /></li>
<li>✅ 知識檢索：回答問題、提供專業建議（如 AI 搜尋引擎）<br /></li>
<li>✅ 教育與學習：個人化教學、智慧問答系統<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4c8400c" class="outline-4">
<h4 id="org4c8400c"><span class="section-number-4">4.3.6.</span> 6. 大語言模型的挑戰與限制</h4>
<div class="outline-text-4" id="text-4-3-6">
<ul class="org-ul">
<li>❌ 幻覺（Hallucination）問題：可能產生錯誤或虛假的資訊<br /></li>
<li>❌ 計算成本高：需要大量 GPU 訓練，運行成本昂貴<br /></li>
<li>❌ 倫理與偏見（Bias）：學習到數據中的偏見，可能造成不公平結果<br /></li>
<li>❌ 上下文記憶有限：長文本可能無法維持連貫性<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org37b739f" class="outline-3">
<h3 id="org37b739f"><span class="section-number-3">4.4.</span> 什麼是圖靈測試</h3>
<div class="outline-text-3" id="text-4-4">
</div>
<div id="outline-container-org7a69ea9" class="outline-4">
<h4 id="org7a69ea9"><span class="section-number-4">4.4.1.</span> 1. 什麼是圖靈測試？</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
圖靈測試（Turing Test） 是由英國數學家 艾倫·圖靈（Alan Turing） 在 1950 年於論文《Computing Machinery and Intelligence》中提出的一種測試 機器是否具備智慧（Intelligence） 的方法。它的核心思想是：如果一台機器能夠在對話中讓人類無法區分它是機器還是人類，那麼這台機器就可以被認為具有智慧。<br />
</p>

<p>
圖靈測試並不是檢測機器是否真正「理解」或「思考」，而是檢查其行為是否能夠模仿人類的智慧。<br />
</p>
</div>
</div>
<div id="outline-container-orgc5a1399" class="outline-4">
<h4 id="orgc5a1399"><span class="section-number-4">4.4.2.</span> 2. 圖靈測試的基本流程</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
圖靈測試通常由 三方 參與：<br />
</p>
<ul class="org-ul">
<li>人類測試者（C，評審）：負責與兩位「受測者」進行純文字的對話（通常透過鍵盤輸入）。<br /></li>
<li>人類受測者（A）：與測試者交流的真人。<br /></li>
<li>機器受測者（B）：一個試圖模仿人類回答問題的人工智慧系統。<br /></li>
</ul>

<p>
測試過程<br />
</p>
<ul class="org-ul">
<li>測試者（C）與人類受測者（A）和機器受測者（B）進行對話。<br /></li>
<li>測試者不知道誰是人類，誰是機器。<br /></li>
<li>如果測試者無法準確分辨機器與人類的對話者，則認為機器通過了圖靈測試。<br /></li>

<li>📌 關鍵點：測試的對話內容不受限，可以涉及日常交流、邏輯推理，甚至是幽默、情感表達等。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0cd31ee" class="outline-4">
<h4 id="org0cd31ee"><span class="section-number-4">4.4.3.</span> 3. 圖靈測試的影響與應用</h4>
<div class="outline-text-4" id="text-4-4-3">
<ol class="org-ol">
<li>AI 研究的發展<br />
<ul class="org-ul">
<li>圖靈測試被視為**人工智慧（Artificial Intelligence, AI）**研究的重要目標之一，推動了自然語言處理（NLP）技術的發展，如 ChatGPT、Google Bard 等聊天機器人。<br /></li>
</ul></li>
<li>聊天機器人與對話系統<br />
<ul class="org-ul">
<li>現今許多聊天機器人（如 Siri、Alexa、Google Assistant）都試圖透過自然語言處理來通過圖靈測試。<br /></li>
</ul></li>
<li>CAPTCHA 測試<br />
<ul class="org-ul">
<li>圖靈測試的概念被應用於 CAPTCHA（Completely Automated Public Turing test to tell Computers and Humans Apart），用來區分網頁上的使用者是人類還是機器。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orga4a94d8" class="outline-4">
<h4 id="orga4a94d8"><span class="section-number-4">4.4.4.</span> 4. 圖靈測試的挑戰與局限</h4>
<div class="outline-text-4" id="text-4-4-4">
<ol class="org-ol">
<li>能否真正測試「智慧」？<br />
<ul class="org-ul">
<li>圖靈測試只檢查機器的行為，而不考慮機器是否真正理解語言或具備「意識」（Consciousness）。<br /></li>
<li>「模仿人類」不等於「思考能力」。<br /></li>
</ul></li>
<li>作弊與花招<br />
<ul class="org-ul">
<li>一些 AI 可能通過隨機回答、迴避問題、使用幽默等方式欺騙測試者，而非真正理解對話內容。<br /></li>
</ul></li>
<li>中文房間（Chinese Room）悖論<br />
<ul class="org-ul">
<li>哲學家 John Searle 提出「中文房間（Chinese Room）」思想實驗，質疑圖靈測試是否能真正證明機器具有「理解」能力。<br /></li>
<li>例子：假設有一個不懂中文的人，透過一本「中英翻譯對照表」與外界對話，讓人以為他懂中文。但實際上，他只是依據規則機械式地回應，並不理解中文的意義。<br /></li>
<li>問題：類似地，機器可能只是透過統計語言模式來生成回答，而不是「理解」內容。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org9ae0117" class="outline-4">
<h4 id="org9ae0117"><span class="section-number-4">4.4.5.</span> 5. 當代 AI 是否通過圖靈測試？</h4>
<div class="outline-text-4" id="text-4-4-5">
<ul class="org-ul">
<li>目前的 AI，如 ChatGPT、GPT-4，已經能夠進行流暢的對話、回答複雜問題，甚至模仿情感，使人難以區分機器與人類。<br /></li>
<li>然而，AI 並未真正理解語言，它只是基於機率模型與數據學習來生成回應，因此是否「通過」圖靈測試仍具爭議。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org96e4da9" class="outline-4">
<h4 id="org96e4da9"><span class="section-number-4">4.4.6.</span> 6. 總結</h4>
<div class="outline-text-4" id="text-4-4-6">
<ul class="org-ul">
<li>圖靈測試 是一種檢驗機器智慧的行為測試，若 AI 能讓人類無法區分其身份，即視為通過測試。<br /></li>
<li>它推動了 AI、自然語言處理（NLP） 技術的發展，並影響了 聊天機器人、語音助手、CAPTCHA 等應用。<br /></li>
<li>但圖靈測試有其局限性，例如機器能夠模仿語言，但不一定真正「理解」對話內容。<br /></li>
<li>目前的 AI（如 ChatGPT）雖然能騙過人類，但是否真正「通過」圖靈測試仍具爭議。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org117fa1c" class="outline-3">
<h3 id="org117fa1c"><span class="section-number-3">4.5.</span> 什麼是圖靈機</h3>
<div class="outline-text-3" id="text-4-5">
</div>
<div id="outline-container-orgaf3d660" class="outline-4">
<h4 id="orgaf3d660"><span class="section-number-4">4.5.1.</span> 1. 什麼是圖靈機？</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
圖靈機（Turing Machine） 是由 艾倫·圖靈（Alan Turing） 在 1936 年提出的一種理論計算模型，用來模擬所有可能的計算過程。它被視為現代計算機科學的理論基礎，證明了計算機能夠執行的所有計算都可以用圖靈機來描述。<br />
</p>

<p>
📌 關鍵概念：圖靈機是一個抽象機器（abstract machine），用來研究計算的極限和可計算性（Computability）。<br />
</p>
</div>
</div>
<div id="outline-container-orgc74ef8f" class="outline-4">
<h4 id="orgc74ef8f"><span class="section-number-4">4.5.2.</span> 2. 圖靈機的基本組成</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
圖靈機由以下幾個部分組成：<br />
</p>
<ul class="org-ul">
<li>無限長的紙帶（Tape）：<br />
<ul class="org-ul">
<li>紙帶上的每一格都可以存放一個符號（如 0 或 1）。<br /></li>
<li>紙帶可以向左或右移動，用來存取和修改數據。<br /></li>
</ul></li>
<li>讀寫頭（Read/Write Head）：<br />
<ul class="org-ul">
<li>讀寫頭可以讀取紙帶上的符號。<br /></li>
<li>它可以根據機器的內部狀態來修改當前符號。<br /></li>
<li>它可以向左或向右移動到下一個符號。<br /></li>
</ul></li>
<li>有限狀態機（Finite Control）：<br />
<ul class="org-ul">
<li>存儲當前狀態，類似於現代電腦的「控制單元」。<br /></li>
<li>根據當前狀態與讀取到的符號，決定下一個動作（寫入、移動、改變狀態）。<br /></li>
</ul></li>
<li>狀態轉移函數（Transition Function）：<br />
<ul class="org-ul">
<li>圖靈機的運行規則是根據一組有限的轉移規則決定的：<br />
<ul class="org-ul">
<li>讀取當前紙帶上的符號。<br /></li>
<li>根據當前狀態和讀取的符號，決定要寫入的符號、移動方向，以及新的狀態。<br /></li>
<li>重複這個過程，直到機器進入終止狀態（Halting State）。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgbb2a675" class="outline-4">
<h4 id="orgbb2a675"><span class="section-number-4">4.5.3.</span> 3. 圖靈機的運作方式</h4>
<div class="outline-text-4" id="text-4-5-3">
<ol class="org-ol">
<li>初始狀態<br />
<ul class="org-ul">
<li>紙帶上有一串輸入符號，讀寫頭位於紙帶上的某個位置。<br /></li>
<li>圖靈機的狀態設定為起始狀態。<br /></li>
</ul></li>
<li>逐步執行<br />
<ul class="org-ul">
<li>讀寫頭讀取當前符號。<br /></li>
<li>根據狀態轉移函數：<br />
<ul class="org-ul">
<li>修改當前符號。<br /></li>
<li>移動讀寫頭（向左或向右）。<br /></li>
<li>改變狀態。<br /></li>
</ul></li>
</ul></li>
<li>運行至終止<br />
<ul class="org-ul">
<li>當進入某個終止狀態，圖靈機停止運行，並輸出最終結果。<br /></li>
</ul></li>

<li>圖靈機的應用與重要性<br /></li>
<li>計算理論基礎<br />
<ul class="org-ul">
<li>圖靈機定義了「可計算性（Computability）」的概念，即哪些問題可以由機器計算解決。<br /></li>
<li>圖靈完全（Turing-complete）：如果一個系統能夠模擬圖靈機，則它能計算任何可計算的函數，例如 Python、C、Java 這些程式語言都是圖靈完備的。<br /></li>
</ul></li>
<li>可決定性（Decidability）<br />
<ul class="org-ul">
<li>決定問題（Decidability Problem）：是否存在一個演算法可以在有限步驟內判斷所有輸入是否滿足某個條件？<br /></li>
<li>停機問題（Halting Problem）：圖靈證明不可能存在一個通用的演算法來判斷所有圖靈機是否會停止運行，這意味著某些問題是無法計算的。<br /></li>
</ul></li>
<li>現代計算機的理論基礎<br />
<ul class="org-ul">
<li>圖靈機是現代電腦的數學模型，影響了 CPU、記憶體、程式設計語言的發展。<br /></li>
<li>雖然現代電腦比圖靈機更複雜，但它們的運作方式仍然可以被圖靈機的概念描述。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org302a755" class="outline-3">
<h3 id="org302a755"><span class="section-number-3">4.6.</span> AI如何應用於資訊管理</h3>
<div class="outline-text-3" id="text-4-6">
<p>
人工智慧（Artificial Intelligence, AI）是一種模擬人類認知能力的技術，涵蓋了機器學習、自然語言處理、電腦視覺等多個領域。在**資訊管理（Information Management, IM）**中，AI 可以幫助組織提升決策效率、優化業務流程、強化客戶服務，並提供更好的數據分析與預測能力。以下將介紹不同類型的 AI 及其在資訊管理領域的應用。<br />
</p>
</div>
<div id="outline-container-org63c9abf" class="outline-4">
<h4 id="org63c9abf"><span class="section-number-4">4.6.1.</span> 1. AI 的主要類型及應用</h4>
<div class="outline-text-4" id="text-4-6-1">
<p>
AI 主要可分為以下幾種類型，每種類型都可對應不同的資訊管理應用場景：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">AI 類型</th>
<th scope="col" class="org-left">定義</th>
<th scope="col" class="org-left">資訊管理應用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">規則型 AI（Rule-based AI）</td>
<td class="org-left">基於明確定義的規則進行決策，依靠專家系統與邏輯推理。</td>
<td class="org-left">- 企業內部流程自動化（如 IT 服務管理系統）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 自動化工作流程（如 ERP、CRM 規則設定）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">機器學習（Machine Learning, ML）</td>
<td class="org-left">透過數據訓練模型來學習模式並做出決策，不需明確規則編碼。</td>
<td class="org-left">- 數據分析與商業智慧（BI）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 供應鏈需求預測</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 使用者行為分析（如電子商務推薦系統）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">深度學習（Deep Learning, DL）</td>
<td class="org-left">透過多層神經網路自動學習複雜模式，適合處理大量非結構化數據。</td>
<td class="org-left">- 圖像與文件識別（如票據審核、自動表單處理）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 自然語言處理（如客服聊天機器人）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">自然語言處理（Natural Language Processing, NLP）</td>
<td class="org-left">處理和理解人類語言，使電腦能讀取、理解和產生自然語言。</td>
<td class="org-left">- 語音識別與轉錄（如自動會議摘要）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 自動化客服（如 ChatGPT）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 文本分析（如企業輿情監控）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">電腦視覺（Computer Vision, CV）</td>
<td class="org-left">讓電腦理解和分析影像、影片數據。</td>
<td class="org-left">- 自動化文件處理（如 OCR 文字識別）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 監控與安全管理（如人臉識別門禁系統）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">強化學習（Reinforcement Learning, RL）</td>
<td class="org-left">透過試錯（Trial &amp; Error）與獎勵機制來學習最優策略。</td>
<td class="org-left">- 自動化決策（如倉儲調度系統）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 企業策略優化（如動態定價模型）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">生成式 AI（Generative AI）</td>
<td class="org-left">透過學習已有數據來產生新的內容，如圖像、文字、音樂等。</td>
<td class="org-left">- 報告與文案自動生成（如 AI 生成商業報告）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">- 產品設計與創意生成（如 AI 自動生成簡報）</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgf2ffb30" class="outline-4">
<h4 id="orgf2ffb30"><span class="section-number-4">4.6.2.</span> 2. 各種 AI 在資訊管理領域的應用案例</h4>
<div class="outline-text-4" id="text-4-6-2">
</div>
<div id="outline-container-orgcc0d15e" class="outline-5">
<h5 id="orgcc0d15e">(1) AI 驅動的數據分析與決策支援</h5>
<div class="outline-text-5" id="text-orgcc0d15e">
<ul class="org-ul">
<li>機器學習 可以幫助企業進行商業智能（BI），透過數據分析來預測市場趨勢、銷售成長等。<br /></li>
<li>自然語言處理（NLP） 可用於企業文本數據挖掘，分析客戶評論、社交媒體情緒，幫助企業制定行銷策略。<br /></li>
<li>🔹 應用案例： ✅ 金融機構 使用 AI 進行信用風險評估與詐欺偵測。<br /></li>
<li>✅ 電子商務平台 利用推薦系統來提升轉換率。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3f30294" class="outline-5">
<h5 id="org3f30294">(2) AI 自動化企業流程（RPA + AI）</h5>
<div class="outline-text-5" id="text-org3f30294">
<ul class="org-ul">
<li>規則型 AI + 機器學習 可實現智慧企業流程自動化（RPA, Robotic Process Automation），減少人工處理時間。<br /></li>
<li>AI 可自動執行合約審核、請款處理、HR 招聘過濾履歷等任務。<br /></li>
<li>🔹 應用案例： ✅ 銀行業 使用 AI 自動審核貸款申請書，提高效率。<br /></li>
<li>✅ 人力資源部門 透過 AI 過濾求職者履歷，提高招聘效率。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb3c6342" class="outline-5">
<h5 id="orgb3c6342">(3) AI 提升企業 IT 管理與安全性</h5>
<div class="outline-text-5" id="text-orgb3c6342">
<ul class="org-ul">
<li>深度學習 + 電腦視覺 可進行異常行為偵測，如 IT 安全防護、內部數據存取異常監測。<br /></li>
<li>AI 驅動的自適應防火牆，可主動預測和防範網路攻擊。<br /></li>
<li>🔹 應用案例： ✅ 企業網絡安全監控，AI 自動發現異常流量，防止駭客攻擊。<br /></li>
<li>✅ 零信任架構（Zero Trust），AI 進行用戶身份驗證與權限管理。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org765de8e" class="outline-5">
<h5 id="org765de8e">(4) AI 驅動的客戶關係管理（CRM）</h5>
<div class="outline-text-5" id="text-org765de8e">
<ul class="org-ul">
<li>自然語言處理（NLP） 可用於智能客服機器人，提供 24/7 自動客服服務。<br /></li>
<li>機器學習 可分析顧客購買行為，進行個性化推薦。<br /></li>
<li>🔹 應用案例： ✅ 企業客服中心 使用 ChatGPT 來處理常見客戶詢問。<br /></li>
<li>✅ 保險公司 利用 AI 進行智能合約分析，提升客戶體驗。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb383afa" class="outline-5">
<h5 id="orgb383afa">(5) AI 在供應鏈與生產管理中的應用</h5>
<div class="outline-text-5" id="text-orgb383afa">
<ul class="org-ul">
<li>強化學習（Reinforcement Learning, RL） 可幫助企業進行供應鏈最佳化，如物流調度、自動訂貨系統。<br /></li>
<li>AI 驅動的預測維護（Predictive Maintenance），透過設備感測數據預測機器何時需要維修，降低成本。<br /></li>
<li>🔹 應用案例： ✅ 製造業 使用 AI 進行機器預測維護，減少停機時間。<br /></li>
<li>✅ 物流業 使用 AI 計算最優配送路線，降低運輸成本。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org948566f" class="outline-4">
<h4 id="org948566f"><span class="section-number-4">4.6.3.</span> 3. AI 在資訊管理的未來發展</h4>
<div class="outline-text-4" id="text-4-6-3">
<p>
智慧決策支援系統（DSS, Decision Support System）<br />
</p>
<ul class="org-ul">
<li>企業決策將更多依賴 AI 驅動的決策支援系統，減少主觀判斷誤差。<br /></li>
</ul>
<p>
AI 與大數據（Big Data）結合<br />
</p>
<ul class="org-ul">
<li>AI 可以即時分析海量數據，幫助企業發現商業機會與風險。<br /></li>
</ul>
<p>
AI 驅動的個人化體驗<br />
</p>
<ul class="org-ul">
<li>透過 AI 分析客戶數據，提供更精準的個性化服務，如動態訂價、個人化推薦。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org0bc7f02" class="outline-2">
<h2 id="org0bc7f02"><span class="section-number-2">5.</span> 中央113計概</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgbce579b" class="outline-3">
<h3 id="orgbce579b"><span class="section-number-3">5.1.</span> 1.(10%)</h3>
<div class="outline-text-3" id="text-5-1">
<p>
請詳細說明 QUIC (Quick UDP Internet Connection) 協定的發展背景與特色。<br />
</p>
</div>
<div id="outline-container-org3d47691" class="outline-4">
<h4 id="org3d47691"><span class="section-number-4">5.1.1.</span> 解</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
QUIC (Quick UDP Internet Connection) 協定是一個在網路傳輸層的協定，旨在改善傳統 TCP 協定的一些限制，特別是在速度和效率方面<br />
。以下詳細說明其發展背景與特色，並擴展相關的計算機概論知識：<br />
</p>
</div>
<div id="outline-container-orge74fa2f" class="outline-5">
<h5 id="orge74fa2f">QUIC 的發展背景</h5>
<div class="outline-text-5" id="text-orge74fa2f">
<ul class="org-ul">
<li>TCP 的限制： 傳統的 TCP 協定在建立連線時需要三次握手，而且在發生封包遺失時會導致重傳，這些都會造成延遲 [來源未提及]。尤其在行動網路環境下，網路不穩定性更高，TCP 的效能會受到更大影響。<br /></li>
<li>HTTP/2 的問題： 雖然 HTTP/2 透過多工處理（multiplexing）改善了網頁載入速度，但它仍然基於 TCP，因此無法完全解決 TCP 本身的問題，例如 Head-of-Line Blocking [來源未提及]。Head-of-Line Blocking 是指當 TCP 連線中的一個封包遺失時，後續的封包必須等待該封包重傳才能繼續處理，這會導致延遲。<br /></li>
<li>Google 的需求： Google 為了提升其服務（例如 Chrome 瀏覽器）的效能，開始開發 QUIC 協定，以解決 TCP 和 HTTP/2 的問題 [來源未提及]。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org20b5157" class="outline-5">
<h5 id="org20b5157">QUIC 的主要特色</h5>
<div class="outline-text-5" id="text-org20b5157">
</div>
<ul class="org-ul">
<li><a id="org51ee364"></a>基於 UDP： QUIC 使用 UDP 作為傳輸層協定，而不是 TCP。UDP 是一種無連線的協定，這讓 QUIC 可以更靈活地控制連線的建立和資料的傳輸<br />
<div class="outline-text-6" id="text-org51ee364">
<ul class="org-ul">
<li>彈性連線建立： QUIC 可以利用 UDP 的無連線特性，大幅減少連線建立的時間，只需要一到兩次往返時間（RTT），相比 TCP 的三次握手更快速 [來源未提及]。<br /></li>
<li>避免 Head-of-Line Blocking： QUIC 在應用層處理封包遺失和重傳，避免了 TCP 層的 Head-of-Line Blocking 問題 [來源未提及]。<br /></li>
</ul>
</div>
</li>
<li><a id="org32dc842"></a>多工處理 (Multiplexing)： QUIC 支援多工處理，可以在同一條連線中同時傳輸多個資料流，避免了 HTTP/1.1 中因為每個請求都需要建立一個新的 TCP 連線而產生的 overhead [來源未提及]。<br />
<div class="outline-text-6" id="text-org32dc842">
<ul class="org-ul">
<li>連線遷移 (Connection Migration)： QUIC 可以讓使用者在網路變更時（例如從 Wi-Fi 切換到行動數據），維持連線不中斷，這對於行動裝置來說非常重要 [來源未提及]。<br /></li>
<li>加密： QUIC 從設計之初就強制要求加密，這使得網路傳輸更加安全 [來源未提及]。<br /></li>
</ul>
</div>
</li>
<li><a id="org8df70a5"></a>QUIC 使用 TLS 1.3 來進行加密，這是一個強大的加密協定，可以保護數據不被竊聽或篡改 [來源未提及]。<br /></li>
<li><a id="org9383900"></a>流量控制和擁塞控制： QUIC 內建了流量控制和擁塞控制機制，可以有效管理網路流量，避免網路壅塞 [來源未提及]。<br /></li>
</ul>
</div>
<div id="outline-container-orgeee1a54" class="outline-5">
<h5 id="orgeee1a54">與 QUIC 相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-orgeee1a54">
<ul class="org-ul">
<li>網路協定: 理解 OSI 模型或 TCP/IP 模型中的各層協定，尤其是傳輸層的 TCP 和 UDP 的差異 [來源未提及]。<br /></li>
<li>TCP (Transmission Control Protocol): 一種面向連線的協定，提供可靠的數據傳輸，但有連線建立的 overhead 和可能出現 Head-of-Line Blocking [來源未提及]。<br /></li>
<li>UDP (User Datagram Protocol): 一種無連線的協定，提供更快的傳輸速度，但數據傳輸可靠性較低 [來源未提及]。<br /></li>
<li>HTTP/2: 了解 HTTP/2 如何透過多工處理改善 HTTP/1.1 的效能問題 [來源未提及]。<br /></li>
<li>TLS/SSL: 理解 TLS/SSL 如何提供加密和驗證，保護網路傳輸的安全 [來源未提及]。<br /></li>
<li>連線建立: 了解 TCP 的三次握手過程，以及 QUIC 如何減少連線建立的時間 [來源未提及]。<br /></li>
<li>網路壅塞控制: 了解網路壅塞控制的機制，以及 QUIC 如何避免網路壅塞 [來源未提及]。<br /></li>
<li>多工處理: 了解多工處理如何改善網路資源的利用率，以及 QUIC 如何在同一條連線中同時傳輸多個資料流 [來源未提及]。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4a688db" class="outline-5">
<h5 id="org4a688db">總結</h5>
<div class="outline-text-5" id="text-org4a688db">
<p>
QUIC 是一個現代化的網路傳輸協定，旨在解決傳統 TCP 協定的一些限制。它基於 UDP，提供更快的連線建立速度、更好的多工處理、連線遷移和強制加密等特性。理解 QUIC 的發展背景和主要特色，可以幫助考生在計算機概論中更好地理解現代網路協定的發展趨勢。 此外，理解 QUIC 背後的相關計算機概念，例如網路協定、加密、擁塞控制和多工處理，對於準備研究所考試也至關重要。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org6e8300e" class="outline-3">
<h3 id="org6e8300e"><span class="section-number-3">5.2.</span> 2. (20%)</h3>
<div class="outline-text-3" id="text-5-2">
<p>
在今日網路環境，無論對個人或企業，VPN (Virtual Private Network) 都是重要的網路安全工具。請先說明 VPN 的一般功能，然後比較 IPSec VPN, SSL VPN 以及 MPLS VPN 三者之間的區別。<br />
</p>
</div>
<div id="outline-container-org2d951a6" class="outline-4">
<h4 id="org2d951a6"><span class="section-number-4">5.2.1.</span> 解</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
VPN（虛擬私人網路）在當今網路環境中扮演著重要的角色，無論對於個人或企業，都是不可或缺的網路安全工具。以下將詳細說明 VPN 的一般功能，並比較 IPSec VPN、SSL VPN 以及 MPLS VPN 三者之間的區別，同時列出相關的計算機概論知識，以幫助考生更全面地理解這些概念。<br />
</p>
</div>
<div id="outline-container-org3207eb0" class="outline-5">
<h5 id="org3207eb0">VPN 的一般功能</h5>
<div class="outline-text-5" id="text-org3207eb0">
<ul class="org-ul">
<li>加密傳輸：VPN 的主要功能之一是加密使用者與網路之間的數據傳輸。這表示當您使用 VPN 時，所有進出您裝置的網路流量都會被加密，使其難以被第三方攔截或讀取 [來源未提及]。這對於在不安全的網路環境（如公共 Wi-Fi）中保護隱私非常重要 [來源未提及]。<br /></li>
<li>隱藏 IP 位址：VPN 會隱藏您的真實 IP 位址，並以 VPN 伺服器的 IP 位址取代。這樣可以提高匿名性，並保護您的網路活動不被追蹤 [來源未提及]。<br /></li>
<li>突破地理限制：VPN 可以讓使用者連線到位於不同地理位置的伺服器，藉此突破地理限制。這對於存取在特定地區被封鎖的內容非常有用 [來源未提及]。<br /></li>
<li>安全遠端存取：VPN 可以提供安全的遠端存取，讓企業員工可以在家或在外地安全地連線到公司網路 [來源未提及]。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7a6afe2" class="outline-5">
<h5 id="org7a6afe2">IPSec VPN、SSL VPN 以及 MPLS VPN 的比較</h5>
<div class="outline-text-5" id="text-org7a6afe2">
<p>
以下比較三種常見的 VPN 類型：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">特性</td>
<td class="org-left">IPSec VPN</td>
<td class="org-left">SSL VPN</td>
<td class="org-left">MPLS VPN</td>
</tr>

<tr>
<td class="org-left">主要用途</td>
<td class="org-left">主要用於建立站點對站點（site-to-site）的 VPN 連線，適用於企業內部網路互連，也可用於遠端存取 [來源未提及]。</td>
<td class="org-left">主要用於遠端存取，透過網頁瀏覽器或特定應用程式即可建立連線，適用於個人使用者或需要遠端存取公司網路的員工 [來源未提及]。</td>
<td class="org-left">主要用於企業級的網路連線，提供高可靠性和高服務品質的網路服務 [來源未提及]。</td>
</tr>

<tr>
<td class="org-left">加密方式</td>
<td class="org-left">使用 IP 安全協定（IPsec），提供網路層（Network Layer）的加密和驗證。安全性較高，但設定較為複雜 [來源未提及]。</td>
<td class="org-left">使用安全通訊協定（SSL/TLS），提供傳輸層（Transport Layer）的加密。設定較為簡單，且易於部署 [來源未提及]。</td>
<td class="org-left">MPLS VPN 本身不提供加密，而是依靠底層的 MPLS 技術來實現虛擬網路連線，安全性通常依賴於其他安全措施 [來源未提及]。</td>
</tr>

<tr>
<td class="org-left">部署複雜度</td>
<td class="org-left">設定較為複雜，需要在網路設備上進行配置 [來源未提及]。</td>
<td class="org-left">設定相對簡單，使用者只需透過網頁瀏覽器或應用程式即可連線 [來源未提及]。</td>
<td class="org-left">設定相對複雜，需要專業的網路設備和配置 [來源未提及]。</td>
</tr>

<tr>
<td class="org-left">效能</td>
<td class="org-left">效能較高，適用於需要大量數據傳輸的應用 [來源未提及]。</td>
<td class="org-left">效能較 IPSec VPN 稍低，但仍可滿足一般遠端存取的需求 [來源未提及]。</td>
<td class="org-left">效能較高，能提供高頻寬和低延遲的網路連線 [來源未提及]。</td>
</tr>

<tr>
<td class="org-left">適用情境</td>
<td class="org-left">企業內部網路互連、與合作夥伴建立安全連線、需要高安全性的遠端存取 [來源未提及]。</td>
<td class="org-left">個人遠端存取、員工在家工作、行動裝置遠端存取 [來源未提及]。</td>
<td class="org-left">企業級網路連線、需要高服務品質的網路應用、數據中心互連 [來源未提及]。</td>
</tr>

<tr>
<td class="org-left">主要優點</td>
<td class="org-left">高安全性、支援多種加密演算法、支援多種驗證方法 [來源未提及]。</td>
<td class="org-left">設定簡單、易於部署、適用於各種裝置 [來源未提及]。</td>
<td class="org-left">高服務品質、高可靠性、可擴展性高 [來源未提及]。</td>
</tr>

<tr>
<td class="org-left">主要缺點</td>
<td class="org-left">設定較為複雜、需要專業知識、可能會有相容性問題 [來源未提及]。</td>
<td class="org-left">效能較 IPSec VPN 稍低、加密安全性可能較弱 [來源未提及]。</td>
<td class="org-left">成本較高、部署較複雜、可能需要專業的網路服務提供商 [來源未提及]。</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org57e9b01" class="outline-5">
<h5 id="org57e9b01">與 VPN 相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-org57e9b01">
<ul class="org-ul">
<li>網路協定: 了解 OSI 模型或 TCP/IP 模型中的各層協定，尤其是網路層（Network Layer）和傳輸層（Transport Layer）的差異 [來源未提及]。<br />
<ul class="org-ul">
<li>IPsec: 一種網路層的安全協定，提供加密、驗證和數據完整性 [來源未提及]。<br /></li>
<li>SSL/TLS: 一種傳輸層的安全協定，提供加密和驗證，常用於保護網頁瀏覽和電子郵件等應用 [來源未提及]。<br /></li>
</ul></li>
<li>加密技術: 了解對稱加密和非對稱加密的原理，以及它們如何應用於 VPN 中 [來源未提及]。<br /></li>
<li>網路安全: 了解各種網路安全威脅，例如中間人攻擊、數據洩漏等，以及 VPN 如何幫助防禦這些威脅 [來源未提及]。<br /></li>
<li>虛擬化技術: 了解虛擬化技術如何應用於 VPN 中，例如虛擬網路介面 [來源未提及]。<br /></li>
<li>MPLS (Multiprotocol Label Switching): 了解 MPLS 如何透過標籤交換來提高網路數據傳輸效率和服務品質 [來源未提及]。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org8a0dcf9"></a>總結<br />
<div class="outline-text-6" id="text-org8a0dcf9">
<p>
VPN 是一種重要的網路安全工具，可以保護使用者的隱私和數據安全。IPSec VPN、SSL VPN 以及 MPLS VPN 適用於不同的應用場景，各有優缺點。了解 VPN 的基本功能、不同類型 VPN 的特性，以及相關的計算機概論知識，對於準備研究所考試非常重要。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbcd587c" class="outline-3">
<h3 id="orgbcd587c"><span class="section-number-3">5.3.</span> 3.(15%)</h3>
<div class="outline-text-3" id="text-5-3">
<p>
給定一作業系統，安裝於硬體的 TLB (Translation Look-aside Buffer) 大小為 1024。記憶體的搜尋時間為 200 ns(nanosecond) 的電腦上。假設系統的 TLB 命中率為 90%，且 TLB 搜尋時間為 20 ns(nanosecond)。若此系統採用的分頁表大小為 64，分頁表中存放的每個基底位置為 11 bits (包含 valid/invalid bit)，每個分頁大小為 512 B，請回答下列問題。<br />
</p>
<ul class="org-ul">
<li>甲、此系統的 TLB 範圍 (TLB Reach) 為多少？(5%)<br /></li>
<li>乙、此系統的實體位址空間大小為何？(5%)<br /></li>
<li>丙、若分頁表採取了三層式(three-level) 的實作方式，其記憶體有效存取時間(effective access time)為何？(5%)<br /></li>
</ul>
</div>
<div id="outline-container-org76ac34c" class="outline-4">
<h4 id="org76ac34c"><span class="section-number-4">5.3.1.</span> 解</h4>
<div class="outline-text-4" id="text-5-3-1">
</div>
<div id="outline-container-org32e810f" class="outline-5">
<h5 id="org32e810f">甲、此系統的 TLB 範圍 (TLB Reach) 為多少？</h5>
<div class="outline-text-5" id="text-org32e810f">
<ul class="org-ul">
<li>LB 的範圍是指 TLB 可以映射的虛擬記憶體空間大小。由於 TLB 儲存的是虛擬位址到實體位址的轉換資訊，其範圍取決於 TLB 的條目數量和每個條目所映射的分頁大小 [來源未提及]。<br /></li>
<li>TLB 大小為 1024 個條目<br /></li>
<li>每個分頁大小為 512 B<br /></li>
<li>因此，TLB 範圍 = TLB 大小 * 分頁大小 = 1024 * 512 B = 524288 B = 512 KB。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgce38616" class="outline-5">
<h5 id="orgce38616">乙、此系統的實體位址空間大小為何？</h5>
<div class="outline-text-5" id="text-orgce38616">
<p>
實體位址空間大小取決於實體位址的位元數。由於分頁表基底位置大小為 11 bits（包含 valid/invalid bit），這表示分頁表中每個條目至少需要 11 bits 來儲存實體框架的資訊。此外，由於每個分頁大小為 512 B，需要額外的位元數來表示分頁內的偏移量。每個分頁的偏移量需要 9 bits (2^9 = 512)，因此實體位址的總位元數會包含 11 bits 的實體框架基底位置，加上 9 bits 的分頁偏移量，等於 20 bits。<br />
</p>
<ul class="org-ul">
<li>分頁大小為 512 B = 2^9 B，表示分頁內的偏移量需要 9 bits<br /></li>
<li>分頁表基底位置為 11 bits<br /></li>
<li>請注意: 此處的 11 bits 是指分頁表的基底位置，而不是指實體框架號的位元數。<br /></li>
<li>由於題目沒有直接提供實體框架號的位元數，我們需要透過分頁表大小來推算。<br /></li>
<li>分頁表大小為 64 個條目 = 2^6 個條目，表示虛擬位址中的分頁號需要 6 bits。<br /></li>
<li>實體位址空間大小應等於 分頁大小 x 實體框架總數。<br /></li>
<li>若題目沒有提供實體框架總數，我們只能用分頁大小搭配實體位址的總位元數來計算。<br /></li>
<li>實體位址空間大小 = 2^20 B = 1MB<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org85bebce" class="outline-5">
<h5 id="org85bebce">丙、若分頁表採取了三層式(three-level) 的實作方式，其記憶體有效存取時間(effective access time)為何？</h5>
<div class="outline-text-5" id="text-org85bebce">
<p>
有效存取時間考慮了 TLB 命中和未命中的情況，以及分頁表查找的額外時間。<br />
</p>
<ul class="org-ul">
<li>TLB 命中時：存取時間為 TLB 搜尋時間 = 20 ns<br /></li>
<li>TLB 未命中時：需要訪問主記憶體查找分頁表。<br /></li>
<li>單層分頁表：需要 1 次記憶體存取來查找分頁表 [來源未提及]。<br /></li>
<li>三層分頁表：需要 3 次記憶體存取來查找分頁表 [來源未提及]。<br /></li>
</ul>
<p>
計算步驟如下：<br />
</p>
<ol class="org-ol">
<li>TLB 命中時間: 20 ns<br /></li>
<li>TLB 未命中時間 (單層分頁): 20 ns (TLB 搜尋) + 200 ns (記憶體存取) + 200 ns (數據存取) = 420 ns [來源未提及]<br /></li>
<li>TLB 未命中時間 (三層分頁): 20 ns (TLB 搜尋) + 3 * 200 ns (分頁表查找) + 200 ns (數據存取) = 820 ns<br /></li>
<li>有效存取時間: (TLB 命中率 * TLB 命中時間) + (TLB 未命中率 * TLB 未命中時間)。<br /></li>
<li>有效存取時間: (0.9 * 20 ns) + (0.1 * 820 ns) = 18 ns + 82 ns = 100 ns。<br /></li>
</ol>

<p>
因此，若分頁表採用三層式實作，記憶體有效存取時間為 100 ns。<br />
</p>
</div>
</div>
<div id="outline-container-orgfefb75f" class="outline-5">
<h5 id="orgfefb75f">與 TLB 和記憶體管理相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-orgfefb75f">
<ul class="org-ul">
<li>虛擬記憶體 (Virtual Memory): 一種記憶體管理技術，允許程式使用比實際物理記憶體更大的位址空間 [來源未提及]。<br /></li>
<li>分頁 (Paging): 將虛擬記憶體和實體記憶體分割成固定大小的區塊，稱為分頁和框架 [來源未提及]。<br /></li>
<li>分頁表 (Page Table): 儲存虛擬分頁到實體框架的映射關係 [來源未提及]。<br /></li>
<li>轉換後備緩衝區 (Translation Lookaside Buffer, TLB): 一種快取，用於儲存最近使用的虛擬位址到實體位址的轉換資訊，以加速記憶體存取 [來源未提及]。<br /></li>
<li>TLB 命中率 (TLB Hit Ratio): TLB 命中次數佔總記憶體存取次數的比例 [來源未提及]。<br /></li>
<li>有效存取時間 (Effective Access Time): 考慮 TLB 命中和未命中的平均記憶體存取時間 [來源未提及]。<br /></li>
<li>多層分頁表 (Multi-level Page Table): 一種分頁表結構，將分頁表分割成多層，以減少分頁表的大小 [來源未提及]。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc481d40" class="outline-5">
<h5 id="orgc481d40">總結</h5>
<div class="outline-text-5" id="text-orgc481d40">
<p>
這題主要考察了 TLB 的基本概念，包括 TLB 的範圍、實體位址空間大小，以及有效存取時間的計算。此外，多層分頁表的使用也需要特別注意。理解這些概念對於準備研究所考試至關重要。<br />
</p>
</div>
</div>
<div id="outline-container-orgb9ca525" class="outline-5">
<h5 id="orgb9ca525">注意事項</h5>
<div class="outline-text-5" id="text-orgb9ca525">
<ul class="org-ul">
<li>實體位址空間大小的計算方式可能有多種，具體取決於題目提供的資訊。<br /></li>
<li>有效存取時間的計算需要考慮 TLB 命中和未命中的情況，以及多層分頁表帶來的額外開銷。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb0a40d2" class="outline-3">
<h3 id="orgb0a40d2"><span class="section-number-3">5.4.</span> 4.(5%)</h3>
<div class="outline-text-3" id="text-5-4">
<p>
考慮一程式碼區段：<br />
</p>
<pre class="example" id="org8ad90d0">
pid_t pid;

pid = fork();
if (pid == 0) (  /*child process)*/
   fork();
   thread_create(...);
}
fork();
</pre>
<ul class="org-ul">
<li>甲、請問會產生多少個獨立的行程(process)？(2%)<br /></li>
<li>乙、請問會產生多少個獨立的執行緒(thread)？(3%)<br /></li>
</ul>
</div>
<div id="outline-container-orge0ba9ba" class="outline-4">
<h4 id="orge0ba9ba"><span class="section-number-4">5.4.1.</span> 解</h4>
<div class="outline-text-4" id="text-5-4-1">
</div>
<div id="outline-container-org665106b" class="outline-5">
<h5 id="org665106b">甲、請問會產生多少個獨立的行程(process)？</h5>
<div class="outline-text-5" id="text-org665106b">
<ul class="org-ul">
<li>初始狀態： 程式開始執行時，會有一個父行程 (parent process)。<br /></li>
<li>第一個 fork()：  pid = fork(); 會建立一個子行程 (child process)。此時，共有兩個行程，父行程和子行程。<br /></li>
<li>if (pid == 0) 區塊： 只有子行程會進入這個區塊，父行程的 pid 不會是 0<br />
<ul class="org-ul">
<li>在子行程內， fork(); 會再建立一個子行程 (child of child process)。此時，子行程會分裂為兩個行程。<br /></li>
<li>所以總共有三個行程，分別是父行程，由第一個 fork() 建立的子行程，以及由第二個 fork() 建立的孫行程。<br /></li>
</ul></li>
<li>最後一個 fork()： 所有行程 (父行程以及第一個 fork() 建立的子行程) 都會執行到最後一個 fork()，所以父行程會產生一個子行程，而原本的子行程也會產生一個新的子行程。<br /></li>
<li>總結：<br />
<ul class="org-ul">
<li>初始父行程：1 個<br /></li>
<li>第一個 fork() 產生的子行程：1 個<br /></li>
<li>子行程內第二個 fork() 產生的孫行程：1 個<br /></li>
<li>最後一個 fork() 父行程產生的子行程：1 個<br /></li>
<li>最後一個 fork() 原本的子行程產生的子行程：1 個<br /></li>
<li>因此，總共有 1 + 1 + 1 + 1 + 1 = 5 個行程。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgca2cdba" class="outline-5">
<h5 id="orgca2cdba">乙、請問會產生多少個獨立的執行緒(thread)？</h5>
<div class="outline-text-5" id="text-orgca2cdba">
<ul class="org-ul">
<li>初始狀態： 每個行程開始時，都有一個主執行緒 (main thread) [來源未提及]。<br /></li>
<li>thread_create(&#x2026;)： 只有子行程 (pid == 0) 會執行到這個函式。這個函式會在子行程內建立一個新的執行緒。<br /></li>
<li>總結：<br />
<ul class="org-ul">
<li>初始行程 (父行程) 包含一個執行緒。<br /></li>
<li>由第一個 fork() 建立的子行程，會產生一個新的執行緒。<br /></li>
<li>其他行程沒有建立新的執行緒。<br /></li>
<li>因此，總共有 1 (父行程) + 1 (子行程建立的執行緒) = 2 個執行緒。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org05f4003" class="outline-5">
<h5 id="org05f4003">與行程和執行緒相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-org05f4003">
<ul class="org-ul">
<li>行程 (Process): 程式執行時的實體，擁有獨立的記憶體空間和系統資源 [來源未提及]。行程是系統進行資源分配和排程的基本單位 [來源未提及]。<br /></li>
<li>執行緒 (Thread): 行程內的執行單元，同一個行程內的執行緒會共享記憶體空間和資源 [來源未提及]。執行緒是 CPU 排程的基本單位 [來源未提及]。<br /></li>
<li>fork() 系統呼叫： 用於建立一個新的子行程，子行程會複製父行程的記憶體空間和資源 [來源未提及]。子行程的 pid 會是0，父行程的 pid 會是子行程的process id<br /></li>
<li>thread_create() 函式： 用於在行程內建立一個新的執行緒<br /></li>
<li>行程間通訊 (Inter-Process Communication, IPC): 行程之間進行資料交換和同步的機制 [來源未提及]。<br /></li>
<li>執行緒同步 (Thread Synchronization): 確保多個執行緒正確存取共享資源的機制，避免資料競爭等問題 [來源未提及]。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org07e75c7" class="outline-5">
<h5 id="org07e75c7">總結</h5>
<div class="outline-text-5" id="text-org07e75c7">
<p>
這題主要考察了 fork() 和 thread_create() 的使用，以及行程和執行緒的基本概念。理解這兩個概念的區別以及它們的創建方式對於準備研究所考試至關重要。<br />
</p>

<p>
注意事項<br />
</p>
<ul class="org-ul">
<li>fork() 會複製整個行程的記憶體空間，而 thread_create() 建立的執行緒會共享行程的記憶體空間。<br /></li>
<li>在實際應用中，行程和執行緒的選擇取決於程式的需求。行程適用於需要隔離資源的情況，而執行緒適用於需要高效共享資源的情況。<br /></li>
<li>本題中，最後一個 fork() 位於 if 條件判斷外，因此所有行程都會執行到。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org9337b24" class="outline-3">
<h3 id="org9337b24"><span class="section-number-3">5.5.</span> 5.(5%)</h3>
<div class="outline-text-3" id="text-5-5">
<p>
資料庫正規化中的 1NF, 2NF 與 3NF 是以哪一些重要觀念發展出來的？(5%)<br />
</p>
</div>
<div id="outline-container-org018a885" class="outline-4">
<h4 id="org018a885"><span class="section-number-4">5.5.1.</span> 解</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
資料庫正規化（Normalization）是一種組織關聯式資料庫的方法，主要目的是減少資料冗餘（redundancy）與消除異常（anomalies），確保資料的一致性與完整性。正規化透過規則與制約條件，將資料拆解並整理，使其符合不同的正規形式（Normal Forms, NFs）。<br />
</p>

<p>
1NF（第一正規形式）、2NF（第二正規形式）與 3NF（第三正規形式）是正規化過程中的三個主要階段，它們是基於以下三大核心概念發展出來的：<br />
</p>
</div>
<div id="outline-container-org8c7aa60" class="outline-5">
<h5 id="org8c7aa60">1. 函數相依性（Functional Dependency, FD）</h5>
<div class="outline-text-5" id="text-org8c7aa60">
<ul class="org-ul">
<li>概念：在關聯式資料庫中，如果屬性 X 能唯一決定屬性 Y，則稱 Y 函數相依 X，記為 X → Y。<br /></li>
<li><p>
舉例：學生的學號（Student_ID）可以唯一決定學生姓名（Name）和科系（Department）。<br />
</p>
<pre class="example" id="org48041ea">
  Student_ID→Name,Department
  Student_ID→Name,Department
</pre></li>
</ul>
<p>
影響：函數相依性是 2NF、3NF 正規化的基礎。<br />
</p>
</div>
</div>
<div id="outline-container-orge308fba" class="outline-5">
<h5 id="orge308fba">2. 候選鍵與主鍵（Candidate Key &amp; Primary Key）</h5>
<div class="outline-text-5" id="text-orge308fba">
<ul class="org-ul">
<li>候選鍵（Candidate Key）：能唯一識別資料列的最小屬性集合。<br /></li>
<li>主鍵（Primary Key）：從候選鍵中選出的一個作為主鍵，用來唯一識別一筆記錄。<br /></li>
<li>影響：2NF 的定義要求所有非主鍵屬性必須完全依賴於主鍵。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc1cc4e9" class="outline-5">
<h5 id="orgc1cc4e9">3. 移除異常（Anomalies）</h5>
<div class="outline-text-5" id="text-orgc1cc4e9">
<ul class="org-ul">
<li>插入異常（Insertion Anomaly）：因為某些屬性不能為空，導致無法插入某些記錄。<br /></li>
<li>刪除異常（Deletion Anomaly）：刪除某筆記錄時，可能會遺失其他重要資訊。<br /></li>
<li>更新異常（Update Anomaly）：同一筆資訊可能存在多個地方，更新時容易導致不一致。<br /></li>
</ul>
<p>
這三個概念推導出不同的正規化形式，幫助資料庫設計者解決資料冗餘與異常問題。<br />
</p>
</div>
</div>
<div id="outline-container-org1554ad2" class="outline-5">
<h5 id="org1554ad2">1NF、2NF、3NF 詳解</h5>
<div class="outline-text-5" id="text-org1554ad2">
</div>
<ul class="org-ul">
<li><a id="org6e18e8f"></a>第一正規形式（1NF, First Normal Form）<br />
<div class="outline-text-6" id="text-org6e18e8f">
<ul class="org-ul">
<li>條件：<br />
<ul class="org-ul">
<li>每個欄位（屬性）只能儲存單一值（原子性，Atomicity）。<br /></li>
<li>每列（Tuple）必須有唯一識別的主鍵（Primary Key）。<br /></li>
</ul></li>
<li><p>
違反 1NF 的例子：<br />
</p>
<pre class="example" id="org0b2c5bd">
  學號 | 姓名 | 電話號碼
  ---- | ---- | -----------------
  001  | 小明 | 0912-345678, 02-23456789
  002  | 小華 | 0933-987654
</pre>
<p>
電話號碼欄位存放了多個值，違反 1NF。<br />
</p></li>
<li><p>
正規化後（符合 1NF）：<br />
</p>
<pre class="example" id="org16a4916">
  學號 | 姓名 | 電話號碼
  ---- | ---- | ------------
  001  | 小明 | 0912-345678
  001  | 小明 | 02-23456789
  002  | 小華 | 0933-987654
</pre></li>
</ul>
<p>
拆解重複資料，讓每個欄位都只儲存單一值。<br />
</p>
</div>
</li>
<li><a id="org25fa687"></a>第二正規形式（2NF, Second Normal Form）<br />
<div class="outline-text-6" id="text-org25fa687">
<ul class="org-ul">
<li>條件：<br />
<ul class="org-ul">
<li>符合 1NF。<br /></li>
<li>每個非主鍵屬性必須完全依賴於整個主鍵（不能有部分相依性）。<br /></li>
</ul></li>
<li><p>
違反 2NF 的例子：<br />
</p>
<pre class="example" id="orgdf86f24">
  (學號, 課程) | 學生姓名 | 課程名稱 | 學分
  ------------ | ------ | ------ | ----
  (001, CS101) | 小明  | 資料結構 | 3
  (001, CS102) | 小明  | 演算法  | 3
  (002, CS101) | 小華  | 資料結構 | 3
</pre>
<ul class="org-ul">
<li>學生姓名只依賴學號，課程名稱和學分只依賴課程，但主鍵是 (學號, 課程)，因此有部分相依性。<br /></li>
</ul></li>
<li><p>
正規化後（符合 2NF）：<br />
</p>
<pre class="example" id="orgd0a273c">
    學生表：
    學號 | 學生姓名
    ---- | ------
    001  | 小明
    002  | 小華

    課程表：
    課程 | 課程名稱 | 學分
    ---- | ------ | ----
    CS101 | 資料結構 | 3
    CS102 | 演算法  | 3

    選課表：
    學號 | 課程
    ---- | ----
    001  | CS101
    001  | CS102
    002  | CS101
</pre>
<ul class="org-ul">
<li>拆分成三個表，確保每個屬性完全依賴於主鍵。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org701ab2f"></a>第三正規形式（3NF, Third Normal Form）<br />
<div class="outline-text-6" id="text-org701ab2f">
<ul class="org-ul">
<li>條件：<br />
<ul class="org-ul">
<li>符合 2NF。<br /></li>
<li>非主鍵屬性不能依賴於其他非主鍵屬性（避免遞移相依性）。<br /></li>
</ul></li>
<li><p>
違反 3NF 的例子：<br />
</p>
<pre class="example" id="org4bdff12">
  學號 | 學生姓名 | 科系 | 系主任
  ---- | ------ | ---- | ----
  001  | 小明  | 資工系 | 王教授
  002  | 小華  | 資工系 | 王教授
</pre>
<ul class="org-ul">
<li>系主任依賴於科系，而科系又依賴學號，因此有遞移相依性 (學號 → 科系 → 系主任)。<br /></li>
</ul></li>
<li><p>
正規化後（符合 3NF）：<br />
</p>
<pre class="example" id="org12e68e3">
    學生表：
    學號 | 學生姓名 | 科系
    ---- | ------ | ----
    001  | 小明  | 資工系
    002  | 小華  | 資工系

    科系表：
    科系 | 系主任
    ---- | ----
    資工系 | 王教授
</pre>
<ul class="org-ul">
<li>拆分成兩個表，確保非主鍵屬性只依賴於主鍵。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgcd311e3"></a>與正規化相關的計算機概論知識<br />
<div class="outline-text-6" id="text-orgcd311e3">
<ol class="org-ol">
<li>資料庫設計概念<br />
<ul class="org-ul">
<li>ER 模型（Entity-Relationship Model）<br /></li>
<li>關聯式資料庫（Relational Database, RDB）<br /></li>
<li>主鍵（Primary Key）、外鍵（Foreign Key）<br /></li>
<li>SQL 查詢語言（SELECT, INSERT, UPDATE, DELETE）<br /></li>
</ul></li>
<li>資料一致性與完整性<br />
<ul class="org-ul">
<li>資料完整性（Data Integrity）<br /></li>
<li>參考完整性（Referential Integrity）<br /></li>
<li>ACID 屬性（Atomicity, Consistency, Isolation, Durability）<br /></li>
</ul></li>
<li>進階正規化<br />
<ul class="org-ul">
<li>BCNF（Boyce-Codd Normal Form）<br /></li>
<li>4NF（第四正規形式）<br /></li>
<li>5NF（第五正規形式）<br /></li>
</ul></li>
</ol>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge726576" class="outline-3">
<h3 id="orge726576"><span class="section-number-3">5.6.</span> 6. (5%)</h3>
<div class="outline-text-3" id="text-5-6">
<p>
給定一段 C 語言程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>=<span style="color: #da8548; font-weight: bold;">11</span>, <span style="color: #dcaeea;">b</span>=<span style="color: #da8548; font-weight: bold;">21</span>;
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> *<span style="color: #dcaeea;">p</span>;
<span class="linenr">3: </span>p = &amp; a;
<span class="linenr">4: </span>b = *p;
<span class="linenr">5: </span>*p = <span style="color: #da8548; font-weight: bold;">0</span>;
</pre>
</div>
<p>
已知變數 a 的記憶體位置為 0X0012FF74；變數 b 的記憶體位置為 0X0012FF78。請問，執行完程式後，a 和 b 的值各為多少？(5%)<br />
</p>
</div>
<div id="outline-container-org375e120" class="outline-4">
<h4 id="org375e120"><span class="section-number-4">5.6.1.</span> 解</h4>
<div class="outline-text-4" id="text-5-6-1">
<p>
題目提供一段 C 語言程式碼，其中使用了指標 (pointer)。程式碼的目標是修改變數 a 和 b 的值，並且給定了 a 和 b 的記憶體位置。你需要追蹤程式碼的執行流程，並計算出最終 a 和 b 的值。<br />
程式碼如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">11</span>, <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">21</span>;
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> *<span style="color: #dcaeea;">p</span>;
<span class="linenr">3: </span>p = &amp;a;
<span class="linenr">4: </span>b = *p;
<span class="linenr">5: </span>*p = <span style="color: #da8548; font-weight: bold;">0</span>;
</pre>
</div>

<p>
已知：<br />
</p>
<ul class="org-ul">
<li>變數 a 的記憶體位置：0X0012FF74<br /></li>
<li>變數 b 的記憶體位置：0X0012FF78<br /></li>
</ul>
</div>
<div id="outline-container-org8699087" class="outline-5">
<h5 id="org8699087">程式碼執行步驟分析：</h5>
<div class="outline-text-5" id="text-org8699087">
<ol class="org-ol">
<li>初始化：<br />
<ul class="org-ul">
<li>int a = 11, b = 21;：宣告整數變數 a 並賦值為 11，宣告整數變數 b 並賦值為 21。<br /></li>
</ul></li>
<li>宣告指標：<br />
<ul class="org-ul">
<li>int *p;：宣告一個整數指標 p，此時 p 的值是未定義的。<br /></li>
</ul></li>
<li>指標指向 a：<br />
<ul class="org-ul">
<li>p = &amp;a;：將指標 p 指向變數 a 的記憶體位置 (0X0012FF74)。現在 p 儲存的是 a 的記憶體位址。<br /></li>
</ul></li>
<li>b 的值被賦值為 a 的值：<br />
<ul class="org-ul">
<li>b = *p;：將指標 p 所指向的記憶體位置（也就是 a 的值）賦值給 b。因此，b 的值變為 11。<br /></li>
</ul></li>
<li>透過指標修改 a 的值：<br />
<ul class="org-ul">
<li>p = 0;：將指標 p 所指向的記憶體位置的值修改為 0。因為 p 指向 a 的記憶體位置，所以 a 的值變為 0。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org58a54f8" class="outline-5">
<h5 id="org58a54f8">總結：</h5>
<div class="outline-text-5" id="text-org58a54f8">
<ul class="org-ul">
<li>執行完程式後，變數 a 的值為 0。<br /></li>
<li>執行完程式後，變數 b 的值為 11。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd8a5d2d" class="outline-5">
<h5 id="orgd8a5d2d">與指標相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-orgd8a5d2d">
<ul class="org-ul">
<li>指標 (Pointer): 儲存記憶體位址的變數 [來源未提及]。<br /></li>
<li>指標宣告：  使用 * 符號宣告指標變數。例如：int *p; 表示 p 是一個指向整數的指標 [來源未提及]。<br /></li>
<li>取址運算符 (&amp;):  用於取得變數的記憶體位址。例如：&amp;a 表示取得變數 a 的記憶體位址 [來源未提及]。<br /></li>
<li>間接取值運算符 (*): 用於取得指標所指向的記憶體位置的值。例如：*p 表示取得指標 p 所指向的記憶體位置的值 [來源未提及]。<br /></li>
<li>記憶體位址 (Memory Address): 記憶體中每個儲存單元都有一個唯一的位址，用於存取該單元 [來源未提及]。<br /></li>
<li>傳址呼叫 (Call by Address / Call by Reference): 使用指標作為函數參數，可以直接修改函數外部變數的值 [來源未提及]。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4cb7693" class="outline-5">
<h5 id="org4cb7693">重點觀念</h5>
<div class="outline-text-5" id="text-org4cb7693">
<ul class="org-ul">
<li>指標變數儲存的是記憶體位址，而不是值。<br /></li>
<li>使用指標時，需要注意指標的類型，確保指標指向的記憶體位置儲存的資料類型與指標類型一致。<br /></li>
<li>透過指標，可以直接修改指標指向的記憶體位置的值。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org489126b" class="outline-5">
<h5 id="org489126b">注意事項</h5>
<div class="outline-text-5" id="text-org489126b">
<ul class="org-ul">
<li>指標是 C 語言中一個強大的工具，但也容易產生錯誤，例如：<br />
<ul class="org-ul">
<li>野指標 (Dangling Pointer): 指標指向的記憶體位置已經被釋放，但指標仍然指向該位置。<br /></li>
<li>空指標 (Null Pointer): 指標的值為 NULL，表示指標沒有指向任何有效的記憶體位置。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfeaf8f5" class="outline-3">
<h3 id="orgfeaf8f5"><span class="section-number-3">5.7.</span> 7.(15%)</h3>
<div class="outline-text-3" id="text-5-7">
<p>
X(A,B,C,D) is a relational table where X is the table name. A, B, C, and D are the attributes each with 8 bytes long. A is the primary key and the only candidate key. In addition, there exists the following functional dependency:<br />
</p>
<pre class="example" id="org66dff4a">
A -&gt; B, C, D
B -&gt; D
</pre>
<ul class="org-ul">
<li>甲、(5%) Which normal form(s) does Table X satisfy (1st NF, 2nd NF, 3rd NF, or others)? Why?<br /></li>
<li>乙、(5%) Does further normalization needed for Table X to avoid anomaly? How and what normal form can we get?<br /></li>
<li>丙、(5%) If there are 10000 rows in Table X, how much storage space can your answer in (b) save in maximum in the extreme case? Why? Please illustrate your answer for the extreme case.<br /></li>
</ul>
</div>
<div id="outline-container-org32250f2" class="outline-4">
<h4 id="org32250f2"><span class="section-number-4">5.7.1.</span> 解</h4>
<div class="outline-text-4" id="text-5-7-1">
<p>
考題涉及資料庫正規化 (Normalization)，我們需要分析 X(A,B,C,D) 這張表格是否滿足 1NF、2NF、3NF，並探討是否需要進一步正規化來避免異常，最後計算最佳情況下的儲存節省量。<br />
</p>
</div>
<div id="outline-container-orgf3751e4" class="outline-5">
<h5 id="orgf3751e4">(甲) 表格 X 滿足哪些正規化形式？</h5>
<div class="outline-text-5" id="text-orgf3751e4">
</div>
<ul class="org-ul">
<li><a id="org9e84825"></a>1. 第一正規化 (1NF)<br />
<div class="outline-text-6" id="text-org9e84825">
<p>
定義： 所有欄位的值必須是原子值（Atomic values），即不能有重複的數據列，也不能包含集合值或嵌套結構。<br />
</p>
<ul class="org-ul">
<li>X(A, B, C, D) 每個屬性都是單一值（原子性）。<br /></li>
<li>結論：X 滿足 1NF。<br /></li>
</ul>
</div>
</li>
<li><a id="org8f61c44"></a>2. 第二正規化 (2NF)<br />
<div class="outline-text-6" id="text-org8f61c44">
<p>
定義： 1NF，且所有非主鍵屬性完全依賴於主鍵，不能有部分函數相依 (Partial Dependency)。<br />
</p>
<ul class="org-ul">
<li>A 是唯一的候選鍵（Candidate Key），也是主鍵（Primary Key）。<br /></li>
<li>A → B, C, D，所有非主鍵屬性 (B, C, D) 都完全依賴於 A，因此 沒有部分函數相依。<br /></li>
<li>結論：X 滿足 2NF。<br /></li>
</ul>
</div>
</li>
<li><a id="org9e3d878"></a>3. 第三正規化 (3NF)<br />
<div class="outline-text-6" id="text-org9e3d878">
<p>
定義： 2NF，且沒有遞移相依 (Transitive Dependency)，即非主鍵屬性不能透過其他非主鍵屬性來決定其他屬性。<br />
</p>
<ul class="org-ul">
<li>A → B, C, D（A 能唯一決定 B、C、D）<br /></li>
<li>B → D（B 可以決定 D）<br />
<ul class="org-ul">
<li>這代表 D 透過 B 受到影響，導致遞移相依 (Transitive Dependency)：<br />
<ul class="org-ul">
<li>A → B，且 B → D，推得 A → D 是透過 B 而來的。<br /></li>
<li>這違反 3NF。<br /></li>
</ul></li>
</ul></li>
<li>結論：X 只滿足 2NF，但不滿足 3NF。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgde64840" class="outline-5">
<h5 id="orgde64840">(乙) 是否需要進一步正規化？如何處理？</h5>
<div class="outline-text-5" id="text-orgde64840">
</div>
<ul class="org-ul">
<li><a id="org7d86e5b"></a>1. 需要正規化嗎？<br />
<div class="outline-text-6" id="text-org7d86e5b">
<p>
由於 B → D 形成遞移相依 (Transitive Dependency)，這會產生插入異常、刪除異常、更新異常：<br />
</p>
<ul class="org-ul">
<li>插入異常：若要新增 B 的值，卻無法填入 A，會導致無法新增。<br /></li>
<li>刪除異常：若刪除某筆 A 的資料，可能會導致 B → D 的資訊遺失。<br /></li>
<li>更新異常：如果 B 的值對應的 D 發生變化，需要修改多筆 A 的資料。<br /></li>
</ul>
</div>
</li>
<li><a id="orgef9f9eb"></a>2. 如何正規化？<br />
<div class="outline-text-6" id="text-orgef9f9eb">
<p>
將 B → D 拆出成另一張表 Y(B, D)，使 X(A, B, C, D) 拆分成：<br />
</p>
<ul class="org-ul">
<li>X&rsquo;(A, B, C) （保留主要關聯）<br /></li>
<li>Y(B, D) （移除遞移相依）<br /></li>
</ul>
<p>
這樣：<br />
</p>
<ul class="org-ul">
<li>A 仍然是 X&rsquo;(A, B, C) 的主鍵。<br /></li>
<li>B 變成 Y(B, D) 的主鍵。<br /></li>
<li>現在 X&rsquo; 和 Y 都滿足 3NF，因為沒有遞移相依！<br /></li>
</ul>
</div>
</li>
<li><a id="orge517266"></a>3. 最終結果<br />
<div class="outline-text-6" id="text-orge517266">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Table</th>
<th scope="col" class="org-left">Attributes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">X&rsquo;(A, B, C)</td>
<td class="org-left">A (PK), B, C</td>
</tr>

<tr>
<td class="org-left">Y(B, D)</td>
<td class="org-left">B (PK), D</td>
</tr>
</tbody>
</table>
<p>
結論：透過分解，表格 X 滿足 3NF，避免異常。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgd4bf995" class="outline-5">
<h5 id="orgd4bf995">(丙) 最大可能的儲存節省量</h5>
<div class="outline-text-5" id="text-orgd4bf995">
</div>
<ul class="org-ul">
<li><a id="org0501b0e"></a>1. 原始表格的大小<br />
<div class="outline-text-6" id="text-org0501b0e">
<ul class="org-ul">
<li>每個屬性 (A, B, C, D) 各 8 bytes。<br /></li>
<li>每筆資料共 8 × 4 = 32 bytes。<br /></li>
<li>共 10,000 筆資料：<br />
<ul class="org-ul">
<li>總大小 = 10,000 × 32 = 320,000 bytes (320 KB)。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0795b90"></a>2. 正規化後的儲存計算<br />
<div class="outline-text-6" id="text-org0795b90">
<p>
拆分成：<br />
</p>
<ul class="org-ul">
<li>X&rsquo;(A, B, C)：<br />
<ul class="org-ul">
<li>A (8B) + B (8B) + C (8B) = 24B<br /></li>
<li>10,000 筆資料 → 10,000 × 24 = 240,000 bytes (240 KB)<br /></li>
</ul></li>
<li>Y(B, D)：<br />
<ul class="org-ul">
<li>B (8B) + D (8B) = 16B<br /></li>
<li>B 的值可能重複，因此最壞情況下 B 只有 500 種不同值：<br />
<ul class="org-ul">
<li>500 × 16 = 8,000 bytes (8 KB)<br /></li>
</ul></li>
</ul></li>
</ul>
<p>
正規化後的總大小： 240 KB (X&rsquo;) + 8 KB (Y) = 248 KB<br />
</p>
</div>
</li>
<li><a id="org62ef8ac"></a>3. 儲存節省量<br />
<div class="outline-text-6" id="text-org62ef8ac">
<ul class="org-ul">
<li>節省空間 = 原始 320 KB - 正規化後 248 KB = 72 KB<br /></li>
<li>節省比例 = 72 KB / 320 KB ≈ 22.5%<br /></li>
</ul>
</div>
</li>
<li><a id="orge3ef4f8"></a>4. 為何能節省空間？<br />
<div class="outline-text-6" id="text-orge3ef4f8">
<ul class="org-ul">
<li>在原始 X(A, B, C, D) 中，每個 B 會重複存 10,000 次。<br /></li>
<li>拆分後，B, D 只需存 500 次，避免了重複儲存 D 的空間。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9c68fec" class="outline-5">
<h5 id="org9c68fec">總結</h5>
<div class="outline-text-5" id="text-org9c68fec">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">問題</th>
<th scope="col" class="org-left">解答</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(甲) 哪些正規化？</td>
<td class="org-left">滿足 1NF、2NF，但不滿足 3NF（因為 B → D）。</td>
</tr>

<tr>
<td class="org-left">(乙) 需要正規化嗎？</td>
<td class="org-left">需要，因為 B → D 形成遞移相依，影響插入、刪除、更新異常。</td>
</tr>

<tr>
<td class="org-left">如何正規化？</td>
<td class="org-left">將 B → D 拆出成 Y(B, D)，使 X&rsquo;(A, B, C) 符合 3NF。</td>
</tr>

<tr>
<td class="org-left">(丙) 最大節省？</td>
<td class="org-left">約 72 KB，因為 B, D 只需存 500 次，而不是 10,000 次。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgbd65695" class="outline-5">
<h5 id="orgbd65695">延伸學習：與該主題相關的計算機概論</h5>
<div class="outline-text-5" id="text-orgbd65695">
<ol class="org-ol">
<li>正規化 (Normalization)<br />
<ul class="org-ul">
<li>第一正規化 (1NF)：確保所有欄位值為原子值。<br /></li>
<li>第二正規化 (2NF)：消除部分函數相依。<br /></li>
<li>第三正規化 (3NF)：消除遞移相依，非主鍵屬性不能透過其他非主鍵屬性決定另一個非主鍵屬性。<br /></li>
<li>BCNF（Boyce-Codd Normal Form）：主鍵候選鍵的所有決定因素都必須是超鍵。<br /></li>
</ul></li>
<li>異常類型<br />
<ul class="org-ul">
<li>插入異常 (Insertion Anomaly)：因為要插入一部分資料時，無法提供主鍵，導致無法插入。<br /></li>
<li>刪除異常 (Deletion Anomaly)：刪除某筆資料時，可能連帶刪除有用的資訊。<br /></li>
<li>更新異常 (Update Anomaly)：重複存儲的資料需要同步更新，容易發生不一致問題。<br /></li>
</ul></li>
<li><p>
SQL 與資料庫設計<br />
</p>
<ul class="org-ul">
<li>如何使用 CREATE TABLE 設計符合 3NF 的表格：<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span>   CREATE <span style="color: #ECBE7B;">TABLE</span> <span style="color: #c678dd;">X_prime</span> (
<span class="linenr"> 2: </span>       A INT <span style="color: #ECBE7B;">PRIMARY</span> <span style="color: #dcaeea;">KEY</span>,
<span class="linenr"> 3: </span>       B <span style="color: #ECBE7B;">INT</span> <span style="color: #dcaeea;">NOT</span> <span style="color: #a9a1e1;">NULL</span>,
<span class="linenr"> 4: </span>       C <span style="color: #ECBE7B;">INT</span> <span style="color: #dcaeea;">NOT</span> <span style="color: #a9a1e1;">NULL</span>
<span class="linenr"> 5: </span>   );
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>   CREATE <span style="color: #ECBE7B;">TABLE</span> <span style="color: #c678dd;">Y</span> (
<span class="linenr"> 8: </span>       B <span style="color: #ECBE7B;">INT</span> <span style="color: #ECBE7B;">PRIMARY</span> <span style="color: #dcaeea;">KEY</span>,
<span class="linenr"> 9: </span>       D <span style="color: #ECBE7B;">INT</span> <span style="color: #dcaeea;">NOT</span> <span style="color: #a9a1e1;">NULL</span>
<span class="linenr">10: </span>   );
</pre>
</div>
<p>
索引 (Indexing) 與查詢效能：拆表後，查詢可能需要 JOIN，但可透過索引提升效能。<br />
</p></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org1fe21e1" class="outline-3">
<h3 id="org1fe21e1"><span class="section-number-3">5.8.</span> 8.(10%)</h3>
<div class="outline-text-3" id="text-5-8">
<p>
Locking is used for concurrency control in the transaction processing for database systems. Shared lock and exclusive locks are two kinds of locking.<br />
</p>
<ul class="org-ul">
<li>甲、(5%) What are the difference when applying either shared lock or exclusive lock to a data item?<br /></li>
<li>乙、(5%) The size of the locked data item can be small, such as a tuple or a record in a table; or big, such as a table or a database. Please provide the pros and cons for applying locking to small and/or large sized data item.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org25bb88f" class="outline-3">
<h3 id="org25bb88f"><span class="section-number-3">5.9.</span> 解</h3>
<div class="outline-text-3" id="text-5-9">
<p>
本題涉及並行控制 (Concurrency Control)，鎖定 (Locking) 是解決資料庫系統內交易併發衝突的重要技術。這裡將詳細解釋共享鎖 (Shared Lock, S-Lock) 與 排他鎖 (Exclusive Lock, X-Lock) 的區別，以及不同大小的鎖定範圍對系統的影響。<br />
</p>
</div>
<div id="outline-container-org8a8ecce" class="outline-4">
<h4 id="org8a8ecce"><span class="section-number-4">5.9.1.</span> (甲) 共享鎖 (Shared Lock, S-Lock) 與 排他鎖 (Exclusive Lock, X-Lock) 的區別</h4>
<div class="outline-text-4" id="text-5-9-1">
</div>
<div id="outline-container-orgfd28233" class="outline-5">
<h5 id="orgfd28233">1. 共享鎖 (S-Lock)</h5>
<div class="outline-text-5" id="text-orgfd28233">
<p>
定義： 允許多個交易同時讀取 (READ) 相同的資料項目，但不允許寫入 (WRITE)。<br />
</p>

<p>
特性：<br />
</p>
<ul class="org-ul">
<li>如果一個資料項 X 被某個交易 T1 加上共享鎖，則其他交易 T2, T3, &#x2026; 仍然可以讀取 X，但不能修改 X。<br /></li>
<li>適用於只讀操作 (SELECT)。<br /></li>
</ul>

<p>
應用場景：<br />
</p>
<ul class="org-ul">
<li><p>
查詢 (SELECT) 但不進行修改時，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  SELECT * FROM Customers WHERE id = <span style="color: #da8548; font-weight: bold;">10</span>;
</pre>
</div></li>
<li>讀取數據而不影響其他交易的場景，例如報表生成。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd658198" class="outline-5">
<h5 id="orgd658198">2. 排他鎖 (X-Lock)</h5>
<div class="outline-text-5" id="text-orgd658198">
<p>
定義： 允許單一交易對資料項目進行讀取 (READ) 與寫入 (WRITE)，但其他交易不能同時讀取或寫入。<br />
</p>

<p>
特性：<br />
</p>
<ul class="org-ul">
<li>只能有一個交易持有排他鎖，其他交易無法存取該資料項目。<br /></li>
<li>適用於寫入操作 (UPDATE, INSERT, DELETE)。<br /></li>
</ul>

<p>
應用場景：<br />
</p>
<ul class="org-ul">
<li><p>
修改 (UPDATE)、新增 (INSERT)、刪除 (DELETE) 操作，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  UPDATE Customers <span style="color: #ECBE7B;">SET</span> <span style="color: #dcaeea;">balance</span> = balance - <span style="color: #da8548; font-weight: bold;">100</span> WHERE id = <span style="color: #da8548; font-weight: bold;">10</span>;
</pre>
</div></li>
<li>保證交易對數據一致性要求較高的情況，例如銀行交易。<br /></li>

<li>S-Lock 與 X-Lock 比較<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">共享鎖 (S-Lock)</th>
<th scope="col" class="org-left">排他鎖 (X-Lock)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">允許的操作</td>
<td class="org-left">READ (讀取)</td>
<td class="org-left">READ + WRITE (讀取 + 修改)</td>
</tr>

<tr>
<td class="org-left">同時允許的鎖</td>
<td class="org-left">允許多個 S-Lock</td>
<td class="org-left">只能有一個 X-Lock</td>
</tr>

<tr>
<td class="org-left">允許其他交易讀取</td>
<td class="org-left">✅ 可以</td>
<td class="org-left">❌ 不能</td>
</tr>

<tr>
<td class="org-left">允許其他交易修改</td>
<td class="org-left">❌ 不能</td>
<td class="org-left">❌ 不能</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">查詢 (SELECT)</td>
<td class="org-left">更新 (UPDATE, INSERT, DELETE)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orge810f09" class="outline-4">
<h4 id="orge810f09"><span class="section-number-4">5.9.2.</span> (乙) 鎖定範圍大小的影響</h4>
<div class="outline-text-4" id="text-5-9-2">
<p>
資料庫鎖定可以應用於不同大小的資料範圍，例如：<br />
</p>
<ul class="org-ul">
<li>細粒度 (Small-granularity) 鎖定：記錄 (Tuple)、欄位 (Field)<br /></li>
<li>粗粒度 (Large-granularity) 鎖定：表 (Table)、資料庫 (Database)<br /></li>
</ul>
</div>
<div id="outline-container-orgaca869d" class="outline-5">
<h5 id="orgaca869d">1. 細粒度鎖定 (Tuple / Record / Row-Level Locking)</h5>
<div class="outline-text-5" id="text-orgaca869d">
<p>
定義：對單筆資料（例如一個 row）加鎖。<br />
</p>

<p>
優點：<br />
</p>
<ul class="org-ul">
<li>高並行度：允許不同交易鎖定不同的記錄，提高交易執行效率。<br /></li>
<li>減少鎖競爭：影響範圍小，不影響整個表的操作。<br /></li>
</ul>

<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>鎖管理開銷大：每筆記錄都要管理鎖，增加系統負擔。<br /></li>
<li>可能發生死鎖 (Deadlock)：如果兩個交易彼此鎖住不同的記錄，可能會互相等待。<br /></li>
</ul>

<p>
應用場景：<br />
</p>
<ul class="org-ul">
<li><p>
OLTP (Online Transaction Processing) 系統：例如銀行帳戶轉帳，只影響特定的帳戶資料：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  UPDATE Accounts <span style="color: #ECBE7B;">SET</span> <span style="color: #dcaeea;">balance</span> = balance - <span style="color: #da8548; font-weight: bold;">100</span> WHERE id = <span style="color: #da8548; font-weight: bold;">101</span>;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgda2df09" class="outline-5">
<h5 id="orgda2df09">2. 粗粒度鎖定 (Table / Database-Level Locking)</h5>
<div class="outline-text-5" id="text-orgda2df09">
<p>
定義：對整張表 (Table Lock) 或整個資料庫 (Database Lock) 進行鎖定。<br />
</p>

<p>
優點：<br />
</p>
<ul class="org-ul">
<li>鎖管理簡單：只需要管理少量鎖，降低系統開銷。<br /></li>
<li>避免死鎖：所有交易都需等待鎖釋放，不會互相競爭。<br /></li>
</ul>

<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>降低並行度：整個表被鎖定，所有交易必須等待鎖釋放，可能影響效能。<br /></li>
<li>影響讀取性能：例如大量 SELECT 可能因為 UPDATE 而阻塞。<br /></li>
</ul>

<p>
應用場景：<br />
</p>
<ul class="org-ul">
<li><p>
批量更新 (Batch Processing)，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  UPDATE Employees <span style="color: #ECBE7B;">SET</span> <span style="color: #dcaeea;">salary</span> = salary * <span style="color: #da8548; font-weight: bold;">1.1</span>;
</pre>
</div>
<p>
此操作影響整張表，使用表級鎖可以避免單筆更新的鎖競爭。<br />
</p></li>
<li>OLAP (Online Analytical Processing) 報表系統，避免同時修改資料影響查詢。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org90df60f" class="outline-5">
<h5 id="org90df60f">3. 小範圍 vs. 大範圍鎖定比較</h5>
<div class="outline-text-5" id="text-org90df60f">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">細粒度鎖定 (Tuple / Row)</th>
<th scope="col" class="org-left">粗粒度鎖定 (Table / Database)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">並行度</td>
<td class="org-left">高</td>
<td class="org-left">低</td>
</tr>

<tr>
<td class="org-left">鎖管理開銷</td>
<td class="org-left">高</td>
<td class="org-left">低</td>
</tr>

<tr>
<td class="org-left">死鎖可能性</td>
<td class="org-left">高</td>
<td class="org-left">低</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">OLTP（即時交易系統）</td>
<td class="org-left">OLAP（批次處理與報表）</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org21bb17e" class="outline-4">
<h4 id="org21bb17e"><span class="section-number-4">5.9.3.</span> 相關計算機概論知識</h4>
<div class="outline-text-4" id="text-5-9-3">
<ol class="org-ol">
<li>ACID 性質<br />
<ul class="org-ul">
<li>A (Atomicity, 原子性)：交易要麼全部執行，要麼全部不執行。<br /></li>
<li>C (Consistency, 一致性)：交易執行後，資料庫應保持一致狀態。<br /></li>
<li>I (Isolation, 隔離性)：交易不應影響其他交易的執行。<br /></li>
<li>D (Durability, 持久性)：交易提交後應永久保留。<br /></li>
</ul></li>
<li>並行控制 (Concurrency Control)<br />
<ul class="org-ul">
<li>悲觀鎖定 (Pessimistic Locking)：<br />
<ul class="org-ul">
<li>透過 共享鎖 (S-Lock) 和 排他鎖 (X-Lock) 來控制併發存取，確保資料一致性。<br /></li>
<li>適合高競爭環境（例如銀行系統）。<br /></li>
</ul></li>
<li>樂觀鎖定 (Optimistic Locking)：<br />
<ul class="org-ul">
<li>不鎖定資源，先讀取資料，執行更新時檢查是否有其他交易修改過數據。<br /></li>
<li>適合讀多寫少的環境（例如線上報表系統）。<br /></li>
</ul></li>
</ul></li>
<li>兩階段鎖定協議 (Two-Phase Locking, 2PL)<br />
<ul class="org-ul">
<li>成長階段 (Growing Phase)：交易可以獲取鎖，但不能釋放鎖。<br /></li>
<li>收縮階段 (Shrinking Phase)：交易可以釋放鎖，但不能獲取新鎖。<br /></li>
<li>這種方法確保無衝突且避免死鎖。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orge7c7045" class="outline-4">
<h4 id="orge7c7045"><span class="section-number-4">5.9.4.</span> 結論</h4>
<div class="outline-text-4" id="text-5-9-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">問題</th>
<th scope="col" class="org-left">解答</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(甲) S-Lock vs. X-Lock</td>
<td class="org-left">S-Lock 允許讀取但不能寫入；X-Lock 允許讀寫但完全鎖定資源。</td>
</tr>

<tr>
<td class="org-left">(乙) 小範圍 vs. 大範圍鎖定</td>
<td class="org-left">小範圍鎖提高並行度但管理成本高；大範圍鎖簡單但影響效能。</td>
</tr>

<tr>
<td class="org-left">建議</td>
<td class="org-left">OLTP 系統應使用細粒度鎖 (Row-Level Locking)，OLAP 或批量作業應使用表級鎖。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orga951463" class="outline-3">
<h3 id="orga951463"><span class="section-number-3">5.10.</span> 9.(5%)</h3>
<div class="outline-text-3" id="text-5-10">
<p>
In Java programing language, write a program to swap two numbers without using a third variable in your program.<br />
-Java 中不使用第三個變數交換兩個數值<br />
</p>
</div>
<div id="outline-container-org8f3e6e3" class="outline-4">
<h4 id="org8f3e6e3"><span class="section-number-4">5.10.1.</span> 1. 問題描述</h4>
<div class="outline-text-4" id="text-5-10-1">
<p>
在 Java 中，一般交換兩個數的方式是使用第三個變數來暫存數值：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">temp</span> = a;
<span class="linenr">3: </span>a = b;
<span class="linenr">4: </span>b = temp;
</pre>
</div>
<p>
但本題要求不使用第三個變數來交換兩個數。<br />
</p>
</div>
</div>
<div id="outline-container-orga615066" class="outline-4">
<h4 id="orga615066"><span class="section-number-4">5.10.2.</span> 2. 解法</h4>
<div class="outline-text-4" id="text-5-10-2">
</div>
<div id="outline-container-org6e3196e" class="outline-5">
<h5 id="org6e3196e">方法 1：使用加減法</h5>
<div class="outline-text-5" id="text-org6e3196e">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> SwapNumbers {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr"> 3: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>        System.out.println(<span style="color: #98be65;">"&#20132;&#25563;&#21069;: a = "</span> + a + <span style="color: #98be65;">", b = "</span> + b);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>        a = a + b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a = 5 + 10 = 15</span>
<span class="linenr"> 8: </span>        b = a - b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">b = 15 - 10 = 5</span>
<span class="linenr"> 9: </span>        a = a - b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a = 15 - 5 = 10</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>        System.out.println(<span style="color: #98be65;">"&#20132;&#25563;&#24460;: a = "</span> + a + <span style="color: #98be65;">", b = "</span> + b);
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>}
</pre>
</div>
<p>
原理：<br />
</p>
<ul class="org-ul">
<li>a = a + b：累加兩數 (a + b) 儲存到 a。<br /></li>
<li>b = a - b：從新 a (a+b) 減去 b，取得 a 原始值，並儲存到 b。<br /></li>
<li>a = a - b：從新 a (a+b) 減去新 b (原 a)，取得 b 原始值，並儲存到 a。<br /></li>
</ul>
<p>
優點：<br />
</p>
<ul class="org-ul">
<li>不需要額外記憶體。<br /></li>
<li>運算速度快，適合數值交換。<br /></li>
</ul>
<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>可能會溢位 (overflow)，當 a + b 超過 int 範圍時可能發生錯誤。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb501a9d" class="outline-5">
<h5 id="orgb501a9d">方法 2：使用 XOR 運算</h5>
<div class="outline-text-5" id="text-orgb501a9d">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> SwapNumbersXOR {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr"> 3: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>        System.out.println(<span style="color: #98be65;">"&#20132;&#25563;&#21069;: a = "</span> + a + <span style="color: #98be65;">", b = "</span> + b);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>        a = a ^ b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a = 5 ^ 10</span>
<span class="linenr"> 8: </span>        b = a ^ b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">b = (5 ^ 10) ^ 10 = 5</span>
<span class="linenr"> 9: </span>        a = a ^ b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a = (5 ^ 10) ^ 5 = 10</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>        System.out.println(<span style="color: #98be65;">"&#20132;&#25563;&#24460;: a = "</span> + a + <span style="color: #98be65;">", b = "</span> + b);
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>}
</pre>
</div>

<p>
原理：<br />
</p>
<ul class="org-ul">
<li>XOR (^ 運算符) 具有互斥 (Exclusive OR) 性質，滿足：<br />
<ul class="org-ul">
<li>X ^ X = 0<br /></li>
<li>X ^ 0 = X<br /></li>
<li>A ^ B ^ B = A<br /></li>
</ul></li>
<li>透過 3 次 XOR 運算完成交換：<br />
<ul class="org-ul">
<li>a = a ^ b：a 存儲 a 和 b 的 XOR 結果。<br /></li>
<li>b = a ^ b：b 變為 a 的原值。<br /></li>
<li>a = a ^ b：a 變為 b 的原值。<br /></li>
</ul></li>
</ul>

<p>
優點：<br />
</p>
<ul class="org-ul">
<li>不會發生溢位 (適用於所有整數型別)。<br /></li>
<li>適合低階程式設計與嵌入式系統 (Bitwise 操作較快)。<br /></li>
</ul>
<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>XOR 運算可能較難理解。<br /></li>
<li>可讀性較低，不直觀。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org6b3c4cc" class="outline-5">
<h5 id="org6b3c4cc">方法 3：使用乘除法</h5>
<div class="outline-text-5" id="text-org6b3c4cc">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> SwapNumbersMultiplyDivide {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr"> 3: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>        System.out.println(<span style="color: #98be65;">"&#20132;&#25563;&#21069;: a = "</span> + a + <span style="color: #98be65;">", b = "</span> + b);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>        a = a * b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a = 5 * 10 = 50</span>
<span class="linenr"> 8: </span>        b = a / b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">b = 50 / 10 = 5</span>
<span class="linenr"> 9: </span>        a = a / b;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a = 50 / 5 = 10</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>        System.out.println(<span style="color: #98be65;">"&#20132;&#25563;&#24460;: a = "</span> + a + <span style="color: #98be65;">", b = "</span> + b);
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>}
</pre>
</div>

<p>
原理：<br />
</p>
<ul class="org-ul">
<li>a = a * b：累積兩個數字的乘積 (a * b) 存入 a。<br /></li>
<li>b = a / b：透過 a / b 取得 a 原始值並存入 b。<br /></li>
<li>a = a / b：透過 a / b 取得 b 原始值並存入 a。<br /></li>
</ul>
<p>
優點：<br />
</p>
<ul class="org-ul">
<li>適用於浮點數。<br /></li>
</ul>
<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>可能出現整數除法誤差或溢位問題 (a * b 可能超出 int 範圍)。<br /></li>
<li>b 不能為 0，否則會發生除以 0 錯誤。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3efb597" class="outline-4">
<h4 id="org3efb597"><span class="section-number-4">5.10.3.</span> 相關計算機概論知識</h4>
<div class="outline-text-4" id="text-5-10-3">
<ol class="org-ol">
<li>變數與記憶體管理<br />
<ul class="org-ul">
<li>變數 (Variable)：儲存數值的容器，必須分配記憶體。<br /></li>
<li>指標 (Pointer) &amp; 變數位址：<br />
<ul class="org-ul">
<li>在低階語言 (如 C, C++)，指標可用來交換變數。<br /></li>
<li>在 Java 中，不允許直接存取記憶體位址，但可透過運算來交換數值。<br /></li>
</ul></li>
</ul></li>
<li>位元運算 (Bitwise Operations)<br />
<ul class="org-ul">
<li>XOR (^) 是一種低階交換技術，可有效運用於嵌入式系統與效能優化。<br /></li>
<li>具體應用：<br />
<ul class="org-ul">
<li>加密技術 (Encryption)<br /></li>
<li>壓縮算法<br /></li>
<li>快取優化<br /></li>
</ul></li>
</ul></li>
<li>資料類型與溢位<br />
<ul class="org-ul">
<li>int 變數通常佔 4 bytes，範圍為 -2,147,483,648 至 2,147,483,647。<br /></li>
<li>若 a + b 或 a * b 超出此範圍，會發生整數溢位 (Integer Overflow)。<br /></li>
</ul></li>
<li>Java 的運算規則<br />
<ul class="org-ul">
<li>Java 支援 加法 (+)、減法 (-)、乘法 (*)、除法 (/)、XOR (^) 運算。<br /></li>
<li>XOR 交換法的優勢：<br />
<ul class="org-ul">
<li>無需額外記憶體。<br /></li>
<li>適用於所有數值類型 (int, long, short)。<br /></li>
</ul></li>
<li>但 XOR 運算不適用於 float 和 double，因為浮點數沒有位元級運算。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org0cebc2c" class="outline-4">
<h4 id="org0cebc2c"><span class="section-number-4">5.10.4.</span> 結論</h4>
<div class="outline-text-4" id="text-5-10-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">優點</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">加減法</td>
<td class="org-left">簡單直觀、運算快</td>
<td class="org-left">可能溢位 (a + b)</td>
</tr>

<tr>
<td class="org-left">XOR 運算</td>
<td class="org-left">無溢位問題、位元級運算</td>
<td class="org-left">不易理解，可讀性低</td>
</tr>

<tr>
<td class="org-left">乘除法</td>
<td class="org-left">適用於浮點數</td>
<td class="org-left">可能發生除以 0 或溢位</td>
</tr>
</tbody>
</table>

<p>
推薦方案：<br />
</p>
<ul class="org-ul">
<li>對於整數型別 (int, long)，XOR 是最佳方案。<br /></li>
<li>對於浮點數 (float, double)，可使用加減法或乘除法，但須避免除以 0 問題。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org002a056" class="outline-3">
<h3 id="org002a056"><span class="section-number-3">5.11.</span> 10.(10%)</h3>
<div class="outline-text-3" id="text-5-11">
<p>
Write a Java program to check if a given number is a prime number. Don’t use Java’s library to directly check for prime number, design your own solution. Your program needs to take an input number, and print out your answer with the input number. Explain why your program is the most efficient one as efficiency and correctness are both graded for the question.<br />
</p>
</div>
<div id="outline-container-orgf1d8ab0" class="outline-4">
<h4 id="orgf1d8ab0"><span class="section-number-4">5.11.1.</span> 解</h4>
<div class="outline-text-4" id="text-5-11-1">
</div>
<div id="outline-container-org832fecd" class="outline-5">
<h5 id="org832fecd">1. 問題描述</h5>
<div class="outline-text-5" id="text-org832fecd">
<p>
設計一個 Java 程式來判斷一個數是否為質數（Prime Number）。不能使用 Java 內建函式（如 BigInteger.isProbablePrime()）。程式需要接受一個整數作為輸入，然後輸出該數是否為質數。<br />
</p>
</div>
</div>
<div id="outline-container-org602a64e" class="outline-5">
<h5 id="org602a64e">2. 什麼是質數？</h5>
<div class="outline-text-5" id="text-org602a64e">
<ul class="org-ul">
<li>定義：<br /></li>
<li>質數（Prime Number）是指大於 1 且只能被 1 和自身整除的數。<br /></li>
<li>例如：2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31&#x2026;<br /></li>
</ul>

<p>
非質數（合數）：<br />
</p>
<ul class="org-ul">
<li>4 不是質數，因為 4 = 2 × 2。<br /></li>
<li>6 不是質數，因為 6 = 2 × 3。<br /></li>
</ul>

<p>
特例：<br />
</p>
<ul class="org-ul">
<li>1 不是質數（因為質數定義要求至少有兩個因數）。<br /></li>
<li>2 是唯一的偶數質數。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2428c1e" class="outline-5">
<h5 id="org2428c1e">3. 最佳化演算法</h5>
<div class="outline-text-5" id="text-org2428c1e">
</div>
<ul class="org-ul">
<li><a id="org323774c"></a>方法 1：暴力檢查（Brute Force）<br />
<div class="outline-text-6" id="text-org323774c">
<ul class="org-ul">
<li>遍歷所有 2 到 n-1 的數字，檢查 n % i == 0。<br /></li>
<li>如果 n 被任何數整除，就不是質數。<br /></li>
</ul>

<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>時間複雜度為 O(n)，對大數效率差。<br /></li>
</ul>
</div>
</li>
<li><a id="org33689f7"></a>方法 2：迭代到 sqrt(n)（最佳化）<br />
<div class="outline-text-6" id="text-org33689f7">
<p>
關鍵觀察：<br />
</p>
<ul class="org-ul">
<li>若 n 有因數，則必然有一個因數 ≤ sqrt(n)。<br /></li>
<li>若 n = a × b，則：<br />
<ul class="org-ul">
<li>若 a &gt; sqrt(n)，則 b &lt; sqrt(n)（否則 a * b &gt; n）。<br /></li>
<li>只需檢查 2 ~ sqrt(n) 是否能整除 n。<br /></li>
</ul></li>
</ul>

<p>
時間複雜度：O(√n)<br />
</p>
<ul class="org-ul">
<li>只需檢查 sqrt(n) 內的數，大幅減少計算次數。<br /></li>
</ul>
</div>
</li>
<li><a id="org1f394b1"></a>方法 3：跳過偶數（進一步優化）<br />
<div class="outline-text-6" id="text-org1f394b1">
<p>
額外最佳化：<br />
</p>
<ul class="org-ul">
<li>若 n 是偶數且大於 2，則 n 一定不是質數（因為 n % 2 == 0）。<br /></li>
<li>只需檢查 2，然後檢查 3, 5, 7, &#x2026; 直到 sqrt(n) 的奇數。<br /></li>
</ul>

<p>
時間複雜度：O(√n / 2) ≈ O(√n)<br />
</p>
<ul class="org-ul">
<li>排除所有偶數，檢查次數減半。<br /></li>
</ul>
</div>
</li>
<li><a id="org370e3d2"></a>4. Java 程式碼<br />
<div class="outline-text-6" id="text-org370e3d2">
<p>
使用 O(√n) 演算法<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">import</span> java.util.Scanner;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> PrimeNumberChecker {
<span class="linenr"> 4: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21028;&#26039;&#26159;&#21542;&#28858;&#36074;&#25976;</span>
<span class="linenr"> 5: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">isPrime</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr"> 6: </span>        <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1 &#19981;&#26159;&#36074;&#25976;</span>
<span class="linenr"> 7: </span>        <span style="color: #51afef;">if</span> (n == <span style="color: #da8548; font-weight: bold;">2</span>) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2 &#26159;&#36074;&#25976;</span>
<span class="linenr"> 8: </span>        <span style="color: #51afef;">if</span> (n % <span style="color: #da8548; font-weight: bold;">2</span> == <span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25490;&#38500;&#20598;&#25976;</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21482;&#27298;&#26597;&#22855;&#25976;&#65288;&#24478; 3 &#38283;&#22987;&#65292;&#27599;&#27425;&#36339;&#36942; 2&#65292;&#30452;&#21040; sqrt(n)&#65289;</span>
<span class="linenr">11: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">3</span>; i * i &lt;= n; i += <span style="color: #da8548; font-weight: bold;">2</span>) {
<span class="linenr">12: </span>            <span style="color: #51afef;">if</span> (n % i == <span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26377;&#22240;&#25976;&#20195;&#34920;&#19981;&#26159;&#36074;&#25976;</span>
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#27794;&#26377;&#25214;&#21040;&#22240;&#25976;&#65292;&#21063;&#26159;&#36074;&#25976;</span>
<span class="linenr">15: </span>    }
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">18: </span>        Scanner scanner = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Scanner</span>(System.<span style="color: #51afef;">in</span>);
<span class="linenr">19: </span>        System.out.print(<span style="color: #98be65;">"&#35531;&#36664;&#20837;&#19968;&#20491;&#25976;&#23383;: "</span>);
<span class="linenr">20: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">number</span> = scanner.nextInt();
<span class="linenr">21: </span>        scanner.close();
<span class="linenr">22: </span>
<span class="linenr">23: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21628;&#21483;&#20989;&#24335;&#21028;&#26039;&#36074;&#25976;</span>
<span class="linenr">24: </span>        <span style="color: #51afef;">if</span> (isPrime(number)) {
<span class="linenr">25: </span>            System.out.println(number + <span style="color: #98be65;">" &#26159;&#36074;&#25976;"</span>);
<span class="linenr">26: </span>        } <span style="color: #51afef;">else</span> {
<span class="linenr">27: </span>            System.out.println(number + <span style="color: #98be65;">" &#19981;&#26159;&#36074;&#25976;"</span>);
<span class="linenr">28: </span>        }
<span class="linenr">29: </span>    }
<span class="linenr">30: </span>}
</pre>
</div>
</div>
</li>
<li><a id="org5617d68"></a>5. 程式運行範例<br />
<div class="outline-text-6" id="text-org5617d68">
<pre class="example" id="org3a3eb2f">
請輸入一個數字: 17
17 是質數

請輸入一個數字: 18
18 不是質數
</pre>
</div>
</li>
<li><a id="orgf359069"></a>6. 時間與空間複雜度分析<br />
<div class="outline-text-6" id="text-orgf359069">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">演算法</th>
<th scope="col" class="org-left">時間複雜度</th>
<th scope="col" class="org-left">空間複雜度</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">暴力檢查 O(n)</td>
<td class="org-left">O(n)</td>
<td class="org-left">O(1)</td>
<td class="org-left">遍歷所有數，效率差</td>
</tr>

<tr>
<td class="org-left">sqrt(n) 方法</td>
<td class="org-left">O(√n)</td>
<td class="org-left">O(1)</td>
<td class="org-left">只檢查 2 ~ sqrt(n)</td>
</tr>

<tr>
<td class="org-left">跳過偶數 O(√n/2)</td>
<td class="org-left">O(√n)</td>
<td class="org-left">O(1)</td>
<td class="org-left">最佳化版本，最快</td>
</tr>
</tbody>
</table>

<p>
空間複雜度： O(1)，因為沒有使用額外的數據結構（只用變數）。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6a42e07" class="outline-5">
<h5 id="org6a42e07">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-org6a42e07">
<ol class="org-ol">
<li>資料結構與演算法<br />
<ul class="org-ul">
<li>暴力法（Brute Force）：檢查 1 ~ n，時間複雜度 O(n)，效率差。<br /></li>
<li>數學最佳化（Mathematical Optimization）：使用 sqrt(n) 降低計算次數。<br /></li>
<li>質數判定（Primality Test）：適用於密碼學、數論應用。<br /></li>
</ul></li>
<li>記憶體與計算資源<br />
<ul class="org-ul">
<li>時間複雜度（Time Complexity）：影響演算法執行速度。<br /></li>
<li>空間複雜度（Space Complexity）：O(1)，因為只使用少量變數。<br /></li>
</ul></li>
<li>數論（Number Theory）<br />
<ul class="org-ul">
<li>質數特性（Prime Number Properties）<br />
<ul class="org-ul">
<li>除了 2 以外，所有質數都是奇數。<br /></li>
<li>質數的最小公因數不超過 sqrt(n)。<br /></li>
</ul></li>
<li>質數在計算機科學的應用<br />
<ul class="org-ul">
<li>RSA 加密：使用兩個大質數來產生密鑰。<br /></li>
<li>隨機數生成：基於質數來產生安全隨機數。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org16491cf" class="outline-2">
<h2 id="org16491cf"><span class="section-number-2">6.</span> 中山113計概</h2>
<div class="outline-text-2" id="text-6">
<p>
國立中山大學 113 學年度 碩士班暨碩士在職專班招生考試試題 科目名稱：計算機概論 【資管系碩士班甲組、乙組】<br />
</p>
</div>
<div id="outline-container-orgdb5182e" class="outline-3">
<h3 id="orgdb5182e"><span class="section-number-3">6.1.</span> |單選</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-orge2a5035" class="outline-4">
<h4 id="orge2a5035"><span class="section-number-4">6.1.1.</span> 1.</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
A CPU performs instruction execution by fetch-decode-execute-store cycle. Which component executes the instruction?<br />
</p>
<ol class="org-ol">
<li>CU<br /></li>
<li>ALU<br /></li>
<li>IR<br /></li>
<li>RAM<br /></li>
</ol>
</div>
<div id="outline-container-org77c85f4" class="outline-5">
<h5 id="org77c85f4">解</h5>
<div class="outline-text-5" id="text-org77c85f4">
<p>
中央處理器 (CPU) 的運作分為 取指 (Fetch)、解碼 (Decode)、執行 (Execute)、存回 (Store) 四個階段，稱為 指令週期 (Instruction Cycle)。其中，「執行 (Execute) 階段」負責實際執行指令的計算與邏輯操作。<br />
</p>

<p>
題目問：「哪個元件負責執行指令？」<br />
</p>
<ul class="org-ul">
<li>(A) CU (控制單元，Control Unit)<br /></li>
<li>(B) ALU (算術邏輯單元，Arithmetic Logic Unit)<br /></li>
<li>(C) IR (指令暫存器，Instruction Register)<br /></li>
<li>(D) RAM (隨機存取記憶體，Random Access Memory)<br /></li>
</ul>
<p>
✅ 正確答案： (B) ALU (算術邏輯單元，Arithmetic Logic Unit)<br />
</p>
</div>
</div>
<div id="outline-container-org2e1dd87" class="outline-5">
<h5 id="org2e1dd87">解析每個選項的功能</h5>
<div class="outline-text-5" id="text-org2e1dd87">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">元件名稱</th>
<th scope="col" class="org-left">功能</th>
<th scope="col" class="org-left">是否負責執行指令？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A) CU</td>
<td class="org-left">控制單元 (Control Unit, CU)</td>
<td class="org-left">負責指令的取指 (fetch) 和解碼 (decode)，但不執行運算</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">(B) ALU</td>
<td class="org-left">算術邏輯單元 (Arithmetic Logic Unit, ALU)</td>
<td class="org-left">負責執行算術運算 (加減乘除) 和邏輯運算 (AND, OR, NOT)</td>
<td class="org-left">✅</td>
</tr>

<tr>
<td class="org-left">(C) IR</td>
<td class="org-left">指令暫存器 (Instruction Register, IR)</td>
<td class="org-left">暫存 目前執行的指令，不負責執行</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">(D) RAM</td>
<td class="org-left">隨機存取記憶體 (Random Access Memory, RAM)</td>
<td class="org-left">儲存指令與資料，但不執行指令</td>
<td class="org-left">❌</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
為什麼 ALU 負責執行指令？<br />
</p>
<ul class="org-ul">
<li>算術運算 (Arithmetic Operations)：<br />
<ul class="org-ul">
<li>例如 A = B + C，加法 (+) 由 ALU 處理。<br /></li>
</ul></li>
<li>邏輯運算 (Logical Operations)：<br />
<ul class="org-ul">
<li>例如 AND、OR、XOR、NOT 這些布林運算都由 ALU 處理。<br /></li>
</ul></li>
<li>比較 (Comparison Operations)：<br />
<ul class="org-ul">
<li>例如 A &gt; B、A == B，這些比較結果影響條件跳躍 (conditional jump)。<br /></li>
</ul></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org4695f27"></a>指令週期 (Instruction Cycle) 詳細解析<br />
<div class="outline-text-6" id="text-org4695f27">
<ol class="org-ol">
<li>取指 (Fetch)<br />
<ul class="org-ul">
<li>CPU (CU) 從記憶體 (RAM) 取出下一條指令，並放入 指令暫存器 (IR)。<br /></li>
<li>主要元件：<br />
<ul class="org-ul">
<li>程式計數器 (PC, Program Counter) 指向下一條指令的記憶體位址。<br /></li>
<li>指令暫存器 (IR, Instruction Register) 儲存目前指令。<br /></li>
</ul></li>
</ul></li>
<li>解碼 (Decode)<br />
<ul class="org-ul">
<li>控制單元 (CU) 解讀指令的運作碼 (Opcode)，確定指令類型 (運算、存取記憶體、條件跳躍等)。<br /></li>
<li>如果指令需要運算，CU 會指示 ALU 進行執行。<br /></li>
</ul></li>
<li>執行 (Execute)<br />
<ul class="org-ul">
<li>ALU 負責執行指令中的運算與邏輯處理。<br />
<ul class="org-ul">
<li>例如 ADD A, B (A = A + B)<br /></li>
<li>例如 CMP A, B (比較 A 和 B)<br /></li>
</ul></li>
<li>如果是存取記憶體，則可能與 RAM 交換資料。<br /></li>
</ul></li>
<li>存回 (Store)<br />
<ul class="org-ul">
<li>將 ALU 的運算結果存回記憶體 (RAM) 或暫存器 (Registers)。<br /></li>
</ul></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org75ebf94" class="outline-5">
<h5 id="org75ebf94">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-org75ebf94">
<ol class="org-ol">
<li><p>
CPU 的主要組成<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">元件</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">控制單元 (CU)</td>
<td class="org-left">解析指令，指揮 CPU 的操作</td>
</tr>

<tr>
<td class="org-left">算術邏輯單元 (ALU)</td>
<td class="org-left">執行數學運算與邏輯運算</td>
</tr>

<tr>
<td class="org-left">暫存器 (Registers)</td>
<td class="org-left">高速記憶體，用來存放暫時數據</td>
</tr>

<tr>
<td class="org-left">快取記憶體 (Cache)</td>
<td class="org-left">暫存記憶體中的資料，加速存取</td>
</tr>
</tbody>
</table></li>
<li>記憶體架構<br />
<ul class="org-ul">
<li>RAM (隨機存取記憶體)：存放指令與數據，但不執行指令。<br /></li>
<li>ROM (唯讀記憶體)：存放開機程式 (BIOS)。<br /></li>
<li>快取 (Cache Memory)：加速 CPU 存取數據。<br /></li>
</ul></li>
<li><p>
ALU 運算種類<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">運算類型</th>
<th scope="col" class="org-left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">算術運算 (Arithmetic Operations)</td>
<td class="org-left">ADD, SUB, MUL, DIV</td>
</tr>

<tr>
<td class="org-left">邏輯運算 (Logical Operations)</td>
<td class="org-left">AND, OR, NOT, XOR</td>
</tr>

<tr>
<td class="org-left">比較運算 (Comparison Operations)</td>
<td class="org-left">CMP, TEST</td>
</tr>

<tr>
<td class="org-left">位元運算 (Bitwise Operations)</td>
<td class="org-left">SHL, SHR, ROL, ROR</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</div>
<div id="outline-container-orge922aa2" class="outline-5">
<h5 id="orge922aa2">結論</h5>
<div class="outline-text-5" id="text-orge922aa2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">問題</th>
<th scope="col" class="org-left">正確答案</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">哪個元件負責執行指令？</td>
<td class="org-left">(B) ALU (算術邏輯單元)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org7d6f3d5" class="outline-4">
<h4 id="org7d6f3d5"><span class="section-number-4">6.1.2.</span> 2.</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
Which of the following statements about network protocols is wrong?<br />
</p>
<ol class="org-ol">
<li>UDP builds up reliable connections.<br /></li>
<li>DNS queries are transmitted through UDP.<br /></li>
<li>FTP requests and responses are transmitted through TCP protocol.<br /></li>
<li>FTP responses are transmitted through TCP protocol<br /></li>
</ol>
</div>
<div id="outline-container-orga09d4b5" class="outline-5">
<h5 id="orga09d4b5">解</h5>
<div class="outline-text-5" id="text-orga09d4b5">
<p>
網路協議是用來規範電腦之間通訊的標準，常見的傳輸協議包括：<br />
</p>
<ul class="org-ul">
<li>TCP (Transmission Control Protocol)：可靠的連線導向 (connection-oriented) 協議。<br /></li>
<li>UDP (User Datagram Protocol)：不可靠的無連線 (connectionless) 協議。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org30c35f5" class="outline-5">
<h5 id="org30c35f5">題目分析</h5>
<div class="outline-text-5" id="text-org30c35f5">
<p>
讓我們逐一檢查四個選項的正確性：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9ecc633"></a>(A) UDP 建立可靠的連線 (UDP builds up reliable connections.)<br />
<div class="outline-text-6" id="text-org9ecc633">
<p>
❌ 錯誤<br />
</p>
<ul class="org-ul">
<li>UDP (User Datagram Protocol) 是一種無連線 (connectionless) 的協議。<br /></li>
<li>UDP 不保證數據的正確性、順序性，也不提供重傳機制，所以它不是可靠的協議。<br /></li>
<li>例如 DNS 查詢、VoIP、線上遊戲、影音串流 通常使用 UDP，因為這些應用允許部分數據丟失，以換取較低的延遲。<br /></li>
</ul>
</div>
</li>
<li><a id="org39a267a"></a>(B) DNS 查詢透過 UDP 傳輸 (DNS queries are transmitted through UDP.)<br />
<div class="outline-text-6" id="text-org39a267a">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>DNS (Domain Name System) 主要透過 UDP 53 埠 來傳輸查詢請求 (query) 和回應 (response)。<br /></li>
<li>DNS 查詢通常是小型封包，UDP 的低延遲特性適合此類請求。<br /></li>
<li>特殊情況：<br />
<ul class="org-ul">
<li>若 DNS 回應過大 (超過 512 bytes)，DNS 可能會使用 TCP 53 埠 來進行傳輸。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org037f33f"></a>(C) FTP 請求與回應透過 TCP 協議傳輸 (FTP requests and responses are transmitted through TCP protocol.)<br />
<div class="outline-text-6" id="text-org037f33f">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>FTP (File Transfer Protocol) 是一種傳輸檔案的協議，使用 TCP 來提供可靠傳輸。<br /></li>
<li>FTP 使用兩個 TCP 連接：<br />
<ul class="org-ul">
<li>控制連線 (Control Connection)：用 TCP 21 埠，用於命令傳輸 (如登入、列出目錄)。<br /></li>
<li>資料連線 (Data Connection)：用 TCP 20 埠 (主動模式) 或其他隨機高埠 (被動模式)，用於傳輸檔案內容。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org8a03e36"></a>(D) FTP 回應透過 TCP 傳輸 (FTP responses are transmitted through TCP protocol.)<br />
<div class="outline-text-6" id="text-org8a03e36">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>FTP 所有通訊 (請求與回應) 都使用 TCP。<br /></li>
<li>控制訊息 (如 220 Welcome message, 331 Password required) 由 TCP 21 埠 傳輸。<br /></li>
<li>數據傳輸 (如檔案傳送) 則依模式不同，可能使用 TCP 20 埠 (主動模式) 或隨機 TCP 高埠 (被動模式)。<br /></li>
</ul>
</div>
</li>
<li><a id="org64f5ee8"></a>最終答案<br />
<div class="outline-text-6" id="text-org64f5ee8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">敘述</th>
<th scope="col" class="org-left">正確性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A)</td>
<td class="org-left">UDP 建立可靠的連線</td>
<td class="org-left">❌ 錯誤</td>
</tr>

<tr>
<td class="org-left">(B)</td>
<td class="org-left">DNS 查詢透過 UDP 傳輸</td>
<td class="org-left">✅ 正確</td>
</tr>

<tr>
<td class="org-left">(C)</td>
<td class="org-left">FTP 請求與回應透過 TCP 傳輸</td>
<td class="org-left">✅ 正確</td>
</tr>

<tr>
<td class="org-left">(D)</td>
<td class="org-left">FTP 回應透過 TCP 傳輸</td>
<td class="org-left">✅ 正確</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgfca819d" class="outline-5">
<h5 id="orgfca819d">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-orgfca819d">
<ol class="org-ol">
<li><p>
什麼是 TCP 和 UDP？<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">TCP</th>
<th scope="col" class="org-left">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">類型</td>
<td class="org-left">可靠 (Reliable)</td>
<td class="org-left">不可靠 (Unreliable)</td>
</tr>

<tr>
<td class="org-left">連線模式</td>
<td class="org-left">連線導向 (Connection-oriented)</td>
<td class="org-left">無連線 (Connectionless)</td>
</tr>

<tr>
<td class="org-left">錯誤控制</td>
<td class="org-left">有錯誤檢查與重傳機制</td>
<td class="org-left">只做基本的錯誤檢查，不重傳</td>
</tr>

<tr>
<td class="org-left">應用</td>
<td class="org-left">HTTP、FTP、SSH、SMTP</td>
<td class="org-left">DNS、VoIP、影片串流、線上遊戲</td>
</tr>
</tbody>
</table></li>
<li>什麼是 DNS？為什麼使用 UDP？<br />
<ul class="org-ul">
<li>DNS 主要使用 UDP 53 埠，因為：<br />
<ul class="org-ul">
<li>輕量、快速<br /></li>
<li>查詢封包通常很小，不需 TCP 可靠性<br /></li>
</ul></li>
<li>當 DNS 回應過大時 (超過 512 bytes)，會改用 TCP 53 埠 傳輸。<br /></li>
</ul></li>
<li><p>
FTP (File Transfer Protocol) 的工作方式<br />
FTP 使用兩條 TCP 連線：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">連線類型</th>
<th scope="col" class="org-left">使用埠</th>
<th scope="col" class="org-left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">控制連線 (Control Connection)</td>
<td class="org-left">TCP 21</td>
<td class="org-left">負責命令與回應 (如登入、目錄清單)</td>
</tr>

<tr>
<td class="org-left">資料連線 (Data Connection)</td>
<td class="org-left">TCP 20 (主動模式) / 隨機高埠 (被動模式)</td>
<td class="org-left">負責實際的檔案傳輸</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
<ul class="org-ul">
<li><a id="org84debc2"></a>總結<br />
<div class="outline-text-6" id="text-org84debc2">
<ul class="org-ul">
<li>UDP 是無連線 (connectionless) 協議，無法建立「可靠」連線，所以 A 錯誤。<br /></li>
<li>DNS 查詢通常使用 UDP 53 埠，FTP 相關通訊使用 TCP，因此 B、C、D 正確。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org368591a" class="outline-4">
<h4 id="org368591a"><span class="section-number-4">6.1.3.</span> 3.</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Which of the following statements about Internet of Things (IoTs) is wrong?<br />
</p>
<ol class="org-ol">
<li>For security purpose, IoT devices should be deployed in internal network.<br /></li>
<li>All IoT devices have connectivity.<br /></li>
<li>Bluetooth earphones are IoT devices.<br /></li>
<li>An IP camera is an IoT device and safer than a personal computer.<br /></li>
</ol>
</div>
<div id="outline-container-org37d3f3c" class="outline-5">
<h5 id="org37d3f3c">解</h5>
<div class="outline-text-5" id="text-org37d3f3c">
<p>
物聯網 (IoT) 指的是透過網路將各種設備 (devices) 連接起來，使其能夠自動交換數據並執行動作，例如 智慧家庭設備、智慧交通系統、健康監測裝置等。<br />
題目問：「哪個關於 IoT 的敘述是錯的？」<br />
</p>

<p>
讓我們檢查每個選項的正確性。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd9d31a8"></a>(A) 為了安全考量，IoT 設備應該部署在內部網路<br />
<div class="outline-text-6" id="text-orgd9d31a8">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>IoT 設備通常存在安全漏洞，如 弱密碼、韌體漏洞、未加密通訊。<br /></li>
<li>為了降低風險，不應讓 IoT 設備直接暴露在公網 (Internet)，建議：<br />
<ul class="org-ul">
<li>將 IoT 設備隔離在內部網路 (Internal Network)<br /></li>
<li>使用 VLAN、網路防火牆來限制存取<br /></li>
<li>定期更新韌體<br /></li>
</ul></li>
</ul>
<p>
🔹 正確示範： IoT 網路 → 路由器 (防火牆) → 內部設備<br />
</p>
</div>
</li>
<li><a id="org564f09b"></a>(B) 所有 IoT 設備都具備連線能力<br />
<div class="outline-text-6" id="text-org564f09b">
<p>
❌ 錯誤<br />
</p>
<ul class="org-ul">
<li>並非所有 IoT 設備都能直接連網！<br /></li>
<li>一些 IoT 設備可能依賴 閘道器 (Gateway) 來連接網際網路，例如：<br />
<ul class="org-ul">
<li>Zigbee 和 Z-Wave 設備需要 Zigbee Hub 轉換為 Wi-Fi 訊號。<br /></li>
<li>感測器 可能只是透過本地通訊 (如 NFC) 傳輸資料。<br /></li>
</ul></li>
</ul>
<p>
🔹 錯誤示範：傳統溫濕度感測器 → 只能本地傳輸，無法直接連網<br />
🔹 正確 IoT 例子：Wi-Fi 智慧燈泡 → 直接連網<br />
</p>
</div>
</li>
<li><a id="org7cb5f09"></a>(C) 藍牙耳機是 IoT 設備<br />
<div class="outline-text-6" id="text-org7cb5f09">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>IoT 定義：任何可以透過網路交換數據的設備。<br /></li>
<li>藍牙耳機能與手機連線，並與雲端應用程式交換數據，例如：<br />
<ul class="org-ul">
<li>Apple AirPods 可以透過 iCloud 設備查找功能 (Find My) 傳輸位置數據。<br /></li>
<li>一些高階耳機能記錄使用者的聆聽習慣並透過 App 儲存設定。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc6be7ee"></a>(D) IP 攝影機是 IoT 設備，並且比個人電腦更安全<br />
<div class="outline-text-6" id="text-orgc6be7ee">
<p>
❌ 錯誤<br />
IP 攝影機是 IoT 設備，但它通常比個人電腦更不安全！<br />
</p>
<ul class="org-ul">
<li>原因：<br />
<ul class="org-ul">
<li>IoT 設備更新頻率較低<br />
<ul class="org-ul">
<li>許多 IoT 設備製造商不會頻繁發布安全更新，導致漏洞未修復。<br /></li>
</ul></li>
<li>預設密碼容易被破解<br />
<ul class="org-ul">
<li>很多使用者不更改預設密碼，例如 admin/admin，導致容易被入侵。<br /></li>
</ul></li>
<li>弱加密與通訊協議<br />
<ul class="org-ul">
<li>部分 IP 攝影機仍使用 HTTP 而非 HTTPS，容易遭受中間人攻擊 (MITM)。<br /></li>
</ul></li>
<li>Botnet 攻擊<br />
<ul class="org-ul">
<li>例如 Mirai 殭屍網路 (Botnet) 會入侵 IoT 設備，並將它們用於 DDoS 攻擊。<br /></li>
</ul></li>
</ul></li>
</ul>
<p>
🔹 歷史案例：<br />
</p>
<ul class="org-ul">
<li>2016 年 Mirai Botnet 攻擊：利用大量 IP 攝影機發動大規模 DDoS，癱瘓了 Netflix、GitHub、Twitter 等服務。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd615673"></a>最終答案<br />
<div class="outline-text-6" id="text-orgd615673">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">敘述</th>
<th scope="col" class="org-left">正確性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A)</td>
<td class="org-left">IoT 設備應部署於內部網路以提高安全性</td>
<td class="org-left">✅ 正確</td>
</tr>

<tr>
<td class="org-left">(B)</td>
<td class="org-left">所有 IoT 設備都具備連線能力</td>
<td class="org-left">❌ 錯誤 (正確答案)</td>
</tr>

<tr>
<td class="org-left">(C)</td>
<td class="org-left">藍牙耳機是 IoT 設備</td>
<td class="org-left">✅ 正確</td>
</tr>

<tr>
<td class="org-left">(D)</td>
<td class="org-left">IP 攝影機比個人電腦更安全</td>
<td class="org-left">❌ 錯誤</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5eb9298" class="outline-5">
<h5 id="org5eb9298">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-org5eb9298">
<ol class="org-ol">
<li>什麼是物聯網 (IoT)?<br />
<ul class="org-ul">
<li>物聯網是一個由 感測器 (sensors)、網路連線 (connectivity)、數據處理 (data processing) 所組成的生態系統。<br /></li>
<li>IoT 設備類型：<br />
<ul class="org-ul">
<li>智慧家庭：智能燈泡、智慧門鎖、智慧插座<br /></li>
<li>工業 IoT (IIoT)：工廠自動化機械<br /></li>
<li>醫療 IoT：健康監測設備 (心率感測器)<br /></li>
<li>智慧城市：交通監控、垃圾管理<br /></li>
</ul></li>
</ul></li>
<li>IoT 連線方式<br />
<ul class="org-ul">
<li>Wi-Fi：高頻寬，但耗電量高。<br /></li>
<li>Bluetooth / BLE (低功耗藍牙)：短距離，適用於穿戴裝置。<br /></li>
<li>Zigbee / Z-Wave：低功耗，適合智慧家庭設備。<br /></li>
<li>NB-IoT / LTE-M：適用於遠距 IoT 設備。<br /></li>
</ul></li>
<li><p>
IoT 安全性風險<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">風險類型</th>
<th scope="col" class="org-left">影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">預設密碼弱點</td>
<td class="org-left">設備容易被駭客入侵</td>
</tr>

<tr>
<td class="org-left">未加密的通訊</td>
<td class="org-left">可能被中間人攻擊 (MITM)</td>
</tr>

<tr>
<td class="org-left">更新頻率低</td>
<td class="org-left">未修補的漏洞可能遭利用</td>
</tr>

<tr>
<td class="org-left">殭屍網路攻擊</td>
<td class="org-left">IoT 設備被控制發動 DDoS</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</div>
<div id="outline-container-org3e0d15d" class="outline-5">
<h5 id="org3e0d15d">總結</h5>
<div class="outline-text-5" id="text-org3e0d15d">
<ul class="org-ul">
<li>IoT 設備應該部署在內部網路，避免暴露在公網 (A 正確)。<br /></li>
<li>並非所有 IoT 設備都能直接連網，一些設備需要透過閘道器 (B 錯誤，正確答案)。<br /></li>
<li>藍牙耳機具備 IoT 連接能力，例如 AirPods (C 正確)。<br /></li>
<li>IP 攝影機通常比個人電腦更容易被攻擊，因為安全更新較少 (D 錯誤)。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0288416" class="outline-5">
<h5 id="org0288416">IoT會用到的各種網路類型</h5>
<div class="outline-text-5" id="text-org0288416">
<p>
物聯網 (Internet of Things, IoT) 需要不同類型的網路技術來連接設備，依據傳輸距離、功耗、頻寬需求，可以將 IoT 網路分為以下幾類：<br />
</p>
<ol class="org-ol">
<li><p>
個人區域網路 (PAN, Personal Area Network)<br />
適用場景：短距離 IoT 設備，如穿戴式裝置、智慧家電<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">技術</th>
<th scope="col" class="org-left">傳輸距離</th>
<th scope="col" class="org-left">優點</th>
<th scope="col" class="org-left">缺點</th>
<th scope="col" class="org-left">應用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Bluetooth / BLE (低功耗藍牙)</td>
<td class="org-left">10 - 100 公尺</td>
<td class="org-left">低功耗、支援行動裝置</td>
<td class="org-left">傳輸範圍有限、頻寬低</td>
<td class="org-left">無線耳機、智慧手環、健康監測</td>
</tr>

<tr>
<td class="org-left">Zigbee</td>
<td class="org-left">10 - 100 公尺</td>
<td class="org-left">低功耗、適用於 Mesh 網狀網路</td>
<td class="org-left">傳輸速率較低</td>
<td class="org-left">智慧燈泡、智慧門鎖</td>
</tr>

<tr>
<td class="org-left">Z-Wave</td>
<td class="org-left">30 - 100 公尺</td>
<td class="org-left">低功耗、干擾少</td>
<td class="org-left">頻寬較低、設備支援較少</td>
<td class="org-left">智慧家庭、自動化控制</td>
</tr>

<tr>
<td class="org-left">NFC (近場通訊)</td>
<td class="org-left">&lt;10 公分</td>
<td class="org-left">低功耗、即時通訊</td>
<td class="org-left">距離極短</td>
<td class="org-left">行動支付、門禁系統</td>
</tr>
</tbody>
</table></li>
<li><p>
區域網路 (LAN, Local Area Network)<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">適用場景：需要較高頻寬、較穩定連線的 IoT 設備</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">技術</td>
<td class="org-left">傳輸距離</td>
<td class="org-left">優點</td>
<td class="org-left">缺點</td>
<td class="org-left">應用</td>
</tr>

<tr>
<td class="org-left">Wi-Fi</td>
<td class="org-left">50 - 100 公尺</td>
<td class="org-left">高速傳輸、廣泛應用</td>
<td class="org-left">高功耗、連線數量有限</td>
<td class="org-left">智慧電視、智慧冰箱、IP 監視器</td>
</tr>

<tr>
<td class="org-left">Ethernet (有線網路)</td>
<td class="org-left">100 公尺 (Cat5/6)</td>
<td class="org-left">穩定性高、低延遲</td>
<td class="org-left">需要網線、佈線不便</td>
<td class="org-left">企業 IoT、工業 IoT</td>
</tr>
</tbody>
</table></li>
<li><p>
廣域網路 (WAN, Wide Area Network)<br />
適用場景：需要長距離傳輸的 IoT 設備，如智慧城市、車聯網<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">技術</th>
<th scope="col" class="org-left">傳輸距離</th>
<th scope="col" class="org-left">優點</th>
<th scope="col" class="org-left">缺點</th>
<th scope="col" class="org-left">應用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">3G / 4G / 5G</td>
<td class="org-left">幾公里到全球</td>
<td class="org-left">高速、適用於行動設備</td>
<td class="org-left">高功耗、費用高</td>
<td class="org-left">車聯網、智慧監控</td>
</tr>

<tr>
<td class="org-left">LPWAN (低功耗廣域網)</td>
<td class="org-left">2 - 15 公里</td>
<td class="org-left">超低功耗、遠距傳輸</td>
<td class="org-left">傳輸速率低</td>
<td class="org-left">智慧水表、智慧農業</td>
</tr>

<tr>
<td class="org-left">NB-IoT (窄頻物聯網)</td>
<td class="org-left">1 - 10 公里</td>
<td class="org-left">低功耗、穿透力強</td>
<td class="org-left">頻寬有限</td>
<td class="org-left">智慧停車、環境監測</td>
</tr>

<tr>
<td class="org-left">LoRa (長距離廣域網)</td>
<td class="org-left">2 - 15 公里</td>
<td class="org-left">低功耗、適合遠距 IoT</td>
<td class="org-left">傳輸速率低</td>
<td class="org-left">智慧城市、物流追蹤</td>
</tr>
</tbody>
</table></li>
<li><p>
衛星網路 (Satellite Network)<br />
適用場景：偏遠地區 IoT 設備，如海洋監測、遠距環境監測<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">技術</th>
<th scope="col" class="org-left">傳輸距離</th>
<th scope="col" class="org-left">優點</th>
<th scope="col" class="org-left">缺點</th>
<th scope="col" class="org-left">應用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GPS (全球定位系統)</td>
<td class="org-left">全球</td>
<td class="org-left">精確定位</td>
<td class="org-left">只能發送位置信息</td>
<td class="org-left">物流追蹤、導航系統</td>
</tr>

<tr>
<td class="org-left">衛星 IoT (如 Starlink, Iridium, Inmarsat)</td>
<td class="org-left">全球</td>
<td class="org-left">可在無地面網路區域使用</td>
<td class="org-left">成本高、延遲較高</td>
<td class="org-left">海洋監測、災害監測</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
<ul class="org-ul">
<li><a id="org5c1ee4a"></a>總結：不同 IoT 應用的網路選擇<br />
<div class="outline-text-6" id="text-org5c1ee4a">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">應用場景</th>
<th scope="col" class="org-left">建議網路技術</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">智慧家庭 (智慧燈泡、門鎖)</td>
<td class="org-left">Zigbee、Z-Wave、Wi-Fi</td>
</tr>

<tr>
<td class="org-left">穿戴式設備 (智慧手環、藍牙耳機)</td>
<td class="org-left">Bluetooth / BLE</td>
</tr>

<tr>
<td class="org-left">智慧農業 (環境監測、溫度感測器)</td>
<td class="org-left">LoRa、NB-IoT</td>
</tr>

<tr>
<td class="org-left">智慧城市 (停車管理、智慧路燈)</td>
<td class="org-left">NB-IoT、LoRa</td>
</tr>

<tr>
<td class="org-left">車聯網 (自駕車、遠端診斷)</td>
<td class="org-left">5G、LTE-M</td>
</tr>

<tr>
<td class="org-left">遠距監測 (海洋監測、森林監測)</td>
<td class="org-left">衛星 IoT、LoRa</td>
</tr>
</tbody>
</table>
<p>
不同的 IoT 應用需要根據 功耗、傳輸距離、頻寬需求 選擇適合的網路技術，以確保設備的高效運作與最佳效能！ ✅<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga51a7be" class="outline-4">
<h4 id="orga51a7be"><span class="section-number-4">6.1.4.</span> 4.</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
Which of the following statements about wireless networks is wrong?<br />
</p>
<ol class="org-ol">
<li>Wireless networks have the exposed node problem.<br /></li>
<li>Wireless networks have the hidden node problem.<br /></li>
<li>802.11 does not run on ISM radio band.<br /></li>
<li>802.11 uses the multiple access with collision avoidance algorithm to transmit data.<br /></li>
</ol>
</div>
<div id="outline-container-orgbbf08c1" class="outline-5">
<h5 id="orgbbf08c1">解</h5>
<div class="outline-text-5" id="text-orgbbf08c1">
<p>
無線網路 (Wireless Networks) 是利用無線電波 (Radio Waves) 來傳輸數據的網路技術。常見標準包括 Wi-Fi (IEEE 802.11)、藍牙 (Bluetooth)、蜂巢式網路 (3G/4G/5G) 等。<br />
</p>
</div>
</div>
<div id="outline-container-org7ba55c9" class="outline-5">
<h5 id="org7ba55c9">題目解析</h5>
<div class="outline-text-5" id="text-org7ba55c9">
<p>
題目問：「哪個關於無線網路的敘述是錯的？」讓我們檢查每個選項的正確性。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgbd3b2fc"></a>(A) 無線網路存在「暴露節點 (Exposed Node)」問題<br />
<div class="outline-text-6" id="text-orgbd3b2fc">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>暴露節點問題 (Exposed Node Problem) 是無線網路中的一種問題，發生在：<br />
<ul class="org-ul">
<li>A 可以聽到 B 傳輸，但 A 無法傳給 C，因為它錯誤地認為會干擾 B。<br /></li>
<li>這會導致不必要的通訊延遲，降低網路效率。<br /></li>
</ul></li>
<li><p>
🔹 範例：<br />
</p>
<pre class="example" id="org8ad04a8">
  [A] ----- [B]       [C] ----- [D]
</pre>
<ul class="org-ul">
<li>B 正在與 C 通訊，A 也想與 D 通訊。<br /></li>
<li>A「以為」它的訊號會干擾 B，因此不傳送，但事實上 A 可以傳送給 D 而不影響 B。<br /></li>
<li>這就是「暴露節點問題」，導致 A 不必要地停止傳輸。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org1487f98"></a>(B) 無線網路存在「隱藏節點 (Hidden Node)」問題<br />
<div class="outline-text-6" id="text-org1487f98">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>隱藏節點問題 (Hidden Node Problem) 指的是：<br />
<ul class="org-ul">
<li>A 和 C 無法直接聽到彼此的傳輸，但它們都會影響 B，導致碰撞 (Collision)。<br /></li>
<li>這會導致數據衝突 (Data Collision)，降低網路效能。<br /></li>
</ul></li>
<li><p>
🔹 範例：<br />
</p>
<pre class="example" id="org50a5eb9">
   [A]       [B]       [C]
</pre>
<ul class="org-ul">
<li>A 和 C 無法直接聽到彼此的訊號。<br /></li>
<li>A 和 C 同時傳輸給 B，B 會收到碰撞的訊號 (collision)，導致資料傳輸失敗。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org138a031"></a>(C) 802.11 不運行在 ISM 頻段 (802.11 does not run on ISM radio band)<br />
<div class="outline-text-6" id="text-org138a031">
<p>
❌ 錯誤<br />
</p>
<ul class="org-ul">
<li>802.11 (Wi-Fi) 主要運行在 ISM (Industrial, Scientific, and Medical) 頻段！<br /></li>
<li>ISM 頻段 是全球開放的頻段，不需要特別授權，適合無線通訊應用。<br /></li>
<li>Wi-Fi 主要使用頻段：<br />
<ul class="org-ul">
<li>2.4 GHz ISM 頻段 (802.11b/g/n/ax)<br /></li>
<li>5 GHz U-NII 頻段 (802.11a/n/ac/ax)<br /></li>
<li>6 GHz (Wi-Fi 6E, 802.11ax) 但仍屬於未授權頻段。<br /></li>
</ul></li>
<li><p>
🔹 Wi-Fi 頻段對應表<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Wi-Fi 標準</th>
<th scope="col" class="org-left">頻段</th>
<th scope="col" class="org-left">是否屬於 ISM</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">802.11b/g/n/ax</td>
<td class="org-left">2.4 GHz</td>
<td class="org-left">✅ 是 ISM 頻段</td>
</tr>

<tr>
<td class="org-left">802.11a/n/ac/ax</td>
<td class="org-left">5 GHz</td>
<td class="org-left">❌ 不是 ISM (屬於 U-NII 頻段)</td>
</tr>

<tr>
<td class="org-left">802.11ax (Wi-Fi 6E)</td>
<td class="org-left">6 GHz</td>
<td class="org-left">❌ 不是 ISM</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</li>
<li><a id="org2dc232a"></a>(D) 802.11 使用「多重存取避免碰撞 (CSMA/CA)」來傳輸數據<br />
<div class="outline-text-6" id="text-org2dc232a">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>Wi-Fi 使用 CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance) 來避免碰撞。<br /></li>
<li>CSMA/CA 運作方式：<br />
<ul class="org-ul">
<li>載波偵測 (Carrier Sense)：設備先聆聽頻道是否忙碌。<br /></li>
<li>隨機退避 (Backoff Mechanism)：如果頻道忙碌，設備會等待一段隨機時間再嘗試傳輸。<br /></li>
<li>確認機制 (ACK, Acknowledgement)：Wi-Fi 使用 ACK 機制來確保資料成功傳輸。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org6ba374c"></a>🔹 與乙太網路 (Ethernet) 的比較<br />
<div class="outline-text-6" id="text-org6ba374c">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">技術</th>
<th scope="col" class="org-left">乙太網路 (Ethernet)</th>
<th scope="col" class="org-left">Wi-Fi (802.11)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">使用協議</td>
<td class="org-left">CSMA/CD (碰撞偵測)</td>
<td class="org-left">CSMA/CA (碰撞避免)</td>
</tr>

<tr>
<td class="org-left">傳輸方式</td>
<td class="org-left">碰撞後重傳</td>
<td class="org-left">避免碰撞後傳輸</td>
</tr>

<tr>
<td class="org-left">可靠性</td>
<td class="org-left">有線網路，可靠</td>
<td class="org-left">無線網路，容易受干擾</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org435a10e"></a>最終答案<br />
<div class="outline-text-6" id="text-org435a10e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">敘述</th>
<th scope="col" class="org-left">正確性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A)</td>
<td class="org-left">無線網路有「暴露節點問題」</td>
<td class="org-left">✅ 正確</td>
</tr>

<tr>
<td class="org-left">(B)</td>
<td class="org-left">無線網路有「隱藏節點問題」</td>
<td class="org-left">✅ 正確</td>
</tr>

<tr>
<td class="org-left">(C)</td>
<td class="org-left">802.11 不運行在 ISM 頻段</td>
<td class="org-left">❌ 錯誤 (正確答案)</td>
</tr>

<tr>
<td class="org-left">(D)</td>
<td class="org-left">802.11 使用 CSMA/CA 避免碰撞</td>
<td class="org-left">✅ 正確</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga02d2db" class="outline-5">
<h5 id="orga02d2db">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-orga02d2db">
<ol class="org-ol">
<li><p>
無線網路常見問題<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">問題</th>
<th scope="col" class="org-left">說明</th>
<th scope="col" class="org-left">影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">隱藏節點問題 (Hidden Node Problem)</td>
<td class="org-left">A 和 C 聽不到彼此，但都會影響 B</td>
<td class="org-left">增加碰撞機率，降低效率</td>
</tr>

<tr>
<td class="org-left">暴露節點問題 (Exposed Node Problem)</td>
<td class="org-left">A 誤以為 B 會干擾通訊，所以不傳輸</td>
<td class="org-left">造成不必要的延遲</td>
</tr>

<tr>
<td class="org-left">干擾 (Interference)</td>
<td class="org-left">來自藍牙、微波爐等設備的訊號干擾</td>
<td class="org-left">Wi-Fi 連線不穩定</td>
</tr>

<tr>
<td class="org-left">衰減 (Signal Attenuation)</td>
<td class="org-left">距離過遠、障礙物太多導致訊號變弱</td>
<td class="org-left">傳輸速率下降</td>
</tr>
</tbody>
</table></li>
<li><p>
Wi-Fi (IEEE 802.11) 頻段與標準<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Wi-Fi 標準</th>
<th scope="col" class="org-left">頻段</th>
<th scope="col" class="org-left">最大速率</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">802.11b</td>
<td class="org-left">2.4 GHz</td>
<td class="org-left">11 Mbps</td>
</tr>

<tr>
<td class="org-left">802.11g</td>
<td class="org-left">2.4 GHz</td>
<td class="org-left">54 Mbps</td>
</tr>

<tr>
<td class="org-left">802.11n</td>
<td class="org-left">2.4 / 5 GHz</td>
<td class="org-left">600 Mbps</td>
</tr>

<tr>
<td class="org-left">802.11ac</td>
<td class="org-left">5 GHz</td>
<td class="org-left">6.93 Gbps</td>
</tr>

<tr>
<td class="org-left">802.11ax (Wi-Fi 6)</td>
<td class="org-left">2.4 / 5 / 6 GHz</td>
<td class="org-left">9.6 Gbps</td>
</tr>
</tbody>
</table></li>
<li><p>
CSMA/CD vs. CSMA/CA<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">技術</th>
<th scope="col" class="org-left">CSMA/CD (乙太網路)</th>
<th scope="col" class="org-left">CSMA/CA (Wi-Fi)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">應用</td>
<td class="org-left">有線網路 (Ethernet)</td>
<td class="org-left">無線網路 (Wi-Fi)</td>
</tr>

<tr>
<td class="org-left">處理碰撞方式</td>
<td class="org-left">碰撞後偵測並重傳</td>
<td class="org-left">避免碰撞 再傳輸</td>
</tr>

<tr>
<td class="org-left">是否使用 ACK</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">適用環境</td>
<td class="org-left">共享式有線網路</td>
<td class="org-left">共享式無線網路</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</div>
<div id="outline-container-org51005db" class="outline-5">
<h5 id="org51005db">總結</h5>
<div class="outline-text-5" id="text-org51005db">
<ul class="org-ul">
<li>無線網路存在隱藏節點與暴露節點問題 (A、B 正確)。<br /></li>
<li>Wi-Fi (802.11) 使用 ISM 頻段 (C 錯誤，正確答案)。<br /></li>
<li>Wi-Fi 使用 CSMA/CA 來避免碰撞 (D 正確)。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org65fa617" class="outline-4">
<h4 id="org65fa617"><span class="section-number-4">6.1.5.</span> 5.</h4>
<div class="outline-text-4" id="text-6-1-5">
<p>
Given a binary tree T in which each internal node of T stores a single character. If its inorder traversal yields GOODBOOK and its postorder traversal yields GOOOBKOD. What is its preorder traversal?<br />
</p>
<ol class="org-ol">
<li>DOGBOOOK<br /></li>
<li>DOGOBOOK<br /></li>
<li>DOOGOBOK<br /></li>
<li>DOGOOBOK<br /></li>
</ol>
</div>
<div id="outline-container-org69e6444" class="outline-5">
<h5 id="org69e6444">解</h5>
<div class="outline-text-5" id="text-org69e6444">
<p>
我們已知二元樹 TT 的 中序 (Inorder) 遍歷 結果是：<br />
</p>
<pre class="example" id="org5d5499e">
    GOODBOOK
</pre>
<p>
以及 後序 (Postorder) 遍歷 結果是：<br />
</p>
<pre class="example" id="orgb6b9cc5">
    GOOOBKOD
</pre>
<p>
我們要找出其 前序 (Preorder) 遍歷 結果。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org772887e"></a>步驟 1：理解中序與後序遍歷<br />
<div class="outline-text-6" id="text-org772887e">
<ol class="org-ol">
<li>中序遍歷 (Inorder, LVR)<br />
<ul class="org-ul">
<li>順序： 左子樹 → 根節點 → 右子樹<br /></li>
<li>例如對應到中序遍歷結果 GOODBOOK，代表 O 是在 G 和 D 的右側，並且 B, O, O, K 可能形成右子樹。<br /></li>
</ul></li>
<li>後序遍歷 (Postorder, LRV)<br />
<ul class="org-ul">
<li>順序： 左子樹 → 右子樹 → 根節點<br /></li>
<li>給定後序遍歷 GOOOBKOD，最後一個字母 D 是整棵樹的根。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org5209ea1"></a>步驟 2：構造二元樹<br />
<div class="outline-text-6" id="text-org5209ea1">
<ol class="org-ol">
<li>由於後序遍歷的最後一個字母 D 是根節點，我們可以確定 D 是整棵樹的根。<br /></li>
<li>在中序遍歷 GOODBOOK 中，D 出現在索引 4，這代表：<br />
<ul class="org-ul">
<li>GOOD 是 D 的左子樹<br /></li>
<li>BOOK 是 D 的右子樹<br /></li>
</ul></li>
<li>接著，我們根據後序遍歷 GOOOBKOD：<br />
<ul class="org-ul">
<li>O 是最晚出現在左子樹的字母，代表 O 可能是 D 的直接子節點。<br /></li>
<li>K 是 B 的右子節點，因為 B 出現在 BOOK 中，而 K 在 B 之後出現。<br /></li>
<li>O 在 G 和 O 的後面，可能表示它是 O 的右子節點。<br /></li>
</ul></li>
<li><p>
最後，我們可以推導出如下的樹結構：<br />
</p>
<pre class="example" id="orgf4fa731">
           D
          / \
         O   B
        / \   \
       G   O   K
</pre></li>
</ol>
</div>
</li>
<li><a id="orgfed30e6"></a>步驟 3：取得前序遍歷<br />
<div class="outline-text-6" id="text-orgfed30e6">
<ul class="org-ul">
<li>前序遍歷 (Preorder, VLR)<br /></li>
<li>順序： 根節點 → 左子樹 → 右子樹<br /></li>
</ul>

<p>
按照我們推導的樹：<br />
</p>
<ol class="org-ol">
<li>根節點：D<br /></li>
<li>左子樹：<br />
<ul class="org-ul">
<li>O<br /></li>
<li>G<br /></li>
<li>O<br /></li>
</ul></li>
<li>右子樹：<br />
<ul class="org-ul">
<li>B<br /></li>
<li>O<br /></li>
<li>K<br /></li>
</ul></li>
</ol>
<p>
所以前序遍歷結果是：<br />
</p>
<pre class="example" id="org74d0009">
    DOGOOBOK
</pre>
<p>
答案為 D. DOGOOBOK<br />
</p>
</div>
</li>
<li><a id="org7dff979"></a>相關計概知識整理<br />
<div class="outline-text-6" id="text-org7dff979">
<ol class="org-ol">
<li>二元樹 (Binary Tree)<br />
<ul class="org-ul">
<li>二元樹是一種樹狀結構，每個節點最多有兩個子節點，分為 左子樹 (Left Subtree) 和 右子樹 (Right Subtree)。<br /></li>
</ul></li>
<li>二元樹遍歷 (Tree Traversal)<br />
常見的遍歷方式：<br />
<ul class="org-ul">
<li>前序遍歷 (Preorder, VLR)：根 → 左 → 右<br /></li>
<li>中序遍歷 (Inorder, LVR)：左 → 根 → 右<br /></li>
<li>後序遍歷 (Postorder, LRV)：左 → 右 → 根<br /></li>
<li>層序遍歷 (Level-order Traversal)：按層級順序從上到下、從左到右遍歷。<br /></li>
</ul></li>
<li>樹的應用<br />
<ul class="org-ul">
<li>表達式樹 (Expression Tree)：用來表示數學運算，例如 ((A + B) * C)。<br /></li>
<li>Huffman 編碼樹：用於壓縮算法，Huffman 編碼透過樹來最小化字元存儲長度。<br /></li>
<li>搜尋樹 (Binary Search Tree, BST)：具有排序特性的二元樹，左子樹的值小於根節點，右子樹的值大於根節點。<br /></li>
<li>紅黑樹 (Red-Black Tree)、AVL 樹：平衡二元搜尋樹，保證操作的時間複雜度。<br /></li>
</ul></li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org460e764" class="outline-4">
<h4 id="org460e764"><span class="section-number-4">6.1.6.</span> 6.</h4>
<div class="outline-text-4" id="text-6-1-6">
<p>
Which of the following statements about hash table is wrong?<br />
</p>
<ol class="org-ol">
<li>In the average cases, search in a hash table is O(1).<br /></li>
<li>In the average cases, insert in a hash table is O(1).<br /></li>
<li>In the average cases, delete in a hash table is O(N).<br /></li>
<li>An imperfect hash function may result in many collisions.<br /></li>
</ol>
</div>
<div id="outline-container-org9859dfd" class="outline-5">
<h5 id="org9859dfd">解</h5>
<div class="outline-text-5" id="text-org9859dfd">
<p>
我們需要判斷 哪一個選項關於 Hash Table（雜湊表）的敘述是錯誤的。<br />
</p>
</div>
</div>
<div id="outline-container-org461e74b" class="outline-5">
<h5 id="org461e74b">選項分析</h5>
<div class="outline-text-5" id="text-org461e74b">
<ol class="org-ol">
<li>在平均情況下，哈希表的搜尋時間為 O(1)O(1)<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>在沒有過多碰撞的情況下，哈希表使用 哈希函數 (hash function) 直接映射到存儲位置，因此搜尋時間平均為 O(1)O(1)。<br /></li>
<li>若發生碰撞，需依賴 鏈結串列 (chaining) 或 開放定址法 (open addressing)，但在均勻分佈的情況下，平均搜尋仍接近 O(1)O(1)。<br /></li>
</ul></li>
<li>在平均情況下，哈希表的插入時間為 O(1)O(1)<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>插入的過程類似於搜尋，先透過哈希函數計算索引，再存入資料。若發生碰撞，則依照處理策略解決，如 鏈結串列法 或 開放定址法，但仍可維持 O(1)O(1) 的平均時間。<br /></li>
</ul></li>
<li>在平均情況下，哈希表的刪除時間為 O(N)O(N)<br />
<ul class="org-ul">
<li>❌ 錯誤（這是正確答案）<br /></li>
<li>刪除通常只需進行搜尋並移除該元素，與搜尋操作相同，平均時間仍為 O(1)O(1)。<br /></li>
<li>只有在極端情況（如所有元素都碰撞到同一個位置，導致鏈結串列變長）時，搜尋和刪除的時間才會達到 O(N)O(N)，但這不是平均情況。<br /></li>
</ul></li>
<li>不完美的哈希函數可能導致許多碰撞<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>若哈希函數無法均勻分配鍵值，某些索引可能會存放過多元素，導致頻繁發生碰撞，使搜尋、插入和刪除的效率降低。<br /></li>
</ul></li>
</ol>
<p>
正確答案：C<br />
</p>
</div>
</div>
<div id="outline-container-org2697cec" class="outline-5">
<h5 id="org2697cec">相關計概知識整理</h5>
<div class="outline-text-5" id="text-org2697cec">
<ol class="org-ol">
<li>哈希表 (Hash Table)<br />
<ul class="org-ul">
<li>哈希表是一種以陣列為基礎的資料結構，透過哈希函數 (hash function) 將鍵 (key) 映射到索引值，實現快速存取。<br /></li>
<li>基本概念<br />
<ul class="org-ul">
<li>哈希函數 (Hash Function)：將鍵值映射到固定大小的陣列索引。<br /></li>
<li>碰撞 (Collision)：不同鍵值經過哈希函數計算後映射到相同索引的位置。<br /></li>
<li>負載因子 (Load Factor)：哈希表的填充程度，計算方式為：<br /></li>
<li>負載因子=已存儲元素數量表的大小<br /></li>
<li>負載因子=表的大小已存儲元素數量​ 當負載因子過高時，可能需要 擴展 (Rehashing) 來提升性能。<br /></li>
</ul></li>
</ul></li>
<li><p>
哈希表的操作與時間複雜度<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">操作</th>
<th scope="col" class="org-left">平均時間複雜度</th>
<th scope="col" class="org-left">最壞情況</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">插入 (Insert)</td>
<td class="org-left">O(1)O(1)</td>
<td class="org-left">O(N)O(N)</td>
</tr>

<tr>
<td class="org-left">搜尋 (Search)</td>
<td class="org-left">O(1)O(1)</td>
<td class="org-left">O(N)O(N)</td>
</tr>

<tr>
<td class="org-left">刪除 (Delete)</td>
<td class="org-left">O(1)O(1)</td>
<td class="org-left">O(N)O(N)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>最壞情況通常發生於：<br />
<ul class="org-ul">
<li>哈希函數不均勻分佈，導致過多碰撞。<br /></li>
<li>未及時擴展哈希表 (Rehashing)，導致鏈結串列變長。<br /></li>
</ul></li>
</ul></li>
<li>碰撞處理方法<br />
當兩個或多個鍵對應到同一個哈希索引時，稱為「碰撞 (Collision)」，常見解決方法如下：<br />
<ul class="org-ul">
<li>(1) 鏈結串列法 (Chaining)<br />
<ul class="org-ul">
<li>每個哈希索引對應一個鏈結串列。<br /></li>
<li>若發生碰撞，則將新元素附加到對應索引的鏈結串列中。<br /></li>
<li>優點：適用於負載因子較高的情況，靈活擴展。<br /></li>
<li>缺點：鏈結串列可能變長，搜尋最壞情況為 O(N)O(N)。<br /></li>
</ul></li>
<li>(2) 開放定址法 (Open Addressing)<br />
<ul class="org-ul">
<li>所有元素都存放在哈希表內，不使用額外的鏈結串列。<br /></li>
<li>常見策略：<br />
<ul class="org-ul">
<li>線性探測 (Linear Probing)：當插入位置被佔用時，依序檢查下一個索引 (i.e., h(k)+1,h(k)+2,…h(k)+1,h(k)+2,…)。<br /></li>
<li>二次探測 (Quadratic Probing)：使用平方間距來避免聚集 (i.e., h(k),h(k)+12,h(k)+22,…h(k),h(k)+12,h(k)+22,…)。<br /></li>
<li>雙重雜湊 (Double Hashing)：使用兩個不同的哈希函數來減少碰撞。<br /></li>
</ul></li>
</ul></li>
</ul></li>
<li>哈希函數設計<br />
<ul class="org-ul">
<li>好的哈希函數應該：<br />
<ul class="org-ul">
<li>均勻分佈 (Uniform Distribution)：不同鍵盡可能均勻映射到各個索引。<br /></li>
<li>避免碰撞 (Minimize Collisions)：減少不同鍵對應到相同索引的機率。<br /></li>
<li>計算效率高 (Efficient Computation)：快速計算索引值。<br /></li>
</ul></li>
<li>常見的哈希函數：<br />
<ul class="org-ul">
<li>除法取餘數法 (Modulo Method)：<br /></li>
<li>h(k)=kmod  m<br /></li>
<li>h(k)=kmodm mm 通常取為 質數 以減少碰撞。<br /></li>
<li>乘法法 (Multiplication Method)：<br /></li>
<li>h(k)=⌊m×(kAmod  1)⌋<br /></li>
<li>h(k)=⌊m×(kAmod1)⌋ 其中 AA 為一個介於 0 和 1 之間的常數，如 Knuth’s golden ratio A=0.6180339887A=0.6180339887。<br /></li>
</ul></li>
</ul></li>
<li>哈希表的應用<br />
<ul class="org-ul">
<li>哈希表在許多計算機科學領域都有應用：<br />
<ul class="org-ul">
<li>符號表 (Symbol Table)：如 編譯器 存儲變數名稱與其對應的記憶體位置。<br /></li>
<li>快取機制 (Caching)：如 DNS 快取、記憶體快取 (CPU Cache)。<br /></li>
<li>資料庫索引 (Database Indexing)：如 NoSQL 資料庫 (MongoDB, Redis)。<br /></li>
<li>密碼存儲 (Password Storage)：密碼雜湊 (如 SHA-256)。<br /></li>
<li>字詞計數 (Word Frequency Counting)：如 Google 搜尋引擎的索引。<br /></li>
</ul></li>
</ul></li>
<li>研究所考試應注意的細節<br />
在考試中，考生應熟悉：<br />
<ul class="org-ul">
<li>哈希表的基本操作與時間複雜度。<br /></li>
<li>碰撞處理方法 (鏈結串列法 vs. 開放定址法)。<br /></li>
<li>哈希函數的設計原則。<br /></li>
<li>哈希表與其他資料結構 (如 BST, AVL 樹) 的比較。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org9a25912" class="outline-5">
<h5 id="org9a25912">總結</h5>
<div class="outline-text-5" id="text-org9a25912">
<ul class="org-ul">
<li>錯誤選項為 C，因為刪除操作的平均時間複雜度應為 O(1)O(1)，而非 O(N)O(N)。<br /></li>
<li>哈希表的搜尋、插入、刪除通常都是 O(1)O(1)，但當碰撞嚴重時，最壞情況可達 O(N)O(N)。<br /></li>
<li>考試中應掌握哈希函數設計、碰撞處理策略、負載因子影響等知識，以應對不同的題型。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org015bf05" class="outline-4">
<h4 id="org015bf05"><span class="section-number-4">6.1.7.</span> 7.</h4>
<div class="outline-text-4" id="text-6-1-7">
<p>
Which of the following statements about ARP is wrong?<br />
</p>
<ol class="org-ol">
<li>ARP is used to build up a mapping table of IP addresses to MAC addresses.<br /></li>
<li>ARP is a network protocol at the network layer of the OSI model.<br /></li>
<li>ARP assigns a host an IP address dynamically.<br /></li>
<li>An ARP cache is a collection of ARP entries that are created when an IP address is resolved to a MAC address.<br /></li>
</ol>
</div>
<div id="outline-container-org4fd35ad" class="outline-5">
<h5 id="org4fd35ad">解</h5>
<div class="outline-text-5" id="text-org4fd35ad">
<p>
我們要判斷 哪個選項關於 ARP (Address Resolution Protocol, 位址解析協定) 是錯誤的。<br />
</p>
</div>
</div>
<div id="outline-container-orgf0853d0" class="outline-5">
<h5 id="orgf0853d0">選項分析</h5>
<div class="outline-text-5" id="text-orgf0853d0">
<ol class="org-ol">
<li>ARP 用來建立 IP 位址到 MAC 位址的對應表 (ARP table)<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>ARP (位址解析協定) 主要功能是將 IP 位址轉換為對應的 MAC 位址，因此會維護一張 ARP 表 (ARP table)。<br /></li>
<li>每當一個設備需要與另一個設備通訊時，它會透過 ARP 來查詢對方的 MAC 位址。<br /></li>
</ul></li>
<li>ARP 是 OSI 模型的網路層 (Network Layer) 協定<br />
<ul class="org-ul">
<li>❌ 錯誤（這是正確答案）<br /></li>
<li>ARP 屬於 OSI 第 2 層 (資料鏈結層, Data Link Layer)，而非網路層 (Network Layer)。<br /></li>
<li>雖然 ARP 是為了處理 IP 位址 (第 3 層) 到 MAC 位址 (第 2 層) 的映射，但它實際上運作於 資料鏈結層，因為它直接與 MAC 位址相關。<br /></li>
</ul></li>
<li>ARP 動態分配 IP 位址給主機<br />
<ul class="org-ul">
<li>❌ 錯誤<br /></li>
<li>ARP 並不負責 IP 位址的分配，它只是解決 IP-to-MAC 的對應。<br /></li>
<li>動態 IP 位址分配是由 DHCP (Dynamic Host Configuration Protocol) 負責，而非 ARP。<br /></li>
</ul></li>
<li>ARP 快取 (ARP Cache) 是一組 IP 位址與 MAC 位址的映射表，當 IP 被解析為 MAC 位址時建立<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>ARP 快取 是一張記錄 IP 與 MAC 地址對應關係的表，避免每次通訊都重新發送 ARP 請求，提高效率。<br /></li>
<li>這些映射會根據系統的快取機制保存一段時間，然後自動過期。<br /></li>
</ul></li>
</ol>

<p>
正確答案：B<br />
</p>
<ul class="org-ul">
<li>ARP 屬於資料鏈結層 (Data Link Layer)，而非網路層 (Network Layer)，因此 B 是錯誤的敘述。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge0c75c3" class="outline-5">
<h5 id="orge0c75c3">相關計概知識整理</h5>
<div class="outline-text-5" id="text-orge0c75c3">
<ol class="org-ol">
<li>ARP (Address Resolution Protocol) 簡介<br />
<ul class="org-ul">
<li>ARP (位址解析協定) 是一種通訊協定，用於 將 IP 位址解析為 MAC 位址。當設備想要傳送資料時，它需要知道對方的 MAC 位址，而 ARP 可以幫助完成這個解析過程。<br /></li>
</ul></li>
<li>ARP 工作流程<br />
當主機想要與另一台設備通訊時，會進行以下步驟：<br />
<ol class="org-ol">
<li>查詢 ARP 快取 (ARP Cache)<br />
<ul class="org-ul">
<li>如果 ARP 快取 (本地 ARP 表) 已經有該 IP 對應的 MAC 地址，則直接使用。<br /></li>
<li>若沒有對應記錄，則發送 ARP 請求。<br /></li>
</ul></li>
<li>發送 ARP Request (ARP 請求)<br />
<ul class="org-ul">
<li>若 ARP 快取中沒有該位址，則設備會廣播 (Broadcast) 一個 ARP 請求：<br />
<ul class="org-ul">
<li>「誰擁有 IP 192.168.1.100？請回傳你的 MAC 地址。」<br /></li>
</ul></li>
<li>這個請求是透過 乙太網路 (Ethernet) 廣播 傳送到所有設備。<br /></li>
</ul></li>
<li>目標設備回應 ARP Reply (ARP 回應)<br />
<ul class="org-ul">
<li>擁有該 IP 地址的設備 會回應 ARP 回應 (ARP Reply)：<br />
<ul class="org-ul">
<li>「我是 192.168.1.100，我的 MAC 地址是 00:1A:2B:3C:4D:5E。」<br /></li>
</ul></li>
<li>這個回應是 單播 (Unicast) 傳送 給請求者。<br /></li>
</ul></li>
<li>更新 ARP 快取<br />
<ul class="org-ul">
<li>發送請求的設備將此映射儲存在 ARP 快取中，以便下次使用時不需要重新查詢。<br /></li>
</ul></li>
</ol></li>
<li>ARP 的類型<br />
<ul class="org-ul">
<li>普通 ARP (Standard ARP)<br />
<ul class="org-ul">
<li>用於解析 IP 到 MAC 位址，適用於同一個區域網路 (LAN)。<br /></li>
</ul></li>
<li>逆向 ARP (Reverse ARP, RARP)<br />
<ul class="org-ul">
<li>從 MAC 位址查找對應的 IP 位址，但已被 DHCP 取代。<br /></li>
</ul></li>
<li>代理 ARP (Proxy ARP)<br />
<ul class="org-ul">
<li>路由器代替其他網段的設備回應 ARP 請求，用於連接不同子網。<br /></li>
</ul></li>
<li>免費 ARP (Gratuitous ARP)<br />
<ul class="org-ul">
<li>檢查 IP 位址是否重複，或 主動更新 ARP 快取。<br /></li>
</ul></li>
</ul></li>
<li><p>
ARP 與 DHCP 的區別<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">協定</th>
<th scope="col" class="org-left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ARP (Address Resolution Protocol)</td>
<td class="org-left">解析 IP 位址 → MAC 位址</td>
</tr>

<tr>
<td class="org-left">DHCP (Dynamic Host Configuration Protocol)</td>
<td class="org-left">分配 IP 位址給主機</td>
</tr>
</tbody>
</table>
<p>
區別：<br />
</p>
<ul class="org-ul">
<li>ARP：透過廣播查找 MAC 位址。<br /></li>
<li>DHCP：負責動態分配 IP 位址給設備，並提供 DNS、網關等資訊。<br /></li>
</ul></li>
<li>ARP 的安全性問題<br />
ARP 具有一些安全風險，因為它 不具備驗證機制，容易受到攻擊，例如：<br />
<ul class="org-ul">
<li>ARP 欺騙 (ARP Spoofing)：<br />
<ul class="org-ul">
<li>攻擊者偽造 ARP 回應，導致合法設備將流量發送到攻擊者。<br /></li>
<li>例如，攻擊者回應：「我是 192.168.1.1 (路由器)，請發送所有流量給我！」，進而進行 中間人攻擊 (Man-in-the-Middle, MITM)。<br /></li>
</ul></li>
<li>ARP 洪水攻擊 (ARP Flooding)：<br />
<ul class="org-ul">
<li>攻擊者持續發送大量偽造的 ARP 回應，導致 ARP 快取表爆滿，使網路變慢或宕機。<br /></li>
</ul></li>
</ul></li>
</ol>
<p>
解決方法：<br />
</p>
<ul class="org-ul">
<li>靜態 ARP 表 (Static ARP Table)：設定固定的 IP-MAC 映射，防止惡意變更。<br /></li>
<li>使用 ARP 監控工具：如 arpwatch 來監控異常的 ARP 變化。<br /></li>
<li>啟用動態 ARP 檢測 (DAI, Dynamic ARP Inspection)：可在企業級交換機上防止 ARP 欺騙。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org8da62b5" class="outline-5">
<h5 id="org8da62b5">總結</h5>
<div class="outline-text-5" id="text-org8da62b5">
<ul class="org-ul">
<li>錯誤選項為 B，因為 ARP 是第 2 層 (資料鏈結層) 而非第 3 層 (網路層) 協定。<br /></li>
<li>ARP 用於解析 IP 至 MAC 位址，並不負責 IP 位址分配 (這是 DHCP 的工作)。<br /></li>
<li>ARP 快取用於加快解析過程，避免每次查詢都廣播 ARP 請求。<br /></li>
<li>ARP 存在安全性風險，如 ARP 欺騙攻擊，應透過靜態 ARP 表或動態 ARP 檢測進行防範。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcd57516" class="outline-4">
<h4 id="orgcd57516"><span class="section-number-4">6.1.8.</span> 8.</h4>
<div class="outline-text-4" id="text-6-1-8">
<p>
Which of the following statements about malware is wrong?<br />
</p>
<ol class="org-ol">
<li>A computer must be infected without connecting to a network.<br /></li>
<li>PDF files may contain malware.<br /></li>
<li>Image files may include malware.<br /></li>
<li>Web browsing is safe and will not get infected by malware.<br /></li>
</ol>
</div>
<div id="outline-container-org52b3f7c" class="outline-5">
<h5 id="org52b3f7c">解</h5>
<div class="outline-text-5" id="text-org52b3f7c">
<p>
我們要判斷 哪個選項關於惡意軟體（Malware）的敘述是錯誤的。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8e3c553"></a>選項分析<br />
<div class="outline-text-6" id="text-org8e3c553">
<ol class="org-ol">
<li>電腦即使未連接網路，仍可能被感染<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>惡意軟體（Malware）不一定透過網路傳播，它也可以透過：<br />
<ul class="org-ul">
<li>USB 隨身碟<br /></li>
<li>受感染的軟體安裝包<br /></li>
<li>受感染的文件（如 PDF, EXE, DOCX）<br /></li>
<li>硬體感染（如固件病毒）<br /></li>
</ul></li>
<li>例如 Stuxnet 病毒，就是透過 USB 傳播，攻擊未連網的工業控制系統。<br /></li>
</ul></li>
<li>PDF 檔案可能包含惡意軟體<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>PDF 可能內嵌惡意 JavaScript 或 嵌入式可執行程式，導致電腦被感染。<br /></li>
<li>例如 CVE-2013-0641（Adobe Reader 漏洞）允許攻擊者執行任意程式碼。<br /></li>
</ul></li>
<li>圖片檔案可能包含惡意軟體<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>惡意程式可能隱藏在圖片內，例如：<br />
<ul class="org-ul">
<li>Steganography（隱寫術）：攻擊者在圖片內嵌入惡意程式，透過工具解碼後執行。<br /></li>
<li>格式漏洞攻擊：某些圖片格式（如 JPEG, PNG, GIF）可能因解析漏洞觸發任意代碼執行（如 CVE-2016-3714，ImageMagick 漏洞）。<br /></li>
</ul></li>
</ul></li>
<li>網頁瀏覽是安全的，不會感染惡意軟體<br />
<ul class="org-ul">
<li>❌ 錯誤（這是正確答案）<br /></li>
<li>網頁瀏覽不一定安全！ 惡意網站可能透過：<br />
<ul class="org-ul">
<li>惡意 JavaScript（如 XSS 攻擊）<br /></li>
<li>惡意廣告（Malvertising）<br /></li>
<li>釣魚網站（Phishing Sites）<br /></li>
<li>零時差漏洞攻擊（Zero-day Exploit）<br /></li>
</ul></li>
<li>例如：Drive-by Download 攻擊，當用戶訪問受感染網站時，瀏覽器會自動下載並執行惡意軟體。<br /></li>
</ul></li>
</ol>

<p>
正確答案：D<br />
</p>
<ul class="org-ul">
<li>瀏覽網頁並非絕對安全，錯誤的網站可能導致惡意軟體感染。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org64fcb79" class="outline-5">
<h5 id="org64fcb79">相關計概知識整理</h5>
<div class="outline-text-5" id="text-org64fcb79">
<ol class="org-ol">
<li>惡意軟體（Malware）概述<br />
惡意軟體（Malware, Malicious Software） 指的是設計來傷害、入侵或破壞系統的程式，包含：<br />
<ul class="org-ul">
<li>病毒（Virus）：依附在合法程式上，透過執行傳播。<br /></li>
<li>蠕蟲（Worm）：可獨立運行，通常透過網路傳播。<br /></li>
<li>木馬（Trojan Horse）：偽裝成合法軟體，誘騙使用者安裝。<br /></li>
<li>勒索軟體（Ransomware）：加密使用者檔案，要求支付贖金才能解鎖。<br /></li>
<li>間諜軟體（Spyware）：偷偷收集使用者資訊，例如鍵盤側錄器（Keylogger）。<br /></li>
<li>廣告軟體（Adware）：強制顯示廣告，影響使用者體驗。<br /></li>
<li>Rootkit：隱藏惡意行為，讓系統難以偵測其存在。<br /></li>
</ul></li>

<li><p>
惡意軟體的傳播方式<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">傳播方式</th>
<th scope="col" class="org-left">解釋</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">網路攻擊</td>
<td class="org-left">透過網頁漏洞（XSS, SQL Injection）、惡意廣告、釣魚郵件等方式傳播。</td>
</tr>

<tr>
<td class="org-left">USB 或外部儲存裝置</td>
<td class="org-left">例如 Stuxnet 病毒透過 USB 傳播到未連網的系統。</td>
</tr>

<tr>
<td class="org-left">電子郵件附件</td>
<td class="org-left">攻擊者透過釣魚郵件附加惡意檔案，如 EXE、PDF、Word 文件等。</td>
</tr>

<tr>
<td class="org-left">軟體安裝包</td>
<td class="org-left">某些非法軟體（如盜版軟體、破解版）可能夾帶木馬程式。</td>
</tr>

<tr>
<td class="org-left">即時訊息與社群媒體</td>
<td class="org-left">惡意連結或下載檔案可能會在社群網站（如 Facebook, Line, Discord）上傳播。</td>
</tr>
</tbody>
</table></li>
<li>圖片與 PDF 如何成為攻擊媒介？<br />
<ul class="org-ul">
<li>(1) 圖片檔案中的惡意軟體<br />
<ul class="org-ul">
<li>攻擊者可能利用以下技術：<br /></li>
<li>隱寫術（Steganography）<br />
<ul class="org-ul">
<li>在圖片中嵌入惡意程式碼，使用者下載後再透過工具解碼執行。<br /></li>
<li>例如「Evil JPEG Attack」可以透過圖片執行惡意指令。<br /></li>
</ul></li>
<li>格式漏洞攻擊<br />
<ul class="org-ul">
<li>某些圖片格式解析器（如 ImageMagick, Windows GDI+）存在漏洞，可導致遠端執行惡意程式碼。<br /></li>
<li>案例：CVE-2016-3714（ImageMagick 漏洞） 允許攻擊者透過圖片檔案執行任意命令。<br /></li>
</ul></li>
</ul></li>
<li>(2) PDF 文件中的惡意軟體<br />
<ul class="org-ul">
<li>內嵌 JavaScript<br />
<ul class="org-ul">
<li>PDF 可執行 JavaScript，攻擊者可能利用此功能來下載惡意程式。<br /></li>
<li>案例：CVE-2013-0641（Adobe Reader 漏洞）<br /></li>
</ul></li>
<li>嵌入式惡意代碼<br />
<ul class="org-ul">
<li>某些 PDF 可能包含 EXE、Shellcode 或 遠端載入惡意程式，一旦打開 PDF，惡意程式就會執行。<br /></li>
</ul></li>
</ul></li>
</ul></li>
<li>針對惡意軟體的防禦措施<br />
<ul class="org-ul">
<li>定期更新作業系統與軟體: 使用 Windows Update、MacOS 更新來修補安全漏洞。<br /></li>
<li>安裝防毒軟體:使用知名防毒軟體（如 Windows Defender、ESET、Kaspersky）來即時監測惡意軟體。<br /></li>
<li>避免開啟未知附件與下載檔案:切勿開啟不明來源的 PDF、Word、EXE 檔案。<br /></li>
<li>避免造訪不安全網站:不要點擊可疑連結！ 使用 HTTPS 網站，並安裝瀏覽器安全擴充功能（如 uBlock Origin）。<br /></li>
<li>使用沙盒技術（Sandboxing）:透過 Windows Sandbox、Virtual Machine 測試可疑軟體。<br /></li>
<li>啟用 Windows Defender ATP 或類似安全機制:企業環境可使用 端點防護（Endpoint Protection） 來阻擋高級惡意攻擊。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org2ec6121" class="outline-4">
<h4 id="org2ec6121"><span class="section-number-4">6.1.9.</span> 9.</h4>
<div class="outline-text-4" id="text-6-1-9">
<p>
Which of the following statements about process scheduling is wrong?<br />
</p>
<ol class="org-ol">
<li>FIFO scheduling may result long waiting time.<br /></li>
<li>Round-robin scheduling has the shortest waiting time.<br /></li>
<li>A very large time quantum in round-robin scheduling results in FIFO scheduling.<br /></li>
<li>Round-robin scheduling is suitable for interactive systems as it has short response time.<br /></li>
</ol>
</div>
<div id="outline-container-org3a3a336" class="outline-5">
<h5 id="org3a3a336">解</h5>
<div class="outline-text-5" id="text-org3a3a336">
<p>
本題考察的是 程序排程 (Process Scheduling)，我們需要判斷 哪個選項是錯誤的。<br />
</p>
</div>
</div>
<div id="outline-container-orgc6e0e65" class="outline-5">
<h5 id="orgc6e0e65">選項分析</h5>
<div class="outline-text-5" id="text-orgc6e0e65">
<ol class="org-ol">
<li>FIFO（先來先服務）排程可能導致長時間等待<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>FIFO（First-In-First-Out） 也稱為 FCFS（First-Come-First-Served），是最簡單的排程策略，按照到達順序執行。<br /></li>
<li>問題：可能導致「等待時間過長」，特別是當第一個工作執行時間過長時，後面的工作都要等待（稱為「短任務飢餓 (Convoy Effect)」）。<br /></li>
</ul></li>
<li>RR（Round-Robin）排程擁有最短的等待時間<br />
<ul class="org-ul">
<li>❌ 錯誤（這是正確答案）<br /></li>
<li>RR（Round-Robin，循環輪轉） 主要用於 時間分片系統，將 CPU 時間分配給每個程序，然後依序執行。<br /></li>
<li>問題：RR 不一定能保證最短的等待時間，因為：<br />
<ul class="org-ul">
<li>如果 時間片（time quantum）過小，上下文切換（context switching）開銷大，影響效能。<br /></li>
<li>如果 時間片過大，則會變得接近 FIFO 排程，造成長等待時間。<br /></li>
<li>最短等待時間的排程算法通常是 SJF（Shortest Job First, 最短作業優先）或 SRJF（Shortest Remaining Job First, 最短剩餘時間優先）。<br /></li>
</ul></li>
</ul></li>
<li>在 RR 排程中，若時間片過大，則會變成 FIFO<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>如果 時間片（Time Quantum）設定過大，每個進程都能執行完整任務，這等同於FCFS（先來先服務），因為每個進程都會按照順序執行完畢。<br /></li>
</ul></li>
<li>RR 排程適用於互動式系統，因為它具有短回應時間<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li>RR 排程適合交互式系統，因為它可以確保每個進程都能在合理的時間內獲得 CPU 時間，減少用戶等待。<br /></li>
<li>例如，多工操作系統（如 Linux, Windows） 通常使用 RR 排程來確保交互式應用程式（如瀏覽器、文字編輯器）可以快速響應使用者輸入。<br /></li>
</ul></li>

<li>正確答案：B<br /></li>
<li>因為 RR 並不一定擁有最短的等待時間，SJF 或 SRJF 通常會有更短的等待時間，因此 B 是錯誤的敘述。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orga05057a" class="outline-5">
<h5 id="orga05057a">相關計概知識整理</h5>
<div class="outline-text-5" id="text-orga05057a">
<ol class="org-ol">
<li>什麼是程序排程 (Process Scheduling)？<br />
程序排程是 作業系統（Operating System, OS） 分配 CPU 給不同進程的機制。根據進程狀態，可以分為：<br />
<ul class="org-ul">
<li>長程排程（Long-term Scheduling）：決定哪些程序進入主記憶體。<br /></li>
<li>中程排程（Medium-term Scheduling）：決定哪些程序需要被暫停（如交換到磁碟）。<br /></li>
<li>短程排程（Short-term Scheduling, CPU Scheduling）：決定哪個進程獲得 CPU，通常是考試重點。<br /></li>
</ul></li>
<li><p>
常見的排程算法<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">排程策略</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">優點</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">FCFS（FIFO）</td>
<td class="org-left">先來先服務</td>
<td class="org-left">簡單、無需上下文切換</td>
<td class="org-left">可能導致長等待時間（短任務飢餓）</td>
</tr>

<tr>
<td class="org-left">SJF（最短作業優先）</td>
<td class="org-left">先執行最短的任務</td>
<td class="org-left">最短平均等待時間</td>
<td class="org-left">可能造成長作業飢餓</td>
</tr>

<tr>
<td class="org-left">SRJF（最短剩餘時間優先）</td>
<td class="org-left">允許短任務插隊</td>
<td class="org-left">進一步降低等待時間</td>
<td class="org-left">需要預測作業時間，可能有飢餓問題</td>
</tr>

<tr>
<td class="org-left">RR（Round-Robin）</td>
<td class="org-left">每個進程輪流獲得 CPU 時間片</td>
<td class="org-left">適合交互式系統，低響應時間</td>
<td class="org-left">上下文切換開銷大，時間片選擇影響效能</td>
</tr>

<tr>
<td class="org-left">Priority Scheduling（優先級排程）</td>
<td class="org-left">依照優先權執行</td>
<td class="org-left">適用於不同類型的任務</td>
<td class="org-left">低優先權任務可能永遠不被執行（飢餓問題）</td>
</tr>

<tr>
<td class="org-left">Multilevel Queue（多級佇列）</td>
<td class="org-left">分類不同類型的進程並指定不同排程</td>
<td class="org-left">可根據需求分層</td>
<td class="org-left">複雜，佇列之間的權重難以調整</td>
</tr>

<tr>
<td class="org-left">Multilevel Feedback Queue（多級回饋佇列）</td>
<td class="org-left">允許進程根據執行時間在佇列間移動</td>
<td class="org-left">適應性高，可兼顧多種需求</td>
<td class="org-left">設計複雜，參數難調整</td>
</tr>
</tbody>
</table></li>
<li>RR 排程與時間片（Time Quantum）<br />
<ul class="org-ul">
<li>時間片（Time Quantum, TQ）大小對系統效能影響很大：<br />
<ul class="org-ul">
<li>時間片太小 → 頻繁上下文切換，效率低。<br /></li>
<li>時間片太大 → 變成 FIFO，交互式系統響應變慢。<br /></li>
</ul></li>
<li>如何選擇最佳時間片？<br />
<ul class="org-ul">
<li>一般來說，TQ 應該大於上下文切換時間，但小於交互式應用程式的執行時間，以確保流暢性。<br /></li>
</ul></li>
</ul></li>
<li>CPU 排程評估指標<br />
考試可能會考 如何評估 CPU 排程的好壞，這些指標包括：<br />
<ol class="org-ol">
<li>等待時間（Waiting Time, WT）<br />
<ul class="org-ul">
<li>WT=完成時間−到達時間−執行時間<br /></li>
<li>愈短愈好，代表進程不用等太久。<br /></li>
<li>SJF/SRJF 通常有最短的等待時間。<br /></li>
</ul></li>
<li>周轉時間（Turnaround Time, TAT）<br />
<ul class="org-ul">
<li>TAT=完成時間−到達時間<br /></li>
<li>愈短愈好，代表進程可以更快完成。<br /></li>
</ul></li>
<li>回應時間（Response Time, RT）<br />
<ul class="org-ul">
<li>RT=第一次獲得 CPU 的時間−到達時間<br /></li>
<li>RR 排程通常有較短的回應時間，適合交互式系統。<br /></li>
</ul></li>
<li>CPU 使用率（CPU Utilization）<br />
<ul class="org-ul">
<li>越高越好，代表 CPU 不會閒置太久。<br /></li>
</ul></li>
<li>吞吐量（Throughput）<br />
<ul class="org-ul">
<li>單位時間內完成的進程數，愈高愈好。<br /></li>
</ul></li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-org1157df5" class="outline-5">
<h5 id="org1157df5">總結</h5>
<div class="outline-text-5" id="text-org1157df5">
<ul class="org-ul">
<li>錯誤選項為 B，因為 RR 排程並不一定擁有最短的等待時間，SJF 或 SRJF 才通常有最短的等待時間。<br /></li>
<li>FIFO 可能導致長等待時間，特別是「短任務飢餓」問題。<br /></li>
<li>如果 RR 的時間片過大，則變成 FIFO 排程。<br /></li>
<li>RR 適合交互式系統，因為它能確保每個進程定期獲得 CPU 執行，降低回應時間。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2b4c1b1" class="outline-4">
<h4 id="org2b4c1b1"><span class="section-number-4">6.1.10.</span> 10.</h4>
<div class="outline-text-4" id="text-6-1-10">
<p>
If binary trees are represented in arrays, what formula can be used to locate the left child of node i?<br />
</p>
<ol class="org-ol">
<li>2i.<br /></li>
<li>2i+1.<br /></li>
<li>2i-1.<br /></li>
<li>None of the above.<br /></li>
</ol>
</div>
<div id="outline-container-orgdfc0865" class="outline-5">
<h5 id="orgdfc0865">解</h5>
<div class="outline-text-5" id="text-orgdfc0865">
<p>
本題考察的是 用陣列（Array）表示二元樹（Binary Tree）時，如何計算子節點的位置。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org93fdf82"></a>1. 陣列表示二元樹的規則<br />
<div class="outline-text-6" id="text-org93fdf82">
<p>
在陣列中儲存二元樹時，根節點（Root）通常放在索引 1（有時候也會從索引 0 開始，但考試多數情境假設從 1 開始）。對於 節點 ii，其左子節點（Left Child） 和 右子節點（Right Child） 的索引可以透過數學公式計算。<br />
</p>
<ul class="org-ul">
<li>左子節點（Left Child）的位置：<br />
<ul class="org-ul">
<li>Left(i)=2i<br /></li>
</ul></li>
<li>右子節點（Right Child）的位置：<br />
<ul class="org-ul">
<li>Right(i)=2i+1<br /></li>
</ul></li>
<li>父節點（Parent）的位置：<br />
<ul class="org-ul">
<li>Parent(i)=⌊i/2⌋<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org2137624"></a>2. 選項分析<br />
<div class="outline-text-6" id="text-org2137624">
<ol class="org-ol">
<li>左子節點的位置是 2i2i<br />
<ul class="org-ul">
<li>✅ 正確（這是答案）<br /></li>
<li>根據上述公式，左子節點的位置為 2i2i。<br /></li>
</ul></li>
<li>左子節點的位置是 2i+12i+1<br />
<ul class="org-ul">
<li>❌ 錯誤<br /></li>
<li>這其實是 右子節點 的計算公式。<br /></li>
</ul></li>
<li>左子節點的位置是 2i−12i−1<br />
<ul class="org-ul">
<li>❌ 錯誤<br /></li>
<li>沒有這樣的規則，這個公式不符合二元樹的數組表示法。<br /></li>
</ul></li>
<li>以上皆非<br />
<ul class="org-ul">
<li>❌ 錯誤<br /></li>
<li>A 選項是正確的，因此這個選項錯誤。<br /></li>
</ul></li>
</ol>

<p>
正確答案：A<br />
</p>
<ul class="org-ul">
<li>Left(i)=2i<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgca76772" class="outline-5">
<h5 id="orgca76772">相關計概知識整理</h5>
<div class="outline-text-5" id="text-orgca76772">
<ol class="org-ol">
<li>陣列表示二元樹<br />
在程式設計中，二元樹可以用 指標（鏈結串列 Linked List） 或 陣列（Array） 來表示。其中 用陣列表示二元樹 時：<br />
<ul class="org-ul">
<li>根節點（Root） 儲存在索引 1（有些情況從索引 0 開始）。<br /></li>
<li>節點的子節點可以透過索引計算，而不需要指標。<br /></li>
<li>常用於堆積（Heap）結構、二元樹排序（Binary Tree Sort）等應用。<br /></li>
</ul></li>
<li><p>
陣列與二元樹的映射關係<br />
假設陣列儲存的二元樹如下：<br />
</p>
<pre class="example" id="org061ff3a">
          A(1)
         /    \
      B(2)    C(3)
     /   \    /   \
    D(4)  E(5) F(6) G(7)
</pre>
<ul class="org-ul">
<li><p>
則陣列表示為：<br />
</p>
<pre class="example" id="org3eaf242">
     Index:  1   2   3   4   5   6   7
     Value:  A   B   C   D   E   F   G
</pre></li>
<li>索引關係：<br />
<ul class="org-ul">
<li>B 的索引為 2，A 的左子節點索引為 2×1=22×1=2<br /></li>
<li>C 的索引為 3，A 的右子節點索引為 2×1+1=32×1+1=3<br /></li>
<li>D 的索引為 4，B 的左子節點索引為 2×2=42×2=4<br /></li>
<li>E 的索引為 5，B 的右子節點索引為 2×2+1=52×2+1=5<br /></li>
</ul></li>
<li>這證明了：Left(i)=2i,Right(i)=2i+1<br /></li>
</ul></li>
<li>陣列表示法的優點與缺點<br />
<ul class="org-ul">
<li>優點<br />
<ul class="org-ul">
<li>節省記憶體<br />
<ul class="org-ul">
<li>不需要額外指標儲存左右子節點的地址，只需一個陣列即可表示樹。<br /></li>
<li>適合滿二元樹（Complete Binary Tree），因為節點佔用位置連續，無需浪費空間。<br /></li>
</ul></li>
<li>快速查找父節點與子節點<br />
<ul class="org-ul">
<li>透過數學計算即可獲得左右子節點和父節點，效率高。<br /></li>
</ul></li>
<li>適合應用於堆積（Heap）與優先佇列（Priority Queue）<br />
<ul class="org-ul">
<li>最大堆積（Max Heap）與最小堆積（Min Heap） 經常使用陣列來存儲，並透過這些公式來操作堆積資料。<br /></li>
</ul></li>
</ul></li>
<li>缺點<br />
<ul class="org-ul">
<li>不適合不規則的二元樹<br />
<ul class="org-ul">
<li>若二元樹的結構不規則（如有很多空節點），會造成陣列有大量浪費的空間。<br /></li>
</ul></li>
<li>難以動態調整<br />
<ul class="org-ul">
<li>如果二元樹需要頻繁增加或刪除節點，使用 鏈結串列（Linked List） 可能更靈活。<br /></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>
相關考試重點<br />
在研究所考試中，常見的考點包括：<br />
</p>
<ul class="org-ul">
<li>陣列與二元樹的對應關係<br /></li>
<li>如何根據節點索引計算父節點與子節點<br /></li>
<li>堆積排序（Heap Sort）與優先佇列的操作<br /></li>
<li>二元樹的不同表示方式（陣列 vs. 鏈結串列）<br /></li>
<li>二元樹的應用，如 Huffman 編碼、搜尋樹（BST）<br /></li>
</ul>
<p>
常見題型<br />
</p>
<ul class="org-ul">
<li>給定一個二元樹的陣列表示，求某個節點的左、右子節點<br /></li>
<li>堆積（Heap）的插入與刪除操作<br /></li>
<li>求滿二元樹的節點數與陣列索引關係<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orga130bb8" class="outline-5">
<h5 id="orga130bb8">總結</h5>
<div class="outline-text-5" id="text-orga130bb8">
<ul class="org-ul">
<li>正確答案為 A，因為二元樹中節點 ii 的左子節點位置為 2i2i。<br /></li>
<li>陣列儲存二元樹時，索引計算為：<br />
<ul class="org-ul">
<li>左子節點：2i2i<br /></li>
<li>右子節點：2i+12i+1<br /></li>
<li>父節點：⌊i/2⌋⌊i/2⌋<br /></li>
</ul></li>
<li>這種方式適合「滿二元樹」或「完全二元樹」，但對於稀疏樹會浪費大量空間。<br /></li>
<li>考試可能會考「給定陣列，找出二元樹節點關係」，務必熟記公式並能快速推導。<br /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb9e8c5b" class="outline-3">
<h3 id="orgb9e8c5b"><span class="section-number-3">6.2.</span> 複選</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-orgb3829a1" class="outline-4">
<h4 id="orgb3829a1"><span class="section-number-4">6.2.1.</span> 11.</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
A tautology is a compound statement which always results in Truth value. Which one(s) of the following statements is(are) tautology(tautologies)?<br />
</p>
<ol class="org-ol">
<li>(p ∧ q)→q<br /></li>
<li>q→(p ∧ q)<br /></li>
<li>p∨(p→q)<br /></li>
<li>q∨(p∧q)<br /></li>
</ol>
</div>
<div id="outline-container-org03872ad" class="outline-5">
<h5 id="org03872ad">解</h5>
<div class="outline-text-5" id="text-org03872ad">
<p>
本題考察的是重言式（Tautology），也就是邏輯上「無論變數如何變化，結果永遠為真」的命題。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgf26b826"></a>1. 重言式（Tautology）簡介<br />
<div class="outline-text-6" id="text-orgf26b826">
<p>
重言式（Tautology） 是指 無論命題變數 p,q,r,&#x2026;p,q,r,&#x2026; 取任何真值，整個命題的結果永遠為真（T）。<br />
</p>

<p>
舉例：<br />
</p>
<ul class="org-ul">
<li>p∨¬pp∨¬p （排中律，永遠為真）<br /></li>
<li>(p→q)∨(¬p)(p→q)∨(¬p) （蘊涵的等價形式，永遠為真）<br /></li>
</ul>

<p>
相對地：<br />
</p>
<ul class="org-ul">
<li>矛盾式（Contradiction）：無論變數如何變化，結果永遠為假（F），例如 p∧¬pp∧¬p。<br /></li>
<li>可滿足式（Satisfiable）：有些情況為真，有些情況為假。<br /></li>
</ul>
</div>
</li>
<li><a id="org91a06be"></a>2. 選項分析<br />
<div class="outline-text-6" id="text-org91a06be">
<p>
我們透過真值表來檢驗每個命題是否為重言式。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org894c1e4"></a>(A) (p∧q)→q(p∧q)→q<br />
<div class="outline-text-7" id="text-org894c1e4">
<p>
等價轉換： (p∧q)→q<br />
</p>
<ul class="org-ul">
<li>蘊涵 A→BA→B 的邏輯規則是：當 AA 為真且 BB 為假時，結果為假；其他情況皆為真。<br /></li>
<li>(p∧q)(p∧q) 表示 p,qp,q 皆為真時才為真，否則為假。<br /></li>
<li>當 p∧qp∧q 為真時，qq 也必然為真，因此此命題永遠為真。<br /></li>
</ul>

<p>
✅ AA 是重言式（Tautology）<br />
</p>
</div>
</li>
<li><a id="orgf914680"></a>(B) q→(p∧q)q→(p∧q)<br />
<div class="outline-text-7" id="text-orgf914680">
<p>
等價轉換： q→(p∧q)<br />
</p>
<ul class="org-ul">
<li>當 qq 為假時，蘊涵公式必為真（因為 A→BA→B 當 AA 為假時，無論 BB 為何皆為真）。<br /></li>
<li>當 qq 為真時，則公式變為 p∧qp∧q：<br />
<ul class="org-ul">
<li>如果 pp 為假，則 p∧qp∧q 也為假，導致 q→(p∧q)q→(p∧q) 為假。<br /></li>
</ul></li>
</ul>
<p>
🚫 BB 不是重言式（有些情況為假）<br />
</p>
</div>
</li>
<li><a id="orgb0f1874"></a>(C) p∨(p→q)p∨(p→q)<br />
<div class="outline-text-7" id="text-orgb0f1874">
<p>
等價轉換：p∨(¬p∨q)<br />
</p>

<p>
根據分配律（Distributive Law）：(p∨¬p)∨q<br />
</p>
<ul class="org-ul">
<li>p∨¬pp∨¬p 永遠為真（排中律），所以整個式子也永遠為真。<br /></li>
</ul>
<p>
✅ CC 是重言式（Tautology）<br />
</p>
</div>
</li>
<li><a id="orga43bac8"></a>(D) q∨(p∧q)q∨(p∧q)<br />
<div class="outline-text-7" id="text-orga43bac8">
<p>
等價轉換：q∨pq<br />
</p>
<ul class="org-ul">
<li>根據 吸收律（Absorption Law），q∨(p∧q)q∨(p∧q) 會簡化為 qq。<br /></li>
<li>qq 並不總是為真，當 q=Fq=F 時，整個命題為假。<br /></li>
</ul>

<p>
🚫 DD 不是重言式（有些情況為假）<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org1625b52"></a>3. 最終答案<br />
<div class="outline-text-6" id="text-org1625b52">
<ul class="org-ul">
<li>✅ A. (p∧q)→q(p∧q)→q 是重言式<br /></li>
<li>✅ C. p∨(p→q)p∨(p→q) 是重言式<br /></li>
<li>🚫 B. q→(p∧q)q→(p∧q) 不是重言式<br /></li>
<li>🚫 D. q∨(p∧q)q∨(p∧q) 不是重言式<br /></li>
</ul>
<p>
正確答案：A, C<br />
</p>
</div>
</li>
<li><a id="org4f84e25"></a>4. 相關計概知識整理<br />
<div class="outline-text-6" id="text-org4f84e25">
<ul class="org-ul">
<li><p>
(1) 命題邏輯（Propositional Logic）<br />
命題邏輯是計算機概論與離散數學的基礎，常見運算符包括：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">符號</th>
<th scope="col" class="org-left">運算</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">¬p¬p</td>
<td class="org-left">否定</td>
<td class="org-left">pp 為真時，¬p¬p 為假</td>
</tr>

<tr>
<td class="org-left">p∧qp∧q</td>
<td class="org-left">連接</td>
<td class="org-left">p,qp,q 皆為真時，才為真</td>
</tr>

<tr>
<td class="org-left">p∨qp∨q</td>
<td class="org-left">選擇</td>
<td class="org-left">p,qp,q 只要有一個為真，就為真</td>
</tr>

<tr>
<td class="org-left">p→qp→q</td>
<td class="org-left">蘊涵</td>
<td class="org-left">當 pp 為真但 qq 為假時，結果為假；其他皆為真</td>
</tr>

<tr>
<td class="org-left">p↔qp↔q</td>
<td class="org-left">雙條件</td>
<td class="org-left">p,qp,q 具有相同值時，為真</td>
</tr>
</tbody>
</table></li>
<li>(2) 命題邏輯的主要性質<br />
<ol class="org-ol">
<li>重言式（Tautology）：<br />
<ul class="org-ul">
<li>命題無論如何都為真，例如：<br /></li>
<li>p∨¬p<br /></li>
</ul></li>
<li>矛盾式（Contradiction）：<br />
<ul class="org-ul">
<li>命題無論如何都為假，例如：<br /></li>
<li>p∧¬p<br /></li>
</ul></li>
<li>可滿足式（Satisfiable）：<br />
<ul class="org-ul">
<li>至少有一種變數賦值能使命題為真，例如：<br /></li>
<li>p∨q<br /></li>
<li>只有在 p=F,q=Fp=F,q=F 時才為假。<br /></li>
</ul></li>
</ol></li>
<li>(3) 常見的邏輯定理<br />
<ol class="org-ol">
<li>德摩根定律（De Morgan’s Law）<br />
<ul class="org-ul">
<li>¬(p∧q)≡¬p∨¬q<br /></li>
<li>¬(p∨q)≡¬p∧¬q<br /></li>
</ul></li>
<li>蘊涵的等價轉換<br />
<ul class="org-ul">
<li>p→q≡¬p∨q<br /></li>
</ul></li>
<li>吸收律（Absorption Law）<br />
<ul class="org-ul">
<li>p∨(p∧q)≡p<br /></li>
</ul></li>
<li>排中律（Law of Excluded Middle）<br />
<ul class="org-ul">
<li>p∨¬p=T<br /></li>
</ul></li>
</ol></li>
</ul>
<p>
（任何命題 pp 不是真就是假）<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6ca1d34" class="outline-4">
<h4 id="org6ca1d34"><span class="section-number-4">6.2.2.</span> 12.</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
Logical inference is used to create new sentences that logically follow from a given set of predicate calculus sentences (KB). An inference rule is sound if any sentence X produced by an inference rule operating on a KB logically follows from the KB. A rule is sound if its conclusion is true whenever the premises is true. Which one(s) of the following rules is(are) sound?<br />
</p>
<ol class="org-ol">
<li>Premise: p, p→q; conclusion: q<br /></li>
<li>Premise: p, q; conclusion: p ∧ q<br /></li>
<li>Premise: p ∧ q; conclusion: p<br /></li>
<li>Premise: ¬¬p; conclusion: p<br /></li>
</ol>
</div>
<div id="outline-container-orgd81aed2" class="outline-5">
<h5 id="orgd81aed2">解</h5>
<div class="outline-text-5" id="text-orgd81aed2">
<p>
本題考察的是邏輯推理（Logical Inference）與推理規則的正確性（Soundness）。推理規則是邏輯系統中的一組規則，這些規則允許我們從已知的前提（Premises）導出新的結論（Conclusions）。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org54e6042"></a>何謂「Sound 推理規則」？<br />
<div class="outline-text-6" id="text-org54e6042">
<ul class="org-ul">
<li>「Soundness」（健全性）：如果一個推理規則能夠保證「前提為真時，結論必定為真」，則該推理規則是健全的（Sound）。<br /></li>
<li>換句話說，如果一個推理規則是 Sound，那麼它的結論必然是正確的，不會導出錯誤的推論。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1c894e8" class="outline-5">
<h5 id="org1c894e8">選項分析</h5>
<div class="outline-text-5" id="text-org1c894e8">
<p>
我們需要檢查每個推理規則是否為Sound，也就是當前提為真時，結論是否一定為真。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd165294"></a>(A) 前提：p,p→q; 結論：qq<br />
<div class="outline-text-6" id="text-orgd165294">
<p>
這是 Modus Ponens（MP，肯定前件） 推理規則：\( \frac{p, p->q}{q\)<br />
</p>
<ul class="org-ul">
<li>解釋： 如果我們知道 pp 為真，且 p→qp→q 為真，那麼 qq 必然為真。<br /></li>
<li>這是一個 Sound 推理規則，因為它符合邏輯蘊涵的定義。<br /></li>
</ul>
<p>
✅ AA 是 Sound 的推理規則。<br />
</p>
</div>
</li>
<li><a id="orga1ee099"></a>(B) 前提：p,q; 結論：p∧qp∧q<br />
<div class="outline-text-6" id="text-orga1ee099">
<p>
這是 Conjunction（合取規則）：\(\frac{p,q}{p^q}\)<br />
</p>
<ul class="org-ul">
<li>解釋： 如果 pp 為真，且 qq 也為真，那麼 p∧q 也必然為真。<br /></li>
<li>這是一個 Sound 推理規則，因為合取律（Conjunction Rule）是正確的邏輯運算。<br /></li>
</ul>
<p>
✅ BB 是 Sound 的推理規則。<br />
</p>
</div>
</li>
<li><a id="org88bd340"></a>(C) 前提：p∧q; 結論：pp<br />
<div class="outline-text-6" id="text-org88bd340">
<p>
這是 Simplification（簡化規則）：\(\frac{p \land q}{p}\)<br />
</p>
<ul class="org-ul">
<li>解釋： 如果 p∧qp∧q 為真，那麼 pp 必然為真（因為 p∧qp∧q 表示兩者皆為真）。<br /></li>
<li>這是一個 Sound 推理規則，因為 p∧qp∧q 蘊含 pp。<br /></li>
</ul>
<p>
✅ CC 是 Sound 的推理規則。<br />
</p>
</div>
</li>
<li><a id="orga02f589"></a>(D) 前提：¬¬p¬¬p; 結論：pp<br />
<div class="outline-text-6" id="text-orga02f589">
<p>
這是 Double Negation（雙重否定律）：\(\frac{\lnot \lnot p}{p}\)<br />
</p>
<ul class="org-ul">
<li>解釋： 在**經典邏輯（Classical Logic）**中，雙重否定成立，即：  ¬¬p≡p<br /></li>
<li>這是一個 Sound 推理規則，因為在任何情況下，¬¬p 與 pp 具有相同的真值。<br /></li>
</ul>
<p>
✅ DD 是 Sound 的推理規則。<br />
</p>
</div>
</li>
<li><a id="org902191e"></a>最終答案<br />
<div class="outline-text-6" id="text-org902191e">
<ul class="org-ul">
<li>✅ A. p,p→q⇒qp,p→q⇒q （Modus Ponens）<br /></li>
<li>✅ B. p,q⇒p∧qp,q⇒p∧q （Conjunction）<br /></li>
<li>✅ C. p∧q⇒pp∧q⇒p （Simplification）<br /></li>
<li>✅ D. ¬¬p⇒p¬¬p⇒p （Double Negation）<br /></li>
</ul>
<p>
正確答案：A, B, C, D（全部皆為 Sound）<br />
</p>
</div>
</li>
<li><a id="org5c718de"></a>相關計概知識整理<br />
<ul class="org-ul">
<li><a id="orgfbd1092"></a>(1) 邏輯推理（Logical Inference）<br />
<div class="outline-text-7" id="text-orgfbd1092">
<p>
在命題邏輯中，我們使用推理規則從已知事實（前提）導出新的結論。這些推理規則可分為：<br />
</p>
<ul class="org-ul">
<li>健全（Sound）推理：確保推導出的結論永遠正確（如本題所有選項）。<br /></li>
<li>完全（Complete）推理：確保所有可以推導的結論都能被推導出來。<br /></li>
</ul>
</div>
</li>
<li><a id="orgf3f646f"></a>(2) 常見的邏輯推理規則<br />
<div class="outline-text-7" id="text-orgf3f646f">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">規則</th>
<th scope="col" class="org-left">表達式</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Modus Ponens（肯定前件）</td>
<td class="org-left">p,p→q⇒q</td>
<td class="org-left">如果 p 為真，且 p→qp→q 為真，則 q 必然為真。</td>
</tr>

<tr>
<td class="org-left">Modus Tollens（否定後件）</td>
<td class="org-left">p→q,¬q⇒¬p</td>
<td class="org-left">如果 p→q為真，且 q 為假，則 p 必然為假。</td>
</tr>

<tr>
<td class="org-left">Hypothetical Syllogism（假言三段論）</td>
<td class="org-left">p→q,q→r⇒p→r</td>
<td class="org-left">如果 p 導致 q，且 qq 導致 r，則 p 也導致 r。</td>
</tr>

<tr>
<td class="org-left">Disjunctive Syllogism（選言三段論）</td>
<td class="org-left">p∨q,¬p⇒q</td>
<td class="org-left">如果 p∨qp∨q 為真，且 pp 為假，則 q 必然為真。</td>
</tr>

<tr>
<td class="org-left">Conjunction（合取）</td>
<td class="org-left">p,q⇒p∧q</td>
<td class="org-left">如果 p 為真，且 q 也為真，則 p∧q 必然為真。</td>
</tr>

<tr>
<td class="org-left">Simplification（簡化）</td>
<td class="org-left">p∧q⇒p</td>
<td class="org-left">如果 p∧q 為真，則 p 必然為真。</td>
</tr>

<tr>
<td class="org-left">Addition（加法）</td>
<td class="org-left">p⇒p∨q</td>
<td class="org-left">如果 p 為真，則 p∨q 也必然為真。</td>
</tr>

<tr>
<td class="org-left">Double Negation（雙重否定律）</td>
<td class="org-left">¬¬p⇒p</td>
<td class="org-left">¬¬p 與 p 具有相同的真值。</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge4ec639" class="outline-4">
<h4 id="orge4ec639"><span class="section-number-4">6.2.3.</span> 13.</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
Which one(s) of the following statements about time complexity is/are correct?<br />
</p>
<ol class="org-ol">
<li>The average time complexity of search in a double-linked list is O(N).<br /></li>
<li>The worst time complexity of insertion in a double-linked list is O(N).<br /></li>
<li>The average time complexity of search in a binary search tree is O(logN).<br /></li>
<li>The worst time complexity of search in a binary search tree is O(N).<br /></li>
</ol>
</div>
<div id="outline-container-orgfcd1b96" class="outline-5">
<h5 id="orgfcd1b96">解</h5>
<div class="outline-text-5" id="text-orgfcd1b96">
<p>
本題考察的是 時間複雜度（Time Complexity），並且涉及雙向鏈結串列（Doubly Linked List） 和 二元搜尋樹（Binary Search Tree, BST） 的操作，包括搜尋（Search）和插入（Insertion）。<br />
</p>
</div>
</div>
<div id="outline-container-orgeebdd7b" class="outline-5">
<h5 id="orgeebdd7b">1. 選項分析</h5>
<div class="outline-text-5" id="text-orgeebdd7b">
<p>
我們逐一檢視每個選項的正確性：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7917c5e"></a>(A) 在雙向鏈結串列（Doubly Linked List）中，搜尋的平均時間複雜度為 O(N)O(N)。<br />
<div class="outline-text-6" id="text-org7917c5e">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>搜尋（Search） 在 雙向鏈結串列（Doubly Linked List） 中通常使用線性搜尋（Linear Search），因為鏈結串列不支援隨機存取（不像陣列）。<br /></li>
<li>最壞情況：需要遍歷整個串列，時間複雜度為 O(N)O(N)。<br /></li>
<li>平均情況：假設搜尋目標隨機分佈，則平均要搜尋約 N/2N/2 個節點，時間複雜度仍然為 O(N)O(N)。<br /></li>
</ul>
</div>
</li>
<li><a id="orga6761df"></a>(B) 在雙向鏈結串列中，插入的最壞時間複雜度為 O(N)O(N)。<br />
<div class="outline-text-6" id="text-orga6761df">
<p>
❌ 錯誤<br />
</p>
<ul class="org-ul">
<li>雙向鏈結串列的插入（Insertion） 涉及兩個步驟：<br />
<ul class="org-ul">
<li>找到插入位置（若位置已知，則這步可省略）。<br /></li>
<li>修改指標（Pointers） 來連接新節點。<br /></li>
</ul></li>
<li>最壞情況 是當 我們不知道插入位置，需要先搜尋該位置：<br />
<ul class="org-ul">
<li>搜尋時間複雜度：O(N)O(N)（因為可能需要遍歷整個鏈結串列）。<br /></li>
<li>插入操作本身：O(1)O(1)（因為修改指標的操作是常數時間）。<br /></li>
</ul></li>
<li>如果插入位置已知，則插入的時間複雜度是 O(1)O(1)，而不是 O(N)O(N)。<br /></li>
<li>若插入位置未知，則最壞情況下需先遍歷 O(N)O(N) 才能找到正確位置，但「純插入」仍然是 O(1)O(1)。<br /></li>
</ul>
<p>
🚫 因此，B 選項錯誤，因為插入操作本身的時間複雜度是 O(1)O(1) 而不是 O(N)O(N)，應視搜尋是否必要。<br />
</p>
</div>
</li>
<li><a id="org8bbc944"></a>(C) 在二元搜尋樹（BST）中，搜尋的平均時間複雜度為 O(log⁡N)O(logN)。<br />
<div class="outline-text-6" id="text-org8bbc944">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>二元搜尋樹（Binary Search Tree, BST） 是一種有序的樹結構，滿足：<br />
<ul class="org-ul">
<li>左子樹（Left Subtree） 的值小於根節點。<br /></li>
<li>右子樹（Right Subtree） 的值大於根節點。<br /></li>
</ul></li>
<li>搜尋時，每次比較後，都能將搜尋範圍減少一半，類似二分搜尋（Binary Search）。<br />
<ul class="org-ul">
<li>平均情況下，BST 是平衡的，樹的高度約為 O(log⁡N)O(logN)，因此 搜尋的平均時間複雜度為 O(log⁡N)O(logN)。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org6818fb2"></a>(D) 在二元搜尋樹（BST）中，搜尋的最壞時間複雜度為 O(N)O(N)。<br />
<div class="outline-text-6" id="text-org6818fb2">
<p>
✅ 正確<br />
</p>
<ul class="org-ul">
<li>最壞情況（Worst Case）：BST 退化成單鏈結串列（Linked List）（例如，每個節點只有一個子節點）。<br />
<ul class="org-ul">
<li>這種情況發生在插入順序為遞增或遞減時，樹的高度變成 NN。<br /></li>
<li>搜尋時，可能需要遍歷所有節點，時間複雜度為 O(N)O(N)。<br /></li>
</ul></li>
<li>避免這種情況的方法：<br />
<ul class="org-ul">
<li>使用 平衡樹（Balanced Tree） 如 AVL 樹、紅黑樹（Red-Black Tree），可確保樹的高度維持在 O(log⁡N)O(logN)。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgb4bef34"></a>2. 正確答案<br />
<div class="outline-text-6" id="text-orgb4bef34">
<ul class="org-ul">
<li>✅ A. O(N)O(N) 是雙向鏈結串列搜尋的平均時間複雜度。<br /></li>
<li>❌ B. 插入本身是 O(1)O(1)，但若需搜尋插入位置則為 O(N)O(N)。<br /></li>
<li>✅ C. 在平衡 BST 中，搜尋的平均時間複雜度是 O(log⁡N)O(logN)。<br /></li>
<li>✅ D. 在最壞情況下（BST 退化成鏈結串列），搜尋時間複雜度是 O(N)O(N)。<br /></li>
</ul>
<p>
最終答案：A, C, D<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgdc4f235" class="outline-5">
<h5 id="orgdc4f235">3. 相關計概知識整理</h5>
<div class="outline-text-5" id="text-orgdc4f235">
</div>
<ul class="org-ul">
<li><a id="org4dc9a68"></a>(1) 常見資料結構的時間複雜度<br />
<div class="outline-text-6" id="text-org4dc9a68">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">資料結構</th>
<th scope="col" class="org-left">操作</th>
<th scope="col" class="org-left">平均時間複雜度</th>
<th scope="col" class="org-left">最壞時間複雜度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">陣列（Array）</td>
<td class="org-left">搜尋</td>
<td class="org-left">O(N)</td>
<td class="org-left">O(N)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">插入</td>
<td class="org-left">O(N)</td>
<td class="org-left">O(N)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">刪除</td>
<td class="org-left">O(N)</td>
<td class="org-left">O(N)</td>
</tr>

<tr>
<td class="org-left">單向鏈結串列（Singly Linked List）</td>
<td class="org-left">搜尋</td>
<td class="org-left">O(N)</td>
<td class="org-left">O(N)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">插入（已知位置）</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">刪除（已知位置）</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">雙向鏈結串列（Doubly Linked List）</td>
<td class="org-left">搜尋</td>
<td class="org-left">O(N)</td>
<td class="org-left">O(N)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">插入（已知位置）</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">刪除（已知位置）</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">二元搜尋樹（BST）</td>
<td class="org-left">搜尋</td>
<td class="org-left">O(log⁡N)</td>
<td class="org-left">O(N)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">插入</td>
<td class="org-left">O(log⁡N)</td>
<td class="org-left">O(N)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">刪除</td>
<td class="org-left">O(log⁡N)</td>
<td class="org-left">O(N)</td>
</tr>

<tr>
<td class="org-left">平衡二元搜尋樹（AVL, 紅黑樹）</td>
<td class="org-left">搜尋</td>
<td class="org-left">O(log⁡N)</td>
<td class="org-left">O(log⁡N)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">插入</td>
<td class="org-left">O(log⁡N)</td>
<td class="org-left">O(log⁡N)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">刪除</td>
<td class="org-left">O(log⁡N)</td>
<td class="org-left">O(log⁡N)</td>
</tr>
</tbody>
</table>
<ol class="org-ol">
<li>總結<br /></li>
<li>正確答案為 A, C, D。<br /></li>
<li>雙向鏈結串列的搜尋時間為 O(N)，插入操作本身為 O(1)，但若需搜尋位置則為 O(N)。<br /></li>
<li>BST 搜尋的平均時間為 O(log⁡N)，但最壞情況（退化為鏈結串列）為 O(N)。<br /></li>
<li>研究所考試常考比較不同資料結構的時間複雜度，考生應熟記常見操作的時間分析。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org39b985c" class="outline-4">
<h4 id="org39b985c"><span class="section-number-4">6.2.4.</span> 14.</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
Given the C code below, which one(s) of the execution results is/are correct?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 2: </span>  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>, <span style="color: #dcaeea;">i</span>, <span style="color: #dcaeea;">c</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 3: </span>  printf(<span style="color: #98be65;">"Enter a number: "</span>);
<span class="linenr"> 4: </span>  scanf(<span style="color: #98be65;">"%d"</span>, &amp;n);
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>){
<span class="linenr"> 7: </span>    printf(<span style="color: #98be65;">"The number belongs to N\n"</span>);
<span class="linenr"> 8: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 9: </span>  }
<span class="linenr">10: </span>
<span class="linenr">11: </span>  <span style="color: #51afef;">for</span> (i = <span style="color: #da8548; font-weight: bold;">2</span>; i &lt;= sqrt(n); i++){
<span class="linenr">12: </span>    <span style="color: #51afef;">if</span> (n % i == <span style="color: #da8548; font-weight: bold;">0</span>) {
<span class="linenr">13: </span>      c++; <span style="color: #51afef;">break</span>;
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>  }
<span class="linenr">16: </span>
<span class="linenr">17: </span>  <span style="color: #51afef;">if</span> (c == <span style="color: #da8548; font-weight: bold;">0</span>) {
<span class="linenr">18: </span>    printf(<span style="color: #98be65;">"The number belongs to P\n"</span>);
<span class="linenr">19: </span>  }<span style="color: #51afef;">else</span>{
<span class="linenr">20: </span>    printf(<span style="color: #98be65;">"The number belongs to N\n"</span>);
<span class="linenr">21: </span>  }
<span class="linenr">22: </span>  <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">23: </span>}
</pre>
</div>
<ul class="org-ul">
<li>A. Enter a number: 8<br />
The number belongs to N<br /></li>
<li>B. Enter a number: 7<br />
The number belongs to P<br /></li>
<li>C. Enter a number: 15<br />
The number belongs to P<br /></li>
<li>D. Enter a number: 17<br />
The number belongs to P<br /></li>
</ul>
</div>
<div id="outline-container-orga56d401" class="outline-5">
<h5 id="orga56d401">解</h5>
<div class="outline-text-5" id="text-orga56d401">
<p>
這段 C 語言程式碼的目的是判斷輸入數字 nn 是否為質數（Prime Number, P） 或 非質數（N）。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org1758d2d"></a>1. C 語言程式碼分析<br />
<div class="outline-text-6" id="text-org1758d2d">
<ol class="org-ol">
<li><p>
讀取使用者輸入的數字 nn：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>   scanf(<span style="color: #98be65;">"%d"</span>, &amp;n);
</pre>
</div></li>
<li><p>
n處理 n≤1n≤1 的情況：<br />
</p>
<ul class="org-ul">
<li>如果 n≤1n≤1，則輸出 The number belongs to N，因為 nn 不是質數（質數定義為大於 1 的自然數）。<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>   <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>){
<span class="linenr">2: </span>       printf(<span style="color: #98be65;">"The number belongs to N\n"</span>);
<span class="linenr">3: </span>       <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>   }
</pre>
</div></li>
<li><p>
進行質數判定（試除法）：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>   <span style="color: #51afef;">for</span> (i = <span style="color: #da8548; font-weight: bold;">2</span>; i &lt;= sqrt(n); i++){
<span class="linenr">2: </span>       <span style="color: #51afef;">if</span> (n % i == <span style="color: #da8548; font-weight: bold;">0</span>) {
<span class="linenr">3: </span>           c++; <span style="color: #51afef;">break</span>;
<span class="linenr">4: </span>       }
<span class="linenr">5: </span>   }
</pre>
</div>
<ul class="org-ul">
<li>試除法（Trial Division）：從 2 開始測試，直到 nn為止。<br /></li>
<li>若 nn 被 ii 整除（nmod  i==0nmodi==0），則 nn 不是質數，設置 c++ 並 break。<br /></li>
</ul></li>
<li><p>
判斷輸出：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>   <span style="color: #51afef;">if</span> (c == <span style="color: #da8548; font-weight: bold;">0</span>) {
<span class="linenr">2: </span>       printf(<span style="color: #98be65;">"The number belongs to P\n"</span>);
<span class="linenr">3: </span>   }<span style="color: #51afef;">else</span>{
<span class="linenr">4: </span>       printf(<span style="color: #98be65;">"The number belongs to N\n"</span>);
<span class="linenr">5: </span>   }
</pre>
</div>
<ul class="org-ul">
<li>如果 c == 0，則輸出 P（代表 nn 是質數）。<br /></li>
<li>否則輸出 N（代表 nn 不是質數）。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orgc6a9f6f"></a>2. 測試每個選項<br />
<div class="outline-text-6" id="text-orgc6a9f6f">
<p>
我們檢查每個輸入數字的結果是否正確。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgac0402a"></a>(A) 輸入 8<br />
<div class="outline-text-7" id="text-orgac0402a">
<ul class="org-ul">
<li>8≈2.83<br /></li>
<li>i=2:  8 mod 2=0<br /></li>
<li><p>
8 可被 2 整除，設 c++，因此 c != 0，輸出：<br />
</p>
<pre class="example" id="org84c3bbf">
  The number belongs to N
</pre></li>
<li>✅ A 選項正確<br /></li>
</ul>
</div>
</li>
<li><a id="org803faa0"></a>(B) 輸入 7<br />
<div class="outline-text-7" id="text-org803faa0">
<ul class="org-ul">
<li>7≈2.64<br /></li>
<li>測試 i=2： 7 mod 2 ≠ 0<br /></li>
<li><p>
迴圈結束，c == 0，輸出：<br />
</p>
<pre class="example" id="orge348ee4">
  The number belongs to P
</pre></li>
<li>✅ B 選項正確<br /></li>
</ul>
</div>
</li>
<li><a id="org50f5fdf"></a>(C) 輸入 15<br />
<div class="outline-text-7" id="text-org50f5fdf">
<ul class="org-ul">
<li>15≈3.87<br /></li>
<li>測試 i=2： 15 mod 2≠0<br /></li>
<li>測試 i=3：15 mod 3=0<br /></li>
<li><p>
15 可被 3 整除，設 c++，c != 0，應輸出：<br />
</p>
<pre class="example" id="orgbabb044">
  The number belongs to N
</pre></li>
<li>🚫 C 選項錯誤，應該輸出 N，而非 P。<br /></li>
</ul>
</div>
</li>
<li><a id="org55c0825"></a>(D) 輸入 17<br />
<div class="outline-text-7" id="text-org55c0825">
<ul class="org-ul">
<li>17≈4.12<br /></li>
<li>測試 i=2,3,4：<br />
<ul class="org-ul">
<li>17 mod 2≠0<br /></li>
<li>17 mod 3≠0<br /></li>
<li>17 mod 4≠0<br /></li>
</ul></li>
<li><p>
迴圈結束，c == 0，輸出：<br />
</p>
<pre class="example" id="org4b73868">
  The number belongs to P
</pre></li>
<li>✅ D 選項正確<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orge209f8e"></a>3. 最終答案<br />
<div class="outline-text-6" id="text-orge209f8e">
<ul class="org-ul">
<li>✅ A. The number belongs to N（正確）<br /></li>
<li>✅ B. The number belongs to P（正確）<br /></li>
<li>❌ C. The number belongs to P（錯誤，應該輸出 N）<br /></li>
<li>✅ D. The number belongs to P（正確）<br /></li>
</ul>
<p>
正確答案：A, B, D<br />
</p>
</div>
</li>
<li><a id="orga56c415"></a>4. 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="orgfeb9918"></a>時間複雜度分析<br />
<div class="outline-text-7" id="text-orgfeb9918">
<p>
該演算法使用 試除法（Trial Division） 來檢查質數：<br />
</p>
<ul class="org-ul">
<li>常見方法<br />
<ul class="org-ul">
<li>暴力法（Brute Force）：從 2 到 n−1 測試，時間複雜度為 O(N)。<br /></li>
<li>改進方法：只檢查到 \(\sqrt{n}\)​，時間複雜度降為 \(O(\sqrt{N})\)<br /></li>
<li>更優方法：利用 6k ± 1 規則 進一步降低檢查數量。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org17ab280"></a>時間複雜度比較<br />
<div class="outline-text-7" id="text-org17ab280">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">時間複雜度</td>
<td class="org-left">適用範圍</td>
</tr>

<tr>
<td class="org-left">暴力法</td>
<td class="org-left">O(N)O(N)</td>
<td class="org-left">小數量級</td>
</tr>

<tr>
<td class="org-left">試除法 \(\sqrt{N}\)</td>
<td class="org-left">\(O(\sqrt{N})\)</td>
<td class="org-left">適用大範圍</td>
</tr>

<tr>
<td class="org-left">厄拉多塞篩法（Sieve of Eratosthenes）</td>
<td class="org-left">O(Nlog⁡log⁡N)</td>
<td class="org-left">適用於找多個質數</td>
</tr>

<tr>
<td class="org-left">Miller-Rabin 測試</td>
<td class="org-left">O(klog⁡^3N)</td>
<td class="org-left">適用於大數質數測試</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb8d1a54" class="outline-4">
<h4 id="orgb8d1a54"><span class="section-number-4">6.2.5.</span> 15.</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
Mike is given an assignment to practice recursion. He has a fraction of code below. Which one(s) of the following fill-outs is/are correct?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Function that prints the reverse of the passed string</span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">reverse</span>(<span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">str</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">index</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr"> 5: </span>  <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">temp</span>;
<span class="linenr"> 6: </span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">return if it reaches at the end of the string</span>
<span class="linenr"> 7: </span>  A
<span class="linenr"> 8: </span>  <span style="color: #5B6268;">//</span><span style="color: #5B6268;">stores the char before recursive call</span>
<span class="linenr"> 9: </span>  B
<span class="linenr">10: </span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">calling recursive function</span>
<span class="linenr">11: </span>  <span style="color: #ECBE7B;">C</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">printing each stored character while recurring back</span>
<span class="linenr">14: </span>  <span style="color: #dcaeea;">printf</span>(<span style="color: #98be65;">"%c"</span>, temp);
<span class="linenr">15: </span>}
<span class="linenr">16: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">17: </span>  <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">a</span>[] = <span style="color: #98be65;">"MIS@NSYSU is the best"</span>;
<span class="linenr">18: </span>  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span> = <span style="color: #51afef;">sizeof</span>(a) / <span style="color: #51afef;">sizeof</span>(a);
<span class="linenr">19: </span>  D
<span class="linenr">20: </span>  <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">21: </span>}
</pre>
</div>
<ul class="org-ul">
<li>A. if(index == n) return;<br /></li>
<li>B. temp = str[index];<br /></li>
<li>C. reverse(str, index + 1, n);<br /></li>
<li>D. reverse(a, n, 0);<br /></li>
</ul>
</div>
<div id="outline-container-org768dca4" class="outline-5">
<h5 id="org768dca4">解</h5>
<div class="outline-text-5" id="text-org768dca4">
<p>
本題考察的是 遞迴（Recursion） 的應用，主要目標是透過遞迴方式反轉字串。我們需要填補函式 reverse 的遺漏部分，使其能夠正確執行。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org5ff7480"></a>1. C 語言程式碼分析<br />
<ul class="org-ul">
<li><a id="org75be71a"></a>(1) 程式碼概述<br />
<div class="outline-text-7" id="text-org75be71a">
<p>
這段程式碼的主要功能是：<br />
</p>
<ul class="org-ul">
<li>使用遞迴來反轉輸入字串。<br /></li>
<li>利用函式 reverse(char *str, int index, int n) 進行遞迴調用：<br />
<ul class="org-ul">
<li>index：目前處理的字元位置。<br /></li>
<li>n：字串長度（包含 \0 結尾符）。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org2b9bc91"></a>(2) 填補 A, B, C, D<br />
<div class="outline-text-6" id="text-org2b9bc91">
<p>
我們依序分析每個缺少的部分應該填入的內容。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9b6d81a"></a>(A) 終止條件<br />
<div class="outline-text-7" id="text-org9b6d81a">
<p>
當 index == n 時，表示我們已經遍歷完字串，此時應該停止遞迴：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">if</span>(index == n) <span style="color: #51afef;">return</span>;
</pre>
</div>
<p>
✅ 正確選項：A<br />
</p>
</div>
</li>
<li><a id="orgaa34512"></a>(B) 儲存目前字元<br />
<div class="outline-text-7" id="text-orgaa34512">
<p>
為了在遞迴返回時輸出字串的反轉版本，需要先儲存當前字元：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>temp = str[index];
</pre>
</div>
<p>
✅ 正確選項：B<br />
</p>
</div>
</li>
<li><a id="org9bac206"></a>(C) 遞迴呼叫<br />
<div class="outline-text-7" id="text-org9bac206">
<p>
透過 遞迴 繼續處理字串的下一個字元：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>reverse(str, index + <span style="color: #da8548; font-weight: bold;">1</span>, n);
</pre>
</div>
<p>
✅ 正確選項：C<br />
(D) 初始遞迴呼叫<br />
main 函式需要呼叫 reverse 來開始遞迴處理，並傳入初始索引：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>reverse(a, <span style="color: #da8548; font-weight: bold;">0</span>, n - <span style="color: #da8548; font-weight: bold;">1</span>);
</pre>
</div>
<ul class="org-ul">
<li>錯誤選項 D 提供的是 reverse(a, n, 0);，這會導致錯誤，因為 index 應該從 0 開始，而 n 應該是字串長度。 ✅ 修正後的 D 選項應該是 reverse(a, 0, n - 1);。<br /></li>
<li>🚫 D 選項錯誤<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org5fd8e7d"></a>最終答案<br />
<div class="outline-text-6" id="text-org5fd8e7d">
<ul class="org-ul">
<li>✅ A. if(index == n) return;（遞迴終止條件）<br /></li>
<li>✅ B. temp = str[index];（儲存當前字元）<br /></li>
<li>✅ C. reverse(str, index + 1, n);（遞迴呼叫下一個字元）<br /></li>
<li>🚫 D. reverse(a, n, 0);（錯誤，應該改為 reverse(a, 0, n - 1);）<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org99909b6" class="outline-5">
<h5 id="org99909b6">3. 相關計概知識整理</h5>
<div class="outline-text-5" id="text-org99909b6">
</div>
<ul class="org-ul">
<li><a id="orgd92f748"></a>(1) 遞迴（Recursion）概念<br />
<div class="outline-text-6" id="text-orgd92f748">
<p>
遞迴（Recursion） 是函式呼叫自身來解決問題的一種方式，通常包含：<br />
</p>
<ul class="org-ul">
<li>基礎條件（Base Case）：<br />
<ul class="org-ul">
<li>確保遞迴能夠終止，防止無窮遞迴。<br /></li>
</ul></li>
<li>遞迴步驟（Recursive Step）：<br />
<ul class="org-ul">
<li>問題被拆分成更小的子問題，直到滿足基礎條件。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org2c55aac"></a>(2) 這段程式碼的遞迴運作方式<br />
<div class="outline-text-6" id="text-org2c55aac">
<p>
假設輸入字串為：<br />
</p>
<pre class="example" id="org4216373">
"MIS@NSYSU is the best"
</pre>
<p>
遞迴過程如下：<br />
</p>
<ol class="org-ol">
<li><p>
遞迴向前（儲存字元並呼叫下一個索引）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>   vreverse(<span style="color: #98be65;">"MIS@NSYSU is the best"</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">20</span>)
<span class="linenr">2: </span>   reverse(<span style="color: #98be65;">"MIS@NSYSU is the best"</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">20</span>)
<span class="linenr">3: </span>   reverse(<span style="color: #98be65;">"MIS@NSYSU is the best"</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">20</span>)
<span class="linenr">4: </span>   ...
<span class="linenr">5: </span>   reverse(<span style="color: #98be65;">"MIS@NSYSU is the best"</span>, <span style="color: #da8548; font-weight: bold;">19</span>, <span style="color: #da8548; font-weight: bold;">20</span>)
</pre>
</div></li>
<li><p>
遞迴回傳（依照遞迴結束順序輸出字元）<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>       printf(<span style="color: #98be65;">"%c"</span>, <span style="color: #98be65;">'t'</span>)  -&gt; <span style="color: #98be65;">'t'</span>
<span class="linenr">2: </span>       printf(<span style="color: #98be65;">"%c"</span>, <span style="color: #98be65;">'s'</span>)  -&gt; <span style="color: #98be65;">'s'</span>
<span class="linenr">3: </span>       printf(<span style="color: #98be65;">"%c"</span>, <span style="color: #98be65;">'e'</span>)  -&gt; <span style="color: #98be65;">'e'</span>
<span class="linenr">4: </span>       ...
<span class="linenr">5: </span>       printf(<span style="color: #98be65;">"%c"</span>, <span style="color: #98be65;">'M'</span>)  -&gt; <span style="color: #98be65;">'M'</span>
</pre>
</div></li>
<li>最終輸出：<br /></li>
</ol>
<pre class="example" id="org7c39a0d">
tseb eht si USYSN@SIM
</pre>
<p>
這就是反轉字串的效果。<br />
</p>
</div>
</li>
<li><a id="org37dd728"></a>(3) 遞迴 vs. 迴圈<br />
<div class="outline-text-6" id="text-org37dd728">
<p>
這題使用遞迴來反轉字串，但實際上也可以使用迴圈完成：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">reverse_iterative</span>(<span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">str</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">2: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = n - <span style="color: #da8548; font-weight: bold;">1</span>; i &gt;= <span style="color: #da8548; font-weight: bold;">0</span>; i--) {
<span class="linenr">3: </span>    printf(<span style="color: #98be65;">"%c"</span>, str[i]);
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>}
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">時間複雜度</th>
<th scope="col" class="org-left">空間複雜度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">遞迴</td>
<td class="org-left">O(N)O(N)</td>
<td class="org-left">O(N)O(N)（遞迴堆疊）</td>
</tr>

<tr>
<td class="org-left">迴圈</td>
<td class="org-left">O(N)O(N)</td>
<td class="org-left">O(1)O(1)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>遞迴適合使用在：需要「先處理最後一個字元，再回溯到第一個字元」的情況。<br /></li>
<li>迴圈適合使用在：空間需求較緊張的情境，因為不會佔用額外的堆疊空間。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org00bb182" class="outline-3">
<h3 id="org00bb182"><span class="section-number-3">6.3.</span> 第16~19題為簡答題。</h3>
<div class="outline-text-3" id="text-6-3">
</div>
<div id="outline-container-org6510b69" class="outline-4">
<h4 id="org6510b69"><span class="section-number-4">6.3.1.</span> 16.</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
Please describe the procedure of Proof of Work consensus mechanism used in blockchain technology. (10%)<br />
</p>
</div>
<div id="outline-container-org5d58af2" class="outline-5">
<h5 id="org5d58af2">解</h5>
<div class="outline-text-5" id="text-org5d58af2">
<p>
工作量證明（Proof of Work, PoW） 是區塊鏈技術中最早且最廣泛使用的共識機制，最著名的應用是在 比特幣（Bitcoin） 區塊鏈中。PoW 的核心概念是 透過計算密集的哈希運算來競爭區塊的打包權，以確保區塊鏈的安全性和去中心化。<br />
</p>
</div>
</div>
<div id="outline-container-org4b49db2" class="outline-5">
<h5 id="org4b49db2">工作量證明（PoW）運作機制</h5>
<div class="outline-text-5" id="text-org4b49db2">
</div>
<ul class="org-ul">
<li><a id="orga72efe4"></a>1. 交易打包與區塊建構<br />
<div class="outline-text-6" id="text-orga72efe4">
<ul class="org-ul">
<li>使用者發送交易後，交易會被網絡上的節點（nodes）收集，並存入 記憶池（mempool）。<br /></li>
<li>挖礦節點（miners）會從記憶池中選擇交易，並構造一個新的區塊（block）。<br /></li>
<li>該區塊包含：<br />
<ul class="org-ul">
<li>前一個區塊的哈希值（Previous Block Hash）<br /></li>
<li>待確認的交易（Transactions）<br /></li>
<li>工作量證明的難度目標（Difficulty Target）<br /></li>
<li>時間戳記（Timestamp）<br /></li>
<li>隨機數（Nonce）<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org618c1d0"></a>2.哈希計算（Mining Process）<br />
<div class="outline-text-6" id="text-org618c1d0">
<ul class="org-ul">
<li>挖礦節點透過哈希函數（如 SHA-256），不斷變更「隨機數（Nonce）」來計算區塊的哈希值，使其滿足特定條件：<br />
<ul class="org-ul">
<li>產生的哈希值需小於 網絡設定的目標值（Target Value），即滿足一定數量的前導零（leading zeros）。<br /></li>
<li>例如，比特幣的 PoW 挖礦需要找到：<br /></li>
<li>Hash(Block_Header)&lt;Target<br /></li>
<li>Hash(Block_Header)&lt;Target<br /></li>
</ul></li>
<li>這個過程極為計算密集，稱為挖礦（Mining），需要大量計算資源。<br /></li>
</ul>
</div>
</li>
<li><a id="orgab4c51c"></a>3. 挖礦成功與區塊鏈更新<br />
<div class="outline-text-6" id="text-orgab4c51c">
<ul class="org-ul">
<li>當某個礦工找到符合條件的哈希值時，該礦工會**廣播（broadcast）**這個區塊到整個網絡。<br /></li>
<li>其他節點會驗證此區塊的哈希值是否符合條件，並確認區塊內的交易是否有效（例如是否未雙重支付）。<br /></li>
<li>驗證成功後，該區塊會被添加到區塊鏈中，成為區塊鏈的最新區塊。<br /></li>
</ul>
</div>
</li>
<li><a id="org1aa4965"></a>4. 難度調整（Difficulty Adjustment）<br />
<div class="outline-text-6" id="text-org1aa4965">
<ul class="org-ul">
<li>為了確保區塊產生時間穩定（如比特幣約 10 分鐘產生一個區塊），網絡會根據挖礦速度調整難度：<br />
<ul class="org-ul">
<li>若區塊生成過快，則提升挖礦難度。<br /></li>
<li>若區塊生成過慢，則降低挖礦難度。<br /></li>
</ul></li>
<li>這一機制確保了區塊鏈的穩定性。<br /></li>
</ul>
</div>
</li>
<li><a id="org3385e56"></a>5. 區塊鏈的最長鏈規則（Longest Chain Rule）<br />
<div class="outline-text-6" id="text-org3385e56">
<ul class="org-ul">
<li>在 PoW 機制中，若網絡出現分叉（fork），節點會選擇**累積工作量最高的鏈（即最長鏈）**作為正確的區塊鏈。<br /></li>
<li>這樣可以防止惡意攻擊者建立自己的區塊鏈分支，影響網絡共識。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org29291d6" class="outline-5">
<h5 id="org29291d6">工作量證明的優缺點</h5>
<div class="outline-text-5" id="text-org29291d6">
</div>
<ul class="org-ul">
<li><a id="org408ae6a"></a>優點<br />
<div class="outline-text-6" id="text-org408ae6a">
<ul class="org-ul">
<li>✅ 高度安全性: PoW 機制要求攻擊者擁有**超過 51% 的算力（51% Attack）**才能篡改區塊鏈，使得惡意攻擊成本極高。<br /></li>
<li>✅ 去中心化: 任何擁有計算能力的個人或組織都可以參與挖礦，無需依賴特定機構。<br /></li>
<li>✅ 抗審查: 由於區塊鏈是分散式的，即使某些節點被關閉，其他節點仍可維持網絡運作。<br /></li>
</ul>
</div>
</li>
<li><a id="org4132fe1"></a>缺點<br />
<div class="outline-text-6" id="text-org4132fe1">
<ul class="org-ul">
<li>❌ 能源消耗高: 由於 PoW 需要大量計算來競爭挖礦權，因此耗費大量電力，例如比特幣挖礦的全球能源消耗與某些國家的總電力使用量相當。<br /></li>
<li>❌ 交易確認時間長: PoW 需要等待礦工打包區塊並完成挖礦，通常比其他共識機制（如 PoS）更慢。<br /></li>
<li>❌ 集中化風險: 雖然 PoW 設計為去中心化，但由於礦機成本高昂，大型礦池（Mining Pools）逐漸壟斷挖礦市場，可能導致算力集中化。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc393d22" class="outline-5">
<h5 id="orgc393d22">與 PoW 相關的計算機概論知識整理</h5>
<div class="outline-text-5" id="text-orgc393d22">
<p>
以下是與 PoW 相關的重要計概知識，考生應深入理解，以便應對研究所考試：<br />
</p>
<ol class="org-ol">
<li>資料結構與演算法<br />
<ul class="org-ul">
<li>哈希函數（Hash Function）<br />
<ul class="org-ul">
<li>如 SHA-256（比特幣使用）、Keccak（以太坊使用）<br /></li>
<li>需具備不可逆性、均勻分佈、抗碰撞性<br /></li>
</ul></li>
<li>區塊鏈結構（Blockchain Structure）<br />
<ul class="org-ul">
<li>區塊（Block）<br /></li>
<li>區塊頭（Block Header）<br /></li>
<li>默克爾樹（Merkle Tree）<br /></li>
</ul></li>
<li>工作量證明演算法<br />
<ul class="org-ul">
<li>隨機數（Nonce）調整與哈希計算<br /></li>
</ul></li>
</ul></li>
<li>作業系統<br />
<ul class="org-ul">
<li>並行與分散式計算（Parallel &amp; Distributed Computing）<br /></li>
<li>GPU/ASIC 加速計算（GPU &amp; ASIC Mining）<br /></li>
<li>記憶體與儲存管理（Memory &amp; Storage Management）<br /></li>
<li>排程與計算資源管理（Scheduling &amp; Resource Allocation）<br /></li>
</ul></li>
<li>密碼學<br />
<ul class="org-ul">
<li>公私鑰加密（Public-Private Key Cryptography）<br />
<ul class="org-ul">
<li>橢圓曲線密碼學（Elliptic Curve Cryptography, ECC）<br /></li>
</ul></li>
<li>數位簽章（Digital Signature）<br /></li>
<li>哈希演算法（如 SHA-256, Keccak）<br /></li>
<li>零知識證明（ZKP）與匿名交易技術<br /></li>
</ul></li>
<li>計算複雜度<br />
<ul class="org-ul">
<li>PoW 計算量與時間複雜度<br /></li>
<li>困難度調整機制（Difficulty Adjustment Algorithm）<br /></li>
<li>NP 問題與隨機性<br /></li>
</ul></li>
<li>計算機網路<br />
<ul class="org-ul">
<li>P2P 網路（Peer-to-Peer Networks）<br /></li>
<li>共識協議（Consensus Protocols）<br /></li>
<li>網路延遲與區塊傳播（Network Latency &amp; Block Propagation）<br /></li>
<li>分叉與鏈選擇（Forking &amp; Chain Selection）<br /></li>
</ul></li>
<li>資訊安全<br />
<ul class="org-ul">
<li>51% 攻擊（51% Attack）<br /></li>
<li>重放攻擊（Replay Attack）<br /></li>
<li>雙重支付攻擊（Double Spending Attack）<br /></li>
<li>女巫攻擊（Sybil Attack）<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org0fcfb8e" class="outline-4">
<h4 id="org0fcfb8e"><span class="section-number-4">6.3.2.</span> 17.</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
Please write the Hanoi tower’s recursive function in C programming language:<br />
void Hanoi (int n, char A, char B, char C).<br />
Suppose there are n disks in tower A with indexes 1 to n, and we want to move all disks from tower A to tower C. (20%)<br />
</p>
</div>
<div id="outline-container-org15bf7dd" class="outline-5">
<h5 id="org15bf7dd">解:</h5>
<div class="outline-text-5" id="text-org15bf7dd">
<p>
河內塔問題 (Tower of Hanoi) 及其遞迴函式<br />
</p>

<p>
河內塔（Tower of Hanoi） 是一個經典的遞迴問題，廣泛應用於演算法設計與計算機理論，特別是遞迴與分治法（Divide and Conquer）的教學。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org4b7134a"></a>1. 問題描述<br />
<div class="outline-text-6" id="text-org4b7134a">
<p>
河內塔問題包含三根柱子（A、B、C），以及 n 個大小不同的圓盤，最初全部堆疊在柱子 A 上，目標是將所有圓盤從 A 移動到 C，並遵守以下規則：<br />
</p>
<ul class="org-ul">
<li>一次只能移動一個圓盤。<br /></li>
<li>較小的圓盤必須放在較大的圓盤上方，不能違反這個規則。<br /></li>
<li>可以使用輔助柱 B 來幫助移動。<br /></li>
</ul>
</div>
</li>
<li><a id="orgf733f4c"></a>2. 河內塔的遞迴解法<br />
<div class="outline-text-6" id="text-orgf733f4c">
<p>
河內塔問題的遞迴解法遵循以下邏輯：<br />
</p>
<ul class="org-ul">
<li>當 n = 1（只有一個圓盤時），直接從 A 移動到 C。<br /></li>
<li>當 n &gt; 1 時，拆解為三個步驟：<br />
<ul class="org-ul">
<li>先將前 (n-1) 個圓盤 從 A 移到 B（使用 C 作為輔助）。<br /></li>
<li>再將第 n 個圓盤 從 A 移到 C。<br /></li>
<li>最後將 (n-1) 個圓盤 從 B 移到 C（使用 A 作為輔助）。<br /></li>
</ul></li>
</ul>
<p>
這樣，我們就能用遞迴方式解決河內塔問題。<br />
</p>
</div>
</li>
<li><a id="org4216a17"></a>3. C 語言實現<br />
<div class="outline-text-6" id="text-org4216a17">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27827;&#20839;&#22612;&#36958;&#36852;&#20989;&#24335;</span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">Hanoi</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>, <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">A</span>, <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">B</span>, <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">C</span>) {
<span class="linenr"> 5: </span>    <span style="color: #51afef;">if</span> (n == <span style="color: #da8548; font-weight: bold;">1</span>) {
<span class="linenr"> 6: </span>        printf(<span style="color: #98be65;">"Move disk 1 from %c to %c\n"</span>, A, C);
<span class="linenr"> 7: </span>        <span style="color: #51afef;">return</span>;
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1. &#20808;&#23559;&#21069; n-1 &#20491;&#22291;&#30436;&#24478; A &#31227;&#21040; B&#65292;&#20351;&#29992; C &#20316;&#28858;&#36628;&#21161;</span>
<span class="linenr">10: </span>    Hanoi(n - <span style="color: #da8548; font-weight: bold;">1</span>, A, C, B);
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2. &#23559;&#31532; n &#20491;&#22291;&#30436;&#24478; A &#31227;&#21040; C</span>
<span class="linenr">13: </span>    printf(<span style="color: #98be65;">"Move disk %d from %c to %c\n"</span>, n, A, C);
<span class="linenr">14: </span>
<span class="linenr">15: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">3. &#20877;&#23559; n-1 &#20491;&#22291;&#30436;&#24478; B &#31227;&#21040; C&#65292;&#20351;&#29992; A &#20316;&#28858;&#36628;&#21161;</span>
<span class="linenr">16: </span>    Hanoi(n - <span style="color: #da8548; font-weight: bold;">1</span>, B, A, C);
<span class="linenr">17: </span>}
<span class="linenr">18: </span>
<span class="linenr">19: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20027;&#20989;&#24335;</span>
<span class="linenr">20: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">21: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>;
<span class="linenr">22: </span>    printf(<span style="color: #98be65;">"Enter the number of disks: "</span>);
<span class="linenr">23: </span>    scanf(<span style="color: #98be65;">"%d"</span>, &amp;n);
<span class="linenr">24: </span>    printf(<span style="color: #98be65;">"Steps to solve Hanoi Tower with %d disks:\n"</span>, n);
<span class="linenr">25: </span>    Hanoi(n, <span style="color: #98be65;">'A'</span>, <span style="color: #98be65;">'B'</span>, <span style="color: #98be65;">'C'</span>);
<span class="linenr">26: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">27: </span>}
</pre>
</div>
<p>
輸出範例（n = 3）<br />
</p>
<pre class="example" id="org5875ef8">
Enter the number of disks: 3
Steps to solve Hanoi Tower with 3 disks:
Move disk 1 from A to C
Move disk 2 from A to B
Move disk 1 from C to B
Move disk 3 from A to C
Move disk 1 from B to A
Move disk 2 from B to C
Move disk 1 from A to C
</pre>
</div>
</li>
<li><a id="org9fde96b"></a>4. 時間複雜度分析<br />
<div class="outline-text-6" id="text-org9fde96b">
<ul class="org-ul">
<li>遞迴關係式：T(n)=2T(n−1)+1<br /></li>
<li>展開後可得：T(n)=2^n−1<br /></li>
<li>因此，時間複雜度為：- O(2^n)<br /></li>
<li>O(2n)<br /></li>
<li>這是一個指數級別的演算法，當 n 變大時，運算時間會迅速增加。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc5eb93f" class="outline-5">
<h5 id="orgc5eb93f">與河內塔相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-orgc5eb93f">
</div>
<ul class="org-ul">
<li><a id="org2fd98ab"></a>資料結構與演算法<br />
<div class="outline-text-6" id="text-org2fd98ab">
<ul class="org-ul">
<li>✅ 遞迴（Recursion）<br />
<ul class="org-ul">
<li>基本概念：函式呼叫自己，並有基礎情況（Base Case） 避免無限遞迴。<br /></li>
<li>應用場景：河內塔、費氏數列（Fibonacci）、快速冪（Fast Exponentiation）。<br /></li>
</ul></li>
<li>✅ 分治法（Divide and Conquer）<br />
<ul class="org-ul">
<li>基本概念：將問題拆分為子問題，遞迴求解，最後合併結果。<br /></li>
<li>相關演算法：<br />
<ul class="org-ul">
<li>合併排序（Merge Sort）<br /></li>
<li>快速排序（Quick Sort）<br /></li>
<li>最大子陣列問題（Maximum Subarray Problem）<br /></li>
</ul></li>
</ul></li>
<li>✅ 堆疊（Stack）<br />
<ul class="org-ul">
<li>遞迴的底層機制是 函式呼叫堆疊（Call Stack）。<br /></li>
<li>若要將遞迴改為迴圈實作，可以使用顯式堆疊（Explicit Stack）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgbb385eb"></a>計算理論<br />
<div class="outline-text-6" id="text-orgbb385eb">
<ul class="org-ul">
<li>✅ 遞迴關係（Recurrence Relation）<br />
<ul class="org-ul">
<li>河內塔的遞迴關係：<br /></li>
<li>T(n)=2T(n−1)+1<br /></li>
<li>與主定理（Master Theorem） 相關，可用來分析時間複雜度。<br /></li>
</ul></li>
<li>✅ 計算複雜度（Computational Complexity）<br />
<ul class="org-ul">
<li>指數時間（Exponential Time）：O(2ⁿ)<br /></li>
<li>NP 問題（NP Problem）：指數時間問題通常無法有效解決。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org01d0fe2"></a>作業系統<br />
<div class="outline-text-6" id="text-org01d0fe2">
<ul class="org-ul">
<li>✅ 函式呼叫堆疊（Call Stack）<br />
<ul class="org-ul">
<li>每次函式呼叫，會在堆疊新增一個新框架（Stack Frame）。<br /></li>
<li>遞迴過深 可能導致 堆疊溢位（Stack Overflow）。<br /></li>
</ul></li>
<li>✅ 遞迴與記憶體管理<br />
<ul class="org-ul">
<li>對於 大 n 值，可能需要改用 動態規劃（DP） 或 迭代法（Iterative Method） 來減少記憶體使用。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb05f933" class="outline-4">
<h4 id="orgb05f933"><span class="section-number-4">6.3.3.</span> 18.</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
What is the function of TTL field in IP protocol? (10%)<br />
</p>
</div>
<div id="outline-container-orge2d40f8" class="outline-5">
<h5 id="orge2d40f8">解:</h5>
<div class="outline-text-5" id="text-orge2d40f8">
<p>
TTL（Time to Live，生存時間） 是 IP 封包中的一個欄位，主要用於限制封包在網路中的存活時間，以防止封包無限循環。TTL 是 IPv4 封包標頭（IP Header） 的第 9 個欄位，占 8 位元（1 個 Byte），範圍為 0-255。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org6998856"></a>1. TTL 欄位的功能<br />
<div class="outline-text-6" id="text-org6998856">
<p>
TTL 欄位的主要作用如下：<br />
</p>
<ul class="org-ul">
<li>防止封包無限循環（Prevent Infinite Loop）<br />
<ul class="org-ul">
<li>當 IP 封包在網路中傳輸時，每經過一個路由器（Router），TTL 值會減少 1。<br /></li>
<li>如果 TTL 減少到 0，路由器會丟棄該封包，並回傳 ICMP「時間超時」訊息（Time Exceeded Message） 給發送端。<br /></li>
<li>這防止了因網路拓撲錯誤或路由環路（Routing Loop）導致封包無限傳輸的問題。<br /></li>
</ul></li>
<li>控制封包的生命週期（Limit Packet Lifetime）<br />
<ul class="org-ul">
<li>設定適當的 TTL 值，可以確保封包不會在網路中存活過久，影響網路效能。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>本地區域網路（LAN） 內的封包通常使用較低的 TTL（如 32）。<br /></li>
<li>跨國傳輸（國際網路封包） 可能使用較高的 TTL（如 128 或 255）。<br /></li>
</ul></li>
</ul></li>
<li>用於 Traceroute（路由追蹤工具）<br />
<ul class="org-ul">
<li>Traceroute 工具利用 TTL 欄位來偵測封包經過的每個路由器：<br />
<ul class="org-ul">
<li>發送 TTL = 1 的封包，當第一個路由器丟棄時，回傳 ICMP「時間超時」訊息，記錄該路由器的 IP。<br /></li>
<li>發送 TTL = 2 的封包，獲取第二個路由器的資訊。<br /></li>
<li>依此類推，直到封包到達目標主機。<br /></li>
</ul></li>
<li>這使得 Traceroute 能顯示網路的完整路由資訊。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org717010e"></a>2. TTL 在 IP 封包中的結構<br />
<div class="outline-text-6" id="text-org717010e">
<p>
在 IPv4 的標頭（Header）中，TTL 位於 第 9 個欄位：<br />
</p>
<pre class="example" id="org7474a8f">
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Version |  IHL  |    Type of Service   |        Total Length       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|    Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live (TTL)  |   Protocol  |       Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Source IP Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Destination IP Address                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<ul class="org-ul">
<li>TTL 欄位為 8 位元（1 Byte），範圍為 0-255。<br /></li>
<li>每經過一個路由器，TTL 值 減少 1，直到 0 時封包被丟棄。<br /></li>
</ul>
</div>
</li>
<li><a id="org155236c"></a>3. TTL 的實際應用<br />
<div class="outline-text-6" id="text-org155236c">
<ul class="org-ul">
<li>DNS（Domain Name System）快取時間<br />
<ul class="org-ul">
<li>在 DNS 回應中，TTL 決定了該記錄可被快取的時間，影響 DNS 解析的速度與變更生效時間。<br /></li>
</ul></li>
<li>CDN（內容傳遞網路）<br />
<ul class="org-ul">
<li>CDN 伺服器使用 TTL 來決定快取內容的有效時間，確保更新不會過度延遲。<br /></li>
</ul></li>
<li>Traceroute 網路診斷<br />
<ul class="org-ul">
<li>使用 traceroute（Linux/macOS）或 tracert（Windows）來檢測封包經過的路由器。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org1737639"></a>4. 與 TTL 相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="orgfb5014f"></a>(1) 計算機網路<br />
<div class="outline-text-7" id="text-orgfb5014f">
<ul class="org-ul">
<li>✅ IP 協議（Internet Protocol, IP）<br />
<ul class="org-ul">
<li>IPv4 封包結構<br /></li>
<li>IPv6 無 TTL，而使用 Hop Limit<br /></li>
<li>路由器處理 IP 封包的方式<br /></li>
</ul></li>
<li>✅ ICMP（Internet Control Message Protocol）<br />
<ul class="org-ul">
<li>ICMP「時間超時」訊息（Time Exceeded Message）<br /></li>
<li>ICMP「目標無法到達」（Destination Unreachable）<br /></li>
<li>Traceroute 依賴 ICMP 回應<br /></li>
</ul></li>
<li>✅ 網路層（Network Layer）<br />
<ul class="org-ul">
<li>封包傳輸<br /></li>
<li>路由選擇（Routing）<br /></li>
<li>NAT（Network Address Translation）與 TTL 影響<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgd53f8fb"></a>(2) 作業系統<br />
<div class="outline-text-7" id="text-orgd53f8fb">
<ul class="org-ul">
<li>✅ 網路通訊協議（Networking Protocols）<br />
<ul class="org-ul">
<li>ping 與 traceroute 工具<br /></li>
<li>封包如何在作業系統內部傳輸<br /></li>
<li>防火牆如何利用 TTL 過濾流量<br /></li>
</ul></li>
<li>✅ 路由表（Routing Table）<br />
<ul class="org-ul">
<li>TTL 影響封包在不同網路拓撲中的壽命<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org07cd10a"></a>(3) 計算理論<br />
<div class="outline-text-7" id="text-org07cd10a">
<ul class="org-ul">
<li>✅ 數據包壽命控制機制<br />
<ul class="org-ul">
<li>如何設計 TTL 來影響封包在網路中的行為<br /></li>
</ul></li>
<li>✅ 網路安全<br />
<ul class="org-ul">
<li>如何利用 TTL 檢測網路攻擊（如 IP 偽造、DDoS）<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org2a58c69"></a>5. 總結<br />
<div class="outline-text-6" id="text-org2a58c69">
<p>
TTL（Time to Live）在 IP 封包中用來防止封包無限循環，限制封包的存活時間，同時被應用於 路由選擇、Traceroute 網路診斷、DNS 快取控制 等。考生應熟悉：<br />
</p>
<ul class="org-ul">
<li>TTL 的作用與運作機制<br /></li>
<li>TTL 在 IPv4 標頭中的位置<br /></li>
<li>TTL 在網路診斷（如 Traceroute）中的應用<br /></li>
<li>與 TTL 相關的計算機網路知識<br /></li>
<li>如何影響網路安全與封包傳輸<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8820353" class="outline-4">
<h4 id="org8820353"><span class="section-number-4">6.3.4.</span> 19.</h4>
<div class="outline-text-4" id="text-6-3-4">
<p>
Please describe the procedure of CSMA/CD method used in Ethernet. (10%)<br />
</p>
</div>
<div id="outline-container-orgc6cb169" class="outline-5">
<h5 id="orgc6cb169">解:</h5>
<div class="outline-text-5" id="text-orgc6cb169">
</div>
<ul class="org-ul">
<li><a id="org23c3bbb"></a>1. CSMA/CD（Carrier Sense Multiple Access with Collision Detection）概述<br />
<div class="outline-text-6" id="text-org23c3bbb">
<p>
CSMA/CD（載波監聽多重存取/碰撞偵測） 是 乙太網路（Ethernet） 在 共享式有線網路（如同軸電纜、集線器）中使用的媒體存取控制（MAC，Media Access Control） 方法。其核心概念是：<br />
</p>
<ul class="org-ul">
<li>載波監聽（Carrier Sense, CS）：裝置在傳輸前會先監聽網路狀態，確保沒有其他裝置正在發送數據。<br /></li>
<li>多重存取（Multiple Access, MA）：多個裝置共享同一條傳輸介質（如網路線）。<br /></li>
<li>碰撞偵測（Collision Detection, CD）：若偵測到碰撞，則停止傳輸，並依據退避機制重新發送。<br /></li>
</ul>
</div>
</li>
<li><a id="org88d13a5"></a>2. CSMA/CD 的工作流程<br />
<div class="outline-text-6" id="text-org88d13a5">
<p>
CSMA/CD 的工作流程可分為以下幾個步驟：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgefedda7"></a>步驟 1：監聽網路（Carrier Sense, CS）<br />
<div class="outline-text-7" id="text-orgefedda7">
<ul class="org-ul">
<li>當一台裝置（如電腦）準備傳輸數據時，它會先監聽網路線上的信號，檢查是否有其他裝置正在發送數據：<br />
<ul class="org-ul">
<li>若無其他設備在發送（通道空閒） → 直接發送數據。<br /></li>
<li>若偵測到其他設備正在發送 → 需等待網路閒置後再發送。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org08c7e19"></a>步驟 2：開始發送（Transmit Data）<br />
<div class="outline-text-7" id="text-org08c7e19">
<ul class="org-ul">
<li>若網路是空閒的，則裝置開始發送數據到乙太網路上。<br /></li>
</ul>
</div>
</li>
<li><a id="orgc15dce4"></a>步驟 3：碰撞偵測（Collision Detection, CD）<br />
<div class="outline-text-7" id="text-orgc15dce4">
<ul class="org-ul">
<li>在數據傳輸期間，若有兩台或以上的設備同時開始傳送，則會發生碰撞（Collision）。<br /></li>
<li>乙太網路上的裝置能夠偵測是否發生碰撞：<br />
<ul class="org-ul">
<li>碰撞發生時，數據將變得無法解讀，影響所有裝置的正常通訊。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc0c24d8"></a>步驟 4：發送擾亂信號（Jam Signal）<br />
<div class="outline-text-7" id="text-orgc0c24d8">
<ul class="org-ul">
<li>當裝置偵測到碰撞時，會立即：<br />
<ul class="org-ul">
<li>停止傳輸<br /></li>
<li>發送「擾亂信號（Jam Signal）」，通知所有設備發生碰撞，使其他裝置丟棄該次傳輸的數據。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org45b5fe6"></a>步驟 5：退避機制（Backoff Algorithm）<br />
<div class="outline-text-7" id="text-org45b5fe6">
<ul class="org-ul">
<li>裝置在發生碰撞後，不會立刻重新發送數據，而是根據「指數退避演算法（Exponential Backoff Algorithm）」來決定重新傳輸的時間：<br />
<ul class="org-ul">
<li>計算一個隨機的時間間隔，稱為 退避時間（Backoff Time）。<br /></li>
<li>退避時間依據 二進制指數退避算法（Binary Exponential Backoff, BEB） 計算：<br />
<ul class="org-ul">
<li>第一次碰撞後，隨機等待 00 或 11 個時間單位（slot）。<br /></li>
<li>第二次碰撞後，隨機等待 0,1,2,30,1,2,3 個時間單位。<br /></li>
<li>第三次碰撞後，隨機等待 00 到 77 個時間單位。<br /></li>
<li>若發生多次碰撞，最大退避時間會增長，但最多不超過 16 次（稱為「碰撞上限」）。<br /></li>
</ul></li>
<li>當退避時間結束後，裝置會重新嘗試發送數據。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org65f689f"></a>3. CSMA/CD 方法的優缺點<br />
<ul class="org-ul">
<li><a id="org357aaca"></a>✅ 優點<br />
<div class="outline-text-7" id="text-org357aaca">
<ul class="org-ul">
<li>避免無序傳輸，確保數據完整性<br />
<ul class="org-ul">
<li>透過監聽網路狀態，可降低碰撞機率，減少數據損失。<br /></li>
</ul></li>
<li>有效解決共享介質的競爭問題<br />
<ul class="org-ul">
<li>允許多個裝置共享同一條網路線（如同軸電纜）。<br /></li>
</ul></li>
<li>適用於低負載網路<br />
<ul class="org-ul">
<li>在 流量較低 時，碰撞較少，能有效運作。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc947b8b"></a>❌ 缺點<br />
<div class="outline-text-7" id="text-orgc947b8b">
<ul class="org-ul">
<li>碰撞影響效能<br />
<ul class="org-ul">
<li>在高流量網路中，頻繁的碰撞會降低效能，影響傳輸速率。<br /></li>
</ul></li>
<li>不適用於全雙工網路<br />
<ul class="org-ul">
<li>CSMA/CD 主要設計用於 半雙工（Half-Duplex） 環境，當全雙工（Full-Duplex） 交換式網路出現後，CSMA/CD 逐漸被淘汰。<br /></li>
</ul></li>
<li>不適用於大規模網路<br />
<ul class="org-ul">
<li>在大型網路（如 WAN）中，延遲問題（Propagation Delay）可能導致碰撞檢測失效。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org6c62c6a"></a>4. CSMA/CD 在 Ethernet（乙太網路）中的應用<br />
<div class="outline-text-6" id="text-org6c62c6a">
<p>
CSMA/CD 主要應用於 共享式乙太網路（Shared Ethernet），如：<br />
</p>
<ul class="org-ul">
<li>10BASE-T（10 Mbps）<br /></li>
<li>100BASE-T（100 Mbps，Fast Ethernet）<br /></li>
<li>舊式集線器（Hub-based Ethernet）<br /></li>
</ul>
<p>
然而，在交換式乙太網路（Switched Ethernet） 和 全雙工網路（如 Gigabit Ethernet 及更新版本）中，CSMA/CD 已經不再使用，因為：<br />
</p>
<ul class="org-ul">
<li>交換機（Switch）可以避免碰撞，因為每個設備都有專屬的通訊通道。<br /></li>
<li>全雙工（Full-Duplex）模式允許雙向傳輸，無需監聽通道狀態。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc42bd0f" class="outline-5">
<h5 id="orgc42bd0f">與 CSMA/CD 相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-orgc42bd0f">
</div>
<ul class="org-ul">
<li><a id="orgb293dd7"></a>(1) 計算機網路<br />
<div class="outline-text-6" id="text-orgb293dd7">
<ul class="org-ul">
<li>✅ OSI 七層模型<br />
<ul class="org-ul">
<li>CSMA/CD 位於「資料連結層（Data Link Layer）」<br /></li>
<li>MAC 位址與以太網傳輸<br /></li>
</ul></li>
<li>✅ 乙太網路（Ethernet）<br />
<ul class="org-ul">
<li>共享式 vs. 交換式乙太網路<br /></li>
<li>全雙工與半雙工傳輸模式<br /></li>
</ul></li>
<li>✅ 網路協定<br />
<ul class="org-ul">
<li>CSMA/CD（乙太網路使用） vs. CSMA/CA（Wi-Fi 使用）<br /></li>
<li>TCP/IP 通訊協定<br /></li>
<li>IP 網路傳輸與封包交換<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org3fe1cc1"></a>(2) 資料結構與演算法<br />
<div class="outline-text-6" id="text-org3fe1cc1">
<ul class="org-ul">
<li>✅ 二進制指數退避演算法（Binary Exponential Backoff）<br />
<ul class="org-ul">
<li>隨機退避時間計算<br /></li>
<li>指數增長與碰撞控制<br /></li>
</ul></li>
<li>✅ 隨機存取與媒體存取控制（MAC）<br />
<ul class="org-ul">
<li>隨機存取（Random Access）<br /></li>
<li>時槽排程與衝突避免技術<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orge642eb6"></a>(3) 作業系統<br />
<div class="outline-text-6" id="text-orge642eb6">
<ul class="org-ul">
<li>✅ 網路通訊機制<br />
<ul class="org-ul">
<li>裝置如何監聽傳輸媒體<br /></li>
<li>多任務處理與通訊排程<br /></li>
</ul></li>
<li>✅ 競爭與同步<br />
<ul class="org-ul">
<li>臨界區（Critical Section）<br /></li>
<li>同步機制（Synchronization）<br /></li>
<li>與 CPU 排程中的競爭條件類似<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge60f4c3" class="outline-5">
<h5 id="orge60f4c3">總結</h5>
<div class="outline-text-5" id="text-orge60f4c3">
<p>
CSMA/CD 是乙太網路在共享式網路中的 媒體存取控制（MAC）協議，其主要作用是：<br />
</p>

<p>
監聽網路狀態（Carrier Sense, CS）<br />
偵測碰撞（Collision Detection, CD）<br />
發送干擾信號並使用退避機制（Backoff Algorithm）<br />
確保數據完整性，避免無序傳輸<br />
</p>

<p>
然而，現代網路（如交換式乙太網路、Wi-Fi）已不再使用 CSMA/CD，而改用 CSMA/CA（Wi-Fi）或全雙工模式（Switched Ethernet）。<br />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org70c1713" class="outline-2">
<h2 id="org70c1713"><span class="section-number-2">7.</span> 成大近三年計概</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org7ff9613" class="outline-3">
<h3 id="org7ff9613"><span class="section-number-3">7.1.</span> 110</h3>
<div class="outline-text-3" id="text-7-1">
</div>
<div id="outline-container-org35b165f" class="outline-4">
<h4 id="org35b165f"><span class="section-number-4">7.1.1.</span> A-1 Multiple Choice Questions: (Choose only ONE answer for a question; 3% for each question)</h4>
<div class="outline-text-4" id="text-7-1-1">
</div>
<div id="outline-container-org2050495" class="outline-5">
<h5 id="org2050495">(1) Which of the following protocol is used to translate an IP address to a MAC address? (A) DNS (B) ARP (C) DHCP (D) IP (E) PPP</h5>
<div class="outline-text-5" id="text-org2050495">
</div>
<ul class="org-ul">
<li><a id="org35510cc"></a>解<br />
<div class="outline-text-6" id="text-org35510cc">
<ul class="org-ul">
<li>答案：B) ARP（Address Resolution Protocol）<br /></li>
<li>ARP（位址解析協定） 是一種網路層（Layer 3）與資料連結層（Layer 2）之間的橋樑，用來將 IP 位址（例如 192.168.1.1）轉換為 MAC 位址（例如 00:1A:2B:3C:4D:5E）。當設備需要發送資料到同一個區域網路（LAN）內的另一台設備時，必須先獲得對方的 MAC 位址，而 ARP 負責查找這些對應關係。<br /></li>
<li>ARP 工作原理<br />
<ul class="org-ul">
<li>ARP 的基本運作方式如下：<br />
<ul class="org-ul">
<li>ARP 請求（ARP Request）：<br />
<ul class="org-ul">
<li>當主機 A（192.168.1.100）想要與主機 B（192.168.1.200）通訊時，它需要知道主機 B 的 MAC 位址。<br /></li>
<li>主機 A 會透過 廣播（Broadcast，MAC 位址 FF:FF:FF:FF:FF:FF） 發送 ARP 請求，詢問「192.168.1.200 的 MAC 位址是什麼？」。<br /></li>
</ul></li>
<li>ARP 回應（ARP Reply）：<br />
<ul class="org-ul">
<li>主機 B 收到 ARP 請求後，會回應自己的 MAC 位址（例如 00:1A:2B:3C:4D:5E）。<br /></li>
<li>這個回應是 單播（Unicast） 傳送回給主機 A。<br /></li>
</ul></li>
<li>快取機制（ARP Cache）：<br />
<ul class="org-ul">
<li>主機 A 會將這個對應關係存入本機的 ARP 快取表（ARP Cache Table），以便未來相同的查詢不必重新發送 ARP 請求，減少網路負擔。<br /></li>
</ul></li>
<li>ARP 超時與更新機制：<br />
<ul class="org-ul">
<li>ARP 快取表中的資訊會在一定時間後過期，以確保 MAC 地址與 IP 地址的對應仍然正確。<br /></li>
</ul></li>
</ul></li>
</ul></li>
<li>其他選項解析<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">協定</th>
<th scope="col" class="org-left">主要功能</th>
<th scope="col" class="org-left">為何不是答案</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DNS（Domain Name System）</td>
<td class="org-left">將 網域名稱（如 www.google.com）解析為 IP 位址</td>
<td class="org-left">DNS 負責解析 主機名稱到 IP 位址，而非 IP 位址到 MAC 位址</td>
</tr>

<tr>
<td class="org-left">DHCP（Dynamic Host Configuration Protocol）</td>
<td class="org-left">動態分配 IP 位址、子網路遮罩、預設閘道</td>
<td class="org-left">DHCP 主要用於 IP 分配，與 MAC 地址解析無關</td>
</tr>

<tr>
<td class="org-left">IP（Internet Protocol）</td>
<td class="org-left">負責 網際網路層的數據傳輸</td>
<td class="org-left">IP 負責 資料封包傳輸，但不涉及 MAC 解析</td>
</tr>

<tr>
<td class="org-left">PPP（Point-to-Point Protocol）</td>
<td class="org-left">點對點通訊協定，用於撥號連線</td>
<td class="org-left">PPP 是 點對點通訊，用於序列鏈接，不涉及 ARP</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org5da238d"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org5da238d">
<ol class="org-ol">
<li>網路通訊模型與 ARP<br />
<ul class="org-ul">
<li>OSI 模型（七層模型）：<br />
<ul class="org-ul">
<li>應用層（HTTP, FTP, DNS）<br /></li>
<li>傳輸層（TCP, UDP）<br /></li>
<li>網路層（IP, ICMP, ARP）<br /></li>
<li>資料鏈路層（Ethernet, Wi-Fi, PPP）<br /></li>
<li>實體層（光纖、電纜）<br /></li>
</ul></li>
<li>ARP 屬於網路層，負責將 IP 解析為 MAC 地址，並透過資料鏈路層傳輸數據。<br /></li>
</ul></li>
<li>RARP（Reverse ARP）<br />
<ul class="org-ul">
<li>ARP 的反向版本，用於透過 已知的 MAC 位址來查詢 IP 位址。<br /></li>
<li>目前已由 DHCP 取代，較少使用。<br /></li>
</ul></li>
<li>ARP Spoofing（ARP 欺騙攻擊）<br />
<ul class="org-ul">
<li>攻擊方式：<br />
<ul class="org-ul">
<li>攻擊者透過偽造 ARP 回應，欺騙其他設備將攻擊者的 MAC 記錄為某 IP 位址的對應 MAC。<br /></li>
<li>造成流量攔截，形成 中間人攻擊（MITM, Man-in-the-Middle Attack）。<br /></li>
</ul></li>
<li>防範方式：<br />
<ul class="org-ul">
<li>靜態 ARP 綁定（設定特定 IP 對應 MAC）。<br /></li>
<li>使用 ARP 檢測技術（如 DHCP Snooping）。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org4c47c8c"></a>總結<br />
<div class="outline-text-6" id="text-org4c47c8c">
<ul class="org-ul">
<li>ARP（Address Resolution Protocol） 是 IP 位址轉換為 MAC 位址 的協定，透過廣播請求與單播回應機制運作。<br /></li>
<li>DNS、DHCP、IP、PPP 不負責 IP 轉 MAC，因此不適合做為答案。<br /></li>
<li>ARP 是網路層的核心協定，對 LAN 內的通訊至關重要。<br /></li>
<li>ARP 欺騙攻擊 是常見的網路安全威脅，需使用靜態 ARP 綁定或 DHCP Snooping 來防範。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org13cbf4e" class="outline-5">
<h5 id="org13cbf4e">(2) The type of database that is most capable of supporting complex data types is <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. (A) sequential files (B) relational DBMS (C) object-oriented DBMS (D) hierarchical DBMS (E) random access files</h5>
<div class="outline-text-5" id="text-org13cbf4e">
</div>
<ul class="org-ul">
<li><a id="org711bd54"></a>解<br />
<div class="outline-text-6" id="text-org711bd54">
<p>
(C) 物件導向資料庫管理系統（Object-Oriented DBMS, OODBMS） ✅<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgdc9336d"></a>解析：<br />
<div class="outline-text-7" id="text-orgdc9336d">
<p>
物件導向資料庫管理系統（OODBMS）最能夠支援複雜的資料類型（Complex Data Types），例如：<br />
</p>
<ul class="org-ul">
<li>嵌套物件（Nested Objects）<br /></li>
<li>多媒體資料（Multimedia Data）<br /></li>
<li>圖形結構（Graph Structures）<br /></li>
<li>複合型態（Composite Types，如 List, Set, Map）<br /></li>
<li>繼承（Inheritance）與多型（Polymorphism）<br /></li>
</ul>
<p>
這些特性使 OODBMS 特別適合儲存和管理物件導向程式語言（如 Java、C++）的資料結構，並在應用程式與資料庫之間建立緊密的關聯。<br />
</p>
</div>
</li>
<li><a id="org8c68247"></a>其他選項解析<br />
<div class="outline-text-7" id="text-org8c68247">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">選項</td>
<td class="org-left">主要功能</td>
<td class="org-left">為何不適合作答</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(A) Sequential Files（順序檔案）</td>
<td class="org-left">以 順序方式儲存資料，通常用於簡單的日誌記錄或批次處理</td>
<td class="org-left">只適用於簡單資料結構，無法有效支援複雜資料類型</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(B) Relational DBMS（關聯式資料庫）</td>
<td class="org-left">以 表格（Table） 方式儲存資料，透過關聯（JOIN）進行資料管理</td>
<td class="org-left">RDBMS 雖然支援標量數據（Scalar Data，如數字、字串），但對於物件、巢狀結構、非</td>
<td class="org-left">結構化資料支援有限</td>
</tr>

<tr>
<td class="org-left">(D) Hierarchical DBMS（階層式資料庫）</td>
<td class="org-left">採用樹狀結構（Tree Structure），父節點到子節點關係固定</td>
<td class="org-left">適合用於 階層式關聯數據（如組織架構、文件系統），但對於物件導向的多重關聯性支</td>
<td class="org-left">援較差</td>
</tr>

<tr>
<td class="org-left">(E) Random Access Files（隨機存取檔案）</td>
<td class="org-left">允許以特定索引存取資料，適用於高效能檔案系統</td>
<td class="org-left">主要用於快速存取資料，不具備關聯性與結構化查詢能力，無法處理複雜數據類型</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
<li><a id="orga7ba989"></a>深入探討：OODBMS 與其他資料庫系統<br />
<div class="outline-text-6" id="text-orga7ba989">
<ol class="org-ol">
<li>OODBMS 的核心特點<br />
<ul class="org-ul">
<li>✅ 支援物件導向技術<br />
<ul class="org-ul">
<li>OODBMS 允許使用者直接儲存物件（Objects），避免 RDBMS 需要透過**關聯式映射（ORM, Object-Relational Mapping）**來轉換物件。<br /></li>
<li>例如，OODBMS 可以直接儲存 Java 或 C++ 的物件屬性、方法、繼承等。<br /></li>
</ul></li>
<li>✅ 支援複雜數據類型<br />
<ul class="org-ul">
<li>與 RDBMS 只能處理基本類型（如整數、字串）不同，OODBMS 可以處理**巢狀物件（Nested Objects）、陣列、集合（Set）、清單（List）**等。<br /></li>
</ul></li>
<li>✅ 支援繼承與多型<br />
<ul class="org-ul">
<li>OODBMS 允許物件繼承，能夠將父類別的特性延伸到子類別，使程式開發與資料儲存更加靈活。<br /></li>
</ul></li>
<li>✅ 與物件導向程式語言整合<br />
<ul class="org-ul">
<li>OODBMS 與 C++、Java、Python 等物件導向語言緊密整合，使開發人員不需要在程式碼與資料庫之間進行額外的數據轉換。<br /></li>
</ul></li>
</ul></li>
<li><p>
OODBMS vs. RDBMS（關聯式 vs. 物件導向）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">OODBMS（物件導向資料庫）</th>
<th scope="col" class="org-left">RDBMS（關聯式資料庫）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">資料結構</td>
<td class="org-left">物件導向（Object-Oriented），支援複雜數據</td>
<td class="org-left">表格結構（Table-Based），適合結構化數據</td>
</tr>

<tr>
<td class="org-left">數據型態</td>
<td class="org-left">可處理 物件、陣列、集合、巢狀結構</td>
<td class="org-left">主要處理數字、字串、日期等簡單類型</td>
</tr>

<tr>
<td class="org-left">查詢語言</td>
<td class="org-left">使用物件查詢語言（OQL, Object Query Language）</td>
<td class="org-left">使用SQL（結構化查詢語言）</td>
</tr>

<tr>
<td class="org-left">效能</td>
<td class="org-left">適合處理非結構化資料，如多媒體、3D 模型</td>
<td class="org-left">適合結構化資料處理，如企業級應用</td>
</tr>

<tr>
<td class="org-left">應用領域</td>
<td class="org-left">CAD、工程設計、3D 圖形、AI、大型軟體開發</td>
<td class="org-left">銀行、電子商務、ERP 系統</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</li>
<li><a id="orgc2abb2f"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-orgc2abb2f">
<ol class="org-ol">
<li>資料庫管理系統（DBMS）類型<br />
<ul class="org-ul">
<li>關聯式資料庫（RDBMS） - 透過表格來存儲結構化數據，如 MySQL、PostgreSQL、Oracle。<br /></li>
<li>物件導向資料庫（OODBMS） - 以物件為核心的數據儲存方式，如 db4o、ObjectDB。<br /></li>
<li>NoSQL 資料庫 - 針對非結構化或大規模數據，如 MongoDB（文件型）、Cassandra（列式存儲）、Neo4j（圖形資料庫）。<br /></li>
<li>階層式資料庫（Hierarchical DBMS） - 透過樹狀結構來管理資料，如 IBM IMS。<br /></li>
<li>網路式資料庫（Network DBMS） - 使用圖形結構來連接節點，如 CODASYL。<br /></li>
</ul></li>
<li>物件導向概念<br />
<ul class="org-ul">
<li>封裝（Encapsulation）：將數據與操作數據的方法綁定在一起。<br /></li>
<li>繼承（Inheritance）：允許子類別繼承父類別的屬性與行為。<br /></li>
<li>多型（Polymorphism）：允許相同的方法名稱對應到不同的行為。<br /></li>
</ul></li>
<li>物件關聯對應（ORM, Object-Relational Mapping）<br />
<ul class="org-ul">
<li>RDBMS 需要透過 ORM 技術（如 Hibernate, JPA, SQLAlchemy）來將物件與資料庫表格進行映射。<br /></li>
<li>OODBMS 不需要 ORM，可直接存取物件，減少性能損失。<br /></li>
</ul></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org45164fe" class="outline-5">
<h5 id="org45164fe">(3) A processor contains small, high-speed storage locations, called <span class="underline"><span class="underline"><span class="underline">__</span></span></span>, whose functions include storing the location from where an instruction was fetched, storing instructions and data, etc. (A) cache (B) virtual memory (C) register (D) RAM (E) flash</h5>
<div class="outline-text-5" id="text-org45164fe">
</div>
<ul class="org-ul">
<li><a id="org4365475"></a>解<br />
<div class="outline-text-6" id="text-org4365475">
<p>
✅ (C) 寄存器（Register）<br />
</p>
</div>
</li>
<li><a id="orgc122b94"></a>解析：<br />
<div class="outline-text-6" id="text-orgc122b94">
<p>
寄存器（Register） 是位於處理器（CPU）內部的一種小型、高速的儲存裝置，主要用來暫存指令、運算數據、地址資訊等。在 CPU 執行指令時，寄存器扮演著極為關鍵的角色，因為它比 RAM 更快，可以即時提供 CPU 所需的數據。<br />
</p>

<p>
寄存器的主要功能包括：<br />
</p>
<ul class="org-ul">
<li>儲存當前執行的指令（指令暫存）<br /></li>
<li>儲存數據運算的中間結果（暫存計算數值）<br /></li>
<li>儲存記憶體位址（地址計算與尋址）<br /></li>
</ul>

<p>
其他選項解析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">主要功能</th>
<th scope="col" class="org-left">為何不適合作答</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A) Cache（快取記憶體）</td>
<td class="org-left">介於 CPU 和 RAM 之間的小型高速記憶體，減少 CPU 直接存取 RAM 的頻率</td>
<td class="org-left">雖然 Cache 速度快，但仍在 CPU 外部，並非 CPU 內部的小型儲存位置</td>
</tr>

<tr>
<td class="org-left">(B) Virtual Memory（虛擬記憶體）</td>
<td class="org-left">使用磁碟空間作為 RAM 的擴展</td>
<td class="org-left">速度遠低於 Register，且並非 CPU 內部的一部分</td>
</tr>

<tr>
<td class="org-left">(D) RAM（隨機存取記憶體）</td>
<td class="org-left">主要用於存放當前執行的程式和數據</td>
<td class="org-left">比 Register 慢，且是外部記憶體</td>
</tr>

<tr>
<td class="org-left">(E) Flash（快閃記憶體）</td>
<td class="org-left">用於長期存儲數據，如 SSD、USB 隨身碟</td>
<td class="org-left">用於永久存儲數據，並非 CPU 的工作記憶體</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org326e5a5"></a>寄存器的分類<br />
<div class="outline-text-6" id="text-org326e5a5">
<p>
寄存器可根據其用途分為幾類：<br />
</p>
<ul class="org-ul">
<li>程式計數器（Program Counter, PC）: 存放下一條要執行指令的位址。<br /></li>
<li>指令暫存器（Instruction Register, IR）: 存放當前正在執行的指令。<br /></li>
<li>通用寄存器（General-Purpose Registers, GPRs）: 儲存資料和運算結果（如 RAX, RBX, RCX 在 x86-64 架構）。<br /></li>
<li>累加器（Accumulator, ACC）: 用於算術與邏輯運算的中間結果暫存。<br /></li>
<li>基底指標（Base Register, BR）與堆疊指標（Stack Pointer, SP）: 用於存放記憶體位址，協助記憶體存取。<br /></li>
<li>狀態寄存器（Status Register）:存放 CPU 執行結果的標誌（如進位標誌、零標誌）。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd5f6d61"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-orgd5f6d61">
<ol class="org-ol">
<li>記憶體層級（Memory Hierarchy）<br />
寄存器屬於 CPU 內部的最快儲存裝置，但數量有限，通常搭配**快取記憶體（Cache Memory）與主記憶體（RAM）**來加速資料存取：<br />
<ul class="org-ul">
<li>寄存器（Register）：最快，但數量少<br /></li>
<li>L1 Cache &gt; L2 Cache &gt; L3 Cache：快取記憶體<br /></li>
<li>主記憶體（RAM）：速度較慢但容量大<br /></li>
<li>磁碟（HDD/SSD）：作為長期儲存<br /></li>
<li>虛擬記憶體（Virtual Memory）：用磁碟模擬 RAM，速度最慢<br /></li>
</ul></li>
<li>CPU 指令週期（Instruction Cycle）<br />
在執行一條指令時，CPU 依照以下步驟運作：<br />
<ul class="org-ul">
<li>取指令（Fetch）：從記憶體取得指令，存入 指令暫存器（IR）。<br /></li>
<li>解碼（Decode）：CPU 解析指令的內容，確定要執行的操作。<br /></li>
<li>執行（Execute）：使用 寄存器 進行計算或存取記憶體資料。<br /></li>
<li>寫回（Write Back）：將運算結果存入寄存器或主記憶體。<br /></li>
</ul></li>
<li><p>
寄存器與快取記憶體（Cache）的比較<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">寄存器（Register）</th>
<th scope="col" class="org-left">快取記憶體（Cache）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">位置</td>
<td class="org-left">CPU 內部</td>
<td class="org-left">CPU 外部（但緊鄰）</td>
</tr>

<tr>
<td class="org-left">容量</td>
<td class="org-left">非常小（32~256 個）</td>
<td class="org-left">較小（KB~MB）</td>
</tr>

<tr>
<td class="org-left">存取速度</td>
<td class="org-left">最快（&lt;1ns）</td>
<td class="org-left">次快（~幾 ns）</td>
</tr>

<tr>
<td class="org-left">作用</td>
<td class="org-left">儲存 CPU 即時運算數據</td>
<td class="org-left">減少對 RAM 的存取</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</li>
<li><a id="org54644de"></a>總結<br />
<div class="outline-text-6" id="text-org54644de">
<ul class="org-ul">
<li>CPU 寄存器（Register） 是處理器內部的小型高速儲存裝置，存放指令、運算數據、記憶體位址等關鍵資訊。<br /></li>
<li>快取記憶體（Cache） 雖然也屬於高速記憶體，但仍位於 CPU 外部，無法取代寄存器的角色。<br /></li>
<li>記憶體架構採用層級化設計，從最快（寄存器）到最慢（磁碟）組成完整的記憶體管理機制。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org181bc72" class="outline-5">
<h5 id="org181bc72">(4) Public-key encryption is also known as <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. (A) open-key encryption (B) symmetric key encryption (C) two-key encryption (D) scrambled encryption (E) asymmetric key encryption</h5>
<div class="outline-text-5" id="text-org181bc72">
</div>
<ul class="org-ul">
<li><a id="orgf7f5044"></a>解<br />
<div class="outline-text-6" id="text-orgf7f5044">
<p>
✅ (E) 非對稱式加密（Asymmetric Key Encryption）<br />
</p>
</div>
</li>
<li><a id="org764a65d"></a>解析：<br />
<div class="outline-text-6" id="text-org764a65d">
<p>
公鑰加密（Public-Key Encryption） 又稱為 非對稱式加密（Asymmetric Key Encryption），是一種使用兩把不同的密鑰來加密與解密資料的加密技術：<br />
</p>
<ul class="org-ul">
<li>公鑰（Public Key）：可以公開，通常用來加密資料。<br /></li>
<li>私鑰（Private Key）：需保密，通常用來解密資料。<br /></li>
</ul>
<p>
由於加密與解密使用的是不同的密鑰，因此稱為非對稱式加密。<br />
</p>
</div>
</li>
<li><a id="org77d1a6a"></a>其他選項解析<br />
<div class="outline-text-6" id="text-org77d1a6a">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">主要功能</th>
<th scope="col" class="org-left">為何不適合作答</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A) Open-Key Encryption（開放密鑰加密）</td>
<td class="org-left">不是標準術語，可能誤指公鑰加密，但不常見</td>
<td class="org-left">非標準學術用語</td>
</tr>

<tr>
<td class="org-left">(B) Symmetric Key Encryption（對稱式加密）</td>
<td class="org-left">加密與解密使用相同的密鑰，例如 AES、DES</td>
<td class="org-left">對稱加密與非對稱加密不同</td>
</tr>

<tr>
<td class="org-left">(C) Two-Key Encryption（雙密鑰加密）</td>
<td class="org-left">雖然公鑰加密使用兩把密鑰，但這不是正式名稱</td>
<td class="org-left">非標準術語</td>
</tr>

<tr>
<td class="org-left">(D) Scrambled Encryption（混淆加密）</td>
<td class="org-left">非正式學術術語，與一般加密技術無直接關聯</td>
<td class="org-left">不符合正式密碼學概念</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgbd89b6c"></a>非對稱式加密（Asymmetric Encryption）的工作原理<br />
<div class="outline-text-6" id="text-orgbd89b6c">
<ul class="org-ul">
<li>加密過程：<br />
<ul class="org-ul">
<li>傳送者使用 接收者的公鑰 加密訊息。<br /></li>
<li>只有 接收者的私鑰 能夠解密該訊息。<br /></li>
</ul></li>
<li>解密過程：<br />
<ul class="org-ul">
<li>接收者收到加密訊息後，使用自己的私鑰 進行解密，還原原始內容。<br /></li>
</ul></li>
<li>範例： 假設 Alice 要傳送訊息給 Bob：<br />
<ul class="org-ul">
<li>Bob 提供公鑰 給 Alice。<br /></li>
<li>Alice 使用 Bob 的公鑰加密訊息，然後傳送給 Bob。<br /></li>
<li>Bob 使用自己的私鑰解密，取得原始訊息。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org695fd6c"></a>非對稱式加密的應用<br />
<div class="outline-text-6" id="text-org695fd6c">
<ul class="org-ul">
<li>安全通信（SSL/TLS）：HTTPS 網站使用 SSL/TLS 進行加密數據傳輸，防止竊聽。<br /></li>
<li>數位簽章（Digital Signatures）：使用私鑰進行簽署，公鑰驗證簽章，確保數據未被篡改。<br /></li>
<li>電子郵件加密（PGP, S/MIME）：透過 PGP（Pretty Good Privacy）對電子郵件進行加密和簽署，確保內容隱私性。<br /></li>
<li>區塊鏈與加密貨幣： 加密貨幣如 Bitcoin 使用非對稱加密來保護交易的安全性。<br /></li>
</ul>
</div>
</li>
<li><a id="orgab63290"></a>與非對稱式加密相關的計算機概論知識<br />
<div class="outline-text-6" id="text-orgab63290">
<ol class="org-ol">
<li><p>
對稱式加密（Symmetric Encryption）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">對稱式加密</th>
<th scope="col" class="org-left">非對稱式加密</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">密鑰數量</td>
<td class="org-left">1 把（加密、解密相同）</td>
<td class="org-left">2 把（公鑰加密，私鑰解密）</td>
</tr>

<tr>
<td class="org-left">加密速度</td>
<td class="org-left">快，適用大數據加密</td>
<td class="org-left">慢，適用小數據與安全驗證</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">若密鑰洩露，安全性低</td>
<td class="org-left">較高，因密鑰不同</td>
</tr>

<tr>
<td class="org-left">代表算法</td>
<td class="org-left">AES、DES、3DES</td>
<td class="org-left">RSA、ECC、ElGamal</td>
</tr>
</tbody>
</table></li>
<li><p>
常見的非對稱式加密算法<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">演算法</th>
<th scope="col" class="org-left">密鑰長度</th>
<th scope="col" class="org-left">安全性</th>
<th scope="col" class="org-left">應用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">RSA（Rivest-Shamir-Adleman）</td>
<td class="org-left">1024, 2048, 4096 位元</td>
<td class="org-left">高，但需長密鑰</td>
<td class="org-left">SSL/TLS、數位簽章</td>
</tr>

<tr>
<td class="org-left">ECC（Elliptic Curve Cryptography）</td>
<td class="org-left">256, 384, 521 位元</td>
<td class="org-left">更高，密鑰較短</td>
<td class="org-left">加密貨幣、區塊鏈</td>
</tr>

<tr>
<td class="org-left">ElGamal</td>
<td class="org-left">1024, 2048 位元</td>
<td class="org-left">與 RSA 相似，但較少用</td>
<td class="org-left">PGP 加密</td>
</tr>

<tr>
<td class="org-left">Diffie-Hellman（DH）密鑰交換</td>
<td class="org-left">1024, 2048 位元</td>
<td class="org-left">用於密鑰交換</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">VPN、TLS</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li>混合加密技術（Hybrid Encryption）<br />
<ul class="org-ul">
<li>由於非對稱加密速度慢，通常會與對稱加密結合，形成混合加密機制：<br />
<ul class="org-ul">
<li>使用非對稱加密 來安全地傳輸對稱加密密鑰。<br /></li>
<li>使用對稱加密 來加密大數據，提高運算效率。<br /></li>
</ul></li>
<li>範例：<br />
<ul class="org-ul">
<li>TLS/SSL 通訊協議 使用 RSA 或 ECDH 來交換密鑰，再用 AES 進行數據加密。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org150e9d6"></a>總結<br />
<div class="outline-text-6" id="text-org150e9d6">
<ul class="org-ul">
<li>公鑰加密（Public-Key Encryption）即為非對稱式加密（Asymmetric Key Encryption）。<br /></li>
<li>非對稱加密使用公鑰與私鑰，加密和解密使用不同密鑰。<br /></li>
<li>應用場景廣泛，如 SSL/TLS、數位簽章、電子郵件加密、區塊鏈等。<br /></li>
<li>較常見的演算法 有 RSA、ECC、ElGamal、Diffie-Hellman 等。<br /></li>
<li>實務上常與對稱加密結合，如 TLS/SSL 採用 RSA + AES 來確保安全性與運算效率。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org247a06b" class="outline-5">
<h5 id="org247a06b">(5) The practice used by some ISPs that restricts or slow down a customer’s Internet access when he or she has used all the allotted data amount is known as <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. (A) capping (B) throttling (C) Bluebugging (D) DoS attack (E) IP hijacking</h5>
<div class="outline-text-5" id="text-org247a06b">
</div>
<ul class="org-ul">
<li><a id="orgca62fee"></a>解<br />
<div class="outline-text-6" id="text-orgca62fee">
<p>
✅ (B) 限制頻寬（Throttling）<br />
</p>
</div>
</li>
<li><a id="orgcde63d1"></a>解析：<br />
<div class="outline-text-6" id="text-orgcde63d1">
<p>
頻寬限制（Throttling） 是指 網際網路服務供應商（ISP, Internet Service Provider） 根據使用者的流量限制或降低其網速 的做法，通常發生於：<br />
</p>
<ul class="org-ul">
<li>用戶達到流量上限（例如行動數據方案的流量封頂）<br /></li>
<li>ISP 控制特定類型的流量（如 P2P 下載、串流影片）<br /></li>
<li>網路壅塞時進行流量管理（流量分配策略）<br /></li>
</ul>
<p>
這種行為常被用來限制頻寬消耗大的用戶，以確保網路資源公平分配。<br />
</p>
</div>
</li>
<li><a id="org1256809"></a>其他選項解析<br />
<div class="outline-text-6" id="text-org1256809">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">為何不適合作答</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A) Capping（封頂）</td>
<td class="org-left">ISP 設定使用者每月流量上限，超過後可能會斷網或改為低速網路</td>
<td class="org-left">與 Throttling 相關，但 Capping 是設限，而 Throttling 是降速</td>
</tr>

<tr>
<td class="org-left">(C) Bluebugging</td>
<td class="org-left">一種藍牙攻擊，駭客透過藍牙取得裝置控制權</td>
<td class="org-left">與網路速度無關</td>
</tr>

<tr>
<td class="org-left">(D) DoS 攻擊（Denial of Service）</td>
<td class="org-left">透過大量請求癱瘓目標伺服器，使其無法提供正常服務</td>
<td class="org-left">ISP 限制頻寬與 DoS 攻擊無關</td>
</tr>

<tr>
<td class="org-left">(E) IP Hijacking（IP 劫持）</td>
<td class="org-left">黑客或不良 ISP 劫持 IP 位址段，使流量被重導至惡意節點</td>
<td class="org-left">與用戶個人流量管理無關</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org6fe8ee6"></a>頻寬限制（Throttling）的工作原理<br />
<div class="outline-text-6" id="text-org6fe8ee6">
<ol class="org-ol">
<li>流量監測（Traffic Monitoring）<br />
<ul class="org-ul">
<li>ISP 會監測用戶的網路流量，當用戶達到設定門檻時，啟動頻寬限制機制。<br /></li>
</ul></li>
<li>應用層級限制（Application-Level Throttling）<br />
<ul class="org-ul">
<li>限制特定應用程式的速度，例如：<br />
<ul class="org-ul">
<li>限制 P2P 應用（如 BitTorrent）<br /></li>
<li>限制高畫質影片串流（如 YouTube、Netflix）<br /></li>
</ul></li>
</ul></li>

<li>連線數量限制（Connection Throttling）<br />
<ul class="org-ul">
<li>限制同時開啟的連線數，降低大量請求的影響。<br /></li>
</ul></li>
<li>時段限制（Time-Based Throttling）<br />
<ul class="org-ul">
<li>在高流量時段（如晚上）限制頻寬，低流量時段則開放高速網路。<br /></li>
</ul></li>
</ol>

<p>
頻寬限制（Throttling） vs. 流量封頂（Capping）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">頻寬限制（Throttling）</th>
<th scope="col" class="org-left">流量封頂（Capping）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">方式</td>
<td class="org-left">降低網速</td>
<td class="org-left">設定固定流量上限</td>
</tr>

<tr>
<td class="org-left">影響</td>
<td class="org-left">仍可使用網路，但速度變慢</td>
<td class="org-left">達到上限後可能停止服務或改為低速</td>
</tr>

<tr>
<td class="org-left">觸發條件</td>
<td class="org-left">高流量使用者或特定應用程式</td>
<td class="org-left">每月總流量達到限制</td>
</tr>

<tr>
<td class="org-left">常見應用</td>
<td class="org-left">影片串流、P2P 下載</td>
<td class="org-left">行動數據方案（4G/5G）</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgdaaff45"></a>與頻寬限制（Throttling）相關的計算機概論知識<br />
<div class="outline-text-6" id="text-orgdaaff45">
<ol class="org-ol">
<li>網路頻寬與速率<br />
<ul class="org-ul">
<li>頻寬（Bandwidth）：網路能夠傳輸的最大數據量（如 100Mbps）。<br /></li>
<li>吞吐量（Throughput）：實際傳輸速率，受網路壅塞或 ISP 限制影響。<br /></li>
<li>延遲（Latency）：數據從發送端到接收端所需的時間。<br /></li>
</ul></li>
<li><p>
流量管理技術<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">技術名稱</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">QoS（Quality of Service）</td>
<td class="org-left">設定不同應用的優先級，例如確保視訊通話不受干擾</td>
</tr>

<tr>
<td class="org-left">Deep Packet Inspection（DPI）</td>
<td class="org-left">監測並篩選特定類型的流量（如 P2P）</td>
</tr>

<tr>
<td class="org-left">Fair Usage Policy（FUP）</td>
<td class="org-left">公平使用原則，限制單一用戶過度佔用頻寬</td>
</tr>
</tbody>
</table></li>
<li>ISP 為何會進行頻寬限制？<br />
<ul class="org-ul">
<li>確保網路公平使用：避免部分用戶佔用過多資源，影響其他人。<br /></li>
<li>減少網路擁塞：控制高流量時段的負載，提高整體網路效率。<br /></li>
<li>促銷高級方案：ISP 可能透過頻寬限制來推動用戶升級更昂貴的方案。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org41762b4"></a>總結<br />
<div class="outline-text-6" id="text-org41762b4">
<ul class="org-ul">
<li>頻寬限制（Throttling）是 ISP 降低使用者網速的做法，當用戶達到特定流量或使用特定應用時可能觸發。<br /></li>
<li>它不同於 Capping，Capping 是完全封鎖或切換低速，Throttling 則是降速但仍可上網。<br /></li>
<li>ISP 採用 QoS、DPI、FUP 等技術來管理流量，確保公平使用和網路穩定性。<br /></li>
<li>影響最大的是 P2P 下載、串流影片（如 Netflix）、在線遊戲等高頻寬應用。<br /></li>
<li>頻寬管理有時會被批評為「違反網路中立性（Net Neutrality）」，因為 ISP 可能刻意限制某些應用程式的使用速度。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org313ecec" class="outline-5">
<h5 id="org313ecec">(6) Two’s complement is the way most modern computer represent integers. To get the two’s complement of a number, simply invert every digits of the number and add 1. Based on this rule, what is the two’s complement of 64? (A) 00100000 (B) 11011111 (C) 11000000 (D) 00011111 (E) 11110000</h5>
<div class="outline-text-5" id="text-org313ecec">
</div>
<ul class="org-ul">
<li><a id="org1a3f456"></a>解<br />
<div class="outline-text-6" id="text-org1a3f456">
<p>
✅ (C) 11000000<br />
</p>
</div>
</li>
<li><a id="orgab5ac1c"></a>解析：<br />
<div class="outline-text-6" id="text-orgab5ac1c">
<p>
二補數（Two’s Complement） 是現代計算機中用來表示有符號整數的標準方法，它的主要特點是：<br />
</p>
<ul class="org-ul">
<li>最高位（Most Significant Bit, MSB）用來表示正負號<br />
<ul class="org-ul">
<li>0 代表正數<br /></li>
<li>1 代表負數<br /></li>
</ul></li>
<li>負數的表示方式：<br />
<ul class="org-ul">
<li>先將該數的 二進位表示 取 補數（bit-wise NOT，逐位反轉）。<br /></li>
<li>然後再 加 1。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org7ff16cf"></a>計算步驟<br />
<ul class="org-ul">
<li><a id="org667ea1b"></a>Step 1: 64 的二進位表示<br />
<div class="outline-text-7" id="text-org667ea1b">
<ul class="org-ul">
<li>在 8-bit 的系統中，64（十進位） 的二進位表示為：<br /></li>
<li>6410=010000002<br /></li>
<li>6410​=010000002​<br /></li>
<li>說明：<br />
2^6=64，因此 64 的二進位形式為 01000000。<br /></li>
</ul>
</div>
</li>
<li><a id="orgf1a4f7d"></a>Step 2: 取 64 的二補數<br />
<div class="outline-text-7" id="text-orgf1a4f7d">
<ul class="org-ul">
<li>第一步：對 01000000 進行 bit-wise 反轉<br />
01000000 → 10111111<br /></li>
<li>第二步：加 1<br />
10111111 + 1 = 11000000<br /></li>
</ul>
<p>
所以，64 的二補數表示為 11000000。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org720c50b"></a>答案選項分析<br />
<div class="outline-text-6" id="text-org720c50b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-right">二進位值</th>
<th scope="col" class="org-left">十進位值</th>
<th scope="col" class="org-left">是否為 64 的二補數？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A) 00100000</td>
<td class="org-right">32</td>
<td class="org-left">❌</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(B) 11011111</td>
<td class="org-right">-33</td>
<td class="org-left">❌</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(C) 11000000</td>
<td class="org-right">-64</td>
<td class="org-left">✅ 正確答案</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(D) 00011111</td>
<td class="org-right">31</td>
<td class="org-left">❌</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(E) 11110000</td>
<td class="org-right">-16</td>
<td class="org-left">❌</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org27110e6"></a>與二補數（Two’s Complement）相關的計算機概論知識<br />
<div class="outline-text-6" id="text-org27110e6">
<ol class="org-ol">
<li>為何使用二補數來表示負數？<br />
在計算機系統中，二補數的優勢 包括：<br />
<ul class="org-ul">
<li>單一表示法：無需額外符號位，正數和負數統一處理，方便電路設計。<br /></li>
<li>簡單的加法與減法運算： 加法和減法可以統一使用加法運算來完成，而無需額外的減法電路。<br /></li>
<li>避免 +0 和 -0 的問題：傳統補碼（One’s Complement）有 +0 和 -0 的問題，而二補數不會。<br /></li>
</ul></li>
<li><p>
二補數的求法<br />
若要計算某個數 XX 的 二補數（即 −X−X），可按照以下步驟：<br />
</p>
<ol class="org-ol">
<li>將 XX 的二進位數字反轉（bit-wise NOT）<br /></li>
<li>再加 1<br /></li>
</ol>
<p>
例如：<br />
</p>
<ul class="org-ul">
<li>5 的二補數（即 -5）<br />
<ul class="org-ul">
<li>00000101（5 的二進位表示）<br /></li>
<li>反轉後：11111010<br /></li>
<li>加 1：11111011（即 -5）<br /></li>
</ul></li>
</ul></li>
<li><p>
二補數範圍（以 8-bit 為例）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">數值範圍</th>
<th scope="col" class="org-left">十進位範圍</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">無符號整數（Unsigned）</td>
<td class="org-left">0 ~ 255</td>
</tr>

<tr>
<td class="org-left">有符號整數（Signed, Two’s Complement）</td>
<td class="org-left">-128 ~ 127</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>最高位（MSB）為 1，代表負數<br />
<ul class="org-ul">
<li>10000000（-128）<br /></li>
<li>11111111（-1）<br /></li>
</ul></li>
<li>最高位（MSB）為 0，代表正數<br />
<ul class="org-ul">
<li>00000000（0）<br /></li>
<li>01111111（127）<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org8cb93ef"></a>總結<br />
<div class="outline-text-6" id="text-org8cb93ef">
<ul class="org-ul">
<li>二補數是計算機表示負數的方式，其計算方式是「反轉 + 加 1」<br /></li>
<li>64 的二補數是 11000000（即 -64）<br /></li>
<li>正確答案是 (C) 11000000<br /></li>
<li>二補數使減法簡單化，並避免 +0 和 -0 問題，成為現代計算機標準<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org4d55cc7" class="outline-5">
<h5 id="org4d55cc7">(7) A <span class="underline"><span class="underline"><span class="underline">__</span></span></span> provides a read-only, static view of a source database that is typically used for safeguarding data against errors, offloading reporting, etc. (A) schema (B) map (C) snapshot (D) page (E) transaction</h5>
<div class="outline-text-5" id="text-org4d55cc7">
</div>
<ul class="org-ul">
<li><a id="orge53b107"></a>解<br />
<div class="outline-text-6" id="text-orge53b107">
<p>
✅ (C) snapshot<br />
</p>
</div>
</li>
<li><a id="org5e12262"></a>解析<br />
<div class="outline-text-6" id="text-org5e12262">
<p>
在資料庫系統中，Snapshot（快照） 是一種提供 唯讀、靜態視圖（read-only, static view） 的技術，主要用於：<br />
</p>
<ul class="org-ul">
<li>保護資料，防止因錯誤操作導致的資料遺失或損壞。<br /></li>
<li>提升效能，透過建立靜態副本來減輕主資料庫的負擔，特別適用於報表與分析用途。<br /></li>
<li>提供歷史版本，允許查閱特定時間點的資料狀態。<br /></li>
</ul>
</div>
</li>
<li><a id="orgf08b164"></a>選項分析<br />
<div class="outline-text-6" id="text-orgf08b164">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">是否正確？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A) schema</td>
<td class="org-left">資料庫綱要，定義資料庫的結構（如表格、欄位）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">(B) map</td>
<td class="org-left">映射，通常指數據轉換或關聯關係</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">(C) snapshot</td>
<td class="org-left">快照，提供唯讀、靜態視圖</td>
<td class="org-left">✅ 正確答案</td>
</tr>

<tr>
<td class="org-left">(D) page</td>
<td class="org-left">頁，通常指磁碟中的數據存儲單位</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">(E) transaction</td>
<td class="org-left">交易，資料庫中的原子性操作</td>
<td class="org-left">❌</td>
</tr>
</tbody>
</table>

<p>
與資料庫快照（Snapshot）相關的計算機概論知識<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgcd4a589"></a>1. Snapshot（快照）簡介<br />
<div class="outline-text-7" id="text-orgcd4a589">
<p>
在**資料庫管理系統（DBMS）**中，快照（Snapshot） 是某個時間點資料的副本，並且通常是 唯讀的（Read-only），不允許直接修改。<br />
</p>

<p>
快照的主要特點：<br />
</p>
<ul class="org-ul">
<li>靜態（Static）：快照反映的是資料庫某個時間點的狀態，不會隨主資料庫變動。<br /></li>
<li>唯讀（Read-only）：通常用於報表生成、備份、查詢，不允許修改。<br /></li>
<li>分擔查詢負擔：降低主資料庫的負載，提高查詢效能。<br /></li>
</ul>
</div>
</li>
<li><a id="org814a107"></a>2. 資料庫快照的應用<br />
<div class="outline-text-7" id="text-org814a107">
<ul class="org-ul">
<li>(1) 數據備份（Data Backup）<br />
<ul class="org-ul">
<li>快照可以作為資料庫的備份機制，允許管理員回溯到過去的狀態。<br /></li>
<li>例如，若使用者誤刪資料，管理員可從快照恢復。<br /></li>
</ul></li>
<li>(2) 報表生成（Reporting）<br />
<ul class="org-ul">
<li>快照常用於報表系統，以固定時間的資料來產生統計報告，確保報表的一致性。<br /></li>
</ul></li>
<li>(3) 負載分擔（Load Balancing）<br />
<ul class="org-ul">
<li>讀取密集型應用（如 BI、數據倉儲）可以從快照讀取，而不是直接查詢主資料庫，減少影響。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org143190b"></a>3. Snapshot vs. 其他資料庫技術<br />
<div class="outline-text-7" id="text-org143190b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">技術</th>
<th scope="col" class="org-left">用途</th>
<th scope="col" class="org-left">特性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Snapshot（快照）</td>
<td class="org-left">建立唯讀副本，減輕主資料庫負擔</td>
<td class="org-left">靜態、唯讀、副本</td>
</tr>

<tr>
<td class="org-left">View（視圖）</td>
<td class="org-left">定義查詢的邏輯表示，不儲存實際資料</td>
<td class="org-left">動態、查詢結果</td>
</tr>

<tr>
<td class="org-left">Materialized View（實體化視圖）</td>
<td class="org-left">預計算查詢結果，提升查詢效能</td>
<td class="org-left">定期更新，可寫入磁碟</td>
</tr>

<tr>
<td class="org-left">Backup（備份）</td>
<td class="org-left">備份整個資料庫以防災</td>
<td class="org-left">完整、可還原</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org799c09f"></a>4. 快照的實作方式<br />
<div class="outline-text-7" id="text-org799c09f">
<ul class="org-ul">
<li>(1) 立即快照（Immediate Snapshot）<br />
<ul class="org-ul">
<li>直接建立某一刻的資料副本，適合小型快照。<br /></li>
</ul></li>
<li>(2) 增量快照（Incremental Snapshot）<br />
<ul class="org-ul">
<li>只儲存變更的部分，節省儲存空間，適合大型快照。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org52cae09"></a>結論<br />
<div class="outline-text-6" id="text-org52cae09">
<ul class="org-ul">
<li>快照（Snapshot）是一種提供唯讀、靜態視圖的技術，適用於備份、報表、減輕查詢負載。<br /></li>
<li>快照不會影響主資料庫的數據，確保資料完整性與一致性。<br /></li>
<li>與「視圖（View）」、「備份（Backup）」不同，快照提供的是「靜態副本」，不會隨著原始數據改變。<br /></li>
</ul>

<p>
因此，答案為 (C) snapshot ✅ 🚀<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5691188" class="outline-5">
<h5 id="org5691188">(8) <span class="underline"><span class="underline"><span class="underline">__</span></span></span> is an Internet standard that enables a local-area network (LAN) to use one set of IP addresses for internal traffic and a second set of addresses for external traffic. (A) IPv6 (B) Firewall (C) Tunneling (D) NAT (E) SSH</h5>
<div class="outline-text-5" id="text-org5691188">
</div>
<ul class="org-ul">
<li><a id="orgea57655"></a>解<br />
<div class="outline-text-6" id="text-orgea57655">
<p>
✅ (D) NAT（Network Address Translation，網路位址轉換）<br />
</p>
</div>
</li>
<li><a id="org44c81ca"></a>解析<br />
<div class="outline-text-6" id="text-org44c81ca">
<p>
NAT（網路位址轉換，Network Address Translation） 是一種 網際網路標準（Internet standard），可讓 區域網路（LAN） 內部的裝置使用 內部 IP 位址（Private IP addresses） 來進行內部通訊，而在連接外部網際網路時，則透過 NAT 轉換成 外部公共 IP 位址（Public IP address）。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org4cb917e"></a>NAT 的主要功能<br />
<div class="outline-text-7" id="text-org4cb917e">
<ul class="org-ul">
<li>IP 位址節省：透過 NAT，一個公共 IP 位址可以讓多台內部設備共用，減少對 IPv4 位址的需求。<br /></li>
<li>增強安全性: 內部 IP 地址不會直接暴露在網際網路上，減少被攻擊的風險。<br /></li>
<li>允許私有網路與外部網際網路溝通：NAT 允許使用 私有 IP 位址（如 192.168.x.x、10.x.x.x、172.16.x.x~172.31.x.x） 的設備存取網際網路。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgda8f6bf"></a>選項分析<br />
<div class="outline-text-6" id="text-orgda8f6bf">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">是否正確？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(A) IPv6</td>
<td class="org-left">IPv6 是下一代 IP 位址協定，解決 IPv4 地址不足問題，但不是負責內外部地址轉換。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">(B) Firewall</td>
<td class="org-left">防火牆（Firewall） 用於網路安全過濾，而不是 IP 位址轉換。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">(C) Tunneling</td>
<td class="org-left">通道技術（Tunneling） 用於 VPN 和封裝流量，而非 NAT 的功能。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">(D) NAT</td>
<td class="org-left">網路位址轉換（Network Address Translation），允許 LAN 內部使用一組 IP，對外則使用另一組 IP。</td>
<td class="org-left">✅ 正確答案</td>
</tr>

<tr>
<td class="org-left">(E) SSH</td>
<td class="org-left">安全殼層協議（Secure Shell，SSH） 用於遠端登入，不涉及 IP 位址轉換。</td>
<td class="org-left">❌</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgbb57f1b"></a>與 NAT 相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="org4c61054"></a>1. NAT（網路位址轉換）簡介<br />
<div class="outline-text-7" id="text-org4c61054">
<p>
NAT 是一種允許一個網路內部的裝置使用 私有 IP 位址，並透過 NAT 路由器 轉換成 公共 IP 位址 來進行網際網路通訊的技術。<br />
</p>
</div>
</li>
<li><a id="org259d614"></a>2. NAT 的類型<br />
<div class="outline-text-7" id="text-org259d614">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">NAT 類型</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">靜態 NAT（Static NAT）</td>
<td class="org-left">一對一映射，內部 IP 直接對應到外部 IP，通常用於伺服器。</td>
</tr>

<tr>
<td class="org-left">動態 NAT（Dynamic NAT）</td>
<td class="org-left">內部 IP 轉換為外部 IP，但外部 IP 來自一組可用 IP 範圍。</td>
</tr>

<tr>
<td class="org-left">NAPT（Network Address Port Translation，又稱 PAT）</td>
<td class="org-left">內部多台裝置共用同一個公共 IP，但透過 不同的 Port 號 來區分流量，這是最常見的 NAT 方式（如家用路由器的 NAT）。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orga3dc25b"></a>3. NAT 的應用<br />
<div class="outline-text-7" id="text-orga3dc25b">
<ul class="org-ul">
<li>(1) 家用網路: 家庭 Wi-Fi 路由器使用 NAT，讓家中所有裝置共用一個公共 IP 位址來上網。<br /></li>
<li>(2) 企業網路: 公司內部網路使用 NAT 來隱藏內部 IP 佈局，增強安全性。<br /></li>
<li>(3) 網路負載平衡: 某些網路設備使用 NAT 來將請求分發至不同伺服器，提高可靠性。<br /></li>
</ul>
</div>
</li>
<li><a id="org8878dfb"></a>4. NAT vs. IPv6<br />
<div class="outline-text-7" id="text-org8878dfb">
<ul class="org-ul">
<li>為何需要 NAT？<br />
<ul class="org-ul">
<li>IPv4 位址有限，NAT 允許多台裝置共用 IP，以減少 IPv4 位址需求。<br /></li>
</ul></li>
<li>IPv6 是否需要 NAT？<br />
<ul class="org-ul">
<li>IPv6 提供 龐大的位址空間（128-bit），理論上不需要 NAT。<br /></li>
<li>但某些情境下仍可能使用 NAT64（IPv6 到 IPv4 的轉換技術）。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orge085720"></a>結論<br />
<div class="outline-text-6" id="text-orge085720">
<ul class="org-ul">
<li>NAT（Network Address Translation）是網際網路標準，可讓區域網路（LAN）使用內部 IP，並轉換成外部 IP 來通訊。<br /></li>
<li>NAT 可節省 IP 位址、增強安全性，並允許內部裝置存取網際網路。<br /></li>
<li>NAT 類型包括靜態 NAT、動態 NAT 和 NAPT（PAT），其中 NAPT 是最常見的 NAT 方式。<br /></li>
</ul>
<p>
答案為 (D) NAT ✅ 🚀<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf029e2f" class="outline-5">
<h5 id="orgf029e2f">(9) When an operating system stores data on a disk, it places that data in the first available <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. (A) buffer (B) cell (C) block (D) array (E) sector</h5>
<div class="outline-text-5" id="text-orgf029e2f">
</div>
<ul class="org-ul">
<li><a id="org3c513dc"></a>解<br />
<div class="outline-text-6" id="text-org3c513dc">
<p>
✅ <b><b>(C) Block（區塊）</b></b><br />
</p>
</div>
</li>
<li><a id="orga71bb84"></a><b><b>解析</b></b><br />
<div class="outline-text-6" id="text-orga71bb84">
<p>
當 <b><b>作業系統（Operating System, OS）</b></b> 儲存資料到磁碟（disk）時，它會將資料存入 <b><b>磁碟中的第一個可用區塊（block）**。磁碟中的資料儲存方式採用區塊（block）來管理，而 **每個區塊由多個磁區（sectors）組成**。<br />
 **選項分析</b></b><br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><b><b>選項</b></b></th>
<th scope="col" class="org-left"><b><b>描述</b></b></th>
<th scope="col" class="org-left"><b><b>是否正確？</b></b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>(A) Buffer（緩衝區）</b></b></td>
<td class="org-left">緩衝區是暫存記憶體，主要用來處理 I/O 操作，而不是磁碟存取的單位。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left"><b><b>(B) Cell（儲存格）</b></b></td>
<td class="org-left">記憶體的基本單位，而非磁碟的儲存單位。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left"><b><b>(C) Block（區塊）</b></b></td>
<td class="org-left">磁碟存取的基本單位，每個區塊包含數個磁區，OS 會將資料存入第一個可用區塊。</td>
<td class="org-left">✅ <b><b>正確答案</b></b></td>
</tr>

<tr>
<td class="org-left"><b><b>(D) Array（陣列）</b></b></td>
<td class="org-left">陣列是一種資料結構，而非磁碟存取的基本單位。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left"><b><b>(E) Sector（磁區）</b></b></td>
<td class="org-left">磁區是磁碟的物理儲存單位，但作業系統通常以「區塊」為基本存取單位，而不是磁區。</td>
<td class="org-left">❌</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org14b41f5"></a><b><b>與此主題相關的計算機概論知識</b></b><br />
<ul class="org-ul">
<li><a id="orgd5981d2"></a>1. 磁碟存取的基本單位**<br />
<div class="outline-text-7" id="text-orgd5981d2">
<ul class="org-ul">
<li>**磁區（Sector）**：磁碟的最小物理存取單位，通常為 512 Bytes 或 4096 Bytes。<br /></li>
<li>**區塊（Block）**：OS 存取磁碟的基本邏輯單位，一個區塊通常包含多個磁區（如 4KB 或 8KB）。<br /></li>
</ul>
</div>
</li>
<li><a id="orgb858e20"></a>2. 檔案系統如何存取磁碟**<br />
<div class="outline-text-7" id="text-orgb858e20">
<ul class="org-ul">
<li>作業系統使用 <b><b>檔案系統（File System）</b></b> 來管理磁碟上的資料，常見的檔案系統包括 <b><b>FAT32、NTFS、EXT4、XFS</b></b> 等。<br /></li>
<li>當 OS 需要存取一個檔案時，它會根據 <b><b>檔案分配表（File Allocation Table）或 inode 表</b></b> 來找到該檔案存放的 **區塊（blocks）**，並將資料讀取到記憶體中。<br /></li>
</ul>
</div>
</li>
<li><a id="org7087191"></a>3. 磁碟存取方式**<br />
<div class="outline-text-7" id="text-org7087191">
<ul class="org-ul">
<li>**連續存取（Sequential Access）**：檔案的區塊是連續存放的，適合大檔案，如影音文件。<br /></li>
<li><b><b>非連續存取（Non-Sequential Access）**：檔案的區塊可能分散在磁碟的不同區域，需要透過 **磁碟索引</b></b> 來定位。<br /></li>
</ul>
</div>
</li>
<li><a id="org1e6402a"></a>4. 與磁碟存取相關的 OS 概念**<br />
<div class="outline-text-7" id="text-org1e6402a">
<ul class="org-ul">
<li>**磁碟分頁（Paging）**：作業系統會利用磁碟上的區塊來存放記憶體換出的分頁（page）。<br /></li>
<li>**快取（Disk Cache）**：將經常存取的磁碟區塊暫存於記憶體中，以提升存取速度。<br /></li>
<li>**磁碟排程（Disk Scheduling）**：當多個 I/O 請求發生時，OS 會透過演算法（如 FCFS、SSTF、SCAN）來最佳化磁碟讀寫的順序。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org59eaff2"></a><b><b>結論</b></b><br />
<div class="outline-text-6" id="text-org59eaff2">
<ol class="org-ol">
<li><b><b>區塊（Block）是作業系統存取磁碟時的基本單位，而磁區（Sector）則是物理儲存單位。</b></b><br /></li>
<li><b><b>當作業系統需要寫入資料時，它會將資料存入磁碟上的第一個可用「區塊（Block）」，而非磁區（Sector）。</b></b><br /></li>
<li><b><b>檔案系統（如 NTFS、EXT4）負責管理這些區塊，並將它們組織成檔案與目錄結構。</b></b><br /></li>
</ol>
<p>
因此，答案為 <b><b>(C) Block</b></b> ✅<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf5ce9ee" class="outline-5">
<h5 id="orgf5ce9ee">(10) <span class="underline"><span class="underline"><span class="underline">__</span></span></span> is a region in a program&rsquo;s memory space that stores variables that can be accessed globally. This region does not have size restrictions on variable size. However, it must be used very carefully to prevent memory leaks. (A) Heap (B) Stack (C) Buffer (D) Virtual memory (E) Code page</h5>
<div class="outline-text-5" id="text-orgf5ce9ee">
</div>
<ul class="org-ul">
<li><a id="org0cd3b83"></a>解<br />
<div class="outline-text-6" id="text-org0cd3b83">
<p>
✅ <b><b>(A) Heap（堆區）</b></b><br />
</p>
</div>
</li>
<li><a id="orgf0469a2"></a>解析<br />
<div class="outline-text-6" id="text-orgf0469a2">
<p>
<b><b>堆區（Heap）</b></b> 是程式記憶體的一個區域，專門用來存放**動態分配（dynamic allocation）** 的變數。這些變數的生命週期不受函式範圍限制，可以在整個程式執行期間存取。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org781df1e"></a>Heap 的特性：**<br />
<div class="outline-text-7" id="text-org781df1e">
<ul class="org-ul">
<li>**可存放全域變數**：變數可以在程式的任何部分存取。<br /></li>
<li>**無大小限制**：變數大小只受系統可用記憶體的限制，而不像 Stack 受到固定大小限制。<br /></li>
<li>**手動管理**：程式員需自行管理記憶體分配與釋放，否則可能導致記憶體洩漏（memory leak）。<br /></li>
<li>**存取速度較慢**：Heap 變數需要透過指標存取，存取速度通常比 Stack 慢。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org1579fd1"></a>選項分析**<br />
<div class="outline-text-6" id="text-org1579fd1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><b><b>選項</b></b></th>
<th scope="col" class="org-left"><b><b>描述</b></b></th>
<th scope="col" class="org-left"><b><b>是否正確？</b></b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>(A) Heap（堆區）</b></b></td>
<td class="org-left">儲存動態分配的變數，變數可在整個程式中存取，需手動管理記憶體。</td>
<td class="org-left">✅ <b><b>正確答案</b></b></td>
</tr>

<tr>
<td class="org-left"><b><b>(B) Stack（堆疊）</b></b></td>
<td class="org-left">用於儲存函式呼叫的區域變數，受到固定大小限制，變數在函式結束後自動釋放。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left"><b><b>(C) Buffer（緩衝區）</b></b></td>
<td class="org-left">一種記憶體區域，用於短暫儲存資料以提高效能，但不是全域存取的區域。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left"><b><b>(D) Virtual memory（虛擬記憶體）</b></b></td>
<td class="org-left">是硬碟模擬的額外記憶體，不屬於程式的記憶體空間，主要用於擴展可用記憶體。</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left"><b><b>(E) Code page（程式碼區）</b></b></td>
<td class="org-left">儲存程式的可執行代碼，不適用於變數儲存。</td>
<td class="org-left">❌</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgdadc3a3"></a>與此主題相關的計算機概論知識**<br />
<ul class="org-ul">
<li><a id="org50e6cb2"></a>1. 程式的記憶體區域**<br />
<div class="outline-text-7" id="text-org50e6cb2">
<ol class="org-ol">
<li>**程式碼區（Code Section）**：儲存程式的執行代碼。<br /></li>
<li>**資料區（Data Section）**：包含靜態分配的變數（如全域變數）。<br /></li>
<li>**堆疊（Stack）**：用於函式呼叫的區域變數。<br /></li>
<li>**堆區（Heap）**：用於動態分配的變數。<br /></li>
<li>**虛擬記憶體（Virtual Memory）**：由作業系統提供，作為額外的記憶體空間。<br /></li>
</ol>
</div>
</li>
<li><a id="orgd6627db"></a>2. Heap 的使用場景**<br />
<div class="outline-text-7" id="text-orgd6627db">
<ul class="org-ul">
<li><b><b>C / C++</b></b> 需要透過 `malloc()` 或 `new` 來分配 Heap 記憶體，並用 `free()` 或 `delete` 來釋放。<br /></li>
<li><b><b>Java / Python / C#</b></b> 具有自動記憶體管理機制（如 Garbage Collection），自動釋放 Heap 中未使用的物件。<br /></li>
</ul>
</div>
</li>
<li><a id="org55eb70e"></a>3. 記憶體洩漏（Memory Leak）**<br />
<div class="outline-text-7" id="text-org55eb70e">
<p>
如果程式動態分配了 Heap 記憶體但未適當釋放，則可能導致記憶體洩漏，長時間運行的程式可能因此耗盡系統記憶體。<br />
</p>
</div>
</li>
<li><a id="orgb292299"></a>4. Heap vs. Stack 差異**<br />
<div class="outline-text-7" id="text-orgb292299">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><b><b>比較項目</b></b></th>
<th scope="col" class="org-left"><b><b>Heap（堆區）</b></b></th>
<th scope="col" class="org-left"><b><b>Stack（堆疊）</b></b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>變數存活時間</b></b></td>
<td class="org-left">程式執行期間持續存在</td>
<td class="org-left">函式執行完畢即釋放</td>
</tr>

<tr>
<td class="org-left"><b><b>存取方式</b></b></td>
<td class="org-left">透過指標存取，較慢</td>
<td class="org-left">直接存取，較快</td>
</tr>

<tr>
<td class="org-left"><b><b>記憶體大小</b></b></td>
<td class="org-left">受可用記憶體限制，較大</td>
<td class="org-left">固定大小，通常較小</td>
</tr>

<tr>
<td class="org-left"><b><b>管理方式</b></b></td>
<td class="org-left">需要手動分配與釋放</td>
<td class="org-left">自動管理</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
<li><a id="org6ebdc2b"></a>結論**<br />
<div class="outline-text-6" id="text-org6ebdc2b">
<ol class="org-ol">
<li><b><b>Heap 是程式記憶體中的區域，用於動態分配變數，變數可以在整個程式中存取。</b></b><br /></li>
<li><b><b>與 Stack 相比，Heap 具有較高的彈性，但需要手動管理，否則可能導致記憶體洩漏。</b></b><br /></li>
<li><b><b>在 C / C++ 需要手動釋放 Heap 記憶體，而 Java / Python 則有 Garbage Collection 機制自動管理。</b></b><br /></li>
</ol>
<p>
因此，答案為 <b><b>(A) Heap</b></b> ✅<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc23c8dc" class="outline-4">
<h4 id="orgc23c8dc"><span class="section-number-4">7.1.2.</span> A-2 Short Answer Questions: (20%)</h4>
<div class="outline-text-4" id="text-7-1-2">
</div>
<div id="outline-container-org618dd0a" class="outline-5">
<h5 id="org618dd0a">(1) Convert all the class associations in the following class diagram to tables in RDBMS (Data types can be ignored.) <code>[10%]</code></h5>
<div class="outline-text-5" id="text-org618dd0a">
<p>
(image of a class diagram with Student, Graduate Student, Undergrad Student, Course, and Course Offering)<br />
類別圖 (Class Diagram)：這個圖展示了數個類別及其之間的關聯:<br />
</p>
<pre class="example" id="orgc8a6d92">
- Student (抽象類別):
  - 屬性：name、address、phone
  - 方法：register(class)、calc-tuition()
- Graduate Student (繼承自 Student):
  - 屬性：undergradMajor、greScore、actScore、tuitionPerCred
  - 方法：calc-tuition()
- Undergrad Student (繼承自 Student):
  - 屬性：satScore、actScore、tuitionPerCred
  - 方法：calc-tuition()
- Course
  - 屬性：crseCode, crseTitle, enrollment
- Course Offering
  - 屬性：term, section
  - 方法：Scheduled-for
- 關聯 (Relationships):
  - Student 和 Course Offering 之間存在多對多的關聯 (Register-for)。
  - Course 和 Course Offering 之間存在一對多的關聯 (Scheduled-for)。
  - Graduate Student 和 Undergrad Student 都是 Student 的子類別（繼承關係）。
</pre>

<div id="org5dfce31" class="figure">
<p><img src="images/林北的考前猜題/2025-01-31_19-13-48.png" alt="2025-01-31_19-13-48.png" width="500" /><br />
</p>
</div>
</div>
<ul class="org-ul">
<li><a id="org63b0b61"></a>解：<br />
<div class="outline-text-6" id="text-org63b0b61">
<ul class="org-ul">
<li>\[\]這題的解要有所保留，因為圖是我用AI以文字描述出來的，不確定正確，但應該可以參考做法%%%%<br /></li>
</ul>
<p>
在關聯式資料庫 (RDBMS) 中，將類別圖轉換為資料表時，需要考慮以下幾個主要步驟：<br />
    將類別 (Class) 轉換為資料表 (Table)<br />
        每個類別 (class) 轉換為一張資料表 (table)，其中的屬性 (attributes) 變成欄位 (columns)。<br />
    處理繼承關係 (Inheritance Mapping)<br />
        RDBMS 沒有內建的類別繼承，因此常見的處理方式有：<br />
            單表繼承 (Single Table Inheritance)：所有子類別的屬性與父類別的屬性合併到同一張表，並使用一個 type 欄位區分不同類別。<br />
            類別表繼承 (Class Table Inheritance)：為每個類別創建一張獨立的表，子類別的表包含父類別的主鍵作為外鍵。<br />
            具體類別表繼承 (Concrete Table Inheritance)：不創建父類別表，直接為每個子類別建立獨立的表，包含所有需要的屬性。<br />
    處理關聯 (Relationships to Foreign Keys and Junction Tables)<br />
        一對多 (One-to-Many)：在多的一方增加外鍵 (foreign key) 指向一的一方的主鍵。<br />
        多對多 (Many-to-Many)：使用聯結表 (junction table) 來儲存兩個表的主鍵，以建立關聯。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd2d53a7"></a>轉換類別圖為 RDBMS 資料表<br />
<div class="outline-text-7" id="text-orgd2d53a7">
<ol class="org-ol">
<li><p>
Student (抽象類別)<br />
選擇 類別表繼承 (Class Table Inheritance)，因此 Student 本身是一張表，Graduate Student 和 Undergrad Student 創建獨立的表，並繼承 Student 的主鍵 (studentID)。<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">   CREATE TABLE Student (
       studentID INT PRIMARY KEY,
       name VARCHAR(255),
       address VARCHAR(255),
       phone VARCHAR(20)
   );
</pre>
</div></li>
<li><p>
Graduate Student (研究生)<br />
繼承 Student，需要使用 studentID 作為主鍵和外鍵。<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">   CREATE TABLE GraduateStudent (
       studentID INT PRIMARY KEY,
       undergradMajor VARCHAR(255),
       greScore INT,
       actScore INT,
       tuitionPerCred DECIMAL(10,2),
       FOREIGN KEY (studentID) REFERENCES Student(studentID)
   );
</pre>
</div></li>
<li><p>
Undergrad Student (大學生)<br />
同樣繼承 Student，需要 studentID 作為主鍵和外鍵。<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">   CREATE TABLE UndergradStudent (
       studentID INT PRIMARY KEY,
       satScore INT,
       actScore INT,
       tuitionPerCred DECIMAL(10,2),
       FOREIGN KEY (studentID) REFERENCES Student(studentID)
   );
</pre>
</div></li>
<li><p>
Course (課程)<br />
crseCode 作為主鍵，enrollment 紀錄課程的註冊人數。<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">   CREATE TABLE Course (
       crseCode VARCHAR(20) PRIMARY KEY,
       crseTitle VARCHAR(255),
       enrollment INT
   );
</pre>
</div></li>
<li><p>
Course Offering (課程開設)<br />
section 用來區分不同的開課班次，並與 Course 形成一對多關係。<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">   CREATE TABLE CourseOffering (
       offeringID INT PRIMARY KEY AUTO_INCREMENT,
       crseCode VARCHAR(20),
       term VARCHAR(50),
       section VARCHAR(10),
       FOREIGN KEY (crseCode) REFERENCES Course(crseCode)
   );
</pre>
</div></li>
<li>Register-for (學生註冊課程)<br />
多對多關係，需要額外的聯結表 (Junction Table)。<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-nil">CREATE TABLE RegisterFor (
    studentID INT,
    offeringID INT,
    PRIMARY KEY (studentID, offeringID),
    FOREIGN KEY (studentID) REFERENCES Student(studentID),
    FOREIGN KEY (offeringID) REFERENCES CourseOffering(offeringID)
);
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="org921ee2e"></a>相關計算機概論 (計概) 知識<br />
<div class="outline-text-6" id="text-org921ee2e">
<ol class="org-ol">
<li>物件導向設計 (Object-Oriented Design)<br />
<ul class="org-ul">
<li>類別 (Class) 與 物件 (Object)：<br />
<ul class="org-ul">
<li>類別是物件的藍圖，定義了屬性與行為。<br /></li>
</ul></li>
<li>繼承 (Inheritance)：<br />
<ul class="org-ul">
<li>允許子類別繼承父類別的屬性與方法，提高程式碼的重用性。<br /></li>
</ul></li>
<li>多型 (Polymorphism)：<br />
<ul class="org-ul">
<li>允許子類別使用與父類別相同的方法名稱，但可以有不同的行為。<br /></li>
</ul></li>
</ul></li>
<li>關聯式資料庫 (Relational Database)<br />
<ul class="org-ul">
<li>關聯模式 (Relational Schema)：<br />
<ul class="org-ul">
<li>將類別圖轉換為資料表的過程，就是設計關聯模式。<br /></li>
</ul></li>
<li>主鍵 (Primary Key) 與 外鍵 (Foreign Key)：<br />
<ul class="org-ul">
<li>主鍵：唯一標識表中的每一筆資料，如 studentID。<br /></li>
<li>外鍵：連結兩個表的關聯，如 GraduateStudent.studentID 參考 Student.studentID。<br /></li>
</ul></li>
<li>正規化 (Normalization)：<br />
<ul class="org-ul">
<li>用來消除資料冗餘，提升資料完整性與一致性。<br /></li>
<li>第一正規化 (1NF)：所有欄位的值必須是原子值 (Atomic)。<br /></li>
<li>第二正規化 (2NF)：消除部分函數相依 (Partial Dependency)。<br /></li>
<li>第三正規化 (3NF)：消除傳遞函數相依 (Transitive Dependency)。<br /></li>
</ul></li>
</ul></li>
<li>資料庫關聯 (Database Relationships)<br />
<ul class="org-ul">
<li>一對多 (1:M)：<br />
<ul class="org-ul">
<li>Course 和 CourseOffering 之間的關聯，一個課程可以有多個開設。<br /></li>
</ul></li>
<li>多對多 (M:N)：<br />
<ul class="org-ul">
<li>Student 和 CourseOffering 之間的關聯，學生可以註冊多個課程，一個課程也可以有多個學生，透過 RegisterFor 表來實現。<br /></li>
</ul></li>
</ul></li>
<li>SQL 查詢與操作<br />
<ul class="org-ul">
<li><p>
查詢學生修課資訊<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">     SELECT s.studentID, s.name, c.crseTitle, co.term, co.section
     FROM Student s
     JOIN RegisterFor rf ON s.studentID = rf.studentID
     JOIN CourseOffering co ON rf.offeringID = co.offeringID
     JOIN Course c ON co.crseCode = c.crseCode;
</pre>
</div></li>
<li><p>
新增學生註冊課程<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">     INSERT INTO RegisterFor (studentID, offeringID) VALUES (1, 101);
</pre>
</div></li>
<li><p>
刪除學生註冊課程<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">     DELETE FROM RegisterFor WHERE studentID = 1 AND offeringID = 101;
</pre>
</div></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org1f18585"></a>另一解:<br />
<div class="outline-text-6" id="text-org1f18585">
<p>
類別圖轉換為 RDBMS 表格<br />
根據類別圖，我們將建立以下表格：<br />
</p>
<ol class="org-ol">
<li>Student 表格 (學生)<br />
<ul class="org-ul">
<li>studentID (主鍵) - 學生ID (假設有學生ID)<br /></li>
<li>name (姓名)<br /></li>
<li>address (地址)<br /></li>
<li>phone (電話)<br /></li>
</ul></li>
<li>GraduateStudent 表格 (研究生)<br />
<ul class="org-ul">
<li>studentID (主鍵，外鍵參考 Student 表格)<br /></li>
<li>undergradMajor (大學主修)<br /></li>
<li>greScore (GRE 成績)<br /></li>
<li>actScore (ACT 成績)<br /></li>
<li>tuitionPerCred (每學分學費)<br /></li>
</ul></li>
<li>UndergradStudent 表格 (大學生)<br />
<ul class="org-ul">
<li>studentID (主鍵，外鍵參考 Student 表格)<br /></li>
<li>satScore (SAT 成績)<br /></li>
<li>actScore (ACT 成績)<br /></li>
<li>tuitionPerCred (每學分學費)<br /></li>
</ul></li>
<li>Course 表格 (課程)<br />
<ul class="org-ul">
<li>crseCode (主鍵) - 課程代碼<br /></li>
<li>crseTitle (課程名稱)<br /></li>
<li>enrollment (選課人數)<br /></li>
</ul></li>
<li>CourseOffering 表格 (課程班次)<br />
<ul class="org-ul">
<li>offeringID (主鍵) - 開課ID (假設有開課ID)<br /></li>
<li>term (學期)<br /></li>
<li>section (班次)<br /></li>
<li>crseCode (外鍵參考 Course 表格)<br /></li>
</ul></li>
<li>Registration 表格 (選課紀錄)<br />
<ul class="org-ul">
<li>studentID (外鍵參考 Student 表格)<br /></li>
<li>offeringID (外鍵參考 CourseOffering 表格)<br /></li>
<li>(其他可能包含的欄位，如註冊日期等)<br /></li>
<li>(主鍵為studentID和offeringID的組合)<br /></li>
</ul></li>
</ol>
</div>
<ul class="org-ul">
<li><a id="orgc425485"></a>中文詳解<br />
<div class="outline-text-7" id="text-orgc425485">
<ul class="org-ul">
<li>表格建立原則：<br />
<ul class="org-ul">
<li>類別通常會轉換成表格<br /></li>
<li>類別的屬性 (attributes) 轉換成表格的欄位 (columns)<br /></li>
<li>類別的方法 (methods) 在資料庫中通常不直接對應到欄位，而是透過程式碼邏輯來實現。<br /></li>
<li>繼承關係在關聯式資料庫中通常使用個別表格加上外鍵關聯來表示<br /></li>
<li>多對多的關聯通常會建立一個中間表格 (junction table)，用來儲存兩個表格之間的關聯<br /></li>
</ul></li>
<li>主鍵 (Primary Key): 用來唯一識別表格中的每一筆紀錄。例如 studentID , crseCode, offeringID 等欄位。<br /></li>
<li>外鍵 (Foreign Key): 用來建立表格之間的關聯，參考其他表格的主鍵。例如 GraduateStudent 表格中的 studentID 參考 Student 表格的 studentID，CourseOffering 表格中的 crseCode 參考 Course 表格的 crseCode，Registration 表格中的 studentID 參考 Student 表格的 studentID 和 Registration 表格中的 offeringID 參考 CourseOffering 表格的 offeringID。<br /></li>
<li>繼承關係處理：GraduateStudent 和 UndergradStudent 繼承自 Student，因此各自建立表格，並使用 studentID 作為外鍵與 Student 表格關聯。<br /></li>
<li>多對多關係處理: Student 和 CourseOffering 之間的多對多關聯，需要建立 Registration 表格，使用 studentID 和 offeringID 作為外鍵，紀錄學生的選課紀錄。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgf51d8ef" class="outline-5">
<h5 id="orgf51d8ef">(2) When designing software, particularly object-oriented programs, it is crucial to follow the law of Demeter and the principle of substitutability. Explain what they are and give an example for each. <code>[10%]</code></h5>
<div class="outline-text-5" id="text-orgf51d8ef">
</div>
<ul class="org-ul">
<li><a id="org88d3e75"></a>解<br />
<div class="outline-text-6" id="text-org88d3e75">
<p>
物件導向設計中的兩大原則<br />
</p>

<p>
在物件導向設計 (Object-Oriented Design, OOD) 中，有許多設計原則用來提升程式碼的可讀性、可維護性與可擴展性。本題討論 Demeter 法則 (Law of Demeter, LoD) 及 替換原則 (Liskov Substitution Principle, LSP)，這兩者分別強調「降低物件之間的耦合度」與「保持物件的可替換性」。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgdb8c927"></a>1. Demeter 法則 (Law of Demeter, LoD)<br />
<div class="outline-text-7" id="text-orgdb8c927">
<ul class="org-ul">
<li>定義<br />
<ul class="org-ul">
<li>Demeter 法則又稱為最少知識原則 (Principle of Least Knowledge)，核心思想是：「一個物件應該只與它直接相關的物件進行交互，而不應該知道太多其他物件的內部結構。」<br /></li>
<li>換句話說，不要透過多層級的物件存取 (避免 &ldquo;one-dot rule violation&rdquo;)，這樣可以減少耦合，使系統更加模組化與容易維護。<br /></li>
</ul></li>
<li><p>
違反 Demeter 法則的例子<br />
假設我們有一個 Person 物件，它有 Address 物件，而 Address 物件又包含 City 物件：<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">  class City:
      def __init__(self, name):
          self.name = name

  class Address:
      def __init__(self, city):
          self.city = city

  class Person:
      def __init__(self, address):
          self.address = address

  # 直接存取多層物件，違反 Demeter 法則
  person = Person(Address(City("Taipei")))
  print(person.address.city.name)  # ❌ 違反 Demeter 法則
</pre>
</div>
<p>
這裡的 person.address.city.name 直接存取 city 物件的 name，這樣的寫法會導致：<br />
</p>
<ol class="org-ol">
<li>如果 Address 或 City 的內部結構變動，Person 的程式碼也需要修改，導致高耦合。<br /></li>
<li>Person 依賴過多外部物件的內部細節，違反模組化原則。<br /></li>
</ol></li>
<li><p>
符合 Demeter 法則的寫法<br />
我們可以透過封裝 (Encapsulation) 來避免直接存取內部屬性：<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">  class City:
      def __init__(self, name):
          self.name = name

  class Address:
      def __init__(self, city):
          self._city = city

      def get_city_name(self):
          return self._city.name  # 提供方法存取

  class Person:
      def __init__(self, address):
          self._address = address

      def get_city_name(self):
          return self._address.get_city_name()  # 透過方法存取

  # 使用封裝的方法
  person = Person(Address(City("Taipei")))
  print(person.get_city_name())  # ✅ 符合 Demeter 法則
</pre>
</div>
<p>
這樣 Person 只會與 Address 直接互動，而不會知道 City 的內部細節，降低耦合度，提高可維護性。<br />
</p></li>
</ul>
</div>
</li>
<li><a id="org661611b"></a>2. 替換原則 (Liskov Substitution Principle, LSP)<br />
<div class="outline-text-7" id="text-org661611b">
<ul class="org-ul">
<li><p>
定義<br />
Liskov 替換原則 (Liskov Substitution Principle, LSP) 由 Barbara Liskov 提出，核心概念是：<br />
</p>
<blockquote>
<p>
「子類別應該能夠替換其父類別，而不會影響程式的正確性。」<br />
</p>
</blockquote>
<p>
換句話說，如果程式碼可以使用父類別，那麼它應該也能夠使用子類別，而不需要修改任何額外的程式碼。<br />
</p></li>
<li><p>
違反 LSP 的例子<br />
假設我們有一個 Bird 類別，其中有 fly() 方法，但 Penguin 是鳥類卻不會飛：<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">  class Bird:
      def fly(self):
          print("I can fly!")

  class Penguin(Bird):  # ❌ 企鵝不會飛，卻繼承 fly() 方法
      pass

  def make_bird_fly(bird: Bird):
      bird.fly()  # 期望所有 Bird 都可以飛

  # 測試
  sparrow = Bird()
  penguin = Penguin()

  make_bird_fly(sparrow)  # ✅ 輸出: I can fly!
  make_bird_fly(penguin)  # ❌ 會導致錯誤，因為企鵝不能飛
</pre>
</div>
<p>
這樣的設計違反了 LSP，因為 Penguin 無法完全替換 Bird，導致程式發生邏輯錯誤。<br />
</p></li>
<li><p>
符合 LSP 的寫法<br />
可以透過介面 (Interface) 或抽象類別 (Abstract Class) 分開處理「會飛的鳥」與「不會飛的鳥」：<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">  class Bird:
      def move(self):
          pass  # 允許所有鳥類移動

  class FlyingBird(Bird):
      def fly(self):
          print("I can fly!")

  class Sparrow(FlyingBird):
      pass

  class Penguin(Bird):  # 企鵝不繼承 FlyingBird，因此不會飛
      def swim(self):
          print("I can swim!")

  def make_bird_fly(bird: FlyingBird):
      bird.fly()

  # 測試
  sparrow = Sparrow()
  penguin = Penguin()

  make_bird_fly(sparrow)  # ✅ 輸出: I can fly!
  # make_bird_fly(penguin)  # ❌ 無法編譯，避免了 LSP 違反
</pre>
</div>
<p>
這樣的設計確保 Penguin 不會被誤用為一隻會飛的鳥，符合 Liskov 替換原則。<br />
</p></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgaca9998"></a>相關計算機概論 (計概) 知識<br />
<div class="outline-text-6" id="text-orgaca9998">
<ol class="org-ol">
<li>物件導向設計 (Object-Oriented Design, OOD)<br />
<ul class="org-ul">
<li>封裝 (Encapsulation)：Demeter 法則強調封裝，避免直接存取內部屬性，改用方法存取。<br /></li>
<li>繼承 (Inheritance) 與 多型 (Polymorphism)：LSP 關注子類別是否真正符合父類別的行為，避免不適當的繼承。<br /></li>
</ul></li>
<li>設計原則 (Design Principles)<br />
<ul class="org-ul">
<li>SOLID 原則<br />
<ul class="org-ul">
<li>S：單一職責原則 (SRP) - 一個類別應該只有一個變更的理由。<br /></li>
<li>O：開放封閉原則 (OCP) - 程式應該對擴展開放，對修改封閉。<br /></li>
<li>L：Liskov 替換原則 (LSP) - 子類別應該能夠替代父類別。<br /></li>
<li>I：介面隔離原則 (ISP) - 介面應該要小而精，不應該強迫子類別實作不需要的方法。<br /></li>
<li>D：依賴反轉原則 (DIP) - 高階模組不應該依賴低階模組，應該透過抽象介面互動。<br /></li>
</ul></li>
</ul></li>
<li>設計模式 (Design Patterns)<br />
<ul class="org-ul">
<li>Facade 模式 (門面模式)：提供單一介面來隱藏內部複雜性，符合 Demeter 法則。<br /></li>
<li>Strategy 模式：允許不同類別實作相同介面，使得 LSP 更容易遵守。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orgccc265d"></a>總結<br />
<div class="outline-text-6" id="text-orgccc265d">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">原則</th>
<th scope="col" class="org-left">核心概念</th>
<th scope="col" class="org-left">違反例子</th>
<th scope="col" class="org-left">符合例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Demeter 法則</td>
<td class="org-left">物件應該只與直接相關的物件互動</td>
<td class="org-left">person.address.city.name</td>
<td class="org-left">person.get_city_name()</td>
</tr>

<tr>
<td class="org-left">Liskov 替換原則</td>
<td class="org-left">子類別應該可以無縫替換父類別</td>
<td class="org-left">Penguin 繼承 Bird 並有 fly()</td>
<td class="org-left">使用 FlyingBird 和 Bird 分離</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf6dd8b7" class="outline-4">
<h4 id="orgf6dd8b7"><span class="section-number-4">7.1.3.</span> B-1 (4%) A C++ function that prints a string via pointer arithmetic such as ptr to output each character has a parameter that is</h4>
<div class="outline-text-4" id="text-7-1-3">
<ul class="org-ul">
<li>(a) nonconstant pointer to nonconstant data.<br /></li>
<li>(b) nonconstant pointer to constant data.<br /></li>
<li>(c) constant pointer to nonconstant data.<br /></li>
<li>(d) constant pointer to constant data.<br /></li>
</ul>
</div>
<div id="outline-container-org8a82dca" class="outline-5">
<h5 id="org8a82dca">解</h5>
<div class="outline-text-5" id="text-org8a82dca">
<p>
在 C++ 中，指標 (pointer) 的常數性分為兩個部分：<br />
</p>
<ul class="org-ul">
<li>指標本身是否為常數 (指標是否能改變所指向的位置)<br /></li>
<li>指標所指向的資料是否為常數 (指標能否修改該位置的值)<br /></li>
</ul>

<p>
這些組合可以用四種方式表示：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">類型</th>
<th scope="col" class="org-left">定義方式</th>
<th scope="col" class="org-left">指標本身可變？</th>
<th scope="col" class="org-left">指向的資料可變？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) 非常數指標指向非常數資料</td>
<td class="org-left">char *ptr;</td>
<td class="org-left">✅ 可變</td>
<td class="org-left">✅ 可變</td>
</tr>

<tr>
<td class="org-left">(b) 非常數指標指向常數資料</td>
<td class="org-left">const char *ptr;</td>
<td class="org-left">✅ 可變</td>
<td class="org-left">❌ 不可變</td>
</tr>

<tr>
<td class="org-left">(c) 常數指標指向非常數資料</td>
<td class="org-left">char *const ptr;</td>
<td class="org-left">❌ 不可變</td>
<td class="org-left">✅ 可變</td>
</tr>

<tr>
<td class="org-left">(d) 常數指標指向常數資料</td>
<td class="org-left">const char *const ptr;</td>
<td class="org-left">❌ 不可變</td>
<td class="org-left">❌ 不可變</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org384dc07" class="outline-5">
<h5 id="org384dc07">解析：C++ 指標運算與函式參數類型</h5>
<div class="outline-text-5" id="text-org384dc07">
<p>
題目要求我們使用指標運算 (Pointer Arithmetic) 來輸出字串的每個字元，即透過 ptr++ 遍歷字串。這表示：<br />
</p>
<ul class="org-ul">
<li>指標 ptr 必須是「非常數指標」，因為它需要改變所指向的位置 (ptr++)。<br /></li>
<li>指標所指向的資料是否為常數則取決於需求：<br />
<ul class="org-ul">
<li>如果允許修改字串內容 → (a) 或 (c)<br /></li>
<li>如果不允許修改字串內容 → (b) 或 (d)<br /></li>
</ul></li>
</ul>

<p>
此外，由於這是輸出字串的函式 (printString)，我們通常不會修改原始字串的內容，但需要讓指標前進。因此，我們應該選擇：<br />
(b) const char *ptr; (非常數指標指向常數資料)<br />
這表示 ptr 可以變動 (可遞增 ptr++)，但 *ptr 所指向的內容不能被修改，這是標準的 C++ 字串輸出方式。<br />
</p>
</div>
</div>
<div id="outline-container-orgc78bc74" class="outline-5">
<h5 id="orgc78bc74">正確的 C++ 函式</h5>
<div class="outline-text-5" id="text-orgc78bc74">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">printString</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">ptr</span>) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(b) &#38750;&#24120;&#25976;&#25351;&#27161;&#25351;&#21521;&#24120;&#25976;&#36039;&#26009;</span>
<span class="linenr"> 4: </span>    <span style="color: #51afef;">while</span> (*ptr) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30070; ptr &#25152;&#25351;&#21521;&#30340;&#23383;&#20803;&#19981;&#26159; '\0'</span>
<span class="linenr"> 5: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; *ptr;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986;&#23383;&#20803;</span>
<span class="linenr"> 6: </span>        ptr++;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#27161;&#21069;&#36914;</span>
<span class="linenr"> 7: </span>    }
<span class="linenr"> 8: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr"> 9: </span>}
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">12: </span>    <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">message</span> = <span style="color: #98be65;">"Hello, world!"</span>;
<span class="linenr">13: </span>    printString(message);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986; "Hello, world!"</span>
<span class="linenr">14: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">15: </span>}
<span class="linenr">16: </span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org37f0111"></a>程式分析<br />
<div class="outline-text-6" id="text-org37f0111">
<ul class="org-ul">
<li>const char *ptr：<br />
<ul class="org-ul">
<li>ptr 本身可變，所以可以用 ptr++ 來遍歷字串。<br /></li>
<li>*ptr 為常數，因此無法修改內容 (例如 *ptr = &rsquo;A&rsquo;; 會導致編譯錯誤)。<br /></li>
</ul></li>
<li>while (*ptr)：<br />
<ul class="org-ul">
<li>利用 C++ 的 C 風格字串 (null-terminated string) 來逐一輸出字元。<br /></li>
</ul></li>
<li>指標遞增 (ptr++)：<br />
<ul class="org-ul">
<li>這樣我們就能遍歷字串，直到 \0 (空字元) 為止。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8878bba" class="outline-5">
<h5 id="org8878bba">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-org8878bba">
<ol class="org-ol">
<li>C/C++ 字串與記憶體表示<br />
<ul class="org-ul">
<li>在 C/C++ 中，字串 (char*) 是以 NULL (\0) 結尾的字元陣列。<br /></li>
<li>指標可以直接指向字串的起始位置，透過指標運算 (ptr++) 來遍歷字串。<br /></li>
</ul></li>
<li>指標與常數性 (Pointer Const Qualifiers)<br />
<ul class="org-ul">
<li>為何使用 const char *ptr？<br />
<ul class="org-ul">
<li>這樣可以確保字串內容不可變，符合字串輸出函式的設計原則。<br /></li>
<li>常數字串 (如 &ldquo;Hello&rdquo; 這類的字串常數) 在記憶體中通常儲存於 唯讀區段 (Read-Only Memory, ROM)，嘗試修改會導致執行錯誤。<br /></li>
</ul></li>
</ul></li>
<li>指標運算與指標遞增<br />
<ul class="org-ul">
<li>ptr++ 代表指標前進至下一個記憶體位置 (char 類型的大小通常為 1 byte)。<br /></li>
<li>*ptr 代表指標當前位置的值，可以用來存取字串的每個字元。<br /></li>
</ul></li>
<li>const 的好處<br />
<ul class="org-ul">
<li>避免修改原始資料，提升程式的安全性。<br /></li>
<li>防止未預期的錯誤，例如試圖修改常數字串的內容。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgc1e5bba" class="outline-5">
<h5 id="orgc1e5bba">總結</h5>
<div class="outline-text-5" id="text-orgc1e5bba">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">指標類型</th>
<th scope="col" class="org-left">ptr++ 是否可行？</th>
<th scope="col" class="org-left">*ptr 是否可變？</th>
<th scope="col" class="org-left">適用情境</th>
<th scope="col" class="org-left">是否適合本題？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) char *ptr</td>
<td class="org-left">非常數指標指向非常數資料</td>
<td class="org-left">✅ 可以</td>
<td class="org-left">✅ 可以修改</td>
<td class="org-left">需要修改字串</td>
<td class="org-left">❌ 不適合</td>
</tr>

<tr>
<td class="org-left">(b) const char *ptr</td>
<td class="org-left">非常數指標指向常數資料</td>
<td class="org-left">✅ 可以</td>
<td class="org-left">❌ 不可修改</td>
<td class="org-left">輸出或只讀取字串</td>
<td class="org-left">✅ 最適合</td>
</tr>

<tr>
<td class="org-left">(c) char *const ptr</td>
<td class="org-left">常數指標指向非常數資料</td>
<td class="org-left">❌ 不能移動</td>
<td class="org-left">✅ 可以修改</td>
<td class="org-left">固定指向某塊記憶體但允許改變內容</td>
<td class="org-left">❌ 不適合</td>
</tr>

<tr>
<td class="org-left">(d) const char *const ptr</td>
<td class="org-left">常數指標指向常數資料</td>
<td class="org-left">❌ 不能移動</td>
<td class="org-left">❌ 不可修改</td>
<td class="org-left">指標與內容皆固定</td>
<td class="org-left">❌ 不適合</td>
</tr>
</tbody>
</table>
<p>
本題最佳選擇為 (b) 非常數指標指向常數資料 (const char *ptr)，因為：<br />
</p>
<ul class="org-ul">
<li>允許 ptr++ 進行指標運算。<br /></li>
<li>保證字串內容不會被意外修改。<br /></li>
<li>適合用於「輸出字串」這種不需要改變內容的函式。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5392e14" class="outline-4">
<h4 id="org5392e14"><span class="section-number-4">7.1.4.</span> B-2 (4%) Which of the following is not true when considering pointers to functions in C++?</h4>
<div class="outline-text-4" id="text-7-1-4">
<ul class="org-ul">
<li>(a) They can be stored in arrays.<br /></li>
<li>(b) They are functions used in order to call the function.(c) They contain the starting address of the function code.(d) They cannot be assigned to other function pointers.<br /></li>
</ul>
</div>
<div id="outline-container-orga4fa1e8" class="outline-5">
<h5 id="orga4fa1e8">解</h5>
<div class="outline-text-5" id="text-orga4fa1e8">
<p>
在 C++ 中，函式指標 (Function Pointer) 是一種特殊的指標，指向函式的記憶體位址，允許透過指標呼叫函式，而不需要直接使用函式名稱。這在回呼函式 (callback functions)、函式作為參數、函式陣列 (array of function pointers) 等應用中非常重要。<br />
</p>
</div>
</div>
<div id="outline-container-org043ac62" class="outline-5">
<h5 id="org043ac62">題目解析</h5>
<div class="outline-text-5" id="text-org043ac62">
<p>
我們需要找出錯誤的選項，並分析每個選項是否正確：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgbd52344"></a>(a) 它們可以被存放在陣列中 (They can be stored in arrays.)<br />
<div class="outline-text-6" id="text-orgbd52344">
<p>
✅ 正確 函式指標可以存放在陣列中，使我們可以透過索引來選擇不同的函式來執行。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">add</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) { <span style="color: #51afef;">return</span> a + b; }
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">subtract</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) { <span style="color: #51afef;">return</span> a - b; }
<span class="linenr"> 5: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">multiply</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) { <span style="color: #51afef;">return</span> a * b; }
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">operations</span>[<span style="color: #da8548; font-weight: bold;">3</span>])(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>) = { add, subtract, multiply };
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">5</span>;
<span class="linenr">11: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Add: "</span> &lt;&lt; operations[<span style="color: #da8548; font-weight: bold;">0</span>](a, b) &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10 + 5 = 15</span>
<span class="linenr">12: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Subtract: "</span> &lt;&lt; operations[<span style="color: #da8548; font-weight: bold;">1</span>](a, b) &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10 - 5 = 5</span>
<span class="linenr">13: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Multiply: "</span> &lt;&lt; operations[<span style="color: #da8548; font-weight: bold;">2</span>](a, b) &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10 * 5 = 50</span>
<span class="linenr">14: </span>}
</pre>
</div>
<p>
這證明了函式指標可以存放在陣列中，因此 (a) 是 正確的。<br />
</p>
</div>
</li>
<li><a id="org0a8dd03"></a>(b) 它們是函式，用來呼叫函式 (They are functions used in order to call the function.)<br />
<div class="outline-text-6" id="text-org0a8dd03">
<p>
❌ 錯誤 函式指標不是函式本身，而是指向函式的指標，透過它來呼叫函式。<br />
</p>

<p>
錯誤的理解：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">funcPtr</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>) = add;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521; `add` &#20989;&#24335;&#30340;&#25351;&#27161;</span>
<span class="linenr">2: </span>funcPtr(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#36879;&#36942;&#20989;&#24335;&#25351;&#27161;&#21628;&#21483;&#20989;&#24335;</span>
<span class="linenr">3: </span>add(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#30452;&#25509;&#21628;&#21483;&#20989;&#24335;</span>
</pre>
</div>
<p>
funcPtr 只是一個變數，存放函式的記憶體地址，但它不是函式。因此 (b) 是錯誤的，應該選擇它作為答案。<br />
</p>
</div>
</li>
<li><a id="org5554064"></a>(c) 它們包含函式碼的起始位址 (They contain the starting address of the function code.)<br />
<div class="outline-text-6" id="text-org5554064">
<p>
✅ 正確 函式指標實際上儲存的是函式在記憶體中的起始地址，這樣我們才能透過指標來執行函式。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">hello</span>() {
<span class="linenr"> 4: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Hello, world!"</span> &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr"> 5: </span>}
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">void</span> (*<span style="color: #c678dd;">funcPtr</span>)() = hello;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">`hello` &#20989;&#24335;&#30340;&#35352;&#25014;&#39636;&#20301;&#22336;&#23384;&#20837; `funcPtr`</span>
<span class="linenr"> 9: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Function address: "</span> &lt;&lt; (<span style="color: #ECBE7B;">void</span>*)funcPtr &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr">10: </span>    funcPtr();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21628;&#21483; `hello` &#20989;&#24335;</span>
<span class="linenr">11: </span>}
</pre>
</div>
<p>
這會輸出：<br />
</p>
<pre class="example" id="orge95481f">
Function address: 0x5613b7f76000  // (記憶體位址會依系統不同而變)
Hello, world!
</pre>
<p>
這證明函式指標存放的是函式的記憶體起始地址，因此 (c) 是 正確的。<br />
</p>
</div>
</li>
<li><a id="org2a344ac"></a>(d) 它們不能被賦值給其他函式指標 (They cannot be assigned to other function pointers.)<br />
<div class="outline-text-6" id="text-org2a344ac">
<p>
❌ 錯誤 函式指標可以被賦值給其他函式指標，只要它們的函式簽名 (signature) 相同：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">add</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) { <span style="color: #51afef;">return</span> a + b; }
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">subtract</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) { <span style="color: #51afef;">return</span> a - b; }
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">funcPtr1</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>) = add;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521; add</span>
<span class="linenr">5: </span><span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">funcPtr2</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>) = <span style="color: #a9a1e1;">nullptr</span>;
<span class="linenr">6: </span>
<span class="linenr">7: </span>funcPtr2 = funcPtr1;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21487;&#20197;&#23559;&#19968;&#20491;&#20989;&#24335;&#25351;&#27161;&#36070;&#20540;&#32102;&#21478;&#19968;&#20491;</span>
<span class="linenr">8: </span><span style="color: #a9a1e1;">std</span>::cout &lt;&lt; funcPtr2(<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">2</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986; 6 (&#21628;&#21483; add)</span>
</pre>
</div>
<p>
這證明函式指標可以被賦值給其他函式指標，因此 (d) 是錯誤的。<br />
</p>
</div>
</li>
<li><a id="orgdf65cd3"></a>答案與總結<br />
<div class="outline-text-6" id="text-orgdf65cd3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a)</td>
<td class="org-left">✅ 正確</td>
<td class="org-left">函式指標可以存入陣列</td>
</tr>

<tr>
<td class="org-left">(b)</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">函式指標不是函式，而是指向函式的變數</td>
</tr>

<tr>
<td class="org-left">(c)</td>
<td class="org-left">✅ 正確</td>
<td class="org-left">函式指標存放的是函式的記憶體位址</td>
</tr>

<tr>
<td class="org-left">(d)</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">函式指標可以賦值給其他相同型別的函式指標</td>
</tr>
</tbody>
</table>
<p>
最終答案： (b) ❌ 函式指標不是函式，而是指向函式的變數。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgd2346b1" class="outline-5">
<h5 id="orgd2346b1">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-orgd2346b1">
<ol class="org-ol">
<li>指標 (Pointers) 與函式指標 (Function Pointers)<br />
<ul class="org-ul">
<li><p>
一般指標 存放變數的記憶體位置，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>     <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span class="linenr">2: </span>     <span style="color: #ECBE7B;">int</span> *<span style="color: #dcaeea;">ptr</span> = &amp;x;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">ptr &#25351;&#21521; x &#30340;&#22320;&#22336;</span>
</pre>
</div></li>
<li><p>
函式指標 存放函式的記憶體位置，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>     <span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">funcPtr</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>) = add;
</pre>
</div></li>
</ul></li>
<li>函式指標的應用<br />
<ul class="org-ul">
<li><p>
函式回呼 (Callback Functions)：用於 事件驅動 或 函式作為參數傳遞。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>         <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">executeOperation</span>(<span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">operation</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>), <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>) {
<span class="linenr">2: </span>             <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; operation(a, b) &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr">3: </span>         }
<span class="linenr">4: </span>
</pre>
</div></li>
<li>陣列中的函式指標：用於動態選擇函式，避免使用 switch-case。<br /></li>
</ul></li>
<li>nullptr 與函式指標的安全性<br />
<ul class="org-ul">
<li><p>
nullptr 表示「無效指標」，避免指標指向不合法的位址。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>         <span style="color: #ECBE7B;">int</span> (*<span style="color: #c678dd;">funcPtr</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>) = <span style="color: #a9a1e1;">nullptr</span>;
<span class="linenr">2: </span>         <span style="color: #51afef;">if</span> (funcPtr) funcPtr(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36991;&#20813;&#22519;&#34892;&#28961;&#25928;&#25351;&#27161;</span>
</pre>
</div></li>
</ul></li>
<li>typedef 或 using 定義函式指標<br />
<ul class="org-ul">
<li><p>
讓程式碼更可讀：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>         <span style="color: #51afef;">typedef</span> <span style="color: #ECBE7B;">int</span> (*<span style="color: #ECBE7B;">Operation</span>)(<span style="color: #ECBE7B;">int</span>, <span style="color: #ECBE7B;">int</span>);
<span class="linenr">2: </span>         <span style="color: #ECBE7B;">Operation</span> <span style="color: #dcaeea;">op</span> = add;
<span class="linenr">3: </span>
</pre>
</div></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org914ab4b" class="outline-5">
<h5 id="org914ab4b">總結</h5>
<div class="outline-text-5" id="text-org914ab4b">
<ul class="org-ul">
<li>函式指標可以存入陣列 (a ✅)<br /></li>
<li>函式指標不是函式，而是指向函式的變數 (b ❌)<br /></li>
<li>函式指標存放的是函式的記憶體地址 (c ✅)<br /></li>
<li>函式指標可以被賦值給其他函式指標 (d ❌)<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org12d5b11" class="outline-4">
<h4 id="org12d5b11"><span class="section-number-4">7.1.5.</span> B-3 (4%) Which of the following operators can be overloaded as a global function in C++?</h4>
<div class="outline-text-4" id="text-7-1-5">
<ul class="org-ul">
<li>(a) ==<br /></li>
<li>(b) +=<br /></li>
<li>(c) []<br /></li>
<li>(d) ()<br /></li>
</ul>
</div>
<div id="outline-container-org864f3cf" class="outline-5">
<h5 id="org864f3cf">解</h5>
<div class="outline-text-5" id="text-org864f3cf">
<p>
C++ 允許運算子多載 (Operator Overloading)，讓使用者自定義類別能夠使用運算子來執行特定操作，如 +、-、== 等。<br />
</p>

<p>
運算子多載可以：<br />
</p>
<ul class="org-ul">
<li>作為類別成員函式 (Member Function) 來實作。<br /></li>
<li>作為全域函式 (Global Function) 並友元 (Friend Function) 來實作。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9d59060" class="outline-5">
<h5 id="org9d59060">題目解析</h5>
<div class="outline-text-5" id="text-org9d59060">
<p>
我們要找可以作為全域函式 (Global Function) 來多載的運算子，並分析每個選項是否符合條件。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgfa4e36c"></a>(a) == 運算子<br />
<div class="outline-text-6" id="text-orgfa4e36c">
<p>
✅ 可以作為全域函式多載 <code>= 運算子通常用來比較兩個物件是否相等，因此它不應該修改任一個物件的內容。因此，通常使用非成員函式 (global function) 來多載 =</code> 運算子，確保對稱性 (Symmetry)。<br />
</p>

<p>
正確的多載方式 (全域函式)：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Point</span> {
<span class="linenr"> 4: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>, <span style="color: #dcaeea;">y</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #c678dd;">Point</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>) : x(x), y(y) {}
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">== &#36939;&#31639;&#23376;&#22810;&#36617; (&#20316;&#28858;&#20840;&#22495;&#20989;&#24335;)</span>
<span class="linenr">10: </span>    <span style="color: #51afef;">friend</span> <span style="color: #ECBE7B;">bool</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">==</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Point</span>&amp; <span style="color: #dcaeea;">p1</span>, <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Point</span>&amp; <span style="color: #dcaeea;">p2</span>) {
<span class="linenr">11: </span>        <span style="color: #51afef;">return</span> (p1.x == p2.x &amp;&amp; p1.y == p2.y);
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>};
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">16: </span>    <span style="color: #ECBE7B;">Point</span> <span style="color: #dcaeea;">p1</span>(<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>), <span style="color: #dcaeea;">p2</span>(<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>);
<span class="linenr">17: </span>    <span style="color: #51afef;">if</span> (p1 == p2) {
<span class="linenr">18: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"p1 and p2 are equal\n"</span>;
<span class="linenr">19: </span>    }
<span class="linenr">20: </span>}
</pre>
</div>
<p>
在這裡，我們使用 friend 讓 operator== 以全域函式的方式存取 Point 物件的私有成員。<br />
</p>

<p>
✅ 結論：== 可以作為全域函式多載<br />
</p>
</div>
</li>
<li><a id="org5cb47ec"></a>(b) += 運算子<br />
<div class="outline-text-6" id="text-org5cb47ec">
<p>
❌ 不適合作為全域函式 += 運算子必須修改左側的物件，因此必須作為成員函式，才能存取 this 指標來修改當前物件的狀態。<br />
</p>

<p>
正確的多載方式 (類別成員函式)：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Point</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>, <span style="color: #dcaeea;">y</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #c678dd;">Point</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>) : x(x), y(y) {}
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">+= &#36939;&#31639;&#23376;&#22810;&#36617; (&#24517;&#38920;&#26159;&#25104;&#21729;&#20989;&#24335;)</span>
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">Point</span>&amp; <span style="color: #51afef;">operator</span><span style="color: #c678dd;">+=</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Point</span>&amp; <span style="color: #dcaeea;">other</span>) {
<span class="linenr"> 9: </span>        <span style="color: #51afef;">this</span>-&gt;x += other.x;
<span class="linenr">10: </span>        <span style="color: #51afef;">this</span>-&gt;y += other.y;
<span class="linenr">11: </span>        <span style="color: #51afef;">return</span> *<span style="color: #51afef;">this</span>;
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>};
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">16: </span>    <span style="color: #ECBE7B;">Point</span> <span style="color: #dcaeea;">p1</span>(<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>), <span style="color: #dcaeea;">p2</span>(<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr">17: </span>    p1 += p2;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">p1 &#35722;&#28858; (4,6)</span>
<span class="linenr">18: </span>}
</pre>
</div>
<p>
因為 += 需要修改 p1 本身的內容，所以它不能是全域函式，只能是成員函式。<br />
</p>

<p>
❌ 結論：+= 不能作為全域函式多載<br />
</p>
</div>
</li>
<li><a id="org692f750"></a>(c) [] 運算子<br />
<div class="outline-text-6" id="text-org692f750">
<p>
❌ 不能作為全域函式 [] 運算子必須用來存取物件的內部成員 (如陣列索引)，而這通常需要 this 指標來存取內部成員，因此它只能是成員函式。<br />
</p>

<p>
正確的多載方式 (類別成員函式)：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Array</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">private</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">data</span>[<span style="color: #da8548; font-weight: bold;">10</span>];
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">int</span>&amp; <span style="color: #51afef;">operator</span><span style="color: #c678dd;">[]</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">index</span>) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24517;&#38920;&#26159;&#25104;&#21729;&#20989;&#24335;</span>
<span class="linenr"> 7: </span>        <span style="color: #51afef;">return</span> data[index];
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>};
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">12: </span>    <span style="color: #ECBE7B;">Array</span> <span style="color: #dcaeea;">arr</span>;
<span class="linenr">13: </span>    arr[<span style="color: #da8548; font-weight: bold;">0</span>] = <span style="color: #da8548; font-weight: bold;">10</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#22810;&#36617;&#30340; [] &#36939;&#31639;&#23376;</span>
<span class="linenr">14: </span>}
</pre>
</div>
<p>
operator[] 不能是全域函式，因為它無法存取 this 指標來修改類別內的陣列。<br />
</p>

<p>
❌ 結論：[] 不能作為全域函式多載<br />
</p>
</div>
</li>
<li><a id="orgd151d6f"></a>(d) () 運算子<br />
<div class="outline-text-6" id="text-orgd151d6f">
<p>
❌ 不能作為全域函式 () 運算子（函式呼叫運算子）允許物件像函式一樣被呼叫，但它必須是成員函式，因為它需要存取 this 指標來調用內部函式。<br />
</p>

<p>
正確的多載方式 (類別成員函式)：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Functor</span> {
<span class="linenr"> 4: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">()</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">num</span>) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24517;&#38920;&#26159;&#25104;&#21729;&#20989;&#24335;</span>
<span class="linenr"> 6: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Number: "</span> &lt;&lt; num &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr"> 7: </span>    }
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">11: </span>    <span style="color: #ECBE7B;">Functor</span> <span style="color: #dcaeea;">fun</span>;
<span class="linenr">12: </span>    fun(<span style="color: #da8548; font-weight: bold;">10</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20687;&#20989;&#24335;&#19968;&#27171;&#21628;&#21483;&#29289;&#20214;</span>
<span class="linenr">13: </span>}
</pre>
</div>
<p>
因為 () 運算子需要修改或存取類別內部的狀態，所以它不能是全域函式。<br />
</p>

<p>
❌ 結論：() 不能作為全域函式多載<br />
</p>
</div>
</li>
<li><a id="org6f4f9c5"></a>答案與總結<br />
<div class="outline-text-6" id="text-org6f4f9c5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">運算子</th>
<th scope="col" class="org-left">是否可以作為全域函式？</th>
<th scope="col" class="org-left">需要說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) ==</td>
<td class="org-left">✅ 可以</td>
<td class="org-left">適用於比較兩個物件，通常是 friend 函式</td>
</tr>

<tr>
<td class="org-left">(b) +=</td>
<td class="org-left">❌ 不可以</td>
<td class="org-left">需要修改 this，只能是成員函式</td>
</tr>

<tr>
<td class="org-left">(c) []</td>
<td class="org-left">❌ 不可以</td>
<td class="org-left">需要存取內部成員，必須是成員函式</td>
</tr>

<tr>
<td class="org-left">(d) ()</td>
<td class="org-left">❌ 不可以</td>
<td class="org-left">需要 this 指標來模擬函式呼叫，必須是成員函式</td>
</tr>
</tbody>
</table>
<p>
最終答案：(a) == ✅<br />
</p>

<p>
只有 == 運算子可以作為全域函式來多載。<br />
</p>
</div>
</li>
<li><a id="org5192993"></a>與本題相關的計算機概論 (計概) 知識<br />
<div class="outline-text-6" id="text-org5192993">
<ol class="org-ol">
<li>運算子多載 (Operator Overloading)<br />
<ul class="org-ul">
<li>C++ 支援運算子多載，使得類別物件可以使用內建的 C++ 運算子進行操作。但並不是所有的運算子都能作為全域函式來多載。<br /></li>
</ul></li>
<li>何時使用全域函式與成員函式？<br />
<ul class="org-ul">
<li>應該使用全域函式：<br />
<ul class="org-ul">
<li>當運算子不需要修改物件的狀態，例如 ==、+、-。<br /></li>
<li>這些函式通常應該是 friend 函式，以便存取私有成員。<br /></li>
</ul></li>
<li>應該使用成員函式：<br />
<ul class="org-ul">
<li>當運算子需要修改物件，例如 +=、-=、++、&#x2013;。<br /></li>
<li>當運算子需要存取內部狀態，例如 []、() 。<br /></li>
</ul></li>
</ul></li>
<li>friend 函式的使用<br />
<ul class="org-ul">
<li><p>
當需要讓全域函式存取類別的私有成員時，可以宣告為 friend：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span>         <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Example</span> {
<span class="linenr"> 2: </span>             <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">value</span>;
<span class="linenr"> 3: </span>         <span style="color: #51afef;">public</span>:
<span class="linenr"> 4: </span>             <span style="color: #c678dd;">Example</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">val</span>) : value(val) {}
<span class="linenr"> 5: </span>             <span style="color: #51afef;">friend</span> <span style="color: #ECBE7B;">bool</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">==</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Example</span>&amp; <span style="color: #dcaeea;">a</span>, <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Example</span>&amp; <span style="color: #dcaeea;">b</span>);
<span class="linenr"> 6: </span>         };
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>         <span style="color: #ECBE7B;">bool</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">==</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Example</span>&amp; <span style="color: #dcaeea;">a</span>, <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Example</span>&amp; <span style="color: #dcaeea;">b</span>) {
<span class="linenr"> 9: </span>             <span style="color: #51afef;">return</span> a.value == b.value;
<span class="linenr">10: </span>         }
</pre>
</div></li>
</ul></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org28c25c3" class="outline-5">
<h5 id="org28c25c3">總結</h5>
<div class="outline-text-5" id="text-org28c25c3">
<ul class="org-ul">
<li>== 可以作為全域函式，因為它不需要修改物件的狀態。<br /></li>
<li>+= 必須是成員函式，因為它需要修改物件的值。<br /></li>
<li>[] 必須是成員函式，因為它需要存取內部成員。<br /></li>
<li>() 必須是成員函式，因為它需要像函式一樣被呼叫。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7e28f8f" class="outline-4">
<h4 id="org7e28f8f"><span class="section-number-4">7.1.6.</span> B-4 (4%) Which of the following is not a kind of inheritance in C++?</h4>
<div class="outline-text-4" id="text-7-1-6">
<p>
(a) Public (b) private (c) static (d) protected<br />
</p>
</div>
<div id="outline-container-org010bf5d" class="outline-5">
<h5 id="org010bf5d">解</h5>
<div class="outline-text-5" id="text-org010bf5d">
<p>
繼承 (Inheritance) 是物件導向程式設計 (OOP) 的核心概念之一，它允許子類別 (Derived Class) 繼承父類別 (Base Class) 的成員，使得程式碼更具重用性和擴展性。<br />
</p>

<p>
在 C++ 中，繼承可以使用三種存取權限 (Access Specifiers) 來控制子類別對父類別成員的可見性：<br />
</p>
<ol class="org-ol">
<li>Public 繼承 (public)<br /></li>
<li>Protected 繼承 (protected)<br /></li>
<li>Private 繼承 (private)<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orga259b80" class="outline-5">
<h5 id="orga259b80">題目解析</h5>
<div class="outline-text-5" id="text-orga259b80">
<p>
題目詢問 「以下哪一個不是 C++ 的繼承方式？」<br />
</p>
<ul class="org-ul">
<li>(a) public → ✅ 是 繼承方式<br /></li>
<li>(b) private → ✅ 是 繼承方式<br /></li>
<li>(c) static → ❌ 不是 繼承方式<br /></li>
<li>(d) protected → ✅ 是 繼承方式<br /></li>
</ul>

<p>
正確答案為 (c) static，因為 static 只與靜態變數、靜態函式和靜態類別成員有關，與繼承無關。<br />
</p>

<p>
C++ 繼承方式詳細解析<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org1ffd8f5"></a>(a) Public 繼承 (public)<br />
<div class="outline-text-6" id="text-org1ffd8f5">
<p>
Public 繼承保留父類別的公開 (public) 與保護 (protected) 成員的可見性：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>;
<span class="linenr"> 4: </span><span style="color: #51afef;">protected</span>:
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>;
<span class="linenr"> 6: </span><span style="color: #51afef;">private</span>:
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">c</span>;
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr">11: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a &#20173;&#28982;&#26159; public</span>
<span class="linenr">12: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">b &#20173;&#28982;&#26159; protected</span>
<span class="linenr">13: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">c &#28961;&#27861;&#34987;&#32380;&#25215;</span>
<span class="linenr">14: </span>};
</pre>
</div>
<p>
當使用 public 繼承時：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">存取權限</th>
<th scope="col" class="org-left">在子類別中的可見性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">public</td>
<td class="org-left">保持 public</td>
</tr>

<tr>
<td class="org-left">protected</td>
<td class="org-left">保持 protected</td>
</tr>

<tr>
<td class="org-left">private</td>
<td class="org-left">無法繼承</td>
</tr>
</tbody>
</table>

<p>
適用情境：當子類別是一種「父類別的特殊版本」時，應使用 public 繼承。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Animal</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">eat</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Eating...\n"</span>; }
<span class="linenr"> 4: </span>};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Dog</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Animal</span> {
<span class="linenr"> 7: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">bark</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Barking...\n"</span>; }
<span class="linenr"> 9: </span>};
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">12: </span>    <span style="color: #ECBE7B;">Dog</span> <span style="color: #dcaeea;">d</span>;
<span class="linenr">13: </span>    d.eat();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#32380;&#25215;&#33258; Animal</span>
<span class="linenr">14: </span>    d.bark(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; Dog &#33258;&#24049;&#30340;&#20989;&#24335;</span>
<span class="linenr">15: </span>}
</pre>
</div>
<p>
這裡 Dog 繼承 Animal，並保留 eat() 方法。<br />
</p>
</div>
</li>
<li><a id="orgde9bd7b"></a>(b) Private 繼承 (private)<br />
<div class="outline-text-6" id="text-orgde9bd7b">
<p>
Private 繼承會將父類別的public 和 protected 成員變為 private：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>;
<span class="linenr"> 4: </span><span style="color: #51afef;">protected</span>:
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>;
<span class="linenr"> 6: </span><span style="color: #51afef;">private</span>:
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">c</span>;
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr">11: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a &#35722;&#25104; private</span>
<span class="linenr">12: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">b &#35722;&#25104; private</span>
<span class="linenr">13: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">c &#28961;&#27861;&#34987;&#32380;&#25215;</span>
<span class="linenr">14: </span>};
</pre>
</div>
<p>
當使用 private 繼承時：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">存取權限</th>
<th scope="col" class="org-left">在子類別中的可見性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">public</td>
<td class="org-left">變成 private</td>
</tr>

<tr>
<td class="org-left">protected</td>
<td class="org-left">變成 private</td>
</tr>

<tr>
<td class="org-left">private</td>
<td class="org-left">無法繼承</td>
</tr>
</tbody>
</table>
<p>
適用情境：當子類別不應該被當作父類別的替代品，而是只想使用其內部實作時，應使用 private 繼承。<br />
</p>

<p>
例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Engine</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">start</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Engine started!\n"</span>; }
<span class="linenr"> 4: </span>};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Car</span> : <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">Engine</span> {
<span class="linenr"> 7: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">drive</span>() {
<span class="linenr"> 9: </span>        start();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#20839;&#37096;&#21487;&#20197;&#20351;&#29992; Engine&#65292;&#20294;&#22806;&#37096;&#28961;&#27861;&#30452;&#25509;&#35519;&#29992; start()</span>
<span class="linenr">10: </span>        <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Car is moving...\n"</span>;
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>};
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">15: </span>    <span style="color: #ECBE7B;">Car</span> <span style="color: #dcaeea;">myCar</span>;
<span class="linenr">16: </span>    myCar.drive();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; OK</span>
<span class="linenr">17: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">myCar.start();  // &#10060; &#37679;&#35492;&#65292;&#22240;&#28858; start() &#26159;&#31169;&#26377;&#30340;</span>
<span class="linenr">18: </span>}
</pre>
</div>
<p>
這裡 Car 使用 Engine 的 start() 方法，但不希望外部程式直接訪問 start()，因此使用 private 繼承。<br />
</p>
</div>
</li>
<li><a id="orgd9a4ee6"></a>(c) Static (static)<br />
<div class="outline-text-6" id="text-orgd9a4ee6">
<ul class="org-ul">
<li>❌ 不是 C++ 的繼承方式<br />
<ul class="org-ul">
<li>static 用於靜態變數 (static variables)、靜態函式 (static functions)，而不是繼承。<br /></li>
<li>靜態成員與物件無關，而是屬於整個類別。<br /></li>
<li>static 成員不會被繼承，因為它們已經屬於類別。<br /></li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>;
<span class="linenr"> 4: </span>};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 7: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#32380;&#25215; x&#65292;&#20294;&#23427;&#20173;&#28982;&#23660;&#26044; Base&#65292;&#32780;&#19981;&#26159; Derived</span>
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #ECBE7B;">int</span> <span style="color: #a9a1e1;">Base</span>::<span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">10</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24517;&#38920;&#22312;&#39006;&#21029;&#22806;&#37096;&#21021;&#22987;&#21270;</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">13: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #a9a1e1;">Derived</span>::x;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#23384;&#21462; Base::x</span>
<span class="linenr">14: </span>}
</pre>
</div>
<p>
總結：static 與繼承無關，它只用於定義類別的靜態變數或函式。<br />
</p>
</div>
</li>
<li><a id="org4c6b420"></a>(d) Protected 繼承 (protected)<br />
<div class="outline-text-6" id="text-org4c6b420">
<p>
Protected 繼承會將父類別的 public 變成 protected，但不影響 protected：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>;
<span class="linenr"> 4: </span><span style="color: #51afef;">protected</span>:
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span>;
<span class="linenr"> 6: </span><span style="color: #51afef;">private</span>:
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">c</span>;
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #51afef;">protected</span> <span style="color: #ECBE7B;">Base</span> {
<span class="linenr">11: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a &#35722;&#25104; protected</span>
<span class="linenr">12: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">b &#20445;&#25345; protected</span>
<span class="linenr">13: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">c &#28961;&#27861;&#34987;&#32380;&#25215;</span>
<span class="linenr">14: </span>};
</pre>
</div>
<p>
當使用 protected 繼承時：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">存取權限</th>
<th scope="col" class="org-left">在子類別中的可見性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">public</td>
<td class="org-left">變成 protected</td>
</tr>

<tr>
<td class="org-left">protected</td>
<td class="org-left">保持 protected</td>
</tr>

<tr>
<td class="org-left">private</td>
<td class="org-left">無法繼承</td>
</tr>
</tbody>
</table>
<p>
適用情境：當不希望父類別的 public 成員對外暴露，但仍希望讓子類別訪問時，使用 protected 繼承。<br />
</p>

<p>
範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Parent</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() { <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; <span style="color: #98be65;">"Parent class\n"</span>; }
<span class="linenr"> 4: </span>};
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Child</span> : <span style="color: #51afef;">protected</span> <span style="color: #ECBE7B;">Parent</span> {
<span class="linenr"> 7: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">display</span>() {
<span class="linenr"> 9: </span>        show();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21487;&#29992;&#65292;&#20294;&#22806;&#37096;&#28961;&#27861;&#30452;&#25509;&#35519;&#29992;</span>
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>};
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">14: </span>    <span style="color: #ECBE7B;">Child</span> <span style="color: #dcaeea;">obj</span>;
<span class="linenr">15: </span>    obj.display();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989;</span>
<span class="linenr">16: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">obj.show();  // &#10060; &#37679;&#35492;&#65292;&#22240;&#28858; `show()` &#35722;&#25104; protected</span>
<span class="linenr">17: </span>}
</pre>
</div>
<p>
這裡 show() 在 Child 內部可見，但 main() 無法直接調用。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org544b8eb" class="outline-5">
<h5 id="org544b8eb">答案與總結</h5>
<div class="outline-text-5" id="text-org544b8eb">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">繼承方式</th>
<th scope="col" class="org-left">是否是 C++ 繼承</th>
<th scope="col" class="org-left">影響</th>
<th scope="col" class="org-left">適用場景</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) Public</td>
<td class="org-left">✅ 是</td>
<td class="org-left">繼承 public, protected 成員</td>
<td class="org-left">當子類別是父類別的「特殊版本」</td>
</tr>

<tr>
<td class="org-left">(b) Private</td>
<td class="org-left">✅ 是</td>
<td class="org-left">繼承 public, protected 成員但變 private</td>
<td class="org-left">當子類別不應該被當作父類別的替代品</td>
</tr>

<tr>
<td class="org-left">(c) Static</td>
<td class="org-left">❌ 不是</td>
<td class="org-left">static 只影響類別成員，與繼承無關</td>
<td class="org-left">用於靜態變數與靜態函式</td>
</tr>

<tr>
<td class="org-left">(d) Protected</td>
<td class="org-left">✅ 是</td>
<td class="org-left">繼承 public 變 protected，protected 不變</td>
<td class="org-left">當需要保留內部繼承但不暴露成員</td>
</tr>
</tbody>
</table>
<p>
✅ 正確答案：(c) static (因為 static 不是 C++ 繼承方式) ✅<br />
</p>
</div>
</div>
<div id="outline-container-org16fcc43" class="outline-5">
<h5 id="org16fcc43">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-org16fcc43">
<ul class="org-ul">
<li>物件導向程式設計 (OOP)<br />
<ul class="org-ul">
<li>封裝 (Encapsulation)、繼承 (Inheritance)、多型 (Polymorphism)、抽象化 (Abstraction)。<br /></li>
</ul></li>
<li>存取控制 (Access Control)<br />
<ul class="org-ul">
<li>public, protected, private 的差異。<br /></li>
</ul></li>
<li>多重繼承 (Multiple Inheritance)<br />
<ul class="org-ul">
<li>C++ 支援多重繼承，例如 class C : public A, public B {};。<br /></li>
</ul></li>
<li>虛擬繼承 (Virtual Inheritance)<br />
<ul class="org-ul">
<li>用於解決 菱形繼承 (Diamond Inheritance) 問題。<br /></li>
</ul></li>
<li>static 成員<br />
<ul class="org-ul">
<li>屬於類別本身，而不是個別物件，與繼承無關。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcbaac38" class="outline-4">
<h4 id="orgcbaac38"><span class="section-number-4">7.1.7.</span> B-5 (4%) For a non-constant member function of class Test in C++, the this pointer has type</h4>
<div class="outline-text-4" id="text-7-1-7">
<p>
(a) Test (b) const Test (c) const Test * (d) const Test * const<br />
</p>
</div>
<div id="outline-container-org4c128ce" class="outline-5">
<h5 id="org4c128ce">解</h5>
<div class="outline-text-5" id="text-org4c128ce">
<p>
在 C++ 類別中，this 指標是成員函式內部的一個特殊指標，指向呼叫該函式的物件本身。<br />
</p>

<p>
它的主要特性如下：<br />
</p>
<ul class="org-ul">
<li>this 指標是 隱式傳遞 給每個非靜態 (non-static) 成員函式的。<br /></li>
<li>this 指標的類型取決於函式是否為 常數 (const) 成員函式。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgca0cb0c" class="outline-5">
<h5 id="orgca0cb0c">題目解析</h5>
<div class="outline-text-5" id="text-orgca0cb0c">
<p>
題目要求找出「非常數 (non-constant) 成員函式」中 this 指標的類型。<br />
</p>

<p>
我們來逐一分析選項：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) Test</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">this 是指標，不是物件本身。</td>
</tr>

<tr>
<td class="org-left">(b) const Test</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">this 是指標，而不是物件的常數版本。</td>
</tr>

<tr>
<td class="org-left">(c) const Test *</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">只有當成員函式是 const 時才會這樣。</td>
</tr>

<tr>
<td class="org-left">(d) Test * const</td>
<td class="org-left">✅ 正確</td>
<td class="org-left">this 指標不可變，但指向的物件可變。</td>
</tr>
</tbody>
</table>
<p>
this 指標的正確類型<br />
</p>

<p>
對於非 const 成員函式，this 指標的類型是：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>Test *<span style="color: #51afef;">const</span> <span style="color: #51afef;">this</span>;
</pre>
</div>

<p>
這表示：<br />
</p>
<ul class="org-ul">
<li>this 是一個不可變的指標 (const 指標)，它不能指向其他物件。<br /></li>
<li>但 this 指向的 Test 物件是可變的，因此函式可以修改 Test 的成員變數。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org50e3a74"></a>範例：非 const 成員函式<br />
<div class="outline-text-6" id="text-org50e3a74">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Test</span> {
<span class="linenr"> 4: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">value</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">setValue</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">v</span>) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38750;&#24120;&#25976;&#20989;&#24335;</span>
<span class="linenr"> 8: </span>        <span style="color: #51afef;">this</span>-&gt;value = v;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#21487;&#20197;&#20462;&#25913;&#25104;&#21729;&#35722;&#25976;</span>
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>};
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">13: </span>    <span style="color: #ECBE7B;">Test</span> <span style="color: #dcaeea;">obj</span>;
<span class="linenr">14: </span>    obj.setValue(<span style="color: #da8548; font-weight: bold;">10</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; OK</span>
<span class="linenr">15: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; obj.value;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986; 10</span>
<span class="linenr">16: </span>}
</pre>
</div>

<p>
這裡 this 的類型是 Test *const，可以修改 value。<br />
</p>

<p>
✅ 結論：Test *const 是 this 指標的正確類型，選項 (d) 正確。<br />
</p>
</div>
</li>
<li><a id="org9b7b3b8"></a>補充：當 const 成員函式時 this 指標的類型<br />
<div class="outline-text-6" id="text-org9b7b3b8">
<p>
如果函式是 const 成員函式，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Test</span> {
<span class="linenr">2: </span><span style="color: #51afef;">public</span>:
<span class="linenr">3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">value</span>;
<span class="linenr">4: </span>
<span class="linenr">5: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() <span style="color: #51afef;">const</span> {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">const &#25104;&#21729;&#20989;&#24335;</span>
<span class="linenr">6: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this-&gt;value = 10;  // &#10060; &#32232;&#35695;&#37679;&#35492;&#65292;&#22240;&#28858; this &#25351;&#21521;&#30340;&#26159; const &#29289;&#20214;</span>
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>};
</pre>
</div>
<p>
則 this 指標的類型變為：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Test</span> *<span style="color: #51afef;">const</span> <span style="color: #51afef;">this</span>;
</pre>
</div>
<p>
這表示：<br />
</p>
<ul class="org-ul">
<li>this 是常數指標，不能更改指向的位置 (const 指標)。<br /></li>
<li>this 指向的物件也是 const，所以成員變數不可變。<br /></li>
</ul>
</div>
</li>
<li><a id="org6ed621a"></a>✅ 結論：<br />
<div class="outline-text-6" id="text-org6ed621a">
<ul class="org-ul">
<li>非 const 成員函式 → this 類型為 Test *const<br /></li>
<li>const 成員函式 → this 類型為 const Test *const<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org4e87650" class="outline-5">
<h5 id="org4e87650">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-org4e87650">
<ol class="org-ol">
<li><p>
this 指標的作用<br />
</p>
<ul class="org-ul">
<li>允許成員函式存取呼叫該函式的物件。<br /></li>
<li>主要用於：<br />
<ul class="org-ul">
<li>區分物件成員與參數名稱 (this-&gt;member = param)<br /></li>
<li>返回自身 (方法鏈式調用, Method Chaining)<br /></li>
</ul></li>
</ul>

<p>
例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span>     <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Test</span> {
<span class="linenr"> 2: </span>     <span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>         <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">value</span>;
<span class="linenr"> 4: </span>         <span style="color: #ECBE7B;">Test</span>&amp; <span style="color: #c678dd;">setValue</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">v</span>) {
<span class="linenr"> 5: </span>             <span style="color: #51afef;">this</span>-&gt;value = v;
<span class="linenr"> 6: </span>             <span style="color: #51afef;">return</span> *<span style="color: #51afef;">this</span>;
<span class="linenr"> 7: </span>         }
<span class="linenr"> 8: </span>     };
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>     <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">11: </span>         <span style="color: #ECBE7B;">Test</span> <span style="color: #dcaeea;">obj</span>;
<span class="linenr">12: </span>         obj.setValue(<span style="color: #da8548; font-weight: bold;">10</span>).setValue(<span style="color: #da8548; font-weight: bold;">20</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36899;&#32396;&#35519;&#29992;</span>
<span class="linenr">13: </span>     }
</pre>
</div>
<p>
這裡 setValue() 回傳 *this，允許連續調用。<br />
</p></li>
<li><p>
const 成員函式的意義<br />
</p>
<ul class="org-ul">
<li>確保函式不會修改物件的狀態。<br /></li>
<li><p>
適用於只讀 (read-only) 操作，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>     <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Test</span> {
<span class="linenr">2: </span>     <span style="color: #51afef;">public</span>:
<span class="linenr">3: </span>         <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">value</span>;
<span class="linenr">4: </span>         <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">show</span>() <span style="color: #51afef;">const</span> {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#19981;&#26371;&#20462;&#25913;&#29289;&#20214;</span>
<span class="linenr">5: </span>             <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; value &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr">6: </span>         }
<span class="linenr">7: </span>     };
</pre>
</div></li>
</ul>
<p>
const 成員函式內不能修改任何非 mutable 成員變數。<br />
</p></li>
<li><p>
const 指標與 const 物件的區別<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">類型</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Test *</td>
<td class="org-left">可變指標，可變物件</td>
</tr>

<tr>
<td class="org-left">const Test *</td>
<td class="org-left">可變指標，但物件不可變</td>
</tr>

<tr>
<td class="org-left">Test *const</td>
<td class="org-left">不可變指標，但物件可變</td>
</tr>

<tr>
<td class="org-left">const Test *const</td>
<td class="org-left">不可變指標，物件也不可變</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>對應 this 指標的類型：<br />
<ul class="org-ul">
<li>非 const 成員函式 → Test *const<br /></li>
<li>const 成員函式 → const Test *const<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org42b3062" class="outline-5">
<h5 id="org42b3062">總結</h5>
<div class="outline-text-5" id="text-org42b3062">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) Test</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">this 是指標，不是物件本身。</td>
</tr>

<tr>
<td class="org-left">(b) const Test</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">this 是指標，不是 const 物件。</td>
</tr>

<tr>
<td class="org-left">(c) const Test *</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">只有 const 成員函式時才會是 const Test *const。</td>
</tr>

<tr>
<td class="org-left">(d) Test *const</td>
<td class="org-left">✅ 正確</td>
<td class="org-left">this 是不可變指標，指向可變 Test 物件。</td>
</tr>
</tbody>
</table>
<p>
✅ 最終答案：(d) Test *const<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org415e4f8" class="outline-4">
<h4 id="org415e4f8"><span class="section-number-4">7.1.8.</span> B-6 (10%) What will be the value of each of the following variables after its initialization in C++?</h4>
<div class="outline-text-4" id="text-7-1-8">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">d</span> = <span style="color: #da8548; font-weight: bold;">2</span> * <span style="color: #ECBE7B;">int</span>(<span style="color: #da8548; font-weight: bold;">3.14</span>);
<span class="linenr">2: </span><span style="color: #ECBE7B;">long</span> <span style="color: #dcaeea;">k</span> = <span style="color: #da8548; font-weight: bold;">3.14</span> - <span style="color: #da8548; font-weight: bold;">3</span>;
<span class="linenr">3: </span><span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">x</span> = <span style="color: #98be65;">'a'</span> + <span style="color: #da8548; font-weight: bold;">2</span>;
<span class="linenr">4: </span><span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">y</span> = <span style="color: #98be65;">'p'</span> + <span style="color: #98be65;">'a'</span> - <span style="color: #98be65;">'a'</span>;
</pre>
</div>
</div>
<div id="outline-container-org9b30ef3" class="outline-5">
<h5 id="org9b30ef3">解</h5>
<div class="outline-text-5" id="text-org9b30ef3">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;"># &#35336;&#31639;</span> C++ &#35722;&#25976;&#21021;&#22987;&#21270;&#30340;&#20540;
<span class="linenr">2: </span>d = <span style="color: #da8548; font-weight: bold;">2</span> * <span style="color: #ECBE7B;">int</span>(<span style="color: #da8548; font-weight: bold;">3.14</span>)  # <span style="color: #da8548; font-weight: bold;">3.14</span> &#36681;&#28858; <span style="color: #ECBE7B;">int</span> &#35722;&#25104; <span style="color: #da8548; font-weight: bold;">3</span>&#65292;<span style="color: #da8548; font-weight: bold;">2</span> * <span style="color: #da8548; font-weight: bold;">3</span> = <span style="color: #da8548; font-weight: bold;">6</span>
<span class="linenr">3: </span>k = <span style="color: #da8548; font-weight: bold;">3.14</span> - <span style="color: #da8548; font-weight: bold;">3</span>       # <span style="color: #da8548; font-weight: bold;">3.14</span> - <span style="color: #da8548; font-weight: bold;">3</span> = <span style="color: #da8548; font-weight: bold;">0.14</span>&#65292;<span style="color: #ECBE7B;">long</span> &#26371;&#25130;&#26039;&#23567;&#25976;&#65292;&#35722;&#25104; <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">4: </span>x = chr(ord(<span style="color: #98be65;">'a'</span>) + <span style="color: #da8548; font-weight: bold;">2</span>)  # <span style="color: #98be65;">'a'</span> (<span style="color: #da8548; font-weight: bold;">97</span>) + <span style="color: #da8548; font-weight: bold;">2</span> = <span style="color: #da8548; font-weight: bold;">99</span> -&gt; <span style="color: #98be65;">'c'</span>
<span class="linenr">5: </span>y = chr(ord(<span style="color: #98be65;">'p'</span>) + ord(<span style="color: #98be65;">'a'</span>) - ord(<span style="color: #98be65;">'a'</span>))  # <span style="color: #98be65;">'p'</span> + <span style="color: #98be65;">'a'</span> - <span style="color: #98be65;">'a'</span> = <span style="color: #98be65;">'p'</span> (<span style="color: #da8548; font-weight: bold;">112</span>)
<span class="linenr">6: </span>
<span class="linenr">7: </span>(d, k, x, y)
</pre>
</div>
<p>
result<br />
</p>
<pre class="example" id="org8ce8c48">
(6, 0.14000000000000012, 'c', 'p')
</pre>
</div>
</div>
<div id="outline-container-org542bf00" class="outline-5">
<h5 id="org542bf00">C++ 變數初始化後的值解析</h5>
<div class="outline-text-5" id="text-org542bf00">
<p>
我們來分析每個變數的初始化過程，確保理解 C++ 中的型別轉換 (Type Conversion)。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org6217020"></a>變數 d 的值<br />
<div class="outline-text-6" id="text-org6217020">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">d</span> = <span style="color: #da8548; font-weight: bold;">2</span> * <span style="color: #ECBE7B;">int</span>(<span style="color: #da8548; font-weight: bold;">3.14</span>);
</pre>
</div>
<p>
計算步驟<br />
</p>
<ol class="org-ol">
<li>int(3.14) 進行整數轉換，3.14 轉為 3 (去掉小數部分)。<br /></li>
<li>2 * 3 計算結果為 6 (整數運算)。<br /></li>
<li>6 被賦值給 double d，但 double 可以存儲小數，因此最終 d = 6.0。<br /></li>
</ol>
<p>
✅ d = 6.0<br />
</p>
</div>
</li>
<li><a id="org24a6feb"></a>變數 k 的值<br />
<div class="outline-text-6" id="text-org24a6feb">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">long</span> <span style="color: #dcaeea;">k</span> = <span style="color: #da8548; font-weight: bold;">3.14</span> - <span style="color: #da8548; font-weight: bold;">3</span>;
</pre>
</div>
<p>
計算步驟<br />
</p>
<ol class="org-ol">
<li>3.14 - 3 = 0.14，結果是 double。<br /></li>
<li>long 是整數型別，儲存 0.14 時，會執行截斷 (truncation)，只保留 0。<br /></li>
</ol>

<p>
✅ k = 0<br />
</p>
</div>
</li>
<li><a id="orgc39fab0"></a>變數 x 的值<br />
<div class="outline-text-6" id="text-orgc39fab0">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">x</span> = <span style="color: #98be65;">'a'</span> + <span style="color: #da8548; font-weight: bold;">2</span>;
</pre>
</div>
<p>
計算步驟<br />
</p>
<ol class="org-ol">
<li>&rsquo;a&rsquo; 是 char，但在計算時會自動轉換為 int，其 ASCII 值為 97。<br /></li>
<li>97 + 2 = 99。<br /></li>
<li>99 再轉換回 char，對應的 ASCII 字元是 &rsquo;c&rsquo;。<br /></li>
</ol>
<p>
✅ x = &rsquo;c&rsquo;<br />
</p>
</div>
</li>
<li><a id="org2607a8a"></a>變數 y 的值<br />
<div class="outline-text-6" id="text-org2607a8a">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">y</span> = <span style="color: #98be65;">'p'</span> + <span style="color: #98be65;">'a'</span> - <span style="color: #98be65;">'a'</span>;
</pre>
</div>
<p>
計算步驟<br />
</p>
<ol class="org-ol">
<li>&rsquo;p&rsquo; 的 ASCII 值是 112，&rsquo;a&rsquo; 的 ASCII 值是 97。<br /></li>
<li>112 + 97 - 97 = 112。<br /></li>
<li>112 對應的 ASCII 字元是 &rsquo;p&rsquo;。<br /></li>
</ol>
<p>
✅ y = &rsquo;p&rsquo;<br />
</p>
</div>
</li>
<li><a id="orgd8c14a5"></a>最終結果<br />
<div class="outline-text-6" id="text-orgd8c14a5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">變數</th>
<th scope="col" class="org-left">初始化運算</th>
<th scope="col" class="org-left">計算結果</th>
<th scope="col" class="org-left">最終值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">d</td>
<td class="org-left">2 * int(3.14)</td>
<td class="org-left">2 * 3 = 6</td>
<td class="org-left">6.0 (double)</td>
</tr>

<tr>
<td class="org-left">k</td>
<td class="org-left">3.14 - 3</td>
<td class="org-left">0.14 → long 截斷</td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">x</td>
<td class="org-left">&rsquo;a&rsquo; + 2</td>
<td class="org-left">97 + 2 = 99 → &rsquo;c&rsquo;</td>
<td class="org-left">&rsquo;c&rsquo;</td>
</tr>

<tr>
<td class="org-left">y</td>
<td class="org-left">&rsquo;p&rsquo; + &rsquo;a&rsquo; - &rsquo;a&rsquo;</td>
<td class="org-left">112 + 97 - 97 = 112 → &rsquo;p&rsquo;</td>
<td class="org-left">&rsquo;p&rsquo;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2af10c8" class="outline-5">
<h5 id="org2af10c8">與本題相關的計算機概論 (計概) 知識</h5>
<div class="outline-text-5" id="text-org2af10c8">
<ol class="org-ol">
<li>型別轉換 (Type Conversion)<br />
<ul class="org-ul">
<li>C++ 會在不同型別間進行隱式或顯式轉換：<br />
<ul class="org-ul">
<li>隱式轉換 (Implicit Conversion)：當不同型別運算時，C++ 會自動轉換型別，如 char 轉 int。<br /></li>
<li>顯式轉換 (Explicit Conversion)：使用 int(3.14) 或 (int)3.14 強制轉換。<br /></li>
</ul></li>
</ul></li>
<li>整數截斷 (Truncation)<br />
<ul class="org-ul">
<li><p>
當浮點數 (double) 被賦值給整數 (int 或 long) 時，會執行截斷：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>     <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">5.99</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a = 5</span>
<span class="linenr">2: </span>     <span style="color: #ECBE7B;">long</span> <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">3.14</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">b = 3</span>
</pre>
</div></li>
<li>只保留整數部分，不會四捨五入！<br /></li>
</ul></li>
<li>ASCII 值與 char 運算<br />
<ul class="org-ul">
<li><p>
在 C++ 中，char 其實是 int 的別名，可以直接進行數值運算：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>     <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c</span> = <span style="color: #98be65;">'A'</span> + <span style="color: #da8548; font-weight: bold;">1</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">'A' = 65, &#25152;&#20197; c = 'B' (66)</span>
</pre>
</div></li>
<li>這樣的特性讓 x = &rsquo;a&rsquo; + 2; 能正確計算出 &rsquo;c&rsquo;。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org3bb9c5e" class="outline-5">
<h5 id="org3bb9c5e">總結</h5>
<div class="outline-text-5" id="text-org3bb9c5e">
<ul class="org-ul">
<li>C++ 會在不同型別間進行隱式轉換，運算過程可能影響結果。<br /></li>
<li>整數型別 (int, long) 會截斷小數部分，不會進行四捨五入。<br /></li>
<li>char 運算基於 ASCII 值，可以當作數字計算。<br /></li>
<li>this 指標的型別取決於成員函式是否 const，非 const 函式的 this 是 Test *const。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2de768b" class="outline-4">
<h4 id="org2de768b"><span class="section-number-4">7.1.9.</span> B-7 (20%) Rewrite the following C++ function by using pointer arithmetic:</h4>
<div class="outline-text-4" id="text-7-1-9">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">char</span> <span style="color: #c678dd;">reverseString</span>(<span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">str</span>) {
<span class="linenr">2: </span>  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">len</span> = strlen(str);
<span class="linenr">3: </span>  <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">result</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">char</span>[len + <span style="color: #da8548; font-weight: bold;">1</span>];
<span class="linenr">4: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; len; i++) {
<span class="linenr">5: </span>    result[i] = str[len - i - <span style="color: #da8548; font-weight: bold;">1</span>];
<span class="linenr">6: </span>  }
<span class="linenr">7: </span>  result[len] = <span style="color: #98be65;">'\0'</span>;
<span class="linenr">8: </span>  <span style="color: #51afef;">return</span> result; }
</pre>
</div>
</div>
<div id="outline-container-orgbe907ed" class="outline-5">
<h5 id="orgbe907ed">解</h5>
<div class="outline-text-5" id="text-orgbe907ed">
<p>
我們要改寫 reverseString 來使用指標運算 (Pointer Arithmetic)，而不是使用索引 ([]) 來存取字串的字元。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org82a0fe5"></a>改寫前的函式<br />
<div class="outline-text-6" id="text-org82a0fe5">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">char</span> <span style="color: #c678dd;">reverseString</span>(<span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">str</span>) {
<span class="linenr">2: </span>  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">len</span> = strlen(str);
<span class="linenr">3: </span>  <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">result</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">char</span>[len + <span style="color: #da8548; font-weight: bold;">1</span>];
<span class="linenr">4: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; len; i++) {
<span class="linenr">5: </span>    result[i] = str[len - i - <span style="color: #da8548; font-weight: bold;">1</span>];  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#32034;&#24341;&#26041;&#24335;&#23384;&#21462;&#23383;&#20803;</span>
<span class="linenr">6: </span>  }
<span class="linenr">7: </span>  result[len] = <span style="color: #98be65;">'\0'</span>;
<span class="linenr">8: </span>  <span style="color: #51afef;">return</span> result;
<span class="linenr">9: </span>}
</pre>
</div>

<p>
函式問題點<br />
</p>
<ul class="org-ul">
<li>函式返回型別錯誤 (char 應該是 char*)<br />
<ul class="org-ul">
<li>result 是動態配置的字串 (new char[len + 1])，但函式回傳型別是 char，這應該改為 char*。<br /></li>
</ul></li>
<li>未使用指標運算 (pointer arithmetic)<br />
<ul class="org-ul">
<li>result[i] = str[len - i - 1] 這種做法是使用陣列索引，而不是指標運算。<br /></li>
</ul></li>
<li>記憶體管理 (memory management)<br />
<ul class="org-ul">
<li>new 配置的記憶體需要 delete[] 釋放，否則會導致記憶體洩漏 (memory leak)。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org7b965a9"></a>改寫後的函式 (使用指標運算)<br />
<div class="outline-text-6" id="text-org7b965a9">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;cstring&gt;</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">char</span>* <span style="color: #c678dd;">reverseString</span>(<span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">str</span>) {
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">len</span> = strlen(str);
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">result</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">char</span>[len + <span style="color: #da8548; font-weight: bold;">1</span>];  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20998;&#37197;&#35352;&#25014;&#39636;</span>
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">start</span> = str + len - <span style="color: #da8548; font-weight: bold;">1</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521;&#23383;&#20018;&#30340;&#26368;&#24460;&#19968;&#20491;&#23383;&#20803;</span>
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">end</span> = result;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521;&#26032;&#23383;&#20018;&#30340;&#36215;&#22987;&#20301;&#32622;</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #51afef;">while</span> (start &gt;= str) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21453;&#21521;&#36941;&#27511;&#21407;&#23383;&#20018;</span>
<span class="linenr">11: </span>        *end++ = *start--;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#25351;&#27161;&#36939;&#31639;&#23384;&#21462;&#20006;&#31227;&#21205;</span>
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>
<span class="linenr">14: </span>    *end = <span style="color: #98be65;">'\0'</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28155;&#21152; null &#32080;&#26463;&#31526;</span>
<span class="linenr">15: </span>    <span style="color: #51afef;">return</span> result;
<span class="linenr">16: </span>}
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">19: </span>    <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">str</span>[] = <span style="color: #98be65;">"hello"</span>;
<span class="linenr">20: </span>    <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">reversed</span> = reverseString(str);
<span class="linenr">21: </span>    <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; reversed &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;
<span class="linenr">22: </span>    <span style="color: #51afef;">delete</span>[] reversed;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#37323;&#25918;&#35352;&#25014;&#39636;</span>
<span class="linenr">23: </span>}
</pre>
</div>
</div>
</li>
<li><a id="orgbe7be29"></a>程式碼解析<br />
<ul class="org-ul">
<li><a id="org7fb096c"></a>1. 指標變數<br />
<div class="outline-text-7" id="text-org7fb096c">
<ul class="org-ul">
<li>start = str + len - 1<br />
<ul class="org-ul">
<li>指向字串的最後一個字元 (不包含 \0)。<br /></li>
</ul></li>
<li>end = result<br />
<ul class="org-ul">
<li>指向新字串的起始位置。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org474977c"></a>2. 使用 while 進行反向拷貝<br />
<div class="outline-text-7" id="text-org474977c">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">while</span> (start &gt;= str) {
<span class="linenr">2: </span>    *end++ = *start--;
<span class="linenr">3: </span>}
</pre>
</div>
<ul class="org-ul">
<li>*end++ = *start&#x2013;：<br />
<ul class="org-ul">
<li>拷貝 *start 的字元到 *end，然後兩個指標分別前進與後退。<br /></li>
</ul></li>
<li>*end = &rsquo;\0&rsquo;：<br />
<ul class="org-ul">
<li>確保新字串以 \0 結尾。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc1f4b13"></a>3. 釋放記憶體<br />
<div class="outline-text-7" id="text-orgc1f4b13">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">delete</span>[] reversed;
</pre>
</div>
<ul class="org-ul">
<li>new 配置的記憶體必須用 delete[] 釋放，否則會造成記憶體洩漏。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org181e148"></a>與本題相關的計算機概論 (計概) 知識<br />
<div class="outline-text-6" id="text-org181e148">
<ol class="org-ol">
<li>指標運算 (Pointer Arithmetic)<br />
<ul class="org-ul">
<li>ptr + n：指標向後移動 n 個元素。<br /></li>
<li>ptr - n：指標向前移動 n 個元素。<br /></li>
<li>*ptr++：先存取 *ptr，然後指標前進 (ptr = ptr + 1)。<br /></li>
<li>*ptr&#x2013;：先存取 *ptr，然後指標後退 (ptr = ptr - 1)。<br /></li>
</ul></li>
<li><p>
C++ 記憶體管理<br />
</p>
<ul class="org-ul">
<li>動態記憶體分配 (new)<br />
<ul class="org-ul">
<li>char* buffer = new char[100];<br /></li>
</ul></li>
<li>釋放記憶體 (delete[])<br />
<ul class="org-ul">
<li>delete[] buffer;<br /></li>
</ul></li>
</ul>
<p>
如果 new 配置的記憶體未釋放，會導致記憶體洩漏 (Memory Leak)。<br />
</p></li>
<li>C-style 字串 (char*) 與 std::string<br />
在 C++ 中，字串可以用：<br />
<ol class="org-ol">
<li><p>
C-style 字串 (char*)<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>       <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">str</span>[] = <span style="color: #98be65;">"hello"</span>;
</pre>
</div></li>
<li><p>
C++ std::string<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>      <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">string</span> <span style="color: #dcaeea;">str</span> = <span style="color: #98be65;">"hello"</span>;
</pre>
</div></li>
</ol></li>
</ol>
<p>
C-style 字串的問題：<br />
</p>
<ul class="org-ul">
<li>需要手動管理記憶體 (new/delete)。<br /></li>
<li>strlen() 計算長度，strcpy() 複製字串，這些函式來自 &lt;cstring&gt;。<br /></li>
<li>容易發生 緩衝區溢位 (Buffer Overflow)。<br /></li>
</ul>
</div>
</li>
<li><a id="orgb7e5919"></a>總結<br />
<div class="outline-text-6" id="text-orgb7e5919">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">改進點</th>
<th scope="col" class="org-left">原始版本</th>
<th scope="col" class="org-left">改進後版本</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">函式返回型別</td>
<td class="org-left">char (錯誤)</td>
<td class="org-left">char* (正確)</td>
</tr>

<tr>
<td class="org-left">記憶體管理</td>
<td class="org-left">未釋放 new 記憶體</td>
<td class="org-left">正確釋放 delete[]</td>
</tr>

<tr>
<td class="org-left">存取方式</td>
<td class="org-left">陣列索引 ([])</td>
<td class="org-left">指標運算 (*ptr++)</td>
</tr>

<tr>
<td class="org-left">效率</td>
<td class="org-left">需要額外索引計算 (len - i - 1)</td>
<td class="org-left">直接使用指標遍歷</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org518cfae" class="outline-3">
<h3 id="org518cfae"><span class="section-number-3">7.2.</span> 111</h3>
<div class="outline-text-3" id="text-7-2">
<p>
國立成功大學 111 學年度碩士班招生考試試題 科目：計算機概論<br />
</p>
</div>
<div id="outline-container-orga70b73a" class="outline-4">
<h4 id="orga70b73a"><span class="section-number-4">7.2.1.</span> A-1. Multiple choice questions: (choose only ONE answer for a question; 3% for each question)</h4>
</div>
<div id="outline-container-org703d763" class="outline-4">
<h4 id="org703d763"><span class="section-number-4">7.2.2.</span> (1)</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
What kind of operating system programs will be permanently resident in memory?<br />
</p>
<ol class="org-ol">
<li>Compiler programs<br /></li>
<li>Supervisor programs<br /></li>
<li>Timing programs<br /></li>
<li>Synchronous programs<br /></li>
<li>Spooling programs.<br /></li>
</ol>
</div>
<div id="outline-container-org50833fa" class="outline-5">
<h5 id="org50833fa">解</h5>
<div class="outline-text-5" id="text-org50833fa">
<p>
在作業系統（Operating System, OS）中，某些程式需要**永久駐留（permanently resident）**於記憶體，以確保系統的穩定運行。這些程式通常屬於 核心（Kernel） 或 系統管理層級（System Management Level），主要負責系統資源管理與基本運作。<br />
</p>

<p>
根據題目選項，最符合「永久駐留記憶體」的程式是：<br />
</p>
<ul class="org-ul">
<li>✅ b. Supervisor Programs（監督程式）<br /></li>
<li>監督程式（Supervisor Program） 是 作業系統核心（Kernel） 的一部分，負責**處理系統呼叫、資源分配、行程管理（Process Management）**等。<br /></li>
<li>它永遠駐留在記憶體，因為：<br />
<ul class="org-ul">
<li>負責 CPU 及記憶體管理，確保行程能正常執行。<br /></li>
<li>處理使用者與應用程式的請求，如檔案存取、裝置管理。<br /></li>
<li>監督所有系統活動，確保安全性與穩定性。<br /></li>
</ul></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org0127871"></a>其他選項分析<br />
<div class="outline-text-6" id="text-org0127871">
<ul class="org-ul">
<li>❌ a. Compiler Programs（編譯器程式）<br />
<ul class="org-ul">
<li>編譯器（Compiler） 用於將高階程式語言（如 C、Java）轉換為機器碼，但它不屬於作業系統的一部分。<br /></li>
<li>只在執行時載入記憶體，執行完畢後會被釋放，不會永久駐留。<br /></li>
</ul></li>
<li>❌ c. Timing Programs（計時程式）<br />
<ul class="org-ul">
<li>計時程式（Timing Programs）通常是應用程式，負責執行時間相關的任務，如計時器（Timer）、時間同步（Clock Synchronization）。<br /></li>
<li>雖然作業系統會維護一個系統時鐘（System Clock），但計時功能本身通常不需要常駐記憶體。<br /></li>
</ul></li>
<li>❌ d. Synchronous Programs（同步程式）<br />
<ul class="org-ul">
<li>同步程式（Synchronous Programs） 主要指等待某些條件滿足後才執行的應用程式或作業系統功能，如 I/O 同步。<br /></li>
<li>這類程式通常由作業系統提供的 API 呼叫，不會長時間佔用記憶體。<br /></li>
</ul></li>
<li>❌ e. Spooling Programs（假脫機處理程式）<br />
<ul class="org-ul">
<li>Spooling（假脫機處理） 是一種將輸入或輸出請求緩衝在磁碟上的技術，主要用於印表機、批次處理等。<br /></li>
<li>Spooling 程式通常只在需要時載入記憶體，並非永久駐留。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org0af7065" class="outline-5">
<h5 id="org0af7065">與「作業系統常駐程式」相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-org0af7065">
</div>
<ul class="org-ul">
<li><a id="orgcc082d5"></a>(1) 作業系統核心（Kernel）<br />
<div class="outline-text-6" id="text-orgcc082d5">
<ul class="org-ul">
<li>✅ 核心（Kernel）<br />
<ul class="org-ul">
<li>常駐記憶體<br /></li>
<li>負責行程管理、記憶體管理、裝置管理<br /></li>
<li>系統呼叫（System Calls）<br /></li>
</ul></li>
<li>✅ 監督程式（Supervisor Program）<br />
<ul class="org-ul">
<li>處理行程切換（Context Switching）<br /></li>
<li>管理系統資源<br /></li>
<li>保護模式（Protected Mode）運行<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgfad550e"></a>(2) 記憶體管理<br />
<div class="outline-text-6" id="text-orgfad550e">
<ul class="org-ul">
<li>✅ 常駐與非常駐程式<br />
<ul class="org-ul">
<li>常駐（Resident Programs）：系統管理程式，如 Supervisor Program、排程器（Scheduler）。<br /></li>
<li>非常駐（Non-Resident Programs）：應用程式、使用者程式，執行後釋放記憶體。<br /></li>
</ul></li>
<li>✅ 虛擬記憶體（Virtual Memory）<br />
<ul class="org-ul">
<li>分頁技術（Paging）<br /></li>
<li>分段技術（Segmentation）<br /></li>
<li>交換區（Swap Space）<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgb158826"></a>(3) 行程與排程<br />
<div class="outline-text-6" id="text-orgb158826">
<ul class="org-ul">
<li>✅ 行程管理（Process Management）<br />
<ul class="org-ul">
<li>行程控制區塊（PCB, Process Control Block）<br /></li>
<li>系統呼叫（System Calls）<br /></li>
<li>行程狀態（Process States）<br /></li>
</ul></li>
<li>✅ 排程機制（Scheduling）<br />
<ul class="org-ul">
<li>短期排程（Short-term Scheduling）<br /></li>
<li>長期排程（Long-term Scheduling）<br /></li>
<li>優先權排程（Priority Scheduling）<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org12fc17e"></a>(4) 記憶體配置<br />
<div class="outline-text-6" id="text-org12fc17e">
<ul class="org-ul">
<li>✅ 靜態與動態記憶體管理<br />
<ul class="org-ul">
<li>靜態分割（Fixed Partitioning）<br /></li>
<li>動態分割（Dynamic Partitioning）<br /></li>
<li>最佳適配（Best Fit）、最差適配（Worst Fit）<br /></li>
</ul></li>
<li>✅ 中斷與上下文切換（Interrupts &amp; Context Switching）<br />
<ul class="org-ul">
<li>中斷處理（Interrupt Handling）<br /></li>
<li>硬體與軟體中斷<br /></li>
<li>系統呼叫（System Calls）<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6d2bcbb" class="outline-5">
<h5 id="org6d2bcbb">5. 總結</h5>
<div class="outline-text-5" id="text-org6d2bcbb">
<ul class="org-ul">
<li>✅ 正確答案：b. 監督程式（Supervisor Programs）<br /></li>
<li>監督程式是核心的一部分，負責管理 CPU、記憶體、行程、裝置。<br /></li>
<li>它是所有作業系統功能的基礎，必須長期駐留在記憶體中。<br /></li>
<li>❖ 錯誤選項的分析<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否駐留</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. 編譯器程式</td>
<td class="org-left">❌</td>
<td class="org-left">只在編譯時運行，不是作業系統的一部分</td>
</tr>

<tr>
<td class="org-left">c. 計時程式</td>
<td class="org-left">❌</td>
<td class="org-left">只負責計時，通常不長期駐留</td>
</tr>

<tr>
<td class="org-left">d. 同步程式</td>
<td class="org-left">❌</td>
<td class="org-left">只在特定情況執行，不需駐留</td>
</tr>

<tr>
<td class="org-left">e. Spooling 程式</td>
<td class="org-left">❌</td>
<td class="org-left">處理 I/O 任務，僅在需要時載入</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org6b484d2" class="outline-4">
<h4 id="org6b484d2"><span class="section-number-4">7.2.3.</span> (2)</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
The feature of an object-oriented programming language that allow the instances of different objects to respond to the same message differently is called <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span>.<br />
</p>
<ol class="org-ol">
<li>portability<br /></li>
<li>inheritance<br /></li>
<li>messaging<br /></li>
<li>encapsulation<br /></li>
<li>polymorphism.<br /></li>
</ol>
</div>
<div id="outline-container-org84c2011" class="outline-5">
<h5 id="org84c2011">解:</h5>
<div class="outline-text-5" id="text-org84c2011">
<p>
在 物件導向程式設計（Object-Oriented Programming, OOP） 中，有一個特性允許不同類別的物件對相同的訊息（方法呼叫）做出不同的回應，這稱為：<br />
</p>
<ul class="org-ul">
<li>✅ 正確答案：e. 多型（Polymorphism）<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org1af62df"></a>1. 多型（Polymorphism）的定義與功能<br />
<div class="outline-text-6" id="text-org1af62df">
<ul class="org-ul">
<li>多型（Polymorphism） 是物件導向程式設計中的核心概念之一，指的是同一個介面（Interface）或方法名稱，可以被不同的類別實現，以不同的方式執行。這意味著：<br />
<ul class="org-ul">
<li>物件的行為不僅取決於方法的名稱，還取決於實際呼叫該方法的物件類別。<br /></li>
<li>允許不同的物件對相同的訊息做出不同的回應。<br /></li>
</ul></li>
<li>多型的兩種類型<br />
<ul class="org-ul">
<li>編譯期多型（Compile-time Polymorphism）<br />
<ul class="org-ul">
<li>方法（函式）重載（Method Overloading）<br /></li>
<li>運算子多載（Operator Overloading）<br /></li>
<li>在編譯時期決定哪個方法或運算子被呼叫。<br /></li>
</ul></li>
<li>執行期多型（Run-time Polymorphism）<br />
<ul class="org-ul">
<li>方法覆寫（Method Overriding）<br /></li>
<li>透過動態繫結（Dynamic Binding） 在執行時決定哪個方法被執行。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org6eb71de"></a>2. 多型的範例<br />
<ul class="org-ul">
<li><a id="orge83b6b2"></a>(1) 方法覆寫（Method Overriding）<br />
<div class="outline-text-7" id="text-orge83b6b2">
<p>
假設我們有一個基礎類別 Animal，以及 Dog 和 Cat 兩個子類別，且都有 makeSound() 方法：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Animal</span> {
<span class="linenr"> 5: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 6: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">makeSound</span>() { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#34395;&#25836;&#20989;&#24335;&#20801;&#35377;&#35206;&#23531;</span>
<span class="linenr"> 7: </span>        cout &lt;&lt; <span style="color: #98be65;">"Some generic animal sound"</span> &lt;&lt; endl;
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>};
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Dog</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Animal</span> {
<span class="linenr">12: </span><span style="color: #51afef;">public</span>:
<span class="linenr">13: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">makeSound</span>() <span style="color: #51afef;">override</span> {
<span class="linenr">14: </span>        cout &lt;&lt; <span style="color: #98be65;">"Bark"</span> &lt;&lt; endl;
<span class="linenr">15: </span>    }
<span class="linenr">16: </span>};
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Cat</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Animal</span> {
<span class="linenr">19: </span><span style="color: #51afef;">public</span>:
<span class="linenr">20: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">makeSound</span>() <span style="color: #51afef;">override</span> {
<span class="linenr">21: </span>        cout &lt;&lt; <span style="color: #98be65;">"Meow"</span> &lt;&lt; endl;
<span class="linenr">22: </span>    }
<span class="linenr">23: </span>};
<span class="linenr">24: </span>
<span class="linenr">25: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">26: </span>    <span style="color: #ECBE7B;">Animal</span>* <span style="color: #dcaeea;">animal1</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>();
<span class="linenr">27: </span>    <span style="color: #ECBE7B;">Animal</span>* <span style="color: #dcaeea;">animal2</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Cat</span>();
<span class="linenr">28: </span>
<span class="linenr">29: </span>    animal1-&gt;makeSound(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986;&#65306;Bark</span>
<span class="linenr">30: </span>    animal2-&gt;makeSound(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986;&#65306;Meow</span>
<span class="linenr">31: </span>
<span class="linenr">32: </span>    <span style="color: #51afef;">delete</span> animal1;
<span class="linenr">33: </span>    <span style="color: #51afef;">delete</span> animal2;
<span class="linenr">34: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">35: </span>}
</pre>
</div>
<p>
📌 關鍵點<br />
</p>
<ul class="org-ul">
<li>makeSound() 方法在不同子類別中有不同的行為。<br /></li>
<li>使用 虛擬函式（virtual function） 確保多型機制運作。<br /></li>
<li>物件在執行期決定要執行哪個方法（動態繫結）。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org7676a68"></a>3. 其他選項解析<br />
<div class="outline-text-6" id="text-org7676a68">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Portability（可攜性）</td>
<td class="org-left">❌</td>
<td class="org-left">可攜性指的是程式碼能夠在不同系統上執行，與物件回應訊息方式無關。</td>
</tr>

<tr>
<td class="org-left">b. Inheritance（繼承）</td>
<td class="org-left">❌</td>
<td class="org-left">繼承允許子類別從父類別獲得屬性和方法，但它本身不影響方法的不同回應方式。</td>
</tr>

<tr>
<td class="org-left">c. Messaging（訊息傳遞）</td>
<td class="org-left">❌</td>
<td class="org-left">訊息傳遞指的是物件之間透過方法呼叫來互動，但不涉及不同物件對相同訊息的不同回應。</td>
</tr>

<tr>
<td class="org-left">d. Encapsulation（封裝）</td>
<td class="org-left">❌</td>
<td class="org-left">封裝指的是將物件的內部細節隱藏起來，提供介面供外部存取，與多型無直接關係。</td>
</tr>

<tr>
<td class="org-left">e. Polymorphism（多型）</td>
<td class="org-left">✅</td>
<td class="org-left">允許不同物件對相同方法名稱做出不同的回應，是正確答案。</td>
</tr>

<tr>
<td class="org-left">4. 與多型（Polymorphism）相關的計算機概論知識</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org4779691" class="outline-5">
<h5 id="org4779691">計算機概論（計概） 相關知識</h5>
<div class="outline-text-5" id="text-org4779691">
</div>
<ul class="org-ul">
<li><a id="org6cdf21e"></a>(1) 物件導向程式設計（OOP）<br />
<div class="outline-text-6" id="text-org6cdf21e">
<ul class="org-ul">
<li>✅ 物件導向的四大特性<br />
<ul class="org-ul">
<li>封裝（Encapsulation）：隱藏內部細節，提供公開介面。<br /></li>
<li>繼承（Inheritance）：允許子類別重用父類別的行為。<br /></li>
<li>多型（Polymorphism）：允許不同類別以相同介面執行不同行為。<br /></li>
<li>抽象（Abstraction）：只暴露必要的資訊，隱藏實現細節。<br /></li>
</ul></li>
<li>✅ 動態繫結（Dynamic Binding）<br />
<ul class="org-ul">
<li>透過基底類別指標呼叫子類別的方法<br /></li>
<li>C++ 使用 virtual 方法實現<br /></li>
<li>Java/Python 預設支援動態繫結<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc291552"></a>(2) 記憶體管理與執行時行為<br />
<div class="outline-text-6" id="text-orgc291552">
<ul class="org-ul">
<li>✅ 虛擬函式表（Virtual Table, VTable）<br />
<ul class="org-ul">
<li>C++ 透過 VTable 機制 來實現動態多型。<br /></li>
<li>VTable 儲存類別方法的指標，執行時決定呼叫哪個函式。<br /></li>
</ul></li>
<li>✅ 函式指標（Function Pointer）<br />
<ul class="org-ul">
<li><p>
在 C 語言中，函式指標可實現類似的多型效果：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">void</span> (*<span style="color: #c678dd;">func_ptr</span>)();
<span class="linenr">2: </span>    func_ptr = &amp;someFunction;
<span class="linenr">3: </span>    func_ptr(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21628;&#21483; someFunction</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgb47f87e"></a>(3) 編譯器與執行環境<br />
<div class="outline-text-6" id="text-orgb47f87e">
<ul class="org-ul">
<li>✅ 靜態 vs. 動態多型<br />
<ul class="org-ul">
<li>靜態多型（編譯期確定）<br />
<ul class="org-ul">
<li>方法重載（Method Overloading）<br /></li>
<li>運算子多載（Operator Overloading）<br /></li>
</ul></li>
<li>動態多型（執行期確定）<br />
<ul class="org-ul">
<li>方法覆寫（Method Overriding）<br /></li>
</ul></li>
</ul></li>
<li>✅ C++ vs. Java vs. Python 多型比較<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">語言</th>
<th scope="col" class="org-left">多型特性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">C++</td>
<td class="org-left">透過 virtual 函式與 VTable 機制實現動態多型</td>
</tr>

<tr>
<td class="org-left">Java</td>
<td class="org-left">預設所有方法都是動態繫結，支援介面（Interface）來實現多型</td>
</tr>

<tr>
<td class="org-left">Python</td>
<td class="org-left">無需 virtual，所有方法都是動態多型，支援鴨子型別（Duck Typing）</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgfd96fcf"></a>總結<br />
<div class="outline-text-6" id="text-orgfd96fcf">
<p>
❖ 正確答案<br />
✅ Polymorphism（多型） 是允許不同物件對相同方法名稱做出不同回應的特性。<br />
❖ 其他選項分析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">解釋</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Portability</td>
<td class="org-left">❌</td>
<td class="org-left">指程式能跨平台執行，與 OOP 多型無關</td>
</tr>

<tr>
<td class="org-left">b. Inheritance</td>
<td class="org-left">❌</td>
<td class="org-left">允許類別繼承，但不影響不同物件對相同訊息的回應方式</td>
</tr>

<tr>
<td class="org-left">c. Messaging</td>
<td class="org-left">❌</td>
<td class="org-left">物件之間傳遞訊息，但不代表能根據類別不同回應不同行為</td>
</tr>

<tr>
<td class="org-left">d. Encapsulation</td>
<td class="org-left">❌</td>
<td class="org-left">保護資料，但不影響方法的不同回應</td>
</tr>

<tr>
<td class="org-left">e. Polymorphism</td>
<td class="org-left">✅</td>
<td class="org-left">允許不同類別的物件以相同方法名稱執行不同行為</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge3efdcf" class="outline-4">
<h4 id="orge3efdcf"><span class="section-number-4">7.2.4.</span> (3)</h4>
<div class="outline-text-4" id="text-7-2-4">
<p>
A(n) <span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> class is used take the responsibility of instantiating a group of utilities classes (e.g., data access classes).<br />
</p>
<ol class="org-ol">
<li>factory<br /></li>
<li>adapter<br /></li>
<li>daemon<br /></li>
<li>utility<br /></li>
<li>controller.<br /></li>
</ol>
</div>
<div id="outline-container-org6d0445a" class="outline-5">
<h5 id="org6d0445a">解:</h5>
<div class="outline-text-5" id="text-org6d0445a">
<p>
在軟體設計模式中，有一種設計模式專門用來負責建立並管理某些類別的實例（例如資料存取類別 Data Access Classes），這種類別稱為：<br />
✅ 正確答案：a. 工廠類別（Factory Class）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgc070f20"></a>1. 工廠類別（Factory Class）的定義<br />
<div class="outline-text-6" id="text-orgc070f20">
<p>
工廠模式（Factory Pattern） 是 設計模式（Design Pattern） 中的一種 創建型模式（Creational Pattern），其主要作用是負責建立物件的實例，而不需要直接透過 new 關鍵字來手動創建物件。<br />
</p>
<ul class="org-ul">
<li>工廠模式的主要特性<br />
<ul class="org-ul">
<li>將物件的創建邏輯集中於一處，簡化代碼結構。<br /></li>
<li>允許程式碼根據不同的需求動態創建物件，提高擴展性。<br /></li>
<li>適用於建立多個相關類別的實例，例如 資料存取類別（Data Access Classes）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orga2b658a"></a>2. 工廠模式的應用範例<br />
<div class="outline-text-6" id="text-orga2b658a">
<p>
假設我們有一個資料存取類別（Data Access Class），根據不同的資料庫類型（如 MySQL、PostgreSQL）來建立相應的物件：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org12e7950"></a>(1) 介面定義<br />
<div class="outline-text-7" id="text-org12e7950">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23450;&#32681;&#36039;&#26009;&#23384;&#21462;&#30340;&#20171;&#38754;</span>
<span class="linenr">2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">DataAccess</span> {
<span class="linenr">3: </span><span style="color: #51afef;">public</span>:
<span class="linenr">4: </span>    <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">connect</span>() = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">5: </span>    <span style="color: #51afef;">virtual</span> ~<span style="color: #c678dd;">DataAccess</span>() {}
<span class="linenr">6: </span>};
</pre>
</div>
</div>
</li>
<li><a id="org32f8a8e"></a>(2) 具體實作類別<br />
<div class="outline-text-7" id="text-org32f8a8e">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">MySQL &#36039;&#26009;&#23384;&#21462;&#39006;&#21029;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">MySQLDataAccess</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">DataAccess</span> {
<span class="linenr"> 3: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">connect</span>() <span style="color: #51afef;">override</span> {
<span class="linenr"> 5: </span>        cout &lt;&lt; <span style="color: #98be65;">"Connecting to MySQL Database"</span> &lt;&lt; endl;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>};
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">PostgreSQL &#36039;&#26009;&#23384;&#21462;&#39006;&#21029;</span>
<span class="linenr">10: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">PostgreSQLDataAccess</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">DataAccess</span> {
<span class="linenr">11: </span><span style="color: #51afef;">public</span>:
<span class="linenr">12: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">connect</span>() <span style="color: #51afef;">override</span> {
<span class="linenr">13: </span>        cout &lt;&lt; <span style="color: #98be65;">"Connecting to PostgreSQL Database"</span> &lt;&lt; endl;
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>};
</pre>
</div>
</div>
</li>
<li><a id="org144f476"></a>(3) 工廠類別<br />
<div class="outline-text-7" id="text-org144f476">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24037;&#24288;&#39006;&#21029;&#65306;&#36000;&#36012;&#26681;&#25818;&#21443;&#25976;&#24314;&#31435;&#19981;&#21516;&#30340;&#36039;&#26009;&#23384;&#21462;&#29289;&#20214;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">DataAccessFactory</span> {
<span class="linenr"> 3: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">DataAccess</span>* <span style="color: #c678dd;">createDataAccess</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">string</span>&amp; <span style="color: #dcaeea;">type</span>) {
<span class="linenr"> 5: </span>        <span style="color: #51afef;">if</span> (type == <span style="color: #98be65;">"MySQL"</span>) {
<span class="linenr"> 6: </span>            <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">MySQLDataAccess</span>();
<span class="linenr"> 7: </span>        } <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> (type == <span style="color: #98be65;">"PostgreSQL"</span>) {
<span class="linenr"> 8: </span>            <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">PostgreSQLDataAccess</span>();
<span class="linenr"> 9: </span>        } <span style="color: #51afef;">else</span> {
<span class="linenr">10: </span>            <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">nullptr</span>;
<span class="linenr">11: </span>        }
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>};
</pre>
</div>
</div>
</li>
<li><a id="orgf579955"></a>(4) 測試工廠模式<br />
<div class="outline-text-7" id="text-orgf579955">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 2: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36879;&#36942;&#24037;&#24288;&#26041;&#27861;&#24314;&#31435; MySQL &#36039;&#26009;&#23384;&#21462;&#29289;&#20214;</span>
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">DataAccess</span>* <span style="color: #dcaeea;">db1</span> = <span style="color: #a9a1e1;">DataAccessFactory</span>::createDataAccess(<span style="color: #98be65;">"MySQL"</span>);
<span class="linenr"> 4: </span>    <span style="color: #51afef;">if</span> (db1) {
<span class="linenr"> 5: </span>        db1-&gt;connect();
<span class="linenr"> 6: </span>        <span style="color: #51afef;">delete</span> db1;
<span class="linenr"> 7: </span>    }
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36879;&#36942;&#24037;&#24288;&#26041;&#27861;&#24314;&#31435; PostgreSQL &#36039;&#26009;&#23384;&#21462;&#29289;&#20214;</span>
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">DataAccess</span>* <span style="color: #dcaeea;">db2</span> = <span style="color: #a9a1e1;">DataAccessFactory</span>::createDataAccess(<span style="color: #98be65;">"PostgreSQL"</span>);
<span class="linenr">11: </span>    <span style="color: #51afef;">if</span> (db2) {
<span class="linenr">12: </span>        db2-&gt;connect();
<span class="linenr">13: </span>        <span style="color: #51afef;">delete</span> db2;
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">17: </span>}
</pre>
</div>
<p>
輸出結果<br />
</p>
<pre class="example" id="org08b753c">
Connecting to MySQL Database
Connecting to PostgreSQL Database
</pre>
<p>
📌 關鍵點<br />
</p>
<ul class="org-ul">
<li>DataAccessFactory 是工廠類別，負責創建 MySQL 或 PostgreSQL 的資料存取物件。<br /></li>
<li>客戶端程式（Client Code）不需要直接使用 new，只需呼叫工廠方法。<br /></li>
<li>這種設計模式有助於提高系統的彈性和可擴展性。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org54dd652"></a>3. 其他選項分析<br />
<div class="outline-text-6" id="text-org54dd652">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Factory（工廠類別）</td>
<td class="org-left">✅</td>
<td class="org-left">專門用來建立相關類別的物件（如資料存取類別），是正確答案。</td>
</tr>

<tr>
<td class="org-left">b. Adapter（適配器類別）</td>
<td class="org-left">❌</td>
<td class="org-left">適配器模式（Adapter Pattern）用來讓不同介面之間相容，不負責建立物件。</td>
</tr>

<tr>
<td class="org-left">c. Daemon（背景執行類別）</td>
<td class="org-left">❌</td>
<td class="org-left">Daemon 是在背景執行的系統程序，與物件實例化無關。</td>
</tr>

<tr>
<td class="org-left">d. Utility（公用類別）</td>
<td class="org-left">❌</td>
<td class="org-left">Utility 類別通常包含靜態方法（如數學函數），不負責建立其他物件。</td>
</tr>

<tr>
<td class="org-left">e. Controller（控制器類別）</td>
<td class="org-left">❌</td>
<td class="org-left">Controller 類別用於處理請求，但不負責建立其他類別的實例。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org86eceb7"></a>與工廠模式相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="org340c718"></a>(1) 物件導向程式設計（OOP）<br />
<div class="outline-text-7" id="text-org340c718">
<ul class="org-ul">
<li>✅ 物件導向的四大特性<br />
<ul class="org-ul">
<li>封裝（Encapsulation）：隱藏內部細節，提供公開介面。<br /></li>
<li>繼承（Inheritance）：允許類別之間建立層級關係。<br /></li>
<li>多型（Polymorphism）：允許不同類別以相同方法名稱執行不同行為。<br /></li>
<li>抽象（Abstraction）：只暴露必要的資訊，隱藏實現細節。<br /></li>
</ul></li>
<li>✅ 設計模式（Design Patterns）<br />
<ul class="org-ul">
<li>工廠模式（Factory Pattern）：負責建立物件，降低耦合。<br /></li>
<li>單例模式（Singleton Pattern）：確保某類別只有一個實例。<br /></li>
<li>適配器模式（Adapter Pattern）：用於不同介面間的轉換。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org4562a89"></a>(2) 記憶體管理<br />
<div class="outline-text-7" id="text-org4562a89">
<ul class="org-ul">
<li>✅ 動態記憶體分配（Dynamic Memory Allocation）<br />
<ul class="org-ul">
<li>new 和 delete 在 C++ 中如何分配/釋放記憶體<br /></li>
<li>工廠模式如何管理物件的生命週期<br /></li>
</ul></li>
<li>✅ 智慧指標（Smart Pointers）<br />
<ul class="org-ul">
<li>std::unique_ptr 和 std::shared_ptr 在工廠模式中的應用。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org9d77c08"></a>(3) 軟體工程<br />
<div class="outline-text-7" id="text-org9d77c08">
<ul class="org-ul">
<li>✅ 模組化設計（Modular Design）<br />
<ul class="org-ul">
<li>工廠模式有助於提高程式的可維護性與可擴展性。<br /></li>
</ul></li>
<li>✅ 依賴反轉原則（Dependency Inversion Principle, DIP）<br />
<ul class="org-ul">
<li>高層模組不應該依賴低層模組，而是依賴抽象介面。<br /></li>
<li>工廠模式可以幫助實現這一原則。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgd393f51"></a>總結<br />
<div class="outline-text-6" id="text-orgd393f51">
<p>
❖ 正確答案<br />
</p>
<ul class="org-ul">
<li>✅ Factory（工廠類別） 是負責實例化一組公用類別（如資料存取類別）的設計模式，是正確答案。<br /></li>
</ul>
<p>
❖ 其他選項分析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">解釋</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Factory</td>
<td class="org-left">✅</td>
<td class="org-left">用來建立相關類別的實例，降低耦合，提高可維護性</td>
</tr>

<tr>
<td class="org-left">b. Adapter</td>
<td class="org-left">❌</td>
<td class="org-left">用於介面轉換，不負責建立物件</td>
</tr>

<tr>
<td class="org-left">c. Daemon</td>
<td class="org-left">❌</td>
<td class="org-left">指在背景執行的系統程序，與物件實例化無關</td>
</tr>

<tr>
<td class="org-left">d. Utility</td>
<td class="org-left">❌</td>
<td class="org-left">公用類別通常只有靜態方法，不負責建立其他物件</td>
</tr>

<tr>
<td class="org-left">e. Controller</td>
<td class="org-left">❌</td>
<td class="org-left">用於處理請求，而非建立物件</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd59c218" class="outline-4">
<h4 id="orgd59c218"><span class="section-number-4">7.2.5.</span> (4)</h4>
<div class="outline-text-4" id="text-7-2-5">
<p>
A backup facility (e.g., an office or a warehouse) that has the necessary components (e.g., space, power, cooling equipment, and Internet connection) of a computer facility, but does not have any computer equipment installed is called a <span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span>.<br />
</p>
<ol class="org-ol">
<li>service site<br /></li>
<li>waste site<br /></li>
<li>cold site<br /></li>
<li>reference site<br /></li>
<li>hardware site.<br /></li>
</ol>
</div>
<div id="outline-container-org8a63693" class="outline-5">
<h5 id="org8a63693">解:</h5>
<div class="outline-text-5" id="text-org8a63693">
<p>
在災難復原和備援設施中，有一種類型的設施僅提供空間、電力、冷卻系統和網路連接，但沒有預先配置任何電腦設備或伺服器。這種設施專門用於在發生災難時，企業可以迅速將其設備和數據中心架設於該地點，以便恢復業務運作。這類設施稱為：<br />
</p>

<p>
✅ 正確答案：c. 冷備援（Cold Site）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org925bd3c"></a>1. 冷備援（Cold Site）的定義<br />
<div class="outline-text-6" id="text-org925bd3c">
<p>
冷備援（Cold Site） 是一種災難復原設施，它提供基本的設施條件，例如：<br />
</p>
<ul class="org-ul">
<li>物理空間（Physical Space）<br /></li>
<li>電力供應（Power Supply）<br /></li>
<li>冷卻系統（Cooling Equipment）<br /></li>
<li>網路連接（Internet Connection）<br /></li>
</ul>
<p>
然而，冷備援並不包含任何預先配置的電腦設備或伺服器。企業在災難發生後，需要自行將設備和資料運送到冷備援設施，並進行安裝和配置，這通常會花費較多的時間來使業務恢復運作。<br />
冷備援的特點<br />
</p>
<ul class="org-ul">
<li>成本較低：由於沒有設備配置，冷備援設施的成本相對較低。<br /></li>
<li>恢復時間較長：需要時間將設備運輸並完成安裝，因此恢復業務所需的時間較長。<br /></li>
<li>適用於非關鍵業務：冷備援通常適用於對於恢復時間要求不高的業務，或是中小型企業的基本備援方案。<br /></li>
</ul>
</div>
</li>
<li><a id="org25e874c"></a>2. 冷備援的應用場景<br />
<div class="outline-text-6" id="text-org25e874c">
<p>
假設一家企業在主要數據中心發生重大故障（如火災或洪水）後，該企業可以將必要的硬體設備（伺服器、網路設備等）運送到冷備援設施，並重新安裝和配置系統以恢復運作。雖然需要較長時間，但冷備援設施是一種相對經濟的備援方案。<br />
</p>
</div>
</li>
<li><a id="org964ce90"></a>3. 其他選項分析<br />
<div class="outline-text-6" id="text-org964ce90">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Service Site（服務站點）</td>
<td class="org-left">❌</td>
<td class="org-left">服務站點通常是提供特定服務的地點，與災難備援設施無關。</td>
</tr>

<tr>
<td class="org-left">b. Waste Site（廢棄站點）</td>
<td class="org-left">❌</td>
<td class="org-left">廢棄站點意指垃圾處理或廢棄物存放地，與備援設施毫無關聯。</td>
</tr>

<tr>
<td class="org-left">c. Cold Site（冷備援）</td>
<td class="org-left">✅</td>
<td class="org-left">冷備援提供基本設施，但不包含任何電腦設備，是正確答案。</td>
</tr>

<tr>
<td class="org-left">d. Reference Site（參考站點）</td>
<td class="org-left">❌</td>
<td class="org-left">參考站點通常指供研究或比較的地點，與備援無關。</td>
</tr>

<tr>
<td class="org-left">e. Hardware Site（硬體站點）</td>
<td class="org-left">❌</td>
<td class="org-left">硬體站點並不是常見的災難復原術語，不適合描述不含設備的備援設施。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orge6dd4a4"></a>4. 與冷備援相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="orgb1df0c8"></a>(1) 災難復原與業務持續性（Disaster Recovery &amp; Business Continuity）<br />
<div class="outline-text-7" id="text-orgb1df0c8">
<p>
✅ 災難復原策略<br />
</p>
<ul class="org-ul">
<li>冷備援（Cold Site）：僅提供基本設施，恢復時間長。<br /></li>
<li>溫備援（Warm Site）：具備部分硬體設備，但需要配置應用程式和數據。<br /></li>
<li>熱備援（Hot Site）：完整設備配置，能夠迅速切換和恢復運作。<br /></li>
</ul>
<p>
✅ 業務持續性計劃（Business Continuity Plan, BCP）<br />
</p>
<ul class="org-ul">
<li>針對業務中斷進行風險評估和應對措施。<br /></li>
<li>確保在災難發生後，企業能夠盡快恢復基本運作。<br /></li>
</ul>
</div>
</li>
<li><a id="orgfc445d3"></a>(2) 數據中心管理與備援設施<br />
<div class="outline-text-7" id="text-orgfc445d3">
<p>
✅ 數據中心設計<br />
</p>
<ul class="org-ul">
<li>物理安全（Physical Security）：冷備援設施必須具備防火、防水等基本保護措施。<br /></li>
<li>電力與冷卻系統：確保設備安裝後能正常運行。<br /></li>
</ul>
<p>
✅ 備援設施的分類<br />
</p>
<ul class="org-ul">
<li>資料備份（Data Backup）：確保重要數據不會因災難而丟失。<br /></li>
<li>容錯設計（Fault Tolerance）：設計系統以抵禦特定故障（如硬體損壞）。<br /></li>
</ul>
</div>
</li>
<li><a id="org1507982"></a>(3) 網路基礎設施<br />
<div class="outline-text-7" id="text-org1507982">
<p>
✅ 網路連接（Internet Connection）<br />
</p>
<ul class="org-ul">
<li>冷備援設施通常需具備基本的網路連接，以便在設備安裝後快速上線。<br /></li>
</ul>
<p>
✅ 遠端存取（Remote Access）<br />
</p>
<ul class="org-ul">
<li>災難發生後，技術人員需能遠端配置和管理新設備。<br /></li>
</ul>
</div>
</li>
<li><a id="org955775a"></a>5. 總結<br />
<div class="outline-text-7" id="text-org955775a">
<p>
❖ 正確答案: ✅ Cold Site（冷備援） 是一種僅提供基本設施（如空間、電力、冷卻系統、網路連接），但沒有安裝任何電腦設備的備援設施。<br />
❖ 其他選項分析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">解釋</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Service Site</td>
<td class="org-left">❌</td>
<td class="org-left">提供特定服務，與備援設施無關。</td>
</tr>

<tr>
<td class="org-left">b. Waste Site</td>
<td class="org-left">❌</td>
<td class="org-left">廢棄物處理地點，不相關。</td>
</tr>

<tr>
<td class="org-left">c. Cold Site</td>
<td class="org-left">✅</td>
<td class="org-left">提供基本設施，無設備配置，適合災難復原。</td>
</tr>

<tr>
<td class="org-left">d. Reference Site</td>
<td class="org-left">❌</td>
<td class="org-left">通常用於研究或比較，不適合作為備援設施。</td>
</tr>

<tr>
<td class="org-left">e. Hardware Site</td>
<td class="org-left">❌</td>
<td class="org-left">非常見的術語，不合適。</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8e6b9b9" class="outline-4">
<h4 id="org8e6b9b9"><span class="section-number-4">7.2.6.</span> (5)</h4>
<div class="outline-text-4" id="text-7-2-6">
<p>
Using <span class="underline"><span class="underline"><span class="underline">_</span></span></span> is one of the most effective protective measures to counteract the network attack strategy of &ldquo;digital certificate diddling&rdquo;.<br />
</p>
<ol class="org-ol">
<li>digital certificates<br /></li>
<li>intruder detections<br /></li>
<li>encrypted message digest<br /></li>
<li>firewalls<br /></li>
<li>authentication techniques.<br /></li>
</ol>
</div>
<div id="outline-container-org498554f" class="outline-5">
<h5 id="org498554f">解:</h5>
<div class="outline-text-5" id="text-org498554f">
<p>
數位憑證篡改（Digital Certificate Diddling） 是一種網路攻擊手法，駭客試圖篡改或偽造數位憑證（Digital Certificate），從而竊取身份、攔截加密通訊或進行中間人攻擊（MITM, Man-in-the-Middle Attack）。<br />
</p>

<p>
在防範這類攻擊的保護措施中，最有效的方法是： ✅ 正確答案：c. 加密的訊息摘要（Encrypted Message Digest）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orga85505b"></a>1. 加密的訊息摘要（Encrypted Message Digest）的作用<br />
<div class="outline-text-6" id="text-orga85505b">
<ul class="org-ul">
<li>🔹 訊息摘要（Message Digest）<br />
<ul class="org-ul">
<li>訊息摘要是一種透過單向雜湊函數（Hash Function） 生成的固定長度字串，代表原始數據的「指紋」。常見的雜湊演算法包括：<br />
<ul class="org-ul">
<li>SHA-256（Secure Hash Algorithm 256-bit）<br /></li>
<li>SHA-3（Keccak）<br /></li>
<li>MD5（已不安全，易受碰撞攻擊）<br /></li>
</ul></li>
</ul></li>
<li>🔹 加密的訊息摘要<br />
當訊息摘要被數位簽章（Digital Signature） 進一步加密時，可以：<br />
<ul class="org-ul">
<li>確保數位憑證的完整性：防止惡意篡改憑證內容。<br /></li>
<li>驗證憑證的真實性：確保憑證來自信任的憑證授權機構（Certificate Authority, CA）。<br /></li>
<li>防止 MITM 攻擊：確保通信雙方使用的是合法的公鑰基礎設施（PKI, Public Key Infrastructure）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org1283729"></a>2. 數位憑證篡改（Digital Certificate Diddling）攻擊方式<br />
<div class="outline-text-6" id="text-org1283729">
<p>
數位憑證篡改 主要是透過以下手法進行：<br />
</p>
<ul class="org-ul">
<li>竄改公鑰：駭客可能修改數位憑證中的公鑰，使受害者使用錯誤的加密金鑰進行通訊。<br /></li>
<li>偽造憑證（Fake Certificates）：駭客可能設計與合法網站相同的數位憑證，誘導使用者進行惡意連線。<br /></li>
<li>攔截憑證交換（Certificate Interception）：中間人攻擊（MITM）可攔截並替換合法的憑證，從而進行解密攻擊。<br /></li>
</ul>
</div>
</li>
<li><a id="org6751bf1"></a>3. 其他選項分析<br />
<div class="outline-text-6" id="text-org6751bf1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Digital Certificates（數位憑證）</td>
<td class="org-left">❌</td>
<td class="org-left">數位憑證本身可以保護身份驗證，但若未加密或驗證其完整性，仍可能被篡改。</td>
</tr>

<tr>
<td class="org-left">b. Intruder Detections（入侵偵測系統）</td>
<td class="org-left">❌</td>
<td class="org-left">入侵偵測系統（IDS）可以監測網路攻擊，但無法直接防範憑證篡改。</td>
</tr>

<tr>
<td class="org-left">c. Encrypted Message Digest（加密的訊息摘要）</td>
<td class="org-left">✅</td>
<td class="org-left">加密訊息摘要可確保憑證的完整性與真實性，防範篡改與中間人攻擊。</td>
</tr>

<tr>
<td class="org-left">d. Firewalls（防火牆）</td>
<td class="org-left">❌</td>
<td class="org-left">防火牆可阻擋未經授權的存取，但對於數位憑證篡改攻擊並無直接影響。</td>
</tr>

<tr>
<td class="org-left">e. Authentication Techniques（身份驗證技術）</td>
<td class="org-left">❌</td>
<td class="org-left">身份驗證技術如密碼驗證或雙因素驗證（2FA）可以保護使用者身份，但不直接防範數位憑證篡改。</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6ecb7b7" class="outline-5">
<h5 id="org6ecb7b7">與數位憑證篡改防禦相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-org6ecb7b7">
<ul class="org-ul">
<li>(1) 資訊安全（Cybersecurity）<br />
<ul class="org-ul">
<li>✅ 加密技術（Cryptography）<br />
<ul class="org-ul">
<li>對稱加密（Symmetric Encryption）：如 AES<br /></li>
<li>非對稱加密（Asymmetric Encryption）：如 RSA、ECC<br /></li>
<li>雜湊函數（Hash Functions）：SHA-256、SHA-3<br /></li>
<li>訊息認證碼（Message Authentication Code, MAC）<br /></li>
</ul></li>
<li>✅ 數位簽章（Digital Signature）<br />
<ul class="org-ul">
<li>確保訊息與數位憑證未被篡改<br /></li>
<li>驗證簽章的來源，避免 MITM 攻擊<br /></li>
<li>常見演算法：RSA、ECDSA（橢圓曲線數位簽章）<br /></li>
</ul></li>
<li>✅ 公鑰基礎設施（PKI, Public Key Infrastructure）<br />
<ul class="org-ul">
<li>憑證授權機構（CA, Certificate Authority）<br /></li>
<li>憑證撤銷清單（CRL, Certificate Revocation List）<br /></li>
<li>線上憑證狀態協議（OCSP, Online Certificate Status Protocol）<br /></li>
</ul></li>
</ul></li>
<li>(2) 網路安全（Network Security）<br />
<ul class="org-ul">
<li>✅ SSL/TLS（安全通訊協定）<br />
<ul class="org-ul">
<li>確保 HTTPS 連線的憑證完整性<br /></li>
<li>避免駭客篡改 SSL 憑證<br /></li>
<li>TLS 1.3 提供更安全的加密機制<br /></li>
</ul></li>
<li>✅ 中間人攻擊（MITM, Man-in-the-Middle Attack）<br />
<ul class="org-ul">
<li>駭客透過假憑證攔截 HTTPS 連線<br /></li>
<li>使用加密訊息摘要與數位簽章可防止篡改<br /></li>
</ul></li>
<li>✅ DNS 欺騙與惡意憑證（Fake Certificates）<br />
<ul class="org-ul">
<li>防範方法：使用 DNSSEC（DNS 安全擴展）、HTTPS 憑證釘選（Certificate Pinning）<br /></li>
</ul></li>
</ul></li>
<li>(3) 作業系統安全（Operating System Security）<br />
<ul class="org-ul">
<li>✅ 作業系統如何管理憑證<br />
<ul class="org-ul">
<li>可信憑證存放區（Trusted Certificate Store）<br /></li>
<li>Windows 的「憑證管理員（certmgr.msc）」<br /></li>
<li>Linux/macOS 的 OpenSSL 工具驗證憑證<br /></li>
</ul></li>
<li>✅ 憑證有效性檢查<br />
<ul class="org-ul">
<li>確保憑證來自合法的 CA（如 Let’s Encrypt、DigiCert）<br /></li>
<li>使用 openssl verify 或瀏覽器內建工具檢查憑證<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orga922352"></a>5. 總結<br />
<div class="outline-text-6" id="text-orga922352">
<p>
❖ 正確答案<br />
✅ Encrypted Message Digest（加密的訊息摘要） 是防範數位憑證篡改（Digital Certificate Diddling）攻擊的最佳保護措施，因為它能：<br />
</p>
<ul class="org-ul">
<li>確保數位憑證的完整性（Integrity）<br /></li>
<li>驗證憑證的真實性，防止 MITM 攻擊<br /></li>
<li>與數位簽章一起使用，確保憑證未被竄改<br /></li>
</ul>
</div>
</li>
<li><a id="org022a6ac"></a>❖ 其他選項分析<br />
<div class="outline-text-6" id="text-org022a6ac">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">解釋</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Digital Certificates</td>
<td class="org-left">❌</td>
<td class="org-left">數位憑證本身可能被篡改，需透過雜湊驗證完整性</td>
</tr>

<tr>
<td class="org-left">b. Intruder Detections</td>
<td class="org-left">❌</td>
<td class="org-left">監測入侵行為，但無法防範憑證被篡改</td>
</tr>

<tr>
<td class="org-left">c. Encrypted Message Digest</td>
<td class="org-left">✅</td>
<td class="org-left">最佳選擇，確保憑證完整性，避免篡改</td>
</tr>

<tr>
<td class="org-left">d. Firewalls</td>
<td class="org-left">❌</td>
<td class="org-left">防火牆能阻擋攻擊，但不影響憑證驗證</td>
</tr>

<tr>
<td class="org-left">e. Authentication Techniques</td>
<td class="org-left">❌</td>
<td class="org-left">主要用於身份驗證，不能保證憑證完整性</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org026e1f1" class="outline-4">
<h4 id="org026e1f1"><span class="section-number-4">7.2.7.</span> (6) Among the basic approaches to utilizing the spectrum available to the wireless local area networks, <span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> spreads the data over multiple carrier frequencies to transmit the data in parallel, while those multiple carrier frequencies are specifically secure that they do not interfere with one another.</h4>
<div class="outline-text-4" id="text-7-2-7">
<ol class="org-ol">
<li>frequency-hopping spread spectrum (FHSS)<br /></li>
<li>direct sequence spread spectrum (DSSS)<br /></li>
<li>service set identifier (SSID)<br /></li>
<li>orthogonal frequency-division multiplexing (OFDM)<br /></li>
<li>carrier sense multiple access with collision avoidance (CSMA/CD).<br /></li>
</ol>
</div>
<div id="outline-container-org31d5c23" class="outline-5">
<h5 id="org31d5c23">解:</h5>
<div class="outline-text-5" id="text-org31d5c23">
<p>
在無線區域網路（WLAN）中，將數據分散到多個載波頻率並行傳輸，同時確保這些載波頻率互不干擾的方法是？<br />
</p>

<p>
✅ 正確答案：d. 正交分頻多工（OFDM, Orthogonal Frequency-Division Multiplexing）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgace0898"></a>1. 正交分頻多工（OFDM）的定義<br />
<div class="outline-text-6" id="text-orgace0898">
<p>
OFDM（Orthogonal Frequency-Division Multiplexing） 是一種多載波傳輸技術，透過將數據拆分到多個正交的子載波（Subcarriers）上並行傳輸，以提高頻譜效率並減少干擾。<br />
</p>

<p>
OFDM 的主要特性<br />
</p>
<ul class="org-ul">
<li>使用多個載波並行傳輸數據<br />
<ul class="org-ul">
<li>相較於單一載波技術（如 AM、FM），OFDM 將數據分割成小部分，並同時在多個子載波上傳輸。<br /></li>
</ul></li>
<li>子載波之間互不干擾<br />
<ul class="org-ul">
<li>透過正交性（Orthogonality），OFDM 確保每個子載波的頻譜能夠最大化利用而不產生干擾。<br /></li>
</ul></li>
<li>有效對抗多重路徑衰減（Multipath Fading）<br />
<ul class="org-ul">
<li>在無線網路環境中，信號可能因反射、折射等因素導致衰減，OFDM 可以有效降低這種影響。<br /></li>
</ul></li>
<li>高頻譜效率<br />
<ul class="org-ul">
<li>OFDM 透過正交技術使得載波之間的間隔極小，因此能夠更有效地利用頻譜資源。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orge4e5368"></a>2. OFDM 的應用<br />
<div class="outline-text-6" id="text-orge4e5368">
<p>
OFDM 是現代無線通訊技術的核心，廣泛應用於：<br />
</p>
<ul class="org-ul">
<li>Wi-Fi 標準（802.11a/g/n/ac/ax）<br /></li>
<li>第四代（4G LTE）與第五代（5G）行動通訊<br /></li>
<li>數位電視廣播（DVB-T, Digital Video Broadcasting - Terrestrial）<br /></li>
<li>數位音訊廣播（DAB, Digital Audio Broadcasting）<br /></li>
</ul>
</div>
</li>
<li><a id="org91fd225"></a>3. 其他選項分析<br />
<div class="outline-text-6" id="text-org91fd225">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. 頻率跳躍擴頻（FHSS, Frequency-Hopping Spread Spectrum）</td>
<td class="org-left">❌</td>
<td class="org-left">FHSS 透過頻率隨機跳躍傳輸數據，但不會並行傳輸多個載波頻率。</td>
</tr>

<tr>
<td class="org-left">b. 直接序列擴頻（DSSS, Direct Sequence Spread Spectrum）</td>
<td class="org-left">❌</td>
<td class="org-left">DSSS 透過擴頻碼將數據擴散到更寬的頻譜，但並非將數據分割到多個子載波並行傳輸。</td>
</tr>

<tr>
<td class="org-left">c. 服務集識別碼（SSID, Service Set Identifier）</td>
<td class="org-left">❌</td>
<td class="org-left">SSID 只是 Wi-Fi 網路的識別名稱，與頻譜利用技術無關。</td>
</tr>

<tr>
<td class="org-left">d. 正交分頻多工（OFDM, Orthogonal Frequency-Division Multiplexing）</td>
<td class="org-left">✅</td>
<td class="org-left">OFDM 使用多個載波並行傳輸數據，確保載波間無干擾，最符合題意。</td>
</tr>

<tr>
<td class="org-left">e. 載波侦測多重存取 / 碰撞避免（CSMA/CA, Carrier Sense Multiple Access with Collision Avoidance）</td>
<td class="org-left">❌</td>
<td class="org-left">CSMA/CA 是 Wi-Fi 的媒體存取控制機制，與無線頻譜技術無關。</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org7f70c71" class="outline-5">
<h5 id="org7f70c71">4. 與 OFDM 相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-org7f70c71">
</div>
<ul class="org-ul">
<li><a id="org71e61a8"></a>(1) 無線通訊技術<br />
<div class="outline-text-6" id="text-org71e61a8">
<p>
✅ 無線區域網路（Wireless Local Area Network, WLAN）<br />
</p>
<ul class="org-ul">
<li>IEEE 802.11 標準<br /></li>
<li>Wi-Fi 6（802.11ax）使用 OFDMA（OFDM 的進階版）<br /></li>
</ul>
<p>
✅ 行動通訊技術<br />
</p>
<ul class="org-ul">
<li>4G LTE、5G NR 皆採用 OFDM 作為基礎調變技術<br /></li>
<li>OFDM 的優勢：抗干擾、頻譜利用率高、可適應多重路徑環境<br /></li>
</ul>
</div>
</li>
<li><a id="org0eade1a"></a>(2) 數位訊號處理（DSP, Digital Signal Processing）<br />
<div class="outline-text-6" id="text-org0eade1a">
<p>
✅ 調變技術（Modulation Techniques）<br />
</p>
<ul class="org-ul">
<li>單載波調變（Single Carrier Modulation）<br /></li>
<li>多載波調變（Multicarrier Modulation, 如 OFDM）<br /></li>
</ul>
<p>
✅ 訊號正交性（Orthogonality）<br />
</p>
<ul class="org-ul">
<li>確保不同載波之間互不干擾<br /></li>
<li>透過傅立葉變換（FFT）進行訊號分解與合成<br /></li>
</ul>
</div>
</li>
<li><a id="orga176f95"></a>(3) 網路傳輸與媒體存取控制<br />
<div class="outline-text-6" id="text-orga176f95">
<p>
✅ Wi-Fi 的存取控制技術<br />
</p>
<ul class="org-ul">
<li>CSMA/CA（802.11 無線網路使用）<br /></li>
<li>RTS/CTS（避免隱藏節點問題）<br /></li>
</ul>
<p>
✅ 頻譜利用技術<br />
</p>
<ul class="org-ul">
<li>OFDM（802.11a/g/n/ac/ax 採用）<br /></li>
<li>DSSS（802.11b 採用）<br /></li>
<li>FHS- （早期藍牙技術使用）<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgca857b8" class="outline-4">
<h4 id="orgca857b8"><span class="section-number-4">7.2.8.</span> (7)</h4>
<div class="outline-text-4" id="text-7-2-8">
<p>
<span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> is an effective data storage structure when every record in the table has to be retrieved (in any order) every time the table is accessed.<br />
</p>
<ol class="org-ol">
<li>Heap<br /></li>
<li>Bitset<br /></li>
<li>Array<br /></li>
<li>B+-Tree.<br /></li>
</ol>
</div>
<div id="outline-container-orgc0e4619" class="outline-5">
<h5 id="orgc0e4619">解:</h5>
<div class="outline-text-5" id="text-orgc0e4619">
<p>
當每次存取表格時都需要檢索所有記錄（無序檢索）時，最有效的數據存儲結構是？<br />
</p>

<p>
✅ 正確答案：a. Heap（堆儲存結構）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9a48d92"></a>1. 堆儲存結構（Heap Storage Structure）的定義<br />
<div class="outline-text-6" id="text-org9a48d92">
<p>
在資料庫系統與數據結構中，Heap（堆） 是一種無序存儲的結構，適用於每次存取表格時都要檢索所有記錄的情境。它的特點是：<br />
</p>
<ul class="org-ul">
<li>資料無特定排序：<br />
<ul class="org-ul">
<li>記錄按照插入的順序存儲在磁碟或記憶體中。<br /></li>
<li>沒有索引（Index），沒有鍵值排序，所有資料都以隨機順序存儲。<br /></li>
</ul></li>
<li>適用於全表掃描（Full Table Scan）：<br />
<ul class="org-ul">
<li>由於資料沒有特定排序，因此當查詢需要檢索所有記錄時，Heap 結構能夠高效運行。<br /></li>
<li>例如：SELECT * FROM table 這類查詢。<br /></li>
</ul></li>
<li>插入與刪除操作快速：<br />
<ul class="org-ul">
<li>由於無需維護索引結構，Heap 適合頻繁進行新增（Insert）與刪除（Delete） 的應用場景。<br /></li>
<li>但不適合需要快速查找特定記錄的情境。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org09147bb"></a>2. 其他選項分析<br />
<div class="outline-text-6" id="text-org09147bb">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Heap（堆儲存結構）</td>
<td class="org-left">✅</td>
<td class="org-left">適用於全表掃描，記錄無序存儲，適合每次存取時檢索所有記錄的情境。</td>
</tr>

<tr>
<td class="org-left">b. Bitset（位元集合）</td>
<td class="org-left">❌</td>
<td class="org-left">Bitset 是一種用來存儲位元的結構，主要用於高效標記與布林操作，與整個表的檢索無關。</td>
</tr>

<tr>
<td class="org-left">c. Array（陣列）</td>
<td class="org-left">❌</td>
<td class="org-left">陣列通常適用於有序存儲，並且需要基於索引進行快速檢索，而非全表掃描。</td>
</tr>

<tr>
<td class="org-left">d. B+-Tree（B+ 樹）</td>
<td class="org-left">❌</td>
<td class="org-left">B+ 樹是索引結構，適用於範圍查詢與快速搜尋特定記錄，但不是最適合全表掃描的結構。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org85abadf"></a>3. Heap 儲存結構的應用場景<br />
<div class="outline-text-6" id="text-org85abadf">
<ul class="org-ul">
<li>數據倉儲與大數據分析<br />
<ul class="org-ul">
<li>當需要對大量數據進行完整掃描（如大規模報表生成）。<br /></li>
<li>例如 SELECT COUNT(*) FROM table。<br /></li>
</ul></li>
<li>記錄頻繁變動的表<br />
<ul class="org-ul">
<li>由於 Heap 不維護索引結構，因此對於經常插入與刪除數據的表來說，Heap 具有較好的性能。<br /></li>
</ul></li>
<li>緩衝區管理<br />
<ul class="org-ul">
<li>許多數據庫系統（如 PostgreSQL、MySQL）使用 Heap 作為緩衝區的底層存儲方式。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org30f7db0" class="outline-5">
<h5 id="org30f7db0">4. 與 Heap 儲存相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-org30f7db0">
</div>
<ul class="org-ul">
<li><a id="org65f9bdd"></a>(1) 資料結構（Data Structures）<br />
<div class="outline-text-6" id="text-org65f9bdd">
<p>
✅ 基本存儲結構<br />
</p>
<ul class="org-ul">
<li>Heap（堆）：適用於全表掃描、無序存儲。<br /></li>
<li>Array（陣列）：適合有序數據存儲，支援索引存取。<br /></li>
<li>Linked List（鏈結串列）：適合頻繁插入刪除的數據結構。<br /></li>
</ul>
<p>
✅ 索引結構<br />
</p>
<ul class="org-ul">
<li>B-Tree &amp; B+ Tree：適用於範圍查詢與快速檢索。<br /></li>
<li>Hash Index：適合唯一鍵查找，但不適用於範圍查詢。<br /></li>
</ul>
</div>
</li>
<li><a id="org68e0653"></a>(2) 資料庫管理系統（DBMS）<br />
<div class="outline-text-6" id="text-org68e0653">
<p>
✅ 儲存引擎<br />
</p>
<ul class="org-ul">
<li>MySQL InnoDB：使用 B+ Tree 來儲存索引數據。<br /></li>
<li>MySQL MEMORY：使用 Heap 結構來存放表資料於記憶體中。<br /></li>
<li>PostgreSQL：Heap 是其主要的表存儲結構。<br /></li>
</ul>
<p>
✅ 查詢最佳化<br />
</p>
<ul class="org-ul">
<li>全表掃描（Full Table Scan）：適用於 Heap 存儲結構，特別是在沒有索引的情況下。<br /></li>
<li>索引查詢（Index Scan）：適用於 B+ Tree 索引，適合條件查詢。<br /></li>
</ul>
</div>
</li>
<li><a id="org0b03900"></a>(3) 作業系統與記憶體管理<br />
<div class="outline-text-6" id="text-org0b03900">
<p>
✅ Heap vs. Stack<br />
</p>
<ul class="org-ul">
<li>Heap（堆）：用於動態記憶體配置，不保證數據順序。<br /></li>
<li>Stack（堆疊）：用於函式呼叫管理，具有後進先出（LIFO）特性。<br /></li>
</ul>
<p>
✅ 記憶體分配<br />
</p>
<ul class="org-ul">
<li>動態記憶體管理（Dynamic Memory Management）：Heap 允許變長記錄存儲，但可能會有碎片化問題。<br /></li>
<li>垃圾回收（Garbage Collection）：在 Java、Python 等語言中，Heap 是動態分配的記憶體區域，並由垃圾回收機制管理。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org53c50d0" class="outline-4">
<h4 id="org53c50d0"><span class="section-number-4">7.2.9.</span> A-2. Programming and modeling questions:</h4>
</div>
<div id="outline-container-org72a024a" class="outline-4">
<h4 id="org72a024a"><span class="section-number-4">7.2.10.</span> (1)</h4>
<div class="outline-text-4" id="text-7-2-10">
<p>
Explain what an &ldquo;association class&rdquo; is for and give an example using the format of a class diagram based on the Unified Modeling Language (UML) convention. (8%)<br />
</p>
</div>
<div id="outline-container-org4468ce6" class="outline-5">
<h5 id="org4468ce6">解</h5>
<div class="outline-text-5" id="text-org4468ce6">
</div>
<ul class="org-ul">
<li><a id="org7d65349"></a>1. 什麼是關聯類別（Association Class）？<br />
<div class="outline-text-6" id="text-org7d65349">
<p>
在 UML（統一建模語言） 中，關聯類別（Association Class） 是一種特殊的類別，它同時具有：<br />
</p>
<ul class="org-ul">
<li>關聯（Association）的特性 → 描述兩個類別之間的關係。<br /></li>
<li>類別（Class）的特性 → 可包含屬性（Attributes）與行為（Methods）。<br /></li>
</ul>
<p>
關聯類別主要用於：<br />
</p>
<ul class="org-ul">
<li>當 關聯本身有額外的屬性 需要記錄時，例如關聯的時間、角色、額外資訊等。<br /></li>
<li>更清晰地表示 關聯關係的資訊，避免將過多的資訊放入關聯的類別中，導致不必要的複雜性。<br /></li>
</ul>
</div>
</li>
<li><a id="org3a8c78e"></a>2. UML 關聯類別的表示方式<br />
<div class="outline-text-6" id="text-org3a8c78e">
<p>
在 UML 類別圖（Class Diagram） 中，關聯類別通常位於兩個關聯類別的關聯線上方，並使用虛線連接到關聯線。<br />
</p>
</div>
</li>
<li><a id="org51f7235"></a>3. UML 類別圖範例<br />
<div class="outline-text-6" id="text-org51f7235">
<p>
範例場景：學生（Student）選修課程（Course）<br />
</p>
<ul class="org-ul">
<li>一個學生可以選修多門課程，一門課程也可以被多個學生選修（多對多關係）。<br /></li>
<li>選課資訊（Enrollment） 是關聯的屬性，例如：註冊日期（registrationDate）、成績（grade）。<br /></li>
</ul>

<p>
UML 類別圖（包含關聯類別）<br />
</p>
<pre class="example" id="orga5afbab">
+------------+           +--------------+           +-------------+
|  Student   |           |  Enrollment  |           |   Course    |
|------------|           |--------------|           |-------------|
| -id        |           | -registrationDate : Date| | -code       |
| -name      |           | -grade : String         | | -title      |
+------------+           +--------------+           +-------------+
        |                     ||                         |
        |---------------------|||-------------------------|
              &lt;&lt;Association Class&gt;&gt; Enrollment
</pre>
<p>
📌 說明：<br />
</p>
<ul class="org-ul">
<li>Student 和 Course 之間的 &ldquo;選課&rdquo;（Enrollment） 是一個多對多（M:N）關係。<br /></li>
<li>Enrollment 是一個 關聯類別（Association Class），它記錄了關聯的屬性：<br />
<ul class="org-ul">
<li>registrationDate（註冊日期）<br /></li>
<li>grade（成績）<br /></li>
</ul></li>
<li>UML 表示方式： Enrollment 類別與 &ldquo;學生-課程&rdquo; 的關聯線透過 虛線 連接，表示它是一個關聯類別。<br /></li>
</ul>
</div>
</li>
<li><a id="org05d189f"></a>4. 其他關聯類別的應用場景<br />
<div class="outline-text-6" id="text-org05d189f">
<p>
關聯類別適用於以下情境：<br />
</p>
<ul class="org-ul">
<li>員工參與專案<br />
<ul class="org-ul">
<li>Employee ←→ Project，Participation（參與記錄）作為關聯類別，包含員工在專案中的「角色」與「工作時數」。<br /></li>
</ul></li>
<li>醫生與病人預約<br />
<ul class="org-ul">
<li>Doctor ←→ Patient，Appointment（預約）作為關聯類別，包含「預約時間」、「診療室號碼」等資訊。<br /></li>
</ul></li>
<li>圖書借閱<br />
<ul class="org-ul">
<li>LibraryMember ←→ Book，Loan（借閱資訊）作為關聯類別，包含「借書日期」、「歸還日期」。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org60d25b2"></a>❖ 何時使用關聯類別？<br />
<div class="outline-text-6" id="text-org60d25b2">
<ul class="org-ul">
<li>當關聯本身需要額外屬性（如「選課的成績」、「預約的時間」）。<br /></li>
<li>適用於多對多（M:N）關係，用來降低類別的耦合度。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf0a58be" class="outline-5">
<h5 id="orgf0a58be">與關聯類別相關的計算機概論知識</h5>
<div class="outline-text-5" id="text-orgf0a58be">
</div>
<ul class="org-ul">
<li><a id="orge8b8bac"></a>(1) 物件導向設計（OOD, Object-Oriented Design）<br />
<div class="outline-text-6" id="text-orge8b8bac">
<p>
✅ UML 類別圖（Class Diagram）<br />
</p>
<ul class="org-ul">
<li>類別與屬性<br /></li>
<li>關聯（Association）、聚合（Aggregation）、組合（Composition）<br /></li>
<li>繼承（Inheritance）<br /></li>
</ul>
<p>
✅ 關聯類別的用途<br />
</p>
<ul class="org-ul">
<li>適用於多對多（M:N）關係<br /></li>
<li>當關聯本身需要存放額外資訊時使用<br /></li>
</ul>
</div>
</li>
<li><a id="org9a8862f"></a>(2) 資料庫設計<br />
<div class="outline-text-6" id="text-org9a8862f">
<p>
✅ 關聯資料庫（Relational Database）<br />
</p>
<ul class="org-ul">
<li>關聯類別對應 關聯表（Join Table）<br /></li>
<li>多對多（M:N）關係通常需要額外的橋接表<br /></li>
</ul>
<p>
✅ ER 圖（Entity-Relationship Diagram）<br />
</p>
<ul class="org-ul">
<li>關聯類別類似於「關聯實體」<br /></li>
<li>例如：Enrollment（選課資訊）對應關聯表<br /></li>
</ul>
</div>
</li>
<li><a id="org99622e2"></a>(3) 軟體工程與設計模式<br />
<div class="outline-text-6" id="text-org99622e2">
<p>
✅ UML 在軟體開發中的應用<br />
</p>
<ul class="org-ul">
<li>用於需求分析與系統建模<br /></li>
<li>幫助開發人員設計清晰的類別結構<br /></li>
</ul>
<p>
✅ 物件導向分析與設計（OOAD）<br />
</p>
<ul class="org-ul">
<li>關聯類別幫助拆分責任，降低耦合度<br /></li>
<li>可與 MVC 設計模式（Model-View-Controller） 結合使用<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org92a05fd" class="outline-4">
<h4 id="org92a05fd"><span class="section-number-4">7.2.11.</span> (2)</h4>
<div class="outline-text-4" id="text-7-2-11">
<p>
Write a method (using pseudo code or any programming language that you want) along with the SQL queries needed that allows us to retrieve the information (including movieId, movieTitle, yearReleased, studio, and producer) of all the videos that are directed by a particular director (e.g., Christopher Nolan) and present all the information retrieved to the screen. We can assume that the database connectivity has been established. Additionally, three tables, including Video (including movieId, movieTitle, yearReleased, directorID, studioID, and producerID), Studio (including studioID and studioName), Producer (including producerID, producerFirstName, and producerLastName), and Director (including directorID, directorFirstName, and directorLastName), are used to store all those pieces of information of the videos in the relational database. Create and use the table attributes that are not listed in the questions if you find it necessary. (12%)<br />
</p>
</div>
<div id="outline-container-org59df4f7" class="outline-5">
<h5 id="org59df4f7">解</h5>
<div class="outline-text-5" id="text-org59df4f7">
</div>
<ul class="org-ul">
<li><a id="org2e9d298"></a>1. 解題分析<br />
<div class="outline-text-6" id="text-org2e9d298">
<p>
本題要求撰寫一個方法（可使用偽代碼或任何程式語言）來查詢 特定導演（如 Christopher Nolan）所執導的所有電影資訊，並將結果顯示在螢幕上。<br />
</p>
</div>
</li>
<li><a id="orgff6dd53"></a>2. 關鍵 SQL 查詢<br />
<div class="outline-text-6" id="text-orgff6dd53">
<p>
資料庫表格結構<br />
</p>

<p>
根據題目提供的表格，我們定義以下 4 個關聯資料表：<br />
</p>
<ol class="org-ol">
<li>Video（影片）<br />
<ul class="org-ul">
<li>movieId（主鍵）<br /></li>
<li>movieTitle<br /></li>
<li>yearReleased<br /></li>
<li>directorID（外鍵，參照 Director.directorID）<br /></li>
<li>studioID（外鍵，參照 Studio.studioID）<br /></li>
<li>producerID（外鍵，參照 Producer.producerID）<br /></li>
</ul></li>
<li>Director（導演）<br />
<ul class="org-ul">
<li>directorID（主鍵）<br /></li>
<li>directorFirstName<br /></li>
<li>directorLastName<br /></li>
</ul></li>
<li>Studio（電影公司）<br />
<ul class="org-ul">
<li>studioID（主鍵）<br /></li>
<li>studioName<br /></li>
</ul></li>
<li>Producer（製作人）<br />
<ul class="org-ul">
<li>producerID（主鍵）<br /></li>
<li>producerFirstName<br /></li>
<li>producerLastName<br /></li>
</ul></li>
<li>SQL 查詢<br /></li>
</ol>
<p>
SQL 查詢語句<br />
</p>
<div class="org-src-container">
<pre class="src src-sql"><span class="linenr"> 1: </span><span style="color: #51afef;">SELECT</span>
<span class="linenr"> 2: </span>    v.movieId,
<span class="linenr"> 3: </span>    v.movieTitle,
<span class="linenr"> 4: </span>    v.yearReleased,
<span class="linenr"> 5: </span>    s.studioName <span style="color: #51afef;">AS</span> studio,
<span class="linenr"> 6: </span>    CONCAT(p.producerFirstName, <span style="color: #98be65;">' '</span>, p.producerLastName) <span style="color: #51afef;">AS</span> producer
<span class="linenr"> 7: </span><span style="color: #51afef;">FROM</span> Video v
<span class="linenr"> 8: </span><span style="color: #51afef;">JOIN</span> Director d <span style="color: #51afef;">ON</span> v.directorID = d.directorID
<span class="linenr"> 9: </span><span style="color: #51afef;">JOIN</span> Studio s <span style="color: #51afef;">ON</span> v.studioID = s.studioID
<span class="linenr">10: </span><span style="color: #51afef;">JOIN</span> Producer p <span style="color: #51afef;">ON</span> v.producerID = p.producerID
<span class="linenr">11: </span><span style="color: #51afef;">WHERE</span> d.directorFirstName = <span style="color: #98be65;">'Christopher'</span> <span style="color: #51afef;">AND</span> d.directorLastName = <span style="color: #98be65;">'Nolan'</span>;
</pre>
</div>
<p>
📌 SQL 查詢解釋<br />
</p>
<ul class="org-ul">
<li>透過 JOIN 連結 Video、Director、Studio 和 Producer 表格。<br /></li>
<li>WHERE 條件 過濾出 Christopher Nolan 執導的影片。<br /></li>
<li>CONCAT(p.producerFirstName, &rsquo; &rsquo;, p.producerLastName) 合併製作人的姓與名。<br /></li>
</ul>
</div>
</li>
<li><a id="orgeedc602"></a>4. Python 方法實作<br />
<div class="outline-text-6" id="text-orgeedc602">
<p>
假設已經建立資料庫連線 conn，我們使用 Python 與 sqlite3（或其他 SQL 資料庫驅動）來執行查詢：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">import</span> sqlite3
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">get_movies_by_director</span>(director_firstname, director_lastname):
<span class="linenr"> 4: </span>    <span style="color: #51afef;">try</span>:
<span class="linenr"> 5: </span>        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#20551;&#35373;&#24050;&#32147;&#26377;&#36039;&#26009;&#24235;&#36899;&#32218; conn</span>
<span class="linenr"> 6: </span>        <span style="color: #dcaeea;">conn</span> = sqlite3.connect(<span style="color: #98be65;">'movies.db'</span>)
<span class="linenr"> 7: </span>        <span style="color: #dcaeea;">cursor</span> = conn.cursor()
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">SQL &#26597;&#35426;</span>
<span class="linenr">10: </span>        <span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"""</span>
<span class="linenr">11: </span><span style="color: #98be65;">        SELECT</span>
<span class="linenr">12: </span><span style="color: #98be65;">            v.movieId,</span>
<span class="linenr">13: </span><span style="color: #98be65;">            v.movieTitle,</span>
<span class="linenr">14: </span><span style="color: #98be65;">            v.yearReleased,</span>
<span class="linenr">15: </span><span style="color: #98be65;">            s.studioName AS studio,</span>
<span class="linenr">16: </span><span style="color: #98be65;">            p.producerFirstName || ' ' || p.producerLastName AS producer</span>
<span class="linenr">17: </span><span style="color: #98be65;">        FROM Video v</span>
<span class="linenr">18: </span><span style="color: #98be65;">        JOIN Director d ON v.directorID = d.directorID</span>
<span class="linenr">19: </span><span style="color: #98be65;">        JOIN Studio s ON v.studioID = s.studioID</span>
<span class="linenr">20: </span><span style="color: #98be65;">        JOIN Producer p ON v.producerID = p.producerID</span>
<span class="linenr">21: </span><span style="color: #98be65;">        WHERE d.directorFirstName = ? AND d.directorLastName = ?;</span>
<span class="linenr">22: </span><span style="color: #98be65;">        """</span>
<span class="linenr">23: </span>
<span class="linenr">24: </span>        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#22519;&#34892;&#26597;&#35426;</span>
<span class="linenr">25: </span>        cursor.execute(query, (director_firstname, director_lastname))
<span class="linenr">26: </span>        <span style="color: #dcaeea;">results</span> = cursor.fetchall()
<span class="linenr">27: </span>
<span class="linenr">28: </span>        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#39023;&#31034;&#26597;&#35426;&#32080;&#26524;</span>
<span class="linenr">29: </span>        <span style="color: #c678dd;">print</span>(f<span style="color: #98be65;">"Movies directed by </span>{director_firstname}<span style="color: #98be65;"> </span>{director_lastname}<span style="color: #98be65;">:"</span>)
<span class="linenr">30: </span>        <span style="color: #c678dd;">print</span>(<span style="color: #98be65;">"-"</span> * <span style="color: #da8548; font-weight: bold;">80</span>)
<span class="linenr">31: </span>        <span style="color: #c678dd;">print</span>(f<span style="color: #98be65;">"</span>{'ID':&lt;5}<span style="color: #98be65;"> </span>{'Title':&lt;30}<span style="color: #98be65;"> </span>{'Year':&lt;6}<span style="color: #98be65;"> </span>{'Studio':&lt;20}<span style="color: #98be65;"> </span>{'Producer':&lt;20}<span style="color: #98be65;">"</span>)
<span class="linenr">32: </span>        <span style="color: #c678dd;">print</span>(<span style="color: #98be65;">"-"</span> * <span style="color: #da8548; font-weight: bold;">80</span>)
<span class="linenr">33: </span>        <span style="color: #51afef;">for</span> row <span style="color: #51afef;">in</span> results:
<span class="linenr">34: </span>            <span style="color: #c678dd;">print</span>(f<span style="color: #98be65;">"</span>{row[0]:&lt;5}<span style="color: #98be65;"> </span>{row[1]:&lt;30}<span style="color: #98be65;"> </span>{row[2]:&lt;6}<span style="color: #98be65;"> </span>{row[3]:&lt;20}<span style="color: #98be65;"> </span>{row[4]:&lt;20}<span style="color: #98be65;">"</span>)
<span class="linenr">35: </span>
<span class="linenr">36: </span>        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#38364;&#38281;&#36899;&#32218;</span>
<span class="linenr">37: </span>        cursor.close()
<span class="linenr">38: </span>        conn.close()
<span class="linenr">39: </span>
<span class="linenr">40: </span>    <span style="color: #51afef;">except</span> <span style="color: #ECBE7B;">Exception</span> <span style="color: #51afef;">as</span> e:
<span class="linenr">41: </span>        <span style="color: #c678dd;">print</span>(<span style="color: #98be65;">"Error:"</span>, e)
<span class="linenr">42: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#28204;&#35430;&#20989;&#24335;</span>
<span class="linenr">43: </span>get_movies_by_director(<span style="color: #98be65;">"Christopher"</span>, <span style="color: #98be65;">"Nolan"</span>)
</pre>
</div>
</div>
</li>
<li><a id="orgce737b2"></a>5. 相關計算機概論知識<br />
<ul class="org-ul">
<li><a id="orgad090b4"></a>(1) 資料庫管理與 SQL<br />
<div class="outline-text-7" id="text-orgad090b4">
<p>
✅ SQL 基礎<br />
</p>
<ul class="org-ul">
<li>SELECT、JOIN、WHERE 條件查詢<br /></li>
<li>CONCAT 用於字串合併（或 || 在 SQLite）<br /></li>
</ul>
<p>
✅ 關聯式資料庫（Relational Database）<br />
</p>
<ul class="org-ul">
<li>表格的正規化（Normalization）<br /></li>
<li>外鍵（Foreign Key）關聯<br /></li>
<li>多表聯結查詢（Multi-Table Join）<br /></li>
</ul>
<p>
✅ 索引與效能最佳化<br />
</p>
<ul class="org-ul">
<li>若 Director.directorLastName 常用於查詢，應該加上索引 INDEX(directorLastName)<br /></li>
</ul>
</div>
</li>
<li><a id="org06e993c"></a>(2) 物件導向設計（OOD, Object-Oriented Design）<br />
<div class="outline-text-7" id="text-org06e993c">
<p>
✅ Python 與資料庫連線<br />
</p>
<ul class="org-ul">
<li>sqlite3（適用 SQLite）<br /></li>
<li>MySQL Connector（適用 MySQL）<br /></li>
<li>psycopg2（適用 PostgreSQL）<br /></li>
</ul>
<p>
✅ MVC 設計模式<br />
</p>
<ul class="org-ul">
<li>Model（數據層）：資料庫查詢<br /></li>
<li>View（視圖層）：顯示電影資訊<br /></li>
<li>Controller（控制器）：處理使用者輸入（例如導演姓名）<br /></li>
</ul>
</div>
</li>
<li><a id="orgfc19446"></a>(3) 軟體工程<br />
<div class="outline-text-7" id="text-orgfc19446">
<p>
✅ 模組化程式設計<br />
</p>
<ul class="org-ul">
<li>將 SQL 查詢封裝在獨立函式中<br /></li>
<li>使用 例外處理（Exception Handling） 來管理錯誤<br /></li>
</ul>
<p>
✅ 安全性考量<br />
</p>
<ul class="org-ul">
<li>使用 參數化查詢（Parameterized Query） 避免 SQL 注入攻擊（SQL Injection）<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgc7b609e"></a>6. 總結<br />
<div class="outline-text-6" id="text-orgc7b609e">
<p>
❖ 主要 SQL 查詢<br />
</p>
<div class="org-src-container">
<pre class="src src-sql"><span class="linenr"> 1: </span><span style="color: #51afef;">SELECT</span>
<span class="linenr"> 2: </span>    v.movieId,
<span class="linenr"> 3: </span>    v.movieTitle,
<span class="linenr"> 4: </span>    v.yearReleased,
<span class="linenr"> 5: </span>    s.studioName <span style="color: #51afef;">AS</span> studio,
<span class="linenr"> 6: </span>    CONCAT(p.producerFirstName, <span style="color: #98be65;">' '</span>, p.producerLastName) <span style="color: #51afef;">AS</span> producer
<span class="linenr"> 7: </span><span style="color: #51afef;">FROM</span> Video v
<span class="linenr"> 8: </span><span style="color: #51afef;">JOIN</span> Director d <span style="color: #51afef;">ON</span> v.directorID = d.directorID
<span class="linenr"> 9: </span><span style="color: #51afef;">JOIN</span> Studio s <span style="color: #51afef;">ON</span> v.studioID = s.studioID
<span class="linenr">10: </span><span style="color: #51afef;">JOIN</span> Producer p <span style="color: #51afef;">ON</span> v.producerID = p.producerID
<span class="linenr">11: </span><span style="color: #51afef;">WHERE</span> d.directorFirstName = <span style="color: #98be65;">'Christopher'</span> <span style="color: #51afef;">AND</span> d.directorLastName = <span style="color: #98be65;">'Nolan'</span>;
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org151385a" class="outline-4">
<h4 id="org151385a"><span class="section-number-4">7.2.12.</span> (3)</h4>
<div class="outline-text-4" id="text-7-2-12">
<p>
Please write a method (using pseudo code or any programming language that you want) that performs the task of &ldquo;binary search&rdquo; using a &ldquo;recursive&rdquo; approach. (5%)<br />
</p>
</div>
<div id="outline-container-org7eaa252" class="outline-5">
<h5 id="org7eaa252">解</h5>
<div class="outline-text-5" id="text-org7eaa252">
</div>
<ul class="org-ul">
<li><a id="orgb24275e"></a>1. 二分搜尋（Binary Search）遞迴實作<br />
<div class="outline-text-6" id="text-orgb24275e">
<p>
二分搜尋（Binary Search）是一種高效的搜尋演算法，適用於已排序的陣列。其時間複雜度為 O(log n)，比線性搜尋（O(n)）更快。<br />
</p>

<p>
✅ 二分搜尋的核心概念<br />
</p>
<ul class="org-ul">
<li>確定搜尋範圍：<br />
<ul class="org-ul">
<li>令 low 為陣列起始索引，high 為陣列結束索引。<br /></li>
</ul></li>
<li>計算中間索引（mid）：<br />
<ul class="org-ul">
<li>mid = (low + high) // 2<br /></li>
</ul></li>
<li>比較 arr[mid] 與目標值（target）：<br />
<ul class="org-ul">
<li>若 arr[mid] == target，回傳 mid（找到元素）。<br /></li>
<li>若 arr[mid] &gt; target，搜尋左半部（low 不變，high = mid - 1）。<br /></li>
<li>若 arr[mid] &lt; target，搜尋右半部（low = mid + 1，high 不變）。<br /></li>
</ul></li>
<li>重複遞迴，直到 low &gt; high（表示元素不存在）。<br /></li>
</ul>
</div>
</li>
<li><a id="org7ad58bc"></a>2. 遞迴方式的二分搜尋（Python 實作）<br />
<div class="outline-text-6" id="text-org7ad58bc">
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">binary_search_recursive</span>(arr, low, high, target):
<span class="linenr"> 2: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#22522;&#26412;&#24773;&#27841;&#65306;&#22914;&#26524; low &gt; high&#65292;&#34920;&#31034;&#25214;&#19981;&#21040;&#30446;&#27161;&#20540;</span>
<span class="linenr"> 3: </span>    <span style="color: #51afef;">if</span> low &gt; high:
<span class="linenr"> 4: </span>        <span style="color: #51afef;">return</span> -<span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#35336;&#31639;&#20013;&#38291;&#32034;&#24341;</span>
<span class="linenr"> 7: </span>    <span style="color: #dcaeea;">mid</span> = (low + high) // <span style="color: #da8548; font-weight: bold;">2</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#22914;&#26524;&#25214;&#21040;&#30446;&#27161;&#20540;&#65292;&#22238;&#20659;&#32034;&#24341;</span>
<span class="linenr">10: </span>    <span style="color: #51afef;">if</span> arr[mid] == target:
<span class="linenr">11: </span>        <span style="color: #51afef;">return</span> mid
<span class="linenr">12: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#22914;&#26524;&#30446;&#27161;&#20540;&#23567;&#26044;&#20013;&#38291;&#20540;&#65292;&#25628;&#23563;&#24038;&#21322;&#37096;</span>
<span class="linenr">13: </span>    <span style="color: #51afef;">elif</span> arr[mid] &gt; target:
<span class="linenr">14: </span>        <span style="color: #51afef;">return</span> binary_search_recursive(arr, low, mid - <span style="color: #da8548; font-weight: bold;">1</span>, target)
<span class="linenr">15: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#22914;&#26524;&#30446;&#27161;&#20540;&#22823;&#26044;&#20013;&#38291;&#20540;&#65292;&#25628;&#23563;&#21491;&#21322;&#37096;</span>
<span class="linenr">16: </span>    <span style="color: #51afef;">else</span>:
<span class="linenr">17: </span>        <span style="color: #51afef;">return</span> binary_search_recursive(arr, mid + <span style="color: #da8548; font-weight: bold;">1</span>, high, target)
<span class="linenr">18: </span>
<span class="linenr">19: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#28204;&#35430;&#20989;&#24335;</span>
<span class="linenr">20: </span><span style="color: #dcaeea;">arr</span> = [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">9</span>, <span style="color: #da8548; font-weight: bold;">11</span>, <span style="color: #da8548; font-weight: bold;">13</span>, <span style="color: #da8548; font-weight: bold;">15</span>]
<span class="linenr">21: </span><span style="color: #dcaeea;">target</span> = <span style="color: #da8548; font-weight: bold;">7</span>
<span class="linenr">22: </span><span style="color: #dcaeea;">result</span> = binary_search_recursive(arr, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #c678dd;">len</span>(arr) - <span style="color: #da8548; font-weight: bold;">1</span>, target)
<span class="linenr">23: </span><span style="color: #c678dd;">print</span>(f<span style="color: #98be65;">"Element </span>{target}<span style="color: #98be65;"> found at index </span>{result}<span style="color: #98be65;">"</span> <span style="color: #51afef;">if</span> result != -<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">"Element not found"</span>)
</pre>
</div>
<p>
📌 Python 實作說明<br />
</p>
<ul class="org-ul">
<li>函式 binary_search_recursive(arr, low, high, target)<br />
<ul class="org-ul">
<li>low 和 high 是搜尋範圍的索引。<br /></li>
<li>mid = (low + high) // 2 計算中間索引。<br /></li>
<li>若 arr[mid] 等於 target，回傳 mid。<br /></li>
<li>若 arr[mid] &gt; target，遞迴搜尋左半部。<br /></li>
<li>若 arr[mid] &lt; target，遞迴搜尋右半部。<br /></li>
<li>若 low &gt; high，回傳 -1（代表找不到）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org1dbdd46"></a>3. 偽代碼（Pseudocode）<br />
<div class="outline-text-6" id="text-org1dbdd46">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">FUNCTION</span> <span style="color: #c678dd;">BinarySearchRecursive</span>(arr, low, high, target):
<span class="linenr"> 2: </span>    IF low &gt; high:
<span class="linenr"> 3: </span>        RETURN -<span style="color: #da8548; font-weight: bold;">1</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25628;&#23563;&#32080;&#26463;&#65292;&#30446;&#27161;&#20540;&#19981;&#23384;&#22312;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    mid = (low + high) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">IF</span> <span style="color: #dcaeea;">arr</span>[mid] == target:
<span class="linenr"> 8: </span>        RETURN mid  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25214;&#21040;&#30446;&#27161;&#20540;&#65292;&#22238;&#20659;&#32034;&#24341;</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    ELSE IF arr[mid] &gt; target:
<span class="linenr">11: </span>        RETURN BinarySearchRecursive(arr, low, mid - <span style="color: #da8548; font-weight: bold;">1</span>, target)  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25628;&#23563;&#24038;&#21322;&#37096;</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>    ELSE:
<span class="linenr">14: </span>        RETURN BinarySearchRecursive(arr, mid + <span style="color: #da8548; font-weight: bold;">1</span>, high, target)  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25628;&#23563;&#21491;&#21322;&#37096;</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4c1bb73" class="outline-4">
<h4 id="org4c1bb73"><span class="section-number-4">7.2.13.</span> B-1 Multiple Choice Question: Indicate ONE answer choice that best completes the statement or answers the question. (3% for each question)</h4>
</div>
<div id="outline-container-org6ae0699" class="outline-4">
<h4 id="org6ae0699"><span class="section-number-4">7.2.14.</span> 1.</h4>
<div class="outline-text-4" id="text-7-2-14">
<p>
In a(n) <span class="underline"><span class="underline"><span class="underline">_</span></span></span> database, query data is collected from one or more shards of a distributed database, then processed by the database management system (DBMS) to create the query response.<br />
</p>
<ol class="org-ol">
<li>SQL<br /></li>
<li>NoSQL<br /></li>
<li>relational<br /></li>
<li>OLAP<br /></li>
<li>Cloud.<br /></li>
</ol>
</div>
<div id="outline-container-orgd821dcc" class="outline-5">
<h5 id="orgd821dcc">解</h5>
<div class="outline-text-5" id="text-orgd821dcc">
<ol class="org-ol">
<li>在 <span class="underline"><span class="underline"><span class="underline">_</span></span></span> 資料庫中，查詢數據來自於分散式資料庫的一個或多個分片（shards），然後由資料庫管理系統（DBMS）處理查詢並生成回應。<br /></li>
</ol>
<p>
✅ 正確答案：e. Cloud（雲端資料庫）<br />
</p>
<ol class="org-ol">
<li>解釋與分析<br />
在 雲端資料庫（Cloud Database） 中，數據通常分片（Sharding） 存儲在不同的分佈式節點上，以提供高可用性（High Availability） 和可擴展性（Scalability）。當執行查詢時，資料庫管理系統（DBMS）會：<br />
<ul class="org-ul">
<li>從多個分片（Shards）收集數據。<br /></li>
<li>合併與處理結果，生成最終的查詢回應。<br /></li>
</ul></li>
<li><p>
其他選項分析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. SQL</td>
<td class="org-left">❌</td>
<td class="org-left">SQL（結構化查詢語言） 是一種查詢語言，而不是資料庫類型，不適合作為答案。</td>
</tr>

<tr>
<td class="org-left">b. NoSQL</td>
<td class="org-left">❌</td>
<td class="org-left">NoSQL 資料庫（如 MongoDB、Cassandra） 雖然可以支援分片，但並非所有 NoSQL 都需要從多個分片收集數據，因此不完全符合題意。</td>
</tr>

<tr>
<td class="org-left">c. Relational（關聯式資料庫）</td>
<td class="org-left">❌</td>
<td class="org-left">傳統關聯式資料庫（如 MySQL、PostgreSQL） 通常是單一數據庫，而非分佈式存儲，無法直接從多個分片獲取數據。</td>
</tr>

<tr>
<td class="org-left">d. OLAP（線上分析處理）</td>
<td class="org-left">❌</td>
<td class="org-left">OLAP（Online Analytical Processing） 是一種分析技術，主要用於數據倉儲，但不一定涉及分片查詢。</td>
</tr>

<tr>
<td class="org-left">e. Cloud（雲端資料庫）</td>
<td class="org-left">✅</td>
<td class="org-left">雲端資料庫通常採用分片技術來儲存與處理數據，並能從多個分片收集查詢結果。</td>
</tr>
</tbody>
</table></li>
<li>與雲端資料庫相關的計算機概論知識<br />
<ul class="org-ul">
<li>(1) 分布式資料庫與分片技術<br />
<ul class="org-ul">
<li>✅ 分布式資料庫（Distributed Database）<br />
<ul class="org-ul">
<li>資料分片（Sharding）：將數據拆分儲存到不同節點，提高效能與擴展性。<br /></li>
<li>數據複製（Replication）：確保高可用性與容錯能力。<br /></li>
</ul></li>
<li>✅ 查詢處理（Query Processing）<br />
<ul class="org-ul">
<li>分片查詢（Sharded Query）：查詢數據時，系統會從多個節點收集數據並合併結果。<br /></li>
<li>分片鍵（Shard Key）：決定如何劃分數據，以平衡負載。<br /></li>
</ul></li>
<li>✅ 資料一致性（Data Consistency）<br />
<ul class="org-ul">
<li>強一致性（Strong Consistency）<br /></li>
<li>最終一致性（Eventual Consistency）<br /></li>
</ul></li>
</ul></li>
<li>(2) 雲端計算與資料庫技術<br />
<ul class="org-ul">
<li>✅ 雲端資料庫（Cloud Database）<br />
<ul class="org-ul">
<li>主要提供商：Amazon RDS、Google Cloud Spanner、Azure SQL Database<br /></li>
<li>支援 橫向擴展（Horizontal Scaling）<br /></li>
<li>透過 分片技術（Sharding） 優化大規模查詢。<br /></li>
</ul></li>
<li>✅ SQL vs. NoSQL 資料庫在雲端環境中的應用<br />
<ul class="org-ul">
<li>SQL 資料庫（如 MySQL、PostgreSQL）：支援雲端托管，適用於結構化數據。<br /></li>
<li>NoSQL 資料庫（如 MongoDB、Cassandra）：適用於大規模非結構化數據，常用於雲端應用。<br /></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org108b267" class="outline-4">
<h4 id="org108b267"><span class="section-number-4">7.2.15.</span> 2.</h4>
<div class="outline-text-4" id="text-7-2-15">
<p>
<span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> refers to an industry standard used to support the communication among equipment from several vendors and provide network flexibility.<br />
</p>
<ol class="org-ol">
<li>WAN<br /></li>
<li>LAN<br /></li>
<li>RAN<br /></li>
<li>ORAN<br /></li>
<li>WLAN<br /></li>
</ol>
</div>
<div id="outline-container-org92c44cd" class="outline-5">
<h5 id="org92c44cd">解</h5>
<div class="outline-text-5" id="text-org92c44cd">
<p>
問題：<br />
<span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> 指的是一種業界標準，用於支援來自不同供應商的設備之間的通訊，並提供網路靈活性。<br />
</p>

<p>
✅ 正確答案：d. ORAN（Open Radio Access Network，開放無線接取網路）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org373de81"></a>1. ORAN（開放無線接取網路）的定義<br />
<ul class="org-ul">
<li><a id="orgc2cca0e"></a>O-RAN（Open Radio Access Network） 是一種 開放式、標準化的無線接取網路架構，允許來自不同供應商（vendors）的設備能夠互相兼容並進行通訊。這項技術的核心目標是：<br />
<div class="outline-text-7" id="text-orgc2cca0e">
<ul class="org-ul">
<li>提升網路靈活性與可擴展性<br /></li>
<li>降低建置與維運成本<br /></li>
<li>避免單一供應商綁定（Vendor Lock-in）<br /></li>
<li>促進 5G 與未來網路的創新發展<br /></li>
</ul>
</div>
</li>
<li><a id="org957cfbd"></a>🔹 O-RAN 的技術特色<br />
<div class="outline-text-7" id="text-org957cfbd">
<ul class="org-ul">
<li>開放介面（Open Interfaces）：允許不同供應商的設備互通，改善供應鏈彈性。<br /></li>
<li>虛擬化（Virtualization）：透過軟體定義無線接取網路（Software-Defined RAN, SD-RAN），提高資源配置效率。<br /></li>
<li>雲端架構（Cloud-Based Architecture）：允許網路功能虛擬化（NFV），降低硬體依賴。<br /></li>
<li>AI/ML 自動化（AI/ML-driven Automation）：運用人工智慧優化網路運行。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org25ef247"></a>2. 其他選項分析<br />
<div class="outline-text-6" id="text-org25ef247">
<p>
選項	是否正確	原因<br />
</p>
<ol class="org-ol">
<li>WAN（廣域網路, Wide Area Network）	❌	WAN 是一種網路架構，而非特定的開放標準，主要用於連接不同地理區域的設備，如企業 VPN、ISP 基礎設施等。<br /></li>
<li>LAN（區域網路, Local Area Network）	❌	LAN 是指小範圍內的網路，如企業內部網路或家庭網路，並非用來實現供應商之間的互通標準。<br /></li>
<li>RAN（無線接取網路, Radio Access Network）	❌	RAN 只是一般無線接取網路的概念，傳統 RAN 可能受限於特定供應商技術，而非開放標準。<br /></li>
<li>ORAN（開放無線接取網路, Open RAN）	✅	O-RAN 是業界標準，專門用於支援不同供應商設備的通訊與網路靈活性，最符合題意。<br /></li>
<li>WLAN（無線區域網路, Wireless Local Area Network）	❌	WLAN（如 Wi-Fi）主要用於區域無線網絡，不是專門用於多供應商設備互通的標準。<br /></li>
<li>與 ORAN 相關的計算機概論知識<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgec24a74" class="outline-5">
<h5 id="orgec24a74">計算機概論（計概） 相關知識</h5>
<div class="outline-text-5" id="text-orgec24a74">
<ul class="org-ul">
<li>(1) 無線通訊技術<br />
<ul class="org-ul">
<li>✅ 傳統 RAN（Radio Access Network）<br />
<ul class="org-ul">
<li>傳統 RAN（如 4G LTE、5G）通常由單一供應商提供完整解決方案。<br /></li>
<li>RAN 包含基地台（Base Station, eNodeB/gNodeB）與核心網路（Core Network）。<br /></li>
</ul></li>
<li>✅ O-RAN 的優勢<br />
<ul class="org-ul">
<li>開放標準，提高供應商選擇的彈性<br /></li>
<li>降低 5G 網路建置成本<br /></li>
<li>支援多雲端運行，提高可擴展性<br /></li>
</ul></li>
</ul></li>
<li>(2) 網路架構與通訊標準<br />
<ul class="org-ul">
<li>✅ 5G 與 O-RAN<br />
<ul class="org-ul">
<li>O-RAN 是 5G 重要技術之一，允許不同供應商提供 RAN 設備。<br /></li>
<li>有助於 5G 的開放發展，避免特定廠商壟斷。<br /></li>
</ul></li>
<li>✅ 網路虛擬化與 SDN（Software-Defined Networking）<br />
<ul class="org-ul">
<li>O-RAN 採用 SDN 技術來管理網路資源，提高彈性與可程式化能力。<br /></li>
<li>可與雲端計算結合，實現虛擬化網路（VNF, Virtual Network Functions）。<br /></li>
</ul></li>
</ul></li>
<li>(3) 開放標準與產業聯盟<br />
<ul class="org-ul">
<li>✅ O-RAN 聯盟（O-RAN Alliance）<br />
<ul class="org-ul">
<li>由主要電信業者（如 AT&amp;T、NTT DOCOMO、Vodafone）與技術供應商共同成立。<br /></li>
<li>制定 O-RAN 標準，推動開放式 5G 基礎設施。<br /></li>
</ul></li>
<li>✅ 與 3GPP 標準的關聯<br />
<ul class="org-ul">
<li>O-RAN 是基於 3GPP（5G 國際標準組織）規範設計<br /></li>
<li>目標是讓 RAN 技術更加模組化、開放化<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge34ca99" class="outline-4">
<h4 id="orge34ca99"><span class="section-number-4">7.2.16.</span> 3.</h4>
<div class="outline-text-4" id="text-7-2-16">
<p>
<span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> refers to a compilation of binary data stored in a single DB field.<br />
</p>
<ol class="org-ol">
<li>Memo<br /></li>
<li>Integer<br /></li>
<li>BLOB<br /></li>
<li>Logical<br /></li>
<li>Record<br /></li>
</ol>
</div>
<div id="outline-container-org40e86f3" class="outline-5">
<h5 id="org40e86f3">解</h5>
<div class="outline-text-5" id="text-org40e86f3">
<p>
<span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> 指的是存儲在單個資料庫欄位中的二進制數據集合。<br />
</p>

<p>
✅ 正確答案：c. BLOB（Binary Large Object，二進位大型物件）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org437a3b2"></a>1. BLOB（Binary Large Object）的定義<br />
<div class="outline-text-6" id="text-org437a3b2">
<p>
BLOB（Binary Large Object） 是一種 資料庫資料類型，用來存儲大量的二進位數據（Binary Data），如：<br />
</p>
<ul class="org-ul">
<li>圖像（Images）<br /></li>
<li>音訊（Audio）<br /></li>
<li>影片（Video）<br /></li>
<li>加密數據（Encrypted Data）<br /></li>
<li>程式碼（Executable Files）<br /></li>
</ul>
<p>
📌 BLOB 的關鍵特性<br />
</p>
<ul class="org-ul">
<li>可存儲大量數據（如幾 MB 或 GB）。<br /></li>
<li>二進制格式，不能像文字數據一樣直接查詢。<br /></li>
<li>通常與應用程式搭配使用，如 Python、Java、PHP 等語言透過 API 來讀寫 BLOB 數據。<br /></li>
</ul>
</div>
</li>
<li><a id="orge4f6102"></a>2. 其他選項分析<br />
<div class="outline-text-6" id="text-orge4f6102">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Memo</td>
<td class="org-left">❌</td>
<td class="org-left">Memo 是用來存儲大段純文字數據（如 SQL TEXT 型別），但不能存儲二進位數據。</td>
</tr>

<tr>
<td class="org-left">b. Integer</td>
<td class="org-left">❌</td>
<td class="org-left">Integer 是整數型別，不能存儲二進制數據。</td>
</tr>

<tr>
<td class="org-left">c. BLOB</td>
<td class="org-left">✅</td>
<td class="org-left">BLOB 是專門用來存儲二進制數據的資料類型。</td>
</tr>

<tr>
<td class="org-left">d. Logical</td>
<td class="org-left">❌</td>
<td class="org-left">Logical 是布林類型（Boolean），只能存儲 TRUE 或 FALSE。</td>
</tr>

<tr>
<td class="org-left">e. Record</td>
<td class="org-left">❌</td>
<td class="org-left">Record 代表資料庫中的一筆記錄（Row），而不是一種資料類型。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org75168df"></a>3. BLOB 在不同資料庫系統中的應用<br />
<ul class="org-ul">
<li><a id="org1a524f9"></a>✅ MySQL<br />
<div class="outline-text-7" id="text-org1a524f9">
<div class="org-src-container">
<pre class="src src-sql"><span class="linenr">1: </span><span style="color: #51afef;">CREATE</span> <span style="color: #51afef;">TABLE</span> <span style="color: #c678dd;">images</span> (
<span class="linenr">2: </span>    id <span style="color: #ECBE7B;">INT</span> AUTO_INCREMENT <span style="color: #51afef;">PRIMARY</span> <span style="color: #51afef;">KEY</span>,
<span class="linenr">3: </span>    image_data <span style="color: #ECBE7B;">BLOB</span>
<span class="linenr">4: </span>);
</pre>
</div>
</div>
</li>
<li><a id="orgebcd2a1"></a>✅ PostgreSQL<br />
<div class="outline-text-7" id="text-orgebcd2a1">
<div class="org-src-container">
<pre class="src src-sql"><span class="linenr">1: </span><span style="color: #51afef;">CREATE</span> <span style="color: #51afef;">TABLE</span> <span style="color: #c678dd;">videos</span> (
<span class="linenr">2: </span>    id SERIAL <span style="color: #51afef;">PRIMARY</span> <span style="color: #51afef;">KEY</span>,
<span class="linenr">3: </span>    video_data BYTEA
<span class="linenr">4: </span>);
</pre>
</div>
</div>
</li>
<li><a id="orgcfa4b03"></a>✅ SQLite<br />
<div class="outline-text-7" id="text-orgcfa4b03">
<div class="org-src-container">
<pre class="src src-sql"><span class="linenr">1: </span><span style="color: #51afef;">CREATE</span> <span style="color: #51afef;">TABLE</span> <span style="color: #c678dd;">files</span> (
<span class="linenr">2: </span>    id <span style="color: #ECBE7B;">INTEGER</span> <span style="color: #51afef;">PRIMARY</span> <span style="color: #51afef;">KEY</span>,
<span class="linenr">3: </span>    file_content <span style="color: #ECBE7B;">BLOB</span>
<span class="linenr">4: </span>);
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="org2f5cdfc"></a>4. 與 BLOB 相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="org880d047"></a>(1) 資料庫管理（DBMS）<br />
<div class="outline-text-7" id="text-org880d047">
<p>
✅ 關聯式資料庫（Relational Database）<br />
</p>
<ul class="org-ul">
<li>SQL 資料類型（BLOB, TEXT, INTEGER, BOOLEAN）<br /></li>
<li>如何在資料庫中儲存大文件（如圖像、影片）<br /></li>
</ul>
<p>
✅ NoSQL 與 BLOB<br />
</p>
<ul class="org-ul">
<li>MongoDB 使用 GridFS 來存儲大型文件<br /></li>
<li>Cassandra 使用 BLOB 類型來存儲二進制數據<br /></li>
</ul>
</div>
</li>
<li><a id="org6fabf77"></a>(2) 資料儲存與檔案系統<br />
<div class="outline-text-7" id="text-org6fabf77">
<p>
✅ BLOB vs. 檔案系統<br />
</p>
<ul class="org-ul">
<li>BLOB 儲存法：將數據存於資料庫欄位內。<br /></li>
<li>檔案系統儲存法：只存儲檔案路徑，文件存於磁碟。<br /></li>
</ul>
<p>
✅ BLOB 操作<br />
</p>
<ul class="org-ul">
<li>使用程式語言讀寫 BLOB（如 Python, Java）。<br /></li>
<li>影像處理（OpenCV, PIL）與 BLOB 整合。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org937e2eb" class="outline-4">
<h4 id="org937e2eb"><span class="section-number-4">7.2.17.</span> 4.</h4>
<div class="outline-text-4" id="text-7-2-17">
<p>
To deal with huge amounts of data and computation involved in Big Data, <span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> is a set of frequently used software utilities.<br />
</p>
<ol class="org-ol">
<li>Hadoop<br /></li>
<li>GIMP<br /></li>
<li>KeePass<br /></li>
<li>DBMS<br /></li>
<li>PuTTY<br /></li>
</ol>
</div>
<div id="outline-container-org65e7f98" class="outline-5">
<h5 id="org65e7f98">解</h5>
<div class="outline-text-5" id="text-org65e7f98">
<p>
為了處理大數據（Big Data）中大量的數據和計算，_________ 是一組常用的軟體工具集。<br />
</p>

<p>
✅ 正確答案：a. Hadoop<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org17cc4f2"></a>1. Hadoop 的定義<br />
<div class="outline-text-6" id="text-org17cc4f2">
<p>
Hadoop 是一個 開源的大數據處理框架，主要用來存儲與處理超大規模數據（Big Data），並能夠透過分散式計算（Distributed Computing） 提高數據處理的效率。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8ebeaf3"></a>📌 Hadoop 的核心特點<br />
<div class="outline-text-7" id="text-org8ebeaf3">
<ul class="org-ul">
<li>HDFS（Hadoop Distributed File System，分散式文件系統）<br />
<ul class="org-ul">
<li>存儲超大規模數據，透過多台伺服器分散存儲。<br /></li>
<li>提供容錯機制，即使某些節點故障，數據仍可恢復。<br /></li>
</ul></li>
<li>MapReduce<br />
<ul class="org-ul">
<li>一種分散式計算模型，透過 Map（映射）和 Reduce（歸約）兩個階段來處理數據。<br /></li>
<li>允許多個節點並行運算，提高計算效率。<br /></li>
</ul></li>
<li>YARN（Yet Another Resource Negotiator）<br />
<ul class="org-ul">
<li>管理計算資源，分配 CPU、記憶體給不同的計算任務。<br /></li>
</ul></li>
<li>Hadoop 生态系统<br />
<ul class="org-ul">
<li>Hive：提供類似 SQL 的查詢語言（HiveQL），用來查詢大數據。<br /></li>
<li>HBase：分散式 NoSQL 資料庫，適用於即時讀寫大數據。<br /></li>
<li>Spark：一種比 MapReduce 更快的分散式運算框架。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org626aec0"></a>2. 其他選項分析<br />
<div class="outline-text-6" id="text-org626aec0">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Hadoop</td>
<td class="org-left">✅</td>
<td class="org-left">Hadoop 是大數據處理的主要工具，提供 HDFS、MapReduce 和 YARN，最符合題意。</td>
</tr>

<tr>
<td class="org-left">b. GIMP</td>
<td class="org-left">❌</td>
<td class="org-left">GIMP（GNU Image Manipulation Program）是一款開源圖像編輯軟體，與大數據無關。</td>
</tr>

<tr>
<td class="org-left">c. KeePass</td>
<td class="org-left">❌</td>
<td class="org-left">KeePass 是一款密碼管理器，主要用於安全存儲密碼，與大數據無關。</td>
</tr>

<tr>
<td class="org-left">d. DBMS</td>
<td class="org-left">❌</td>
<td class="org-left">DBMS（資料庫管理系統）是用來管理結構化數據的，但無法處理 Hadoop 規模的大數據。</td>
</tr>

<tr>
<td class="org-left">e. PuTTY</td>
<td class="org-left">❌</td>
<td class="org-left">PuTTY 是一款遠端 SSH 連線工具，與大數據無關。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgd5ddf36"></a>3. 與 Hadoop 相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="org3047719"></a>(1) 大數據技術（Big Data Technologies）<br />
<div class="outline-text-7" id="text-org3047719">
<p>
✅ 大數據的四大特性（4V）<br />
</p>
<ul class="org-ul">
<li>Volume（數據量大）<br /></li>
<li>Velocity（處理速度快）<br /></li>
<li>Variety（數據類型多樣）<br /></li>
<li>Veracity（數據準確性）<br /></li>
</ul>
<p>
✅ Hadoop 與 Spark<br />
</p>
<ul class="org-ul">
<li>Hadoop 透過 HDFS 和 MapReduce 來存儲與處理大數據<br /></li>
<li>Spark 使用記憶體計算，比 Hadoop MapReduce 更快<br /></li>
</ul>
</div>
</li>
<li><a id="org96cc842"></a>(2) 分散式計算（Distributed Computing）<br />
<div class="outline-text-7" id="text-org96cc842">
<p>
✅ MapReduce<br />
</p>
<ul class="org-ul">
<li>Map 階段：將數據分割並計算部分結果<br /></li>
<li>Reduce 階段：彙總計算結果<br /></li>
</ul>
<p>
✅ Hadoop vs. 傳統資料庫<br />
</p>
<ul class="org-ul">
<li>Hadoop 適用於非結構化/半結構化數據（如日誌、社交媒體數據）。<br /></li>
<li>傳統 DBMS 適用於結構化數據（如 SQL 資料庫）。<br /></li>
</ul>
</div>
</li>
<li><a id="org7b3432f"></a>(3) 雲端計算（Cloud Computing）<br />
<div class="outline-text-7" id="text-org7b3432f">
<p>
✅ Hadoop 與雲端平台<br />
</p>
<ul class="org-ul">
<li>Amazon EMR（Elastic MapReduce）：AWS 提供的 Hadoop 託管服務<br /></li>
<li>Google Cloud Dataproc：Google 提供的 Hadoop/Spark 雲端服務<br /></li>
<li>Microsoft Azure HDInsight：Azure 上的 Hadoop 服務<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org2e19bb1" class="outline-4">
<h4 id="org2e19bb1"><span class="section-number-4">7.2.18.</span> 5.</h4>
<div class="outline-text-4" id="text-7-2-18">
<p>
<span class="underline"><span class="underline"><span class="underline">__</span></span></span> refers to a virtual space that users can access and immerse via digital devices and interact with other users.<br />
</p>
<ol class="org-ol">
<li>Multiverse<br /></li>
<li>Originverse<br /></li>
<li>Xenoverse<br /></li>
<li>Zeaverse<br /></li>
<li>Metaverse<br /></li>
</ol>
</div>
<div id="outline-container-orgd4398a2" class="outline-5">
<h5 id="orgd4398a2">解</h5>
<div class="outline-text-5" id="text-orgd4398a2">
<p>
<span class="underline"><span class="underline"><span class="underline">__</span></span></span> 指的是使用者可以透過數位設備進入並沉浸其中，並與其他使用者互動的虛擬空間。<br />
</p>

<p>
✅ 正確答案：e. Metaverse（元宇宙）<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org83c3b83"></a>1. Metaverse（元宇宙）的定義<br />
<div class="outline-text-6" id="text-org83c3b83">
<p>
Metaverse（元宇宙） 是一種虛擬世界（Virtual World），使用者可以透過數位設備（如 VR、AR、電腦、手機）進入並進行沉浸式互動。<br />
</p>

<p>
📌 Metaverse 的關鍵特性<br />
</p>
<ul class="org-ul">
<li>沉浸式體驗（Immersive Experience）<br />
<ul class="org-ul">
<li>使用 VR（虛擬實境）、AR（擴增實境） 或 MR（混合實境） 來進行互動。<br /></li>
</ul></li>
<li>去中心化（Decentralization）<br />
<ul class="org-ul">
<li>透過 區塊鏈技術（Blockchain） 確保數據安全，如 NFT（非同質化代幣）。<br /></li>
</ul></li>
<li>社交互動（Social Interaction）<br />
<ul class="org-ul">
<li>使用者可透過 虛擬化身（Avatar） 在虛擬世界中與他人交流。<br /></li>
</ul></li>
<li>數位經濟（Digital Economy）<br />
<ul class="org-ul">
<li>虛擬貨幣（Cryptocurrency） 與 數字資產（NFTs） 在元宇宙中被廣泛使用。<br /></li>
</ul></li>
<li>持續運行（Persistent World）<br />
<ul class="org-ul">
<li>元宇宙不會停止運行，即使使用者登出，世界仍然會持續發展。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org74e32ad"></a>2. 其他選項分析<br />
<div class="outline-text-6" id="text-org74e32ad">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a. Multiverse</td>
<td class="org-left">❌</td>
<td class="org-left">Multiverse（多重宇宙） 是物理或科幻概念，指多個平行宇宙，而非數位虛擬空間。</td>
</tr>

<tr>
<td class="org-left">b. Originverse</td>
<td class="org-left">❌</td>
<td class="org-left">沒有這個詞，是虛構的名稱，與虛擬世界無關。</td>
</tr>

<tr>
<td class="org-left">c. Xenoverse</td>
<td class="org-left">❌</td>
<td class="org-left">Xenoverse 是來自《龍珠異戰（Dragon Ball Xenoverse）》的遊戲名稱，與 Metaverse 概念不同。</td>
</tr>

<tr>
<td class="org-left">d. Zeaverse</td>
<td class="org-left">❌</td>
<td class="org-left">Zeaverse 不是正式的技術術語，與虛擬世界無關。</td>
</tr>

<tr>
<td class="org-left">e. Metaverse</td>
<td class="org-left">✅</td>
<td class="org-left">Metaverse（元宇宙）是虛擬世界的正式概念，使用者可以透過數位設備進入並與他人互動，最符合題意。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org654264a"></a>3. 與 Metaverse 相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="orgd4e8c89"></a>(1) 虛擬實境（VR）與擴增實境（AR）<br />
<div class="outline-text-7" id="text-orgd4e8c89">
<p>
✅ VR（Virtual Reality, 虛擬實境）<br />
</p>
<ul class="org-ul">
<li>透過裝置（如 Oculus、HTC Vive） 讓使用者進入 3D 虛擬環境。<br /></li>
<li>應用領域：遊戲、虛擬會議、模擬訓練。<br /></li>
</ul>
<p>
✅ AR（Augmented Reality, 擴增實境）<br />
</p>
<ul class="org-ul">
<li>在現實世界中疊加虛擬物件（如 Pokemon GO）。<br /></li>
<li>應用領域：教育、醫療、電子商務。<br /></li>
</ul>
</div>
</li>
<li><a id="org7d39708"></a>(2) 區塊鏈與數位資產<br />
<div class="outline-text-7" id="text-org7d39708">
<p>
✅ NFT（非同質化代幣）<br />
</p>
<ul class="org-ul">
<li>用於代表元宇宙中的虛擬資產（如土地、道具）。<br /></li>
<li>常見平台：Decentraland、The Sandbox。<br /></li>
</ul>
<p>
✅ 去中心化應用（DApps）<br />
</p>
<ul class="org-ul">
<li>透過區塊鏈技術，在元宇宙中交易數位資產。<br /></li>
<li>使用智能合約（Smart Contracts）。<br /></li>
</ul>
</div>
</li>
<li><a id="org65803b7"></a>(3) 人工智慧（AI）與 Metaverse<br />
<div class="outline-text-7" id="text-org65803b7">
<p>
✅ AI 在元宇宙中的應用<br />
</p>
<ul class="org-ul">
<li>自動生成 NPC（非玩家角色）<br /></li>
<li>智慧助理（如 ChatGPT）<br /></li>
<li>虛擬場景建模（AI 生成虛擬世界）<br /></li>
</ul>
<p>
✅ 雲端運算（Cloud Computing）<br />
</p>
<ul class="org-ul">
<li>支援大規模虛擬世界運行<br /></li>
<li>邊緣計算（Edge Computing）提高即時互動能力<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org54bb47e" class="outline-4">
<h4 id="org54bb47e"><span class="section-number-4">7.2.19.</span> B-2 Programming and Short answer</h4>
</div>
<div id="outline-container-org7994051" class="outline-4">
<h4 id="org7994051"><span class="section-number-4">7.2.20.</span> 1.</h4>
<div class="outline-text-4" id="text-7-2-20">
<p>
Bubble Sort, Selection Sort, and Insertion Sort are basic sorting algorithms to sort numbers. To sort 9, 2, and 4, following table can be used to demonstrate the steps of an ascending bubble sort by only showing swapping steps: Table 1 Bubble Sort steps.<br />
</p>

<p>
TABLE 1 :  BUBBLE SORT STEPS<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Bubble sorting</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">9 2 4 (Original)</td>
</tr>

<tr>
<td class="org-left">2 9 4</td>
</tr>

<tr>
<td class="org-left">2 4 9 (Sorted)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Considering following numbers: 75, 29, 47, 3, and 12<br /></li>
<li>Using the table formation above (Table 1) and only showing the steps with swapping (or insertion), please sort the numbers (75, 29, 47, 3, and 12) ascendingly by<br /></li>
<li>Selection Sort (5%)<br /></li>
<li>Insertion Sort (Please only show the insertion steps. 5%)<br /></li>
<li>Bubble Sort (5%)<br /></li>

<li>note 1: Please draw tables on your answer sheet for each sorting algorithm.<br /></li>
<li>note 2: For each table, please clearly indicate which algorithm is used<br /></li>
<li>note 3: In-place sorting.<br /></li>
</ul>
</div>
<div id="outline-container-orgfb1fee9" class="outline-5">
<h5 id="orgfb1fee9">解</h5>
<div class="outline-text-5" id="text-orgfb1fee9">
<p>
排序演算法（Sorting Algorithms）解題分析<br />
</p>

<p>
本題要求對數列 75, 29, 47, 3, 12 進行排序，並使用 Selection Sort（選擇排序）、Insertion Sort（插入排序）、Bubble Sort（氣泡排序） 來演示排序步驟，僅顯示發生交換（或插入）的步驟。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org007f0d1"></a>1) Selection Sort（選擇排序）<br />
<div class="outline-text-6" id="text-org007f0d1">
<p>
演算法概述：<br />
</p>
<ul class="org-ul">
<li>時間複雜度：O(n²)<br /></li>
<li>每一輪選擇最小值並與當前位置交換。<br /></li>
<li>表格僅顯示發生交換的步驟。<br /></li>
</ul>

<p>
Selection Sort 排序步驟<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Selection Sort</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">75 29 47 3 12 (Original)</td>
</tr>

<tr>
<td class="org-left">3 29 47 75 12 (Swap 75 &amp; 3)</td>
</tr>

<tr>
<td class="org-left">3 12 47 75 29 (Swap 29 &amp; 12)</td>
</tr>

<tr>
<td class="org-left">3 12 29 75 47 (Swap 47 &amp; 29)</td>
</tr>

<tr>
<td class="org-left">3 12 29 47 75 (Swap 75 &amp; 47) (Sorted)</td>
</tr>
</tbody>
</table>

<p>
✅ 選擇排序的關鍵點<br />
</p>
<ul class="org-ul">
<li>每一輪選最小值，放到目前的排序區間。<br /></li>
<li>需要 n-1 輪（共 4 輪） 完成排序。<br /></li>
</ul>
</div>
</li>
<li><a id="org5dbeb54"></a>2) Insertion Sort（插入排序）<br />
<div class="outline-text-6" id="text-org5dbeb54">
<p>
演算法概述：<br />
</p>
<ul class="org-ul">
<li>時間複雜度：O(n²)<br /></li>
<li>構建一個部分排序的數列，將每個數插入到合適位置。<br /></li>
<li>表格僅顯示發生插入的步驟。<br /></li>
</ul>

<p>
Insertion Sort 排序步驟<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Insertion Sort</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">75 29 47 3 12 (Original)</td>
</tr>

<tr>
<td class="org-left">29 75 47 3 12 (Insert 29 before 75)</td>
</tr>

<tr>
<td class="org-left">29 47 75 3 12 (Insert 47 between 29 and 75)</td>
</tr>

<tr>
<td class="org-left">3 29 47 75 12 (Insert 3 before 29)</td>
</tr>

<tr>
<td class="org-left">3 12 29 47 75 (Insert 12 between 3 and 29) (Sorted)</td>
</tr>
</tbody>
</table>

<p>
✅ 插入排序的關鍵點<br />
</p>
<ul class="org-ul">
<li>每一輪將當前數字插入到已排序區間的正確位置。<br /></li>
<li>需要 n-1 次插入。<br /></li>
</ul>
</div>
</li>
<li><a id="org705c36a"></a>3) Bubble Sort（氣泡排序）<br />
<div class="outline-text-6" id="text-org705c36a">
<p>
演算法概述：<br />
</p>
<ul class="org-ul">
<li>時間複雜度：O(n²)<br /></li>
<li>透過相鄰元素比較與交換，將最大值「冒泡」到最後。<br /></li>
<li>表格僅顯示發生交換的步驟。<br /></li>
</ul>

<p>
Bubble Sort 排序步驟<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Bubble Sort</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">75 29 47 3 12 (Original)</td>
</tr>

<tr>
<td class="org-left">29 75 47 3 12 (Swap 75 &amp; 29)</td>
</tr>

<tr>
<td class="org-left">29 47 75 3 12 (Swap 75 &amp; 47)</td>
</tr>

<tr>
<td class="org-left">29 47 3 75 12 (Swap 75 &amp; 3)</td>
</tr>

<tr>
<td class="org-left">29 47 3 12 75 (Swap 75 &amp; 12)</td>
</tr>

<tr>
<td class="org-left">29 3 47 12 75 (Swap 47 &amp; 3)</td>
</tr>

<tr>
<td class="org-left">29 3 12 47 75 (Swap 47 &amp; 12)</td>
</tr>

<tr>
<td class="org-left">3 29 12 47 75 (Swap 29 &amp; 3)</td>
</tr>

<tr>
<td class="org-left">3 12 29 47 75 (Swap 29 &amp; 12) (Sorted)</td>
</tr>
</tbody>
</table>

<p>
✅ 氣泡排序的關鍵點<br />
</p>
<ul class="org-ul">
<li>透過相鄰比較與交換，最大值逐步「冒泡」到最右側。<br /></li>
<li>需要 n-1 輪（共 4 輪） 才能完成排序。<br /></li>
</ul>
</div>
</li>
<li><a id="org069852f"></a>4) 與排序演算法相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="org3a9cf22"></a>(1) 基本排序演算法<br />
<div class="outline-text-7" id="text-org3a9cf22">
<p>
✅ Selection Sort（選擇排序）<br />
</p>
<ul class="org-ul">
<li>每次選最小值與當前位置交換。<br /></li>
<li>不穩定排序（因為交換可能改變相同元素的相對順序）。<br /></li>
<li>適用場景：適合元素少、且不要求穩定性的情境。<br /></li>
</ul>
<p>
✅ Insertion Sort（插入排序）<br />
</p>
<ul class="org-ul">
<li>每次將新元素插入適當位置。<br /></li>
<li>穩定排序（相同數字的順序不會改變）。<br /></li>
<li>適用場景：適合小規模數據或部分排序好的數據。<br /></li>
</ul>
<p>
✅ Bubble Sort（氣泡排序）<br />
</p>
<ul class="org-ul">
<li>每次相鄰比較，最大值「冒泡」到最後。<br /></li>
<li>穩定排序，但效率較低。<br /></li>
<li>適用場景：較少使用，主要用於教學目的。<br /></li>
</ul>
</div>
</li>
<li><a id="orgb05e10f"></a>(2) 時間與空間複雜度分析<br />
<div class="outline-text-7" id="text-orgb05e10f">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">演算法</th>
<th scope="col" class="org-left">平均時間複雜度</th>
<th scope="col" class="org-left">最壞時間複雜度</th>
<th scope="col" class="org-left">最小空間複雜度</th>
<th scope="col" class="org-left">穩定性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">選擇排序</td>
<td class="org-left">O(n²)</td>
<td class="org-left">O(n²)</td>
<td class="org-left">O(1)</td>
<td class="org-left">❌ 不穩定</td>
</tr>

<tr>
<td class="org-left">插入排序</td>
<td class="org-left">O(n²)</td>
<td class="org-left">O(n²)</td>
<td class="org-left">O(1)</td>
<td class="org-left">✅ 穩定</td>
</tr>

<tr>
<td class="org-left">氣泡排序</td>
<td class="org-left">O(n²)</td>
<td class="org-left">O(n²)</td>
<td class="org-left">O(1)</td>
<td class="org-left">✅ 穩定</td>
</tr>
</tbody>
</table>
<p>
✅ 時間複雜度比較<br />
</p>
<ul class="org-ul">
<li>最好：O(n)（適用於插入排序的已排序情況）<br /></li>
<li>最差：O(n²)（所有三種排序法）<br /></li>
</ul>
<p>
✅ 空間複雜度<br />
</p>
<ul class="org-ul">
<li>所有演算法都是 O(1)（原地排序 in-place sorting），不需要額外記憶體。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org2b3d16e" class="outline-4">
<h4 id="org2b3d16e"><span class="section-number-4">7.2.21.</span> 2.</h4>
<div class="outline-text-4" id="text-7-2-21">
<p>
Matrix Multiplication (10%)<br />
Following is an example of matrix multiplication between 2 square matrices while row=column=2.<br />
</p>
<pre class="example" id="org27f7b34">
|---+---+   +---+---+   +-------+-------+
| A | B |   | E | F |   | AE+BG | AF+BH |
|---+---+ X +---+---+ = +-------+-------+
| C | D |   | G | H |   | CE+DG | CF+DH |
|---+---+   +---+---+   +-------+-------+
</pre>

<p>
Considering 2 square matrices A and B while row=column=n, please finish the program in the BOX to store the results of the matrix multiplication between 2 matrices to a new square matrix, Result_Matrix[n][n].<br />
</p>
<ul class="org-ul">
<li>note 1: Assuming A and B are not empty.<br /></li>
<li>note 2: C or C++ are preferable to finish the program.<br /></li>
<li>note 3: You may still use other languages if you think it is clear.<br /></li>
</ul>

<p>
Please copy all program (Italic) below on your answer sheet to answer:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">A</span>[n][n];
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">B</span>[n][n];
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">Result_Matrix</span>[n][n]={};
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">row</span>=n;
<span class="linenr"> 6: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">column</span>=n;
<span class="linenr"> 7: </span><span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">0</span>; i&lt; row; i++) {
<span class="linenr"> 8: </span>  <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span>=<span style="color: #da8548; font-weight: bold;">0</span>; j&lt; column; j++) {
<span class="linenr"> 9: </span>    <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">k</span>=<span style="color: #da8548; font-weight: bold;">0</span>; k&lt; column; k++) {
<span class="linenr">10: </span>      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Blank BOX filled here</span>
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>  }
<span class="linenr">13: </span> }
</pre>
</div>
</div>
<div id="outline-container-org362f8dd" class="outline-5">
<h5 id="org362f8dd">解</h5>
<div class="outline-text-5" id="text-org362f8dd">
<p>
矩陣乘法程式填充與解釋<br />
</p>

<p>
本題要求完成 C/C++ 程式碼，計算兩個 n×n 的方陣 A 和 B 的矩陣乘積，並將結果儲存於 Result_Matrix[n][n]。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org5aaccff"></a>1. 矩陣乘法公式<br />
<div class="outline-text-6" id="text-org5aaccff">
<p>
假設矩陣 AA 和矩陣 BB 為：<br />
</p>
\begin{array}{cc}
A =
\begin{bmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{bmatrix}
&
B =
\begin{bmatrix}
B_{11} & B_{12} \\
B_{21} & B_{22}
\end{bmatrix}
\end{array}

<p>
則矩陣乘法 C=A×BC=A×B 計算方式如下：<br />
\[C_{ij}=\sum^{n-1}_{k=0}A_{ik} \times B_{kj}\]<br />
這表示結果矩陣中的元素 C[i][j] 是 A 矩陣的第 i 行 與 B 矩陣的第 j 列 的對應元素相乘後的總和。<br />
</p>
</div>
</li>
<li><a id="org12b26ff"></a>2. C++ 程式碼填充<br />
<div class="outline-text-6" id="text-org12b26ff">
<p>
我們需要填充 內層迴圈 來計算 Result_Matrix[i][j]。<br />
</p>

<p>
完整程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">A</span>[n][n];
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">B</span>[n][n];
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">Result_Matrix</span>[n][n] = {}; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21021;&#22987;&#21270;&#28858; 0</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">row</span> = n;
<span class="linenr"> 6: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">column</span> = n;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; row; i++) {        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36941;&#27511; A &#30340;&#34892;</span>
<span class="linenr"> 9: </span>  <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; column; j++) {   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36941;&#27511; B &#30340;&#21015;</span>
<span class="linenr">10: </span>    <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">k</span> = <span style="color: #da8548; font-weight: bold;">0</span>; k &lt; column; k++) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36941;&#27511; A &#30340;&#21015;/B &#30340;&#34892;</span>
<span class="linenr">11: </span>      Result_Matrix[i][j] += A[i][k] * B[k][j]; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639;&#30697;&#38499;&#20056;&#27861;</span>
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>  }
<span class="linenr">14: </span>}
</pre>
</div>
<p>
✅ 關鍵點<br />
</p>
<ul class="org-ul">
<li>i 遍歷 A 矩陣的行（Row）<br /></li>
<li>j 遍歷 B 矩陣的列（Column）<br /></li>
<li>k 負責遍歷 A 的列和 B 的行，並累加對應數值。<br /></li>
</ul>
</div>
</li>
<li><a id="orgb7b3d2f"></a>3. 測試範例<br />
<div class="outline-text-6" id="text-orgb7b3d2f">
<p>
輸入<br />
</p>

<p>
假設：<br />
</p>
\begin{array}{cc}
A =
\begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}
&
B =
\begin{bmatrix}
5 & 6 \\
7 & 8
\end{bmatrix}
\end{array}
<p>
那麼 Result_Matrix 計算如下：<br />
</p>
\begin{array}{cc}
C =
\begin{bmatrix}
1\times5+2\times 7 &  1\times6+2\times 8\\
3\times5+4\times 7 &  3\times6+4\times 8
\end{bmatrix}
&
=
\begin{bmatrix}
19 & 22 \\
43 & 50
\end{bmatrix}
\end{array}

<p>
C++ 測試程式<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span> = <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20551;&#35373;&#30697;&#38499;&#22823;&#23567;&#28858; 2&#215;2</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 8: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">A</span>[n][n] = { {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>}, {<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>} };
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">B</span>[n][n] = { {<span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">6</span>}, {<span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">8</span>} };
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">Result_Matrix</span>[n][n] = {};
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30697;&#38499;&#20056;&#27861;&#35336;&#31639;</span>
<span class="linenr">13: </span>    <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++) {
<span class="linenr">14: </span>        <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; n; j++) {
<span class="linenr">15: </span>            <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">k</span> = <span style="color: #da8548; font-weight: bold;">0</span>; k &lt; n; k++) {
<span class="linenr">16: </span>                Result_Matrix[i][j] += A[i][k] * B[k][j];
<span class="linenr">17: </span>            }
<span class="linenr">18: </span>        }
<span class="linenr">19: </span>    }
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36664;&#20986;&#32080;&#26524;</span>
<span class="linenr">22: </span>    cout &lt;&lt; <span style="color: #98be65;">"Result Matrix:\n"</span>;
<span class="linenr">23: </span>    <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++) {
<span class="linenr">24: </span>        <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; n; j++) {
<span class="linenr">25: </span>            cout &lt;&lt; Result_Matrix[i][j] &lt;&lt; <span style="color: #98be65;">" "</span>;
<span class="linenr">26: </span>        }
<span class="linenr">27: </span>        cout &lt;&lt; endl;
<span class="linenr">28: </span>    }
<span class="linenr">29: </span>
<span class="linenr">30: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">31: </span>}
</pre>
</div>
<p>
輸出<br />
</p>
<pre class="example" id="orgec8b0ca">
Result Matrix:
19 22
43 50
</pre>
</div>
</li>
<li><a id="org3552a4f"></a>4. 與矩陣乘法相關的計算機概論知識<br />
<ul class="org-ul">
<li><a id="orge389bfc"></a>(1) 演算法分析<br />
<div class="outline-text-7" id="text-orge389bfc">
<p>
✅ 時間複雜度<br />
</p>
<ul class="org-ul">
<li>三層迴圈使得演算法的時間複雜度為：<br /></li>
<li>O(n3)<br /></li>
<li>O(n3)<br />
<ul class="org-ul">
<li>適用於 小型矩陣（n &lt; 1000），但對大矩陣不夠高效。<br /></li>
<li>Strassen 演算法 可將時間複雜度降至 O(n^{2.81})，但需要額外空間。<br /></li>
</ul></li>
</ul>
<p>
✅ 空間複雜度<br />
</p>
<ul class="org-ul">
<li>若 Result_Matrix 需要額外儲存，空間複雜度為 O(n²)。<br /></li>
</ul>
</div>
</li>
<li><a id="org8142d63"></a>(2) 記憶體管理<br />
<div class="outline-text-7" id="text-org8142d63">
<p>
✅ 陣列與記憶體配置<br />
</p>
<ul class="org-ul">
<li>int A[n][n] 使用靜態陣列，適用於小矩陣。<br /></li>
<li><p>
若 n 過大（如 n &gt; 1000），應使用 動態分配（Dynamic Allocation）：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">int</span>** <span style="color: #dcaeea;">A</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">int</span>*[<span style="color: #a9a1e1;">n</span>];
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++) {
<span class="linenr">3: </span>        A[i] = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">int</span>[n];
<span class="linenr">4: </span>    }
</pre>
</div></li>
</ul>
<p>
✅ Cache 優化<br />
</p>
<ul class="org-ul">
<li>A[i][k] 與 B[k][j] 存取時可能影響 CPU Cache 效能，可透過改變迴圈順序來優化。<br /></li>
</ul>
</div>
</li>
<li><a id="orgc522a22"></a>(3) 應用場景<br />
<div class="outline-text-7" id="text-orgc522a22">
<p>
✅ 矩陣運算的應用<br />
</p>
<ul class="org-ul">
<li>電腦圖形學（Computer Graphics）：3D 變換（旋轉、縮放、平移）。<br /></li>
<li>機器學習（Machine Learning）：神經網路計算（如權重矩陣相乘）。<br /></li>
<li>密碼學（Cryptography）：例如 RSA 演算法 中的大數運算。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3d31d07" class="outline-3">
<h3 id="org3d31d07"><span class="section-number-3">7.3.</span> 112</h3>
<div class="outline-text-3" id="text-7-3">
</div>
<div id="outline-container-orge19915f" class="outline-4">
<h4 id="orge19915f"><span class="section-number-4">7.3.1.</span> 1.(15%) True or False: Are each of the following True or False?</h4>
<div class="outline-text-4" id="text-7-3-1">
<ul class="org-ul">
<li>1.1. Dynamic programming provides an O(n) solution to the 0/1 knapsack problem, where n is the number of items to be considered.<br /></li>
<li>1.2. K-means clustering is more computationally efficient than hierarchical clustering.<br /></li>
<li>1.3. The depth of a decision tree is related to the number of independent decisions it records.<br /></li>
<li>1.4. Hierarchical clustering is deterministic, but k-means clustering is not.<br /></li>
<li>1.5. When used to find a root of a polynomial, Newton’s method converges in O(log(n)) iterations, where n is the degree of the polynomial.<br /></li>
</ul>
</div>
<div id="outline-container-org31d3425" class="outline-5">
<h5 id="org31d3425">解</h5>
<div class="outline-text-5" id="text-org31d3425">
</div>
<ul class="org-ul">
<li><a id="org2a827ac"></a>1.1. Dynamic programming provides an O(n) solution to the 0/1 knapsack problem, where n is the number of items to be considered.<br />
<div class="outline-text-6" id="text-org2a827ac">
<p>
False<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgcff959c"></a>解釋：<br />
<div class="outline-text-7" id="text-orgcff959c">
<p>
0/1 背包問題的最佳解法是使用動態規劃 (Dynamic Programming, DP)，但其時間複雜度不是 O(n)O(n) 。<br />
</p>
<ul class="org-ul">
<li>標準動態規劃解法： 設總重量上限為 WW，則時間複雜度為 O(nW)O(nW)，其中 nn 是物品數量，WW 是背包容量。<br /></li>
<li>記憶化搜尋 (Memoization) 解法： 也需要 O(nW)O(nW) 的時間。<br /></li>
<li>完全多項式時間 (Pseudo-polynomial time) 問題： 因為複雜度依賴於 WW，這使得當 WW 很大時仍然不可行。<br /></li>
<li>近似演算法： 使用分支界定 (Branch and Bound) 或 FPTAS（Fully Polynomial Time Approximation Scheme）可以在某些情況下加速求解，但並非精確解法。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org65c593f"></a>1.2. K-means clustering is more computationally efficient than hierarchical clustering.<br />
<div class="outline-text-6" id="text-org65c593f">
<p>
True<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orga776443"></a>解釋：<br />
<div class="outline-text-7" id="text-orga776443">
<p>
K-means 與階層式分群 (Hierarchical Clustering) 的時間複雜度比較如下：<br />
</p>
<ul class="org-ul">
<li>K-means: 每次迭代需要 O(nk)O(nk) 的計算（其中 nn 是資料點數量，kk 是群集數），總共需要多次迭代（通常為 O(iter⋅nk)O(iter⋅nk)）。<br /></li>
<li>Hierarchical Clustering: 一般使用凝聚 (Agglomerative) 方法，其時間複雜度為 O(n2log⁡n)O(n2logn) 或 O(n3)O(n3)（使用不同的實作方式）。<br /></li>
<li>結論： K-means 在大多數情況下較快，特別是當 nn 很大時。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orga2b66e3"></a>1.3. The depth of a decision tree is related to the number of independent decisions it records.<br />
<div class="outline-text-6" id="text-orga2b66e3">
<p>
True<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8dec099"></a>解釋：<br />
<div class="outline-text-7" id="text-org8dec099">
<ul class="org-ul">
<li>決策樹 (Decision Tree) 是一種基於規則的分類與回歸方法，每個節點 (Node) 代表一次決策，每條路徑從根節點 (Root) 到葉節點 (Leaf) 代表一組決策過程。<br /></li>
<li>樹的深度 (Depth) 影響模型的複雜度，通常深度越大，模型的擬合能力越強，但也可能導致過擬合 (Overfitting)。<br /></li>
<li>深度與決策數量的關係：<br />
<ul class="org-ul">
<li>若一棵決策樹有深度 dd，則最多可分成 2d2d 個葉節點，每個葉節點對應一條獨立的決策路徑。<br /></li>
<li>深度越大，代表可以做出的獨立決策數量越多。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org15377c9"></a>1.4. Hierarchical clustering is deterministic, but k-means clustering is not.<br />
<div class="outline-text-6" id="text-org15377c9">
<p>
True<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgef856ca"></a>解釋：<br />
<div class="outline-text-7" id="text-orgef856ca">
<ul class="org-ul">
<li>階層式分群 (Hierarchical Clustering) 是確定性 (Deterministic) 的，因為每次的合併或分裂都是基於距離計算的固定規則，例如最短距離 (single linkage)、最長距離 (complete linkage)，這使得同樣的資料集每次執行結果都是相同的。<br /></li>
<li>K-means 分群 不是確定性演算法，因為其結果依賴於初始中心點 (Centroid Initialization)。<br />
<ul class="org-ul">
<li>K-means 透過隨機選擇初始中心點進行聚類，不同的初始化可能會導致不同的結果。<br /></li>
<li>為了提高穩定性，可以使用 K-means++ 來選擇較佳的初始中心點。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgea47fbc"></a>1.5. When used to find a root of a polynomial, Newton’s method converges in O(log(n)) iterations, where n is the degree of the polynomial.<br />
<div class="outline-text-6" id="text-orgea47fbc">
<p>
False<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7f7d7ff"></a>解釋：<br />
<div class="outline-text-7" id="text-org7f7d7ff">
<p>
牛頓法 (Newton’s Method) 是一種快速收斂的方法，用來解非線性方程 f(x)=0f(x)=0，迭代公式如下：<br />
\(x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}\)<br />
</p>
<ul class="org-ul">
<li>收斂速率： 牛頓法是二次收斂 (Quadratic Convergence)，即當靠近根時，誤差會以平方速度縮小。<br /></li>
<li>複雜度分析： 雖然牛頓法的收斂速度與 O(log⁡n)O(logn) 有關，但這裡的 nn 指的是誤差 ϵϵ 的位數，而不是多項式的次數。實際上，牛頓法的收斂速度與多項式的次數無直接關係。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org15f4a18" class="outline-5">
<h5 id="org15f4a18">📌 相關計概知識整理</h5>
<div class="outline-text-5" id="text-org15f4a18">
<ul class="org-ul">
<li>1️⃣ 動態規劃 (Dynamic Programming)<br />
<ul class="org-ul">
<li>最適子結構 (Optimal Substructure)<br /></li>
<li>重疊子問題 (Overlapping Subproblems)<br /></li>
<li>常見應用：<br />
<ul class="org-ul">
<li>費氏數列 (Fibonacci)<br /></li>
<li>背包問題 (Knapsack Problem)<br /></li>
<li>最長公共子序列 (LCS)<br /></li>
</ul></li>
</ul></li>
<li>2️⃣ 分群 (Clustering)<br />
<ul class="org-ul">
<li>K-means<br />
<ul class="org-ul">
<li>依賴隨機初始化<br /></li>
<li>時間複雜度 O(nk)O(nk)<br /></li>
<li>適合大規模數據<br /></li>
</ul></li>
<li>階層式分群 (Hierarchical Clustering)<br />
<ul class="org-ul">
<li>確定性方法<br /></li>
<li>時間複雜度 O(n2log⁡n)O(n2logn)<br /></li>
<li>適合小數據集<br /></li>
</ul></li>
</ul></li>
<li>3️⃣ 決策樹 (Decision Tree)<br />
<ul class="org-ul">
<li>優勢： 可解釋性強、無需特徵標準化<br /></li>
<li>劣勢： 易過擬合<br /></li>
<li>演算法：<br />
<ul class="org-ul">
<li>ID3 (使用資訊增益)<br /></li>
<li>C4.5 (改進 ID3，支持連續屬性)<br /></li>
<li>CART (使用基尼係數)<br /></li>
</ul></li>
</ul></li>
<li>4️⃣ 牛頓法 (Newton’s Method)<br />
<ul class="org-ul">
<li>公式： \(x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}\)<br /></li>
<li>優勢： 二次收斂速度快<br /></li>
<li>限制： 需計算導數，且可能陷入局部極值點<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org47bd979" class="outline-4">
<h4 id="org47bd979"><span class="section-number-4">7.3.2.</span> 2.</h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
(15%) Multiple choice question: (choose only ONE answer for each question)<br />
</p>
</div>
</div>
<div id="outline-container-org3f39f94" class="outline-4">
<h4 id="org3f39f94"><span class="section-number-4">7.3.3.</span> 2.1</h4>
<div class="outline-text-4" id="text-7-3-3">
<p>
Which of the following is NOT a universal property of reader-writer locks?<br />
</p>
<ul class="org-ul">
<li>(a) Readers can only look at a shared item; writers can also modify it.<br /></li>
<li>(b) If a writer has access to the item, then no other thread also has access.<br /></li>
<li>(c) Any number of readers can read the item at the same time.<br /></li>
<li>(d) A writer waiting for an RW lock will get preference over subsequent read requests.<br /></li>
</ul>
</div>
<div id="outline-container-org62075f8" class="outline-5">
<h5 id="org62075f8">解:</h5>
<div class="outline-text-5" id="text-org62075f8">
<p>
(d) A writer waiting for an RW lock will get preference over subsequent read requests.<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgf7cd01e"></a>📌 詳解<br />
<div class="outline-text-6" id="text-orgf7cd01e">
<p>
讀者-寫者鎖 (Reader-Writer Lock, RW Lock) 是用來解決多執行緒 (multi-threading) 存取共享資源時的競爭條件 (race condition) 問題。其主要特性如下：<br />
</p>
<ul class="org-ul">
<li>(a) Readers can only look at a shared item; writers can also modify it. → ✅ 正確<br />
<ul class="org-ul">
<li>讀者 (Reader) 只能讀取共享資源，不能修改。<br /></li>
<li>寫者 (Writer) 可以修改共享資源，但會導致其他讀者或寫者無法同時存取該資源。<br /></li>
</ul></li>
<li>(b) If a writer has access to the item, then no other thread also has access. → ✅ 正確<br />
<ul class="org-ul">
<li>寫者互斥 (Mutual Exclusion for Writers)：如果一個寫者正在存取資源，則其他任何讀者或寫者都不能存取該資源，以確保資料的一致性。<br /></li>
</ul></li>
<li>(c) Any number of readers can read the item at the same time. → ✅ 正確<br />
<ul class="org-ul">
<li>讀者之間不互斥，多個讀者可以同時存取共享資源，不會影響資料的正確性。<br /></li>
</ul></li>
<li>(d) A writer waiting for an RW lock will get preference over subsequent read requests. → ❌ 錯誤<br />
<ul class="org-ul">
<li>讀者-寫者鎖的具體行為依賴於實作策略，但不一定會優先給等待中的寫者。<br /></li>
<li>常見策略：<br />
<ul class="org-ul">
<li>讀者優先 (Readers-preference)：讀者可以持續進入臨界區，導致寫者可能餓死 (starvation)。<br /></li>
<li>寫者優先 (Writers-preference)：當寫者請求鎖時，會阻止新讀者進入，確保寫者不會長時間等待。<br /></li>
<li>公平策略 (Fairness)：按照請求順序來分配鎖，避免飢餓 (starvation) 問題。<br /></li>
</ul></li>
</ul></li>
</ul>
<p>
因此，並非所有 RW 鎖都會給寫者優先權，這不是通用的 (universal) 屬性。<br />
</p>
</div>
</li>
<li><a id="org41487ca"></a>📌 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="orge4f1a40"></a>1️⃣ 互斥與同步 (Mutual Exclusion &amp; Synchronization)<br />
<div class="outline-text-7" id="text-orge4f1a40">
<p>
在多執行緒環境中，同步機制用於確保不同執行緒存取共享資源時不會產生競爭條件 (race condition)。主要的同步機制包括：<br />
</p>
<ul class="org-ul">
<li>互斥鎖 (Mutex, Mutual Exclusion)<br /></li>
<li>讀者-寫者鎖 (Reader-Writer Lock)<br /></li>
<li>信號量 (Semaphore)<br /></li>
<li>條件變數 (Condition Variable)<br /></li>
<li>自旋鎖 (Spinlock)<br /></li>
</ul>
</div>
</li>
<li><a id="org4515f10"></a>2️⃣ 讀者-寫者鎖 (Reader-Writer Lock, RW Lock)<br />
<div class="outline-text-7" id="text-org4515f10">
<p>
RW 鎖允許：<br />
</p>
<ul class="org-ul">
<li>多個讀者可以同時存取資源。<br /></li>
<li>寫者存取時，其他讀者與寫者都必須等待。<br /></li>
</ul>
<p>
RW 鎖的幾種策略：<br />
</p>
<ul class="org-ul">
<li>讀者優先 (Readers-Preference)<br />
<ul class="org-ul">
<li>讀者可以持續進入臨界區，直到沒有讀者為止。<br /></li>
<li>缺點：如果一直有新讀者進來，寫者可能會永遠無法獲得鎖 (Starvation of Writers)。<br /></li>
</ul></li>
<li>寫者優先 (Writers-Preference)<br />
<ul class="org-ul">
<li>一旦有寫者請求鎖，會阻止新讀者進入，確保寫者不會一直等下去。<br /></li>
<li>缺點：如果一直有寫者到來，讀者可能會餓死。<br /></li>
</ul></li>
<li>公平策略 (Fair RW Lock, FIFO Order)<br />
<ul class="org-ul">
<li>讓讀者與寫者按照請求順序進入，防止任何一方餓死。<br /></li>
<li>代價是效率可能稍低，因為必須維護一個佇列來追蹤順序。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf4ce6a3"></a>3️⃣ 互斥鎖 (Mutex) vs. 讀者-寫者鎖 (RW Lock)<br />
<div class="outline-text-7" id="text-orgf4ce6a3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">互斥鎖 (Mutex)</th>
<th scope="col" class="org-left">讀者-寫者鎖 (RW Lock)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">適用場景</td>
<td class="org-left">任意共享資源</td>
<td class="org-left">適用於讀多寫少的場景</td>
</tr>

<tr>
<td class="org-left">允許多讀？</td>
<td class="org-left">❌ 否</td>
<td class="org-left">✅ 是</td>
</tr>

<tr>
<td class="org-left">允許多寫？</td>
<td class="org-left">❌ 否</td>
<td class="org-left">❌ 否</td>
</tr>

<tr>
<td class="org-left">寫者可被讀者阻塞？</td>
<td class="org-left">❌ 否</td>
<td class="org-left">✅ 是（根據策略不同）</td>
</tr>

<tr>
<td class="org-left">是否容易造成飢餓？</td>
<td class="org-left">否</td>
<td class="org-left">可能，取決於策略</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org6f7852a"></a>4️⃣ 讀者-寫者鎖的實作<br />
<div class="outline-text-7" id="text-org6f7852a">
<p>
在 C/C++ 及 POSIX 中可以使用 pthread_rwlock 來實作 RW 鎖，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">pthread_rwlock_t</span> <span style="color: #dcaeea;">rwlock</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">void</span>* <span style="color: #c678dd;">reader</span>(<span style="color: #ECBE7B;">void</span>* <span style="color: #dcaeea;">arg</span>) {
<span class="linenr"> 4: </span>    pthread_rwlock_rdlock(&amp;rwlock);
<span class="linenr"> 5: </span>    printf(<span style="color: #98be65;">"Reader %d is reading\n"</span>, *(<span style="color: #ECBE7B;">int</span>*)arg);
<span class="linenr"> 6: </span>    pthread_rwlock_unlock(&amp;rwlock);
<span class="linenr"> 7: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">NULL</span>;
<span class="linenr"> 8: </span>}
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #ECBE7B;">void</span>* <span style="color: #c678dd;">writer</span>(<span style="color: #ECBE7B;">void</span>* <span style="color: #dcaeea;">arg</span>) {
<span class="linenr">11: </span>    pthread_rwlock_wrlock(&amp;rwlock);
<span class="linenr">12: </span>    printf(<span style="color: #98be65;">"Writer %d is writing\n"</span>, *(<span style="color: #ECBE7B;">int</span>*)arg);
<span class="linenr">13: </span>    pthread_rwlock_unlock(&amp;rwlock);
<span class="linenr">14: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">NULL</span>;
<span class="linenr">15: </span>}
</pre>
</div>
<p>
Python 也提供 threading.RLock 或 threading.Lock 來模擬 RW 鎖。<br />
</p>
</div>
</li>
<li><a id="org04d21db"></a>5️⃣ 其他同步機制<br />
<div class="outline-text-7" id="text-org04d21db">
<ul class="org-ul">
<li>信號量 (Semaphore)<br />
<ul class="org-ul">
<li>可以控制多個執行緒的存取權限，例如 sem_wait() 和 sem_post()。<br /></li>
</ul></li>
<li>條件變數 (Condition Variable)<br />
<ul class="org-ul">
<li>用於等待特定條件發生，例如 pthread_cond_wait() 和 pthread_cond_signal()。<br /></li>
</ul></li>
<li>自旋鎖 (Spinlock)<br />
<ul class="org-ul">
<li>適合短時間鎖定的情境，減少系統調度開銷。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc6931f6" class="outline-4">
<h4 id="orgc6931f6"><span class="section-number-4">7.3.4.</span> 2.2</h4>
<div class="outline-text-4" id="text-7-3-4">
<p>
Starvation (in relation to threads) refers to:<br />
</p>
<ul class="org-ul">
<li>(a) A thread waiting for a lock indefinitely.<br /></li>
<li>(b) A semaphore that gets locked but the thread never unlocks it after use.<br /></li>
<li>(c) A thread is spawned but never joins the main thread when finished.<br /></li>
<li>(d) A process fails to spawn a new thread because it’s hit the maximum number of threads allowed.<br /></li>
</ul>
</div>
<div id="outline-container-orgb186046" class="outline-5">
<h5 id="orgb186046">解</h5>
<div class="outline-text-5" id="text-orgb186046">
<p>
答案：<br />
(a) A thread waiting for a lock indefinitely.<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orga29b093"></a>📌 詳解<br />
<div class="outline-text-6" id="text-orga29b093">
<p>
Starvation (飢餓) 在多執行緒 (multithreading) 中指的是某個執行緒無限期等待資源，因為其他執行緒持續獲得優先權，導致該執行緒無法執行。<br />
</p>
</div>
</li>
<li><a id="org4d4600d"></a>選項分析<br />
<ul class="org-ul">
<li><a id="org21b1e2a"></a>(a) A thread waiting for a lock indefinitely. → ✅ 正確<br />
<div class="outline-text-7" id="text-org21b1e2a">
<ul class="org-ul">
<li>飢餓 (Starvation) 的典型案例是某個執行緒長時間無法獲得鎖，因為其他高優先權的執行緒一直獲取該鎖。<br /></li>
<li>造成原因：<br />
<ul class="org-ul">
<li>優先權倒置 (Priority Inversion)： 高優先權執行緒佔據資源，低優先權執行緒永遠無法執行。<br /></li>
<li>資源分配不公平 (Unfair Resource Allocation)： 例如寫者優先策略導致讀者一直無法存取資源。<br /></li>
<li>忙等 (Busy Waiting)： 某些同步機制沒有公平機制 (Fairness Policy)，導致某些執行緒永遠排不到。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org6ce5595"></a>(b) A semaphore that gets locked but the thread never unlocks it after use. → ❌ 錯誤<br />
<div class="outline-text-7" id="text-org6ce5595">
<ul class="org-ul">
<li>這描述的是死鎖 (Deadlock)，不是飢餓。<br /></li>
<li>死鎖 指的是多個執行緒互相等待對方釋放資源，導致系統無法繼續運行。<br /></li>
</ul>
</div>
</li>
<li><a id="org2cf980e"></a>(c) A thread is spawned but never joins the main thread when finished. → ❌ 錯誤<br />
<div class="outline-text-7" id="text-org2cf980e">
<ul class="org-ul">
<li>這描述的是孤立執行緒 (Orphan Thread)，與飢餓無關。<br /></li>
<li>一個執行緒如果沒有 join()，它的結果可能會丟失，但這不代表它無法執行。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd70c376"></a>(d) A process fails to spawn a new thread because it’s hit the maximum number of threads allowed. → ❌ 錯誤<br />
<div class="outline-text-7" id="text-orgd70c376">
<ul class="org-ul">
<li>這描述的是資源耗盡 (Resource Exhaustion)，例如超過作業系統的執行緒限制 (ulimit -u)，但不屬於飢餓。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org3ead056"></a>📌 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="org8b50cd0"></a>1️⃣ 多執行緒同步與競爭條件<br />
<div class="outline-text-7" id="text-org8b50cd0">
<p>
在多執行緒環境中，同步 (Synchronization) 是關鍵問題：<br />
</p>
<ul class="org-ul">
<li>互斥 (Mutual Exclusion)： 保證同一時間只有一個執行緒存取共享資源。<br /></li>
<li>競爭條件 (Race Condition)： 當多個執行緒同時存取資源，結果依賴於執行順序。<br /></li>
</ul>
<p>
常見同步工具：<br />
</p>
<ul class="org-ul">
<li>互斥鎖 (Mutex)<br /></li>
<li>信號量 (Semaphore)<br /></li>
<li>條件變數 (Condition Variable)<br /></li>
<li>讀者-寫者鎖 (Reader-Writer Lock)<br /></li>
</ul>
</div>
</li>
<li><a id="orge0f4554"></a>2️⃣ 飢餓 (Starvation)<br />
<div class="outline-text-7" id="text-orge0f4554">
<p>
飢餓發生的常見場景：<br />
</p>
<ul class="org-ul">
<li>高優先權執行緒不斷執行，低優先權執行緒無法執行<br />
<ul class="org-ul">
<li>例子：高優先權的執行緒佔據 CPU，導致低優先權執行緒無限等待。<br /></li>
</ul></li>
<li>資源被長時間鎖住<br />
<ul class="org-ul">
<li>例子：一個 RW 鎖的寫者優先策略可能導致讀者飢餓。<br /></li>
</ul></li>
<li>不公平的資源分配<br />
<ul class="org-ul">
<li>例子：某些資源調度策略 (如 FIFO) 可能讓某些執行緒一直無法獲取資源。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org003963d"></a>3️⃣ 飢餓 vs. 死鎖<br />
<div class="outline-text-7" id="text-org003963d">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">飢餓 (Starvation)</th>
<th scope="col" class="org-left">死鎖 (Deadlock)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定義</td>
<td class="org-left">某些執行緒無限期等待資源</td>
<td class="org-left">多個執行緒互相等待對方釋放資源，導致系統卡住</td>
</tr>

<tr>
<td class="org-left">可恢復性</td>
<td class="org-left">可透過公平策略解決</td>
<td class="org-left">需透過死鎖偵測機制解除</td>
</tr>

<tr>
<td class="org-left">常見原因</td>
<td class="org-left">不公平的資源分配、優先權倒置</td>
<td class="org-left">互相依賴的鎖未釋放</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgd6ef4c5"></a>4️⃣ 解決飢餓的策略<br />
<div class="outline-text-7" id="text-orgd6ef4c5">
<ul class="org-ul">
<li>公平鎖 (Fair Locks)<br />
<ul class="org-ul">
<li>讓所有執行緒按照請求順序 (FIFO, First-In-First-Out) 來獲取鎖。<br /></li>
</ul></li>
<li>優先權提升 (Priority Inheritance)<br />
<ul class="org-ul">
<li>低優先權執行緒獲得鎖後，提升其優先權，以防止高優先權執行緒長時間霸佔 CPU。<br /></li>
</ul></li>
<li>資源共享限制<br />
<ul class="org-ul">
<li>限制寫者優先機制的使用，例如在 RW 鎖中，讓讀者與寫者交替執行。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org4ce74b3"></a>5️⃣ 相關程式碼<br />
<div class="outline-text-7" id="text-org4ce74b3">
<p>
模擬飢餓的範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;pthread.h&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 3: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;unistd.h&gt;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #ECBE7B;">pthread_mutex_t</span> <span style="color: #dcaeea;">lock</span>;
<span class="linenr"> 6: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">shared_resource</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #ECBE7B;">void</span>* <span style="color: #c678dd;">hungry_thread</span>(<span style="color: #ECBE7B;">void</span>* <span style="color: #dcaeea;">arg</span>) {
<span class="linenr"> 9: </span>    <span style="color: #51afef;">while</span> (<span style="color: #da8548; font-weight: bold;">1</span>) {
<span class="linenr">10: </span>        <span style="color: #51afef;">if</span> (pthread_mutex_trylock(&amp;lock) == <span style="color: #da8548; font-weight: bold;">0</span>) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22039;&#35430;&#29554;&#21462;&#37782;</span>
<span class="linenr">11: </span>            shared_resource++;
<span class="linenr">12: </span>            printf(<span style="color: #98be65;">"Low-priority thread executed: %d\n"</span>, shared_resource);
<span class="linenr">13: </span>            pthread_mutex_unlock(&amp;lock);
<span class="linenr">14: </span>            <span style="color: #51afef;">break</span>;
<span class="linenr">15: </span>        } <span style="color: #51afef;">else</span> {
<span class="linenr">16: </span>            printf(<span style="color: #98be65;">"Low-priority thread starving...\n"</span>);
<span class="linenr">17: </span>            sleep(<span style="color: #da8548; font-weight: bold;">1</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31561;&#24453;&#65292;&#20294;&#21487;&#33021;&#28961;&#38480;&#31561;&#24453;</span>
<span class="linenr">18: </span>        }
<span class="linenr">19: </span>    }
<span class="linenr">20: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">NULL</span>;
<span class="linenr">21: </span>}
<span class="linenr">22: </span>
<span class="linenr">23: </span><span style="color: #ECBE7B;">void</span>* <span style="color: #c678dd;">dominant_thread</span>(<span style="color: #ECBE7B;">void</span>* <span style="color: #dcaeea;">arg</span>) {
<span class="linenr">24: </span>    <span style="color: #51afef;">while</span> (<span style="color: #da8548; font-weight: bold;">1</span>) {
<span class="linenr">25: </span>        pthread_mutex_lock(&amp;lock);
<span class="linenr">26: </span>        shared_resource++;
<span class="linenr">27: </span>        printf(<span style="color: #98be65;">"High-priority thread executed: %d\n"</span>, shared_resource);
<span class="linenr">28: </span>        pthread_mutex_unlock(&amp;lock);
<span class="linenr">29: </span>        usleep(<span style="color: #da8548; font-weight: bold;">500000</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27169;&#25836;&#30701;&#26283;&#37323;&#25918;</span>
<span class="linenr">30: </span>    }
<span class="linenr">31: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">NULL</span>;
<span class="linenr">32: </span>}
<span class="linenr">33: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">34: </span>    <span style="color: #ECBE7B;">pthread_t</span> <span style="color: #dcaeea;">t1</span>, <span style="color: #dcaeea;">t2</span>;
<span class="linenr">35: </span>    pthread_mutex_init(&amp;lock, <span style="color: #a9a1e1;">NULL</span>);
<span class="linenr">36: </span>
<span class="linenr">37: </span>    pthread_create(&amp;t1, <span style="color: #a9a1e1;">NULL</span>, dominant_thread, <span style="color: #a9a1e1;">NULL</span>);
<span class="linenr">38: </span>    sleep(<span style="color: #da8548; font-weight: bold;">1</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35731;&#39640;&#20778;&#20808;&#27402;&#22519;&#34892;&#32210;&#20808;&#22519;&#34892;</span>
<span class="linenr">39: </span>    pthread_create(&amp;t2, <span style="color: #a9a1e1;">NULL</span>, hungry_thread, <span style="color: #a9a1e1;">NULL</span>);
<span class="linenr">40: </span>
<span class="linenr">41: </span>    pthread_join(t2, <span style="color: #a9a1e1;">NULL</span>);
<span class="linenr">42: </span>    pthread_cancel(t1);
<span class="linenr">43: </span>
<span class="linenr">44: </span>    pthread_mutex_destroy(&amp;lock);
<span class="linenr">45: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">46: </span>}
</pre>
</div>
<p>
說明：<br />
</p>
<ul class="org-ul">
<li>dominant_thread() 代表高優先權執行緒，不斷獲取鎖。<br /></li>
<li>hungry_thread() 代表低優先權執行緒，嘗試獲取鎖但無限等待 (飢餓發生)。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org607549f" class="outline-4">
<h4 id="org607549f"><span class="section-number-4">7.3.5.</span> 2.3</h4>
<div class="outline-text-4" id="text-7-3-5">
<p>
How does x86 assemble store the return value when a function is finished?<br />
</p>
<ul class="org-ul">
<li>(a) The ret instruction stores it in a special retval register.<br /></li>
<li>(b) By convention, it is always in %eax.<br /></li>
<li>(c) It is stored on the stack just above the (%ebp) of the callee.<br /></li>
<li>(d) It is stored on the stack just above all the arguments to the function.<br /></li>
</ul>
</div>
<div id="outline-container-org9fda6c7" class="outline-5">
<h5 id="org9fda6c7">解:</h5>
<div class="outline-text-5" id="text-org9fda6c7">
<p>
答案：<br />
(b) By convention, it is always in %eax.<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9b3885c"></a>📌 詳解<br />
<div class="outline-text-6" id="text-org9b3885c">
<p>
在 x86 組合語言 (Assembly) 的函式呼叫慣例 (Calling Convention) 中，函式的回傳值 (Return Value) 一般會存放在 EAX 暫存器中。這是因為 EAX 在 x86 架構中被定義為函式回傳值的暫存器。<br />
</p>
</div>
</li>
<li><a id="orgbb97859"></a>選項分析<br />
<div class="outline-text-6" id="text-orgbb97859">
<ul class="org-ul">
<li>(a) The ret instruction stores it in a special retval register. → ❌ 錯誤<br />
<ul class="org-ul">
<li>ret 指令 (Return) 不會存儲回傳值，它只負責從堆疊中取出返回位址，並跳轉回呼叫者 (Caller) 的程式碼繼續執行。<br /></li>
</ul></li>
<li>(b) By convention, it is always in %eax. → ✅ 正確<br />
<ul class="org-ul">
<li>在 x86 的 System V ABI (Application Binary Interface) 中：<br />
<ul class="org-ul">
<li>回傳值會存放在 EAX (或 RAX，在 x86-64 架構下)。<br /></li>
<li>若回傳值為 64 位整數 (long long)，則使用 EDX:EAX 組合。<br /></li>
<li>若回傳值為浮點數，則會存放在 ST(0) (x87 FPU) 或 XMM0 (SSE 指令集)。<br /></li>
</ul></li>
</ul></li>
<li>(c) It is stored on the stack just above the (%ebp) of the callee. → ❌ 錯誤<br />
<ul class="org-ul">
<li>堆疊 (Stack) 通常存放函式的局部變數與返回位址，但回傳值不會存放在 %ebp 附近。<br /></li>
</ul></li>
<li>(d) It is stored on the stack just above all the arguments to the function. → ❌ 錯誤<br />
<ul class="org-ul">
<li>函式參數 通常會存放在堆疊中 (stack) 或暫存器，但回傳值不會存放在參數區上方。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgaadd609"></a>📌 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="org3dabf6e"></a>1️⃣ x86 呼叫慣例 (Calling Conventions)<br />
<div class="outline-text-7" id="text-org3dabf6e">
<p>
不同的 Calling Convention 可能會對回傳值的存放方式有不同規定：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Calling Convention</th>
<th scope="col" class="org-left">回傳值存放地點</th>
<th scope="col" class="org-left">參數傳遞方式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">cdecl (C-style)</td>
<td class="org-left">EAX</td>
<td class="org-left">參數從右到左壓入堆疊</td>
</tr>

<tr>
<td class="org-left">stdcall (Windows API)</td>
<td class="org-left">EAX</td>
<td class="org-left">參數從右到左壓入堆疊，函式負責清除堆疊</td>
</tr>

<tr>
<td class="org-left">fastcall</td>
<td class="org-left">EAX</td>
<td class="org-left">主要參數存於 ECX 和 EDX，其餘壓入堆疊</td>
</tr>

<tr>
<td class="org-left">x86-64 System V ABI</td>
<td class="org-left">RAX</td>
<td class="org-left">RDI, RSI, RDX, RCX, R8, R9</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgf31c27f"></a>2️⃣ x86 函式呼叫的典型流程<br />
<div class="outline-text-7" id="text-orgf31c27f">
<p>
函式呼叫 (Caller)<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">push arg2   ; 先壓入參數 arg2 (後進先出)
push arg1   ; 再壓入參數 arg1
call func   ; 呼叫函式，push 返回位址，跳轉到 func
</pre>
</div>
<p>
函式執行 (Callee)<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">func:
    push ebp        ; 保存舊的基底指標 (Base Pointer)
    mov ebp, esp    ; 設定新的基底指標
    ; 函式內部操作
    mov eax, 42     ; 設定回傳值為 42
    pop ebp         ; 恢復基底指標
    ret             ; 從堆疊彈出返回位址並跳轉
</pre>
</div>
<p>
呼叫者繼續執行<br />
</p>
<div class="org-src-container">
<pre class="src src-nil">add esp, 8    ; 清除參數 (cdecl 呼叫慣例需要自己清除)
mov result, eax  ; 從 eax 取得回傳值
</pre>
</div>
</div>
</li>
<li><a id="org8d9b5dc"></a>3️⃣ EAX 作為回傳值的設計考量<br />
<div class="outline-text-7" id="text-org8d9b5dc">
<ol class="org-ol">
<li>暫存器存取速度快<br />
<ul class="org-ul">
<li>EAX 是通用暫存器 (General Purpose Register)，其存取速度比堆疊存取快很多，因此適合存放回傳值。<br /></li>
</ul></li>
<li>簡化函式呼叫流程<br />
<ul class="org-ul">
<li>透過 EAX 傳遞回傳值，函式呼叫者可以輕鬆取得結果，無需操作堆疊。<br /></li>
</ul></li>
<li>相容性<br />
<ul class="org-ul">
<li>幾乎所有 x86 作業系統 (Windows, Linux, macOS) 都遵循這個規則，使得不同語言 (C, C++, Assembly) 可以互相調用。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org47e2dd9"></a>4️⃣ x86-64 回傳值的變化<br />
<div class="outline-text-7" id="text-org47e2dd9">
<p>
在 x86-64 (64 位元) 架構下：<br />
</p>
<ul class="org-ul">
<li>一般整數回傳值 存在 RAX<br /></li>
<li>64 位元整數 (long long) 則存 RDX:RAX<br /></li>
<li>浮點數回傳值 則存於 XMM0<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-nil">mov rax, 42   ; 回傳值為 42
ret
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="orgea85263"></a>📌 結論<br />
<div class="outline-text-6" id="text-orgea85263">
<ul class="org-ul">
<li>x86 函式回傳值 通常存放在 EAX 暫存器，這是 Calling Convention 的規定之一。<br /></li>
<li>不同的 Calling Convention 可能對參數與回傳值存放方式有所不同，但 EAX 是最常見的回傳值存放位置。<br /></li>
<li>x86-64 架構 仍然遵循類似規則，但擴展到 RAX 及 XMM0。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org62e1b96" class="outline-4">
<h4 id="org62e1b96"><span class="section-number-4">7.3.6.</span> 2.4</h4>
<div class="outline-text-4" id="text-7-3-6">
<p>
In IEEE floating point, what would be an effect of allocating more bits to the exponent part by taking them from the fraction part?<br />
</p>
<ul class="org-ul">
<li>(a) You could represent fewer numbers, but they could be much larger.<br /></li>
<li>(b) You could represent the same numbers, but with more decimal places.<br /></li>
<li>(c) You could represent both larger and smaller numbers, but with less precision.<br /></li>
<li>(d) Some previously representable numbers would now round to infinity<br /></li>
</ul>
</div>
<div id="outline-container-org633b8b9" class="outline-5">
<h5 id="org633b8b9">解:</h5>
<div class="outline-text-5" id="text-org633b8b9">
<p>
答案：<br />
(c) You could represent both larger and smaller numbers, but with less precision.<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org3b69d7c"></a>📌 詳解<br />
<div class="outline-text-6" id="text-org3b69d7c">
<p>
IEEE 浮點數標準 (IEEE 754) 的格式由三個部分組成：<br />
</p>
<ol class="org-ol">
<li>符號位元 (Sign Bit, 1-bit)：決定數字是正數或負數。<br /></li>
<li>指數位元 (Exponent Bits)：表示數字的尺度 (scale)，決定數的範圍 (range)。<br /></li>
<li>尾數 (Fraction/Mantissa Bits)：儲存有效數字，影響精度 (precision)。<br /></li>
</ol>
<p>
當我們增加指數 (Exponent) 位元時，代表的數值範圍會變大，但由於尾數位元減少，精度會降低。<br />
</p>
</div>
</li>
<li><a id="orga648337"></a>選項分析<br />
<div class="outline-text-6" id="text-orga648337">
<ul class="org-ul">
<li>(a) You could represent fewer numbers, but they could be much larger. → ❌ 錯誤<br />
<ul class="org-ul">
<li>錯誤點： 我們仍然可以表示同樣多的數，只是精度變低，不會讓「可表示數量減少」。<br /></li>
<li>正確說法： 可表示的數字範圍變大，但精度降低。<br /></li>
</ul></li>
<li>(b) You could represent the same numbers, but with more decimal places. → ❌ 錯誤<br />
<ul class="org-ul">
<li>錯誤點： 我們的精度是由「尾數位元 (Mantissa)」決定的。如果拿掉 Mantissa 的位元，精度會變差，而不是變好。<br /></li>
</ul></li>
<li>(c) You could represent both larger and smaller numbers, but with less precision. → ✅ 正確<br />
<ul class="org-ul">
<li>正確點：<br />
<ul class="org-ul">
<li>增加指數位元 → 可表示更大的範圍 (範圍擴大)。<br /></li>
<li>減少尾數位元 → 可表示的精度降低 (有效位數變少)。<br /></li>
</ul></li>
<li>例如：<br />
<ul class="org-ul">
<li>32-bit IEEE 754 單精度浮點數 (單精度) 使用 8 位指數 和 23 位尾數。<br /></li>
<li>64-bit IEEE 754 雙精度浮點數 (雙精度) 使用 11 位指數 和 52 位尾數。<br /></li>
<li>如果將 8 位的指數增加到 11 位，則尾數從 23 位減少，這會降低精度。<br /></li>
</ul></li>
</ul></li>
<li>(d) Some previously representable numbers would now round to infinity. → ❌ 錯誤<br />
<ul class="org-ul">
<li>錯誤點： 這只會發生在「指數溢出 (Exponent Overflow)」時，而不是因為重新分配位元。<br /></li>
<li>我們只是改變表示範圍與精度，並不會讓本來能表示的數突然變成無窮大 (Infinity)。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf829c3c"></a>📌 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="orgc8a9341"></a>1️⃣ IEEE 754 浮點數標準<br />
<div class="outline-text-7" id="text-orgc8a9341">
<p>
IEEE 754 定義了單精度 (32-bit) 和雙精度 (64-bit) 的表示方式：<br />
</p>

<p>
IEEE 754 單精度浮點數 (32-bit)<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">位元分佈</th>
<th scope="col" class="org-left">1-bit</th>
<th scope="col" class="org-left">8-bit</th>
<th scope="col" class="org-left">23-bit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">用途</td>
<td class="org-left">符號位元</td>
<td class="org-left">指數位元</td>
<td class="org-left">尾數 (有效數字)</td>
</tr>

<tr>
<td class="org-left">IEEE 754 雙精度浮點數 (64-bit)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">位元分佈</td>
<td class="org-left">1-bit</td>
<td class="org-left">11-bit</td>
<td class="org-left">52-bit</td>
</tr>

<tr>
<td class="org-left">用途</td>
<td class="org-left">符號位元</td>
<td class="org-left">指數位元</td>
<td class="org-left">尾數 (有效數字)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>指數範圍計算方式：<br />
<ul class="org-ul">
<li>單精度： 指數範圍約為 2−1262−126 到 21272127。<br /></li>
<li>雙精度： 指數範圍約為 2−10222−1022 到 2102321023。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgd00925e"></a>2️⃣ 增加指數位元的影響<br />
<div class="outline-text-7" id="text-orgd00925e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">變化</th>
<th scope="col" class="org-left">影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">指數 (Exponent) 增加</td>
<td class="org-left">數值範圍擴大，但精度降低</td>
</tr>

<tr>
<td class="org-left">尾數 (Mantissa) 減少</td>
<td class="org-left">精度降低，可能導致小數點後位數的誤差變大</td>
</tr>

<tr>
<td class="org-left">指數溢出 (Overflow)</td>
<td class="org-left">數字可能變成 Infinity (無窮大)</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orge76930a"></a>3️⃣ 為何要增加指數位元？<br />
<div class="outline-text-7" id="text-orge76930a">
<ol class="org-ol">
<li>應用於科學計算：<br />
<ul class="org-ul">
<li>需要表示極大或極小的數，例如天文學、量子物理學中的計算。<br /></li>
</ul></li>
<li>需要擴展數值範圍的應用：<br />
<ul class="org-ul">
<li>例如 GPU (顯示卡計算) 需要表示極端數值，而非精確數值。<br /></li>
</ul></li>
<li>儲存與運算資源限制：<br />
<ul class="org-ul">
<li>某些應用會選擇較少尾數位元，但更大數值範圍來適應應用需求。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orge425e7c"></a>4️⃣ 如何平衡範圍與精度？<br />
<div class="outline-text-7" id="text-orge425e7c">
<p>
在 IEEE 754 設計時，需要考慮：<br />
</p>
<ul class="org-ul">
<li>數值範圍 (Range)：應付極端數值的表示，例如 天文計算、物理模擬。<br /></li>
<li>精度 (Precision)：影響計算結果的準確性，例如 金融計算、工程應用。<br /></li>
</ul>

<p>
不同應用可能選擇不同的浮點格式：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">應用</th>
<th scope="col" class="org-left">需要範圍還是精度？</th>
<th scope="col" class="org-left">選擇</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">天文學</td>
<td class="org-left">範圍較重要</td>
<td class="org-left">增加指數位元</td>
</tr>

<tr>
<td class="org-left">科學模擬</td>
<td class="org-left">範圍與精度並重</td>
<td class="org-left">雙精度 (64-bit)</td>
</tr>

<tr>
<td class="org-left">金融計算</td>
<td class="org-left">精度較重要	固定小數點或增加 Mantissa</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org0c3a86b" class="outline-4">
<h4 id="org0c3a86b"><span class="section-number-4">7.3.7.</span> 2.5 .(20%)</h4>
<div class="outline-text-4" id="text-7-3-7">
<p>
Consider the following two blocks of code, found in separate files:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">main.c</span><span style="color: #5B6268;"> */</span>
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 3: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>()
<span class="linenr"> 4: </span>{
<span class="linenr"> 5: </span>    foo();
<span class="linenr"> 6: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 7: </span>}
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">foo.c</span><span style="color: #5B6268;"> */</span>
<span class="linenr">10: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">11: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">foo</span>()
<span class="linenr">12: </span>{
<span class="linenr">13: </span>    printf(``%d<span style="color: #ECBE7B;">''</span>, i);
<span class="linenr">14: </span>}
</pre>
</div>
<p>
What will happen when you attempt to compile, link, and run this code?<br />
</p>
<ul class="org-ul">
<li>(a) It will fail to compile.<br /></li>
<li>(b) It will fail to link.<br /></li>
<li>(c) It will raise a segmentation fault.<br /></li>
<li>(d) It will print &ldquo;0&rdquo;.<br /></li>
<li>(e) It will print &ldquo;1&rdquo;.<br /></li>
<li>(f) It will sometimes print &ldquo;0&rdquo; and sometimes print &ldquo;1&rdquo;.<br /></li>
</ul>
</div>
<div id="outline-container-orgbb7c538" class="outline-5">
<h5 id="orgbb7c538">解:</h5>
<div class="outline-text-5" id="text-orgbb7c538">
<p>
答案：<br />
(b) It will fail to link.<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org23277b7"></a>📌 詳解<br />
<div class="outline-text-6" id="text-org23277b7">
<p>
這段 C 程式碼有兩個檔案：<br />
</p>

<p>
main.c<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">3: </span>    foo();
<span class="linenr">4: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">5: </span>}
</pre>
</div>

<p>
foo.c<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">foo</span>() {
<span class="linenr">3: </span>        printf(<span style="color: #98be65;">"%d"</span>, i);
<span class="linenr">4: </span>    }
</pre>
</div>


<p>
在 main.c 和 foo.c 之間，變數 i 被定義兩次，但沒有 extern 來區分作用範圍，這會導致連結 (Linking) 錯誤。<br />
</p>
</div>
</li>
<li><a id="org75d43e2"></a>選項分析<br />
<ul class="org-ul">
<li><a id="orgca48ac9"></a>(a) It will fail to compile. → ❌ 錯誤<br />
<div class="outline-text-7" id="text-orgca48ac9">
<ul class="org-ul">
<li>編譯 (Compilation) 只檢查語法是否正確，在這段程式碼中，每個檔案單獨編譯時都不會出錯。<br /></li>
<li>變數 i 會在 main.c 和 foo.c 各自獨立定義，不影響編譯。<br /></li>
</ul>
</div>
</li>
<li><a id="org0030953"></a>(b) It will fail to link. → ✅ 正確<br />
<div class="outline-text-7" id="text-org0030953">
<ul class="org-ul">
<li>int i 在兩個不同的檔案中重複定義，這會違反One Definition Rule (ODR, 唯一定義規則)，導致連結錯誤。<br /></li>
<li><p>
錯誤訊息範例 (Linux GCC)：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  multiple definition of `i<span style="color: #ECBE7B;">'</span>; first defined here
</pre>
</div></li>
<li>原因：<br />
<ul class="org-ul">
<li>int i=0; 在 main.c 定義為全域變數。<br /></li>
<li>int i=1; 在 foo.c 也定義為全域變數。<br /></li>
<li>因為 C 預設的全域變數是 &ldquo;strong symbol&rdquo;，所以不能有兩個 i，導致連結失敗。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orge2878c5"></a>(c) It will raise a segmentation fault. → ❌ 錯誤<br />
<div class="outline-text-7" id="text-orge2878c5">
<ul class="org-ul">
<li>如果能成功連結，i 只是個全域變數，不涉及無效記憶體存取，所以不會發生 segmentation fault。<br /></li>
</ul>
</div>
</li>
<li><a id="orgea0abf7"></a>(d) It will print &ldquo;0&rdquo;. → ❌ 錯誤<br />
<div class="outline-text-7" id="text-orgea0abf7">
<ul class="org-ul">
<li>如果連結成功，foo() 內部的 i 應該是 foo.c 的 i=1，不會是 main.c 的 i=0。<br /></li>
</ul>
</div>
</li>
<li><a id="org79e11d0"></a>(e) It will print &ldquo;1&rdquo;. → ❌ 錯誤<br />
<div class="outline-text-7" id="text-org79e11d0">
<ul class="org-ul">
<li>這是假設 foo.c 的 i=1 正確被連結，但實際上程式不會成功連結。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd1ddd5c"></a>(f) It will sometimes print &ldquo;0&rdquo; and sometimes print &ldquo;1&rdquo;. → ❌ 錯誤<br />
<div class="outline-text-7" id="text-orgd1ddd5c">
<ul class="org-ul">
<li>變數 i 在兩個檔案內被獨立定義，理論上不應該產生不確定的行為，而是直接產生連結錯誤。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orga793ad5"></a>📌 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="org399d863"></a>1️⃣ 連結 (Linking)<br />
<div class="outline-text-7" id="text-org399d863">
<p>
C 程式的編譯過程分為 編譯 (Compilation) 和 連結 (Linking)：<br />
</p>
<ul class="org-ul">
<li>編譯 (Compilation)：單獨將 main.c 和 foo.c 轉換為 .o 物件檔案。<br /></li>
<li>連結 (Linking)：將所有 .o 檔案合併，解析符號。<br /></li>
</ul>

<p>
這裡 i 變數在兩個 .o 檔案中都有定義 (Definition)，會導致 &ldquo;multiple definition error&rdquo;。<br />
</p>
</div>
</li>
<li><a id="org70d8b7c"></a>2️⃣ extern 的正確使用<br />
<div class="outline-text-7" id="text-org70d8b7c">
<p>
為了解決這個問題，我們應該使用 extern 來避免 i 的重複定義：<br />
</p>

<p>
修改 foo.c：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">extern</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21578;&#35380;&#32232;&#35695;&#22120;&#36889;&#20491;&#35722;&#25976;&#20358;&#33258;&#20854;&#20182;&#27284;&#26696;</span>
<span class="linenr">2: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">foo</span>() {
<span class="linenr">3: </span>    printf(<span style="color: #98be65;">"%d"</span>, i);
<span class="linenr">4: </span>}
</pre>
</div>
<p>
這樣 foo.c 內的 i 會使用 main.c 的 i=0，所以最終輸出會是 0。<br />
</p>
</div>
</li>
<li><a id="orga1baad5"></a>3️⃣ 強符號 (Strong Symbol) vs. 弱符號 (Weak Symbol)<br />
<div class="outline-text-7" id="text-orga1baad5">
<p>
在 C 編譯器 (GCC, Clang) 中，變數 int i=0; 是強符號 (Strong Symbol)，如果兩個 .o 檔案都有 i，則連結器無法決定該選哪一個，因此報錯。<br />
</p>

<p>
如果想讓一個變數在不同檔案中共享，可以使用 extern 或 weak symbol：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">__attribute__</span>((weak)) <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
</pre>
</div>
<p>
這樣如果 main.c 內已經定義 i=0，則 i=1 會被忽略，不會導致連結錯誤。<br />
</p>
</div>
</li>
<li><a id="org79c09d0"></a>4️⃣ C 編譯與連結的流程<br />
<div class="outline-text-7" id="text-org79c09d0">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">步驟</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">預處理 (Preprocessing)</td>
<td class="org-left">展開 #include、巨集</td>
</tr>

<tr>
<td class="org-left">編譯 (Compilation)</td>
<td class="org-left">main.c → main.o，foo.c → foo.o</td>
</tr>

<tr>
<td class="org-left">連結 (Linking)</td>
<td class="org-left">解析符號，解決外部變數與函式</td>
</tr>

<tr>
<td class="org-left">執行 (Execution)</td>
<td class="org-left">產生執行檔，程式開始執行</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org421ac3d"></a>5️⃣ 變數作用域與儲存類型<br />
<div class="outline-text-7" id="text-org421ac3d">
<p>
C 的變數作用域可以分為：<br />
</p>
<ul class="org-ul">
<li>區域變數 (Local Variables)：定義在函式內，儲存在堆疊 (Stack)。<br /></li>
<li>全域變數 (Global Variables)：定義在函式外，預設會在所有 .c 檔案中可見 (可連結)。<br /></li>
<li>靜態變數 (Static Variables)：<br />
<ul class="org-ul">
<li>static int i=1; 使 i 在 該 .c 檔案內部可見，不影響其他檔案。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf23663d" class="outline-4">
<h4 id="orgf23663d"><span class="section-number-4">7.3.8.</span> 3. (20%)</h4>
<div class="outline-text-4" id="text-7-3-8">
<p>
In this problem we consider properties of floating point operations. For each property state whether it is true or false. If false, give a counterexample as a (possibly negative) power of 2 within the range of precision for the variables. We assume that the variables on an x86_64 architecture are declared as follows<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">x</span>,<span style="color: #dcaeea;">y</span>,<span style="color: #dcaeea;">z</span>;
<span class="linenr">2: </span><span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">d</span>,<span style="color: #dcaeea;">e</span>;
</pre>
</div>
<p>
and initialized to some unknown value different from NaN, +1, and -1. We have given the first answer as an example.<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(x + y) + z <code>=</code> x + (y + z)</td>
<td class="org-left">false</td>
<td class="org-left">x = 1, y = 2&lt;sup&gt;127&lt;/sup&gt;, z = -2&lt;sup&gt;127&lt;/sup&gt;</td>
</tr>

<tr>
<td class="org-left">If x &gt; 0 then x / 2 &gt; 0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(x + y) * z <code>=</code> x * z + y * z</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">If x &gt;= y and z &lt;= 0 then x * z &lt;= y * z</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">If x &gt; y then (double) x &gt; (double) y</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">If d &gt; e then (float) d &gt; (float) e</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">x + 1 &gt; x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org66aa8f6" class="outline-5">
<h5 id="org66aa8f6">解：</h5>
<div class="outline-text-5" id="text-org66aa8f6">
</div>
<ul class="org-ul">
<li><a id="org136c7c3"></a>📌 題目解析<br />
<div class="outline-text-6" id="text-org136c7c3">
<p>
此題考察 IEEE 754 浮點數運算的基本性質，並要求判斷這些運算是否遵循數學上的對應性質，若不成立，則需舉出反例 (counterexample)。<br />
</p>

<p>
在 x86_64 架構 下：<br />
</p>
<ul class="org-ul">
<li>float 是 IEEE 754 單精度 (32-bit)，有效精度約 7 位十進位數。<br /></li>
<li><b><b>*</b></b><br /></li>
</ul>
</div>
</li>
<li><a id="org7226d8d"></a>📌 解答<br />
<div class="outline-text-6" id="text-org7226d8d">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">敘述</th>
<th scope="col" class="org-left">答案 (True / False)</th>
<th scope="col" class="org-left">反例 (Counterexample)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(x + y) + z <code>=</code> x + (y + z)</td>
<td class="org-left">False</td>
<td class="org-left">x = 1, y = 2¹²⁷, z = -2¹²⁷ → 加法不具結合律 (Associativity)</td>
</tr>

<tr>
<td class="org-left">If x &gt; 0 then x / 2 &gt; 0</td>
<td class="org-left">False</td>
<td class="org-left">x = 2⁻¹²⁶ (最小正規化浮點數) → x / 2 變為 次正規數 (Subnormal) 或 0</td>
</tr>

<tr>
<td class="org-left">(x + y) * z <code>=</code> x * z + y * z</td>
<td class="org-left">False</td>
<td class="org-left">x = 1, y = 2¹²⁷, z = 2⁻¹²⁷ → 加法誤差導致不相等</td>
</tr>

<tr>
<td class="org-left">If x &gt;= y and z &lt;= 0 then x * z &lt;= y * z</td>
<td class="org-left">False</td>
<td class="org-left">x = 2²⁶, y = 2²⁵, z = -2⁻³ → 由於浮點誤差，可能發生 x * z &gt; y * z</td>
</tr>

<tr>
<td class="org-left">If x &gt; y then (double) x &gt; (double) y</td>
<td class="org-left">True</td>
<td class="org-left">double 有更高精度，擴展轉換時不改變順序</td>
</tr>

<tr>
<td class="org-left">If d &gt; e then (float) d &gt; (float) e</td>
<td class="org-left">False</td>
<td class="org-left">d = 1.0000001, e = 1.0000000 (超過 float 精度範圍)，轉 float 時捨去變為相等</td>
</tr>

<tr>
<td class="org-left">x + 1 &gt; x</td>
<td class="org-left">False</td>
<td class="org-left">x = 2²³ (單精度 float 最大整數)，加 1 後無變化</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org891a4bc"></a>📌 詳細解析<br />
<ul class="org-ul">
<li><a id="org34cc365"></a>1️⃣ (x + y) + z <code>=</code> x + (y + z) → False (浮點數加法不具結合律)<br />
<div class="outline-text-7" id="text-org34cc365">
<p>
在浮點數運算中，加法 (Addition) 不滿足結合律：(a+b)+c≠a+(b+c)<br />
</p>

<p>
當 y 和 z 為極端大的數和極端小的數時，數值的表示精度受限，導致計算順序影響結果。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">2: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">y</span> = pow(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">127</span>);
<span class="linenr">3: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">z</span> = -pow(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">127</span>);
</pre>
</div>
<p>
計算 (x + y) + z：<br />
</p>
<ul class="org-ul">
<li>y + z = 2¹²⁷ - 2¹²⁷ = 0<br /></li>
<li>x + 0 = 1<br /></li>
</ul>
<p>
計算 x + (y + z)：<br />
</p>
<ul class="org-ul">
<li>y + z = 0<br /></li>
<li>x + 0 = 1<br /></li>
</ul>
<p>
這兩者可能產生不同的結果，因為浮點加法會因為溢位 (overflow) 或捨入 (rounding) 而丟失精度。<br />
</p>
</div>
</li>
<li><a id="org2aeda1c"></a>2️⃣ If x &gt; 0 then x / 2 &gt; 0 → False<br />
<div class="outline-text-7" id="text-org2aeda1c">
<p>
這條件通常成立，但當 x 非常小時 (接近 float 能表示的最小數)，x / 2 可能變成 0：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">x</span> = pow(<span style="color: #da8548; font-weight: bold;">2</span>, -<span style="color: #da8548; font-weight: bold;">126</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26368;&#23567;&#27491;&#35215;&#25976;</span>
<span class="linenr">2: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">result</span> = x / <span style="color: #da8548; font-weight: bold;">2</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21487;&#33021;&#35722;&#25104;&#27425;&#27491;&#35215;&#25976;&#25110; 0</span>
</pre>
</div>
<p>
在單精度 float 中，最小正規數為 2⁻¹²⁶，當除以 2 時，結果變成 2⁻¹²⁷，這可能變為次正規數 (subnormal) 或 0。<br />
</p>
</div>
</li>
<li><a id="org14f5c63"></a>3️⃣ (x + y) * z <code>=</code> x * z + y * z → False<br />
<div class="outline-text-7" id="text-org14f5c63">
<p>
這條件通常成立，但當 x + y 的結果超過浮點數能表示的精度時，可能導致不同的結果。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">2: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">y</span> = pow(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">127</span>);
<span class="linenr">3: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">z</span> = pow(<span style="color: #da8548; font-weight: bold;">2</span>, -<span style="color: #da8548; font-weight: bold;">127</span>);
</pre>
</div>
<p>
計算 (x + y) * z：<br />
</p>
<ul class="org-ul">
<li>x + y ≈ y (因為 x 太小，被忽略)<br /></li>
<li>y * z = 2¹²⁷ * 2⁻¹²⁷ = 1<br /></li>
</ul>
<p>
計算 x * z + y * z：<br />
</p>
<ul class="org-ul">
<li>x * z = 1 * 2⁻¹²⁷ = 2⁻¹²⁷ (極小值)<br /></li>
<li>y * z = 1<br /></li>
<li>2⁻¹²⁷ + 1 ≠ 1<br /></li>
</ul>
<p>
結果不同，因此等式不成立。<br />
</p>
</div>
</li>
<li><a id="orgdc7404b"></a>4️⃣ If x &gt;= y and z &lt;= 0 then x * z &lt;= y * z → False<br />
<div class="outline-text-7" id="text-orgdc7404b">
<p>
如果 z 是負數，x * z 和 y * z 會反轉方向。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">x</span> = pow(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">26</span>);
<span class="linenr">2: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">y</span> = pow(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">25</span>);
<span class="linenr">3: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">z</span> = -pow(<span style="color: #da8548; font-weight: bold;">2</span>, -<span style="color: #da8548; font-weight: bold;">3</span>);
</pre>
</div>
<p>
計算：<br />
</p>
<ul class="org-ul">
<li>x * z = 2²⁶ * (-2⁻³) = -2²³<br /></li>
<li>y * z = 2²⁵ * (-2⁻³) = -2²²<br /></li>
<li>-2²³ &gt; -2²²，與原條件矛盾。<br /></li>
</ul>
</div>
</li>
<li><a id="org6832271"></a>5️⃣ If x &gt; y then (double) x &gt; (double) y → True<br />
<div class="outline-text-7" id="text-org6832271">
<p>
因為 double 有更高精度，所以 float 轉 double 不會影響比較結果。<br />
</p>
</div>
</li>
<li><a id="org1e338d5"></a>6️⃣ If d &gt; e then (float) d &gt; (float) e → False<br />
<div class="outline-text-7" id="text-org1e338d5">
<p>
雙精度 (double) 轉 float 時，因為 float 的精度較低，可能導致 d 和 e 被捨入為相同的值：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">d</span> = <span style="color: #da8548; font-weight: bold;">1.0000001</span>;
<span class="linenr">2: </span><span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">e</span> = <span style="color: #da8548; font-weight: bold;">1.0000000</span>;
<span class="linenr">3: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">fd</span> = (<span style="color: #ECBE7B;">float</span>) d;
<span class="linenr">4: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">fe</span> = (<span style="color: #ECBE7B;">float</span>) e;
</pre>
</div>
<p>
因為 float 只有約 7 位十進制數的精度，fd 可能被捨入成 1.000000，導致 fd == fe。<br />
</p>
</div>
</li>
<li><a id="org5e9ba20"></a>7️⃣ x + 1 &gt; x → False<br />
<div class="outline-text-7" id="text-org5e9ba20">
<p>
當 x 很大時 (x = 2²³)，x + 1 可能無法改變 x 的數值，因為 float 只能表示 24 位有效位數：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">x</span> = pow(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">23</span>);
<span class="linenr">2: </span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">result</span> = x + <span style="color: #da8548; font-weight: bold;">1</span>;
</pre>
</div>
<p>
由於 x 的有效位數已滿，+1 不會影響 x，所以 x + 1 == x。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgd46b437"></a>📌 總結<br />
<div class="outline-text-6" id="text-orgd46b437">
<p>
IEEE 754 浮點數的有限精度導致：<br />
</p>
<ol class="org-ol">
<li>不具交換律、結合律 ((x + y) + z ≠ x + (y + z))<br /></li>
<li>極小數可能變成 0 (x / 2 &gt; 0 可能不成立)<br /></li>
<li>小數點誤差影響乘法分配律 ((x + y) * z ≠ x * z + y * z)<br /></li>
<li>負數乘法不一定符合直覺 (x * z &lt;= y * z 可能不成立)<br /></li>
<li>類型轉換可能改變比較結果 ((double) x &gt; (double) y 成立，但 (float) d &gt; (float) e 可能不成立)<br /></li>
<li>當 x 達到 float 精度上限時，x + 1 == x。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgeddf6bd" class="outline-4">
<h4 id="orgeddf6bd"><span class="section-number-4">7.3.9.</span> 4. Short Ansower</h4>
<div class="outline-text-4" id="text-7-3-9">
</div>
<div id="outline-container-org2dcf3ef" class="outline-5">
<h5 id="org2dcf3ef">a) Suppose we have the following array:</h5>
<div class="outline-text-5" id="text-org2dcf3ef">
<p>
8 15 3 1 14 23 6 10<br />
We run a short algorithm on it, and the algorithm prints the updated array after each change. If a some point it prints the following, which algorithm is it?<br />
1 3 8 15 6 10 14 23<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgb908feb"></a>解:<br />
<div class="outline-text-6" id="text-orgb908feb">
<p>
答案：Heap Sort（堆排序）<br />
</p>

<p>
該演算法是 Heap Sort (堆排序)，因為在排序過程中，我們觀察到部分區間被整理成堆積 (Heap)，這與 堆排序 (Heap Sort) 逐步重建最大堆 (Max-Heap) 或最小堆 (Min-Heap) 的特性一致。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org151cdf4"></a>📌 詳細解析<br />
<div class="outline-text-7" id="text-org151cdf4">
<p>
我們從輸入陣列：<br />
</p>
<pre class="example" id="org7284319">
8 15 3 1 14 23 6 10
</pre>
<p>
轉換到：<br />
</p>
<pre class="example" id="org9f62ec7">
1 3 8 15 6 10 14 23
</pre>
<p>
這表示：<br />
</p>
<ul class="org-ul">
<li>部分數字已經按照某種規則重新排列。<br /></li>
<li>(1, 3, 8, 15) 看起來是有序的 (可能是最小堆的一部分)。<br /></li>
<li>(6, 10, 14, 23) 可能是另一部分數據，符合最大堆或最小堆的特性。<br /></li>
</ul>
<p>
這與 堆排序 (Heap Sort) 的中途狀態相符，因為在 堆排序過程中，陣列會經歷部分區間有序、部分區間仍然是堆積的狀態。<br />
</p>
</div>
</li>
<li><a id="org14e5591"></a>📌 相關計概知識整理<br />
<div class="outline-text-7" id="text-org14e5591">
<ul class="org-ul">
<li>1️⃣ 堆排序 (Heap Sort) 的步驟<br />
<ul class="org-ul">
<li>堆排序的主要步驟：<br />
<ul class="org-ul">
<li>建立最大堆 (Max-Heap) 或 最小堆 (Min-Heap)。<br /></li>
<li>將堆頂 (最大或最小的元素) 與陣列最後一個元素交換，然後縮小堆的範圍。<br /></li>
<li>對剩餘元素重新調整為堆 (Heapify)，並重複步驟 2，直到排序完成。<br /></li>
</ul></li>
</ul></li>
<li><p>
2️⃣ Heap Sort 的時間複雜度<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">步驟</th>
<th scope="col" class="org-left">時間複雜度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">建堆 (Heapify)</td>
<td class="org-left">O(n)O(n)</td>
</tr>

<tr>
<td class="org-left">排序 (Extract Max/Min &amp; Heapify)</td>
<td class="org-left">O(nlog⁡n)O(nlogn)</td>
</tr>

<tr>
<td class="org-left">總計</td>
<td class="org-left">O(nlog⁡n)O(nlogn)</td>
</tr>
</tbody>
</table>
<p>
堆排序是 不穩定排序 (Unstable Sort)，但它的時間複雜度在最差情況下依然是 O(nlog⁡n)O(nlogn)，與 Quick Sort 相比，Heap Sort 雖然不一定比 Quick Sort 快，但它擁有 最差情況下仍然是 O(nlog⁡n)O(nlogn) 的穩定性，適用於時間要求嚴格的場景，如 即時系統 (Real-Time Systems)。<br />
</p></li>
</ul>
</div>
</li>
<li><a id="org2718930"></a>3️⃣ 其他可能的排序算法？<br />
<div class="outline-text-7" id="text-org2718930">
<ul class="org-ul">
<li>a) Quick Sort<br />
<ul class="org-ul">
<li>快速排序 (Quick Sort) 會使用「分割 (Partitioning)」來遞迴地排序陣列。<br /></li>
<li>但此題顯示的輸出並不符合 Quick Sort 的典型中間狀態。<br /></li>
</ul></li>
<li>b) Merge Sort<br />
<ul class="org-ul">
<li>合併排序 (Merge Sort) 會將陣列拆分成更小的部分，然後合併，但這與這個排序結果並不符合。<br /></li>
</ul></li>
<li>c) Insertion Sort 或 Bubble Sort<br />
<ul class="org-ul">
<li>這些排序方法會逐步調整位置，但不會產生類似堆的排列方式。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org57daf78" class="outline-5">
<h5 id="org57daf78">b) Suppose we have a genearl tree and we want to print it layer by layer. That is, print the root node at first, follow by all nodes at depth 1, then all nodes at depth 2. What strategy should we used?</h5>
<div class="outline-text-5" id="text-org57daf78">
</div>
<ul class="org-ul">
<li><a id="orgc727bcd"></a>解:<br />
<div class="outline-text-6" id="text-orgc727bcd">
<p>
答案：使用廣度優先搜尋 (Breadth-First Search, BFS)<br />
</p>

<p>
若要逐層 (Layer by Layer) 列印一棵一般樹 (General Tree)，應使用 廣度優先搜尋 (BFS, Breadth-First Search)。<br />
BFS 透過 隊列 (Queue) 來確保先輸出較淺的層級，再輸出較深的層級，這與逐層列印的需求完全吻合。<br />
</p>
</div>
</li>
<li><a id="org89fe07e"></a>📌 詳細解析<br />
<ul class="org-ul">
<li><a id="org83ac430"></a>1️⃣ 廣度優先搜尋 (BFS) 的基本概念<br />
<div class="outline-text-7" id="text-org83ac430">
<p>
廣度優先搜尋是一種圖論與樹結構中的搜尋演算法，主要特性包括：<br />
</p>
<ul class="org-ul">
<li>逐層遍歷 (Level Order Traversal)：<br />
<ul class="org-ul">
<li>先拜訪根節點 (Depth = 0)。<br /></li>
<li>再拜訪所有深度為 1 的節點，然後是深度為 2 的節點，依此類推。<br /></li>
</ul></li>
<li>使用佇列 (Queue) 實作：<br />
<ul class="org-ul">
<li>每當取出一個節點，將它的子節點依序加入佇列。<br /></li>
<li>保證較淺的節點總是在較深的節點之前被處理。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org5180dc5"></a>2️⃣ BFS 演算法步驟<br />
<div class="outline-text-7" id="text-org5180dc5">
<p>
假設我們有一棵一般樹 (General Tree)，每個節點可能有多個子節點。<br />
我們可以用 BFS 來逐層列印：<br />
</p>

<p>
📌 BFS 逐層列印演算法<br />
</p>
<ul class="org-ul">
<li>將根節點 (Root) 加入佇列 (Queue)。<br /></li>
<li>當佇列非空時：<br />
<ul class="org-ul">
<li>取出佇列的第一個節點，列印它。<br /></li>
<li>將其所有子節點依序加入佇列。<br /></li>
</ul></li>
<li>重複步驟 2，直到佇列為空。<br /></li>
</ul>
</div>
</li>
<li><a id="org6bd6df5"></a>3️⃣ BFS 逐層列印的 C++ / Python 實作<br />
<div class="outline-text-7" id="text-org6bd6df5">
<p>
C++ 實作<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;vector&gt;</span>
<span class="linenr"> 3: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;queue&gt;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23450;&#32681;&#27193;&#30340;&#31680;&#40670;&#32080;&#27083;</span>
<span class="linenr"> 8: </span><span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">TreeNode</span> {
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">val</span>;
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">TreeNode</span>*&gt; <span style="color: #dcaeea;">children</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23376;&#31680;&#40670;&#21015;&#34920;</span>
<span class="linenr">11: </span>    <span style="color: #c678dd;">TreeNode</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) : val(x) {}
<span class="linenr">12: </span>};
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">BFS &#23652;&#24207;&#36941;&#27511;</span>
<span class="linenr">15: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">levelOrder</span>(<span style="color: #ECBE7B;">TreeNode</span>* <span style="color: #dcaeea;">root</span>) {
<span class="linenr">16: </span>    <span style="color: #51afef;">if</span> (<span style="color: #51afef; font-weight: bold;">!</span>root) <span style="color: #51afef;">return</span>;
<span class="linenr">17: </span>
<span class="linenr">18: </span>    <span style="color: #ECBE7B;">queue</span>&lt;<span style="color: #ECBE7B;">TreeNode</span>*&gt; <span style="color: #dcaeea;">q</span>;
<span class="linenr">19: </span>    q.push(root);
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #51afef;">while</span> (<span style="color: #51afef; font-weight: bold;">!</span>q.empty()) {
<span class="linenr">22: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">levelSize</span> = q.size();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30070;&#21069;&#23652;&#30340;&#31680;&#40670;&#25976;&#37327;</span>
<span class="linenr">23: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; levelSize; i++) {
<span class="linenr">24: </span>            <span style="color: #ECBE7B;">TreeNode</span>* <span style="color: #dcaeea;">node</span> = q.front();
<span class="linenr">25: </span>            q.pop();
<span class="linenr">26: </span>            cout &lt;&lt; node-&gt;val &lt;&lt; <span style="color: #98be65;">" "</span>;
<span class="linenr">27: </span>
<span class="linenr">28: </span>            <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">TreeNode</span>* <span style="color: #dcaeea;">child</span> : node-&gt;children) {
<span class="linenr">29: </span>                q.push(child);
<span class="linenr">30: </span>            }
<span class="linenr">31: </span>        }
<span class="linenr">32: </span>        cout &lt;&lt; endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25563;&#34892;&#34920;&#31034;&#19981;&#21516;&#23652;</span>
<span class="linenr">33: </span>    }
<span class="linenr">34: </span>}
<span class="linenr">35: </span>
<span class="linenr">36: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28204;&#35430;</span>
<span class="linenr">37: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">38: </span>    <span style="color: #ECBE7B;">TreeNode</span>* <span style="color: #dcaeea;">root</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">TreeNode</span>(<span style="color: #da8548; font-weight: bold;">1</span>);
<span class="linenr">39: </span>    root-&gt;children.push_back(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">TreeNode</span>(<span style="color: #da8548; font-weight: bold;">2</span>));
<span class="linenr">40: </span>    root-&gt;children.push_back(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">TreeNode</span>(<span style="color: #da8548; font-weight: bold;">3</span>));
<span class="linenr">41: </span>    root-&gt;children.push_back(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">TreeNode</span>(<span style="color: #da8548; font-weight: bold;">4</span>));
<span class="linenr">42: </span>
<span class="linenr">43: </span>    root-&gt;children[<span style="color: #da8548; font-weight: bold;">0</span>]-&gt;children.push_back(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">TreeNode</span>(<span style="color: #da8548; font-weight: bold;">5</span>));
<span class="linenr">44: </span>    root-&gt;children[<span style="color: #da8548; font-weight: bold;">0</span>]-&gt;children.push_back(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">TreeNode</span>(<span style="color: #da8548; font-weight: bold;">6</span>));
<span class="linenr">45: </span>    root-&gt;children[<span style="color: #da8548; font-weight: bold;">1</span>]-&gt;children.push_back(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">TreeNode</span>(<span style="color: #da8548; font-weight: bold;">7</span>));
<span class="linenr">46: </span>
<span class="linenr">47: </span>    levelOrder(root);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38928;&#26399;&#36664;&#20986; 1 \n 2 3 4 \n 5 6 7</span>
<span class="linenr">48: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">49: </span>}
</pre>
</div>
<p>
Python 實作<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">from</span> collections <span style="color: #51afef;">import</span> deque
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">TreeNode</span>:
<span class="linenr"> 4: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__init__</span>(<span style="color: #51afef;">self</span>, val):
<span class="linenr"> 5: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">val</span> = val
<span class="linenr"> 6: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">children</span> = []
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">level_order</span>(root):
<span class="linenr"> 9: </span>    <span style="color: #51afef;">if</span> <span style="color: #51afef;">not</span> root:
<span class="linenr">10: </span>        <span style="color: #51afef;">return</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #dcaeea;">queue</span> = deque([root])
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #51afef;">while</span> queue:
<span class="linenr">15: </span>        <span style="color: #dcaeea;">level_size</span> = <span style="color: #c678dd;">len</span>(queue)
<span class="linenr">16: </span>        <span style="color: #51afef;">for</span> _ <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(level_size):
<span class="linenr">17: </span>            <span style="color: #dcaeea;">node</span> = queue.popleft()
<span class="linenr">18: </span>            <span style="color: #c678dd;">print</span>(node.val, end=<span style="color: #98be65;">" "</span>)
<span class="linenr">19: </span>            queue.extend(node.children)
<span class="linenr">20: </span>        <span style="color: #c678dd;">print</span>()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#25563;&#34892;&#34920;&#31034;&#19981;&#21516;&#23652;</span>
<span class="linenr">21: </span>
<span class="linenr">22: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#28204;&#35430;</span>
<span class="linenr">23: </span><span style="color: #dcaeea;">root</span> = TreeNode(<span style="color: #da8548; font-weight: bold;">1</span>)
<span class="linenr">24: </span>root.<span style="color: #dcaeea;">children</span> = [TreeNode(<span style="color: #da8548; font-weight: bold;">2</span>), TreeNode(<span style="color: #da8548; font-weight: bold;">3</span>), TreeNode(<span style="color: #da8548; font-weight: bold;">4</span>)]
<span class="linenr">25: </span>root.children[<span style="color: #da8548; font-weight: bold;">0</span>].<span style="color: #dcaeea;">children</span> = [TreeNode(<span style="color: #da8548; font-weight: bold;">5</span>), TreeNode(<span style="color: #da8548; font-weight: bold;">6</span>)]
<span class="linenr">26: </span>root.children[<span style="color: #da8548; font-weight: bold;">1</span>].<span style="color: #dcaeea;">children</span> = [TreeNode(<span style="color: #da8548; font-weight: bold;">7</span>)]
<span class="linenr">27: </span>
<span class="linenr">28: </span>level_order(root)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#38928;&#26399;&#36664;&#20986; 1 \n 2 3 4 \n 5 6 7</span>
</pre>
</div>
</div>
</li>
<li><a id="org019932a"></a>4️⃣ BFS vs. DFS (深度優先搜尋)<br />
<div class="outline-text-7" id="text-org019932a">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">廣度優先搜尋 (BFS)</th>
<th scope="col" class="org-left">深度優先搜尋 (DFS)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">遍歷順序</td>
<td class="org-left">層序遍歷 (Layer-by-layer)</td>
<td class="org-left">走到最深再回溯</td>
</tr>

<tr>
<td class="org-left">使用資料結構</td>
<td class="org-left">佇列 (Queue)</td>
<td class="org-left">堆疊 (Stack) 或遞迴</td>
</tr>

<tr>
<td class="org-left">適用情境</td>
<td class="org-left">找最短路徑、層序遍歷</td>
<td class="org-left">探索完整路徑、樹的遍歷</td>
</tr>
</tbody>
</table>
<p>
如果我們改用 DFS，則不會逐層列印，而是沿著樹的深度優先遍歷，這與題目需求不同。<br />
</p>
</div>
</li>
<li><a id="org767cdfc"></a>5️⃣ BFS 時間與空間複雜度<br />
<div class="outline-text-7" id="text-org767cdfc">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">操作</td>
<td class="org-left">時間複雜度</td>
<td class="org-left">空間複雜度</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">BFS 層序遍歷</td>
<td class="org-left">O(N)O(N)</td>
<td class="org-left">O(N)O(N)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>時間複雜度：<br />
<ul class="org-ul">
<li>每個節點最多被訪問一次，因此是 O(N)O(N)。<br /></li>
</ul></li>
<li>空間複雜度：<br />
<ul class="org-ul">
<li>佇列的大小在最糟情況下是樹中最寬的一層 (通常 O(N)O(N))。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org561b4bc"></a>📌 結論<br />
<div class="outline-text-6" id="text-org561b4bc">
<ul class="org-ul">
<li>適用策略：<br />
<ul class="org-ul">
<li>逐層遍歷樹時，使用 BFS (廣度優先搜尋) 是最佳策略。<br /></li>
</ul></li>
<li>實作方式：<br />
<ul class="org-ul">
<li>使用佇列 (Queue) 來確保按層遍歷，先處理淺層節點，再處理深層節點。<br /></li>
</ul></li>
<li>BFS 的優勢：<br />
<ul class="org-ul">
<li>時間複雜度 O(N)O(N)<br /></li>
<li>適合最短路徑搜尋、圖遍歷、層序遍歷<br /></li>
</ul></li>
<li>與 DFS (深度優先搜尋) 的區別：<br />
<ul class="org-ul">
<li>DFS 探索完一條路徑才回溯，無法逐層遍歷。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbf690a8" class="outline-5">
<h5 id="orgbf690a8">c) Suppose a CPU uses 8 bytes for its memory addresses. How many bytes of memory can it address?</h5>
<div class="outline-text-5" id="text-orgbf690a8">
</div>
<ul class="org-ul">
<li><a id="orgc127d15"></a>解：<br />
<div class="outline-text-6" id="text-orgc127d15">
<p>
答案：\(2^{64}\) bytes (約 16 exabytes, EB)<br />
</p>
</div>
</li>
<li><a id="org19bf489"></a>📌 詳細解析<br />
<div class="outline-text-6" id="text-org19bf489">
<ul class="org-ul">
<li>當 CPU 使用 8 個位元組 (bytes) 來存儲記憶體位址時，表示它的位址總寬度 (Address Width) 為 8 × 8 = 64 bits。<br /></li>
<li>這表示 CPU 的位址範圍是：264 個位址<br /></li>
</ul>

<p>
由於每個位址指向 1 個 byte，所以最多能存取的記憶體空間為：<br />
264 bytes=16 exabytes (EB)<br />
</p>
</div>
</li>
<li><a id="orgd903c12"></a>📌 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="orgd4e788c"></a>1️⃣ 記憶體尋址 (Memory Addressing)<br />
<div class="outline-text-7" id="text-orgd4e788c">
<p>
在電腦架構中，CPU 使用位址匯流排 (Address Bus) 來存取記憶體，每個位址存儲 1 個 byte (位元組)。<br />
如果 CPU 的位址長度是 nn 位元 (bits)，則它最多可以尋址：<br />
2^n bytes<br />
</p>

<p>
常見 CPU 位址長度：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">位址寬度 (bits)</th>
<th scope="col" class="org-left">可尋址記憶體 (bytes)</th>
<th scope="col" class="org-left">記憶體單位</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">16-bit</td>
<td class="org-left">2^16=65,536</td>
<td class="org-left">64 KB</td>
</tr>

<tr>
<td class="org-left">32-bit</td>
<td class="org-left">2^32=4,294,967,296</td>
<td class="org-left">4 GB</td>
</tr>

<tr>
<td class="org-left">64-bit</td>
<td class="org-left">2^64=18,446,744,073,709,551,616</td>
<td class="org-left">16 EB</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org8e609d7"></a>2️⃣ 64 位元 CPU 對記憶體的影響<br />
<div class="outline-text-7" id="text-org8e609d7">
<p>
理論上，64-bit CPU 可尋址 16EB 記憶體，但實際上受限於作業系統與硬體設計：<br />
</p>
<ul class="org-ul">
<li>Windows 10 Home：最大支援 128GB RAM。<br /></li>
<li>Windows 10 Pro / Server：最大支援 2TB RAM。<br /></li>
<li>Linux (x86_64 Kernel)：最大支援 4PB (Petabytes, 1024 TB)。<br /></li>
</ul>
<p>
為何實際系統無法達到 16EB？<br />
</p>
<ul class="org-ul">
<li>主機板與硬體限制：大多數主機板只支援數百 GB 至數 TB 的 RAM。<br /></li>
<li>記憶體管理：作業系統使用分頁技術 (paging) 來管理記憶體，而分頁表也會佔據大量空間。<br /></li>
<li>位址映射 (Address Mapping)：64-bit 位址空間會用於記憶體映射 I/O (MMIO)，因此不全都可用於 RAM。<br /></li>
</ul>
</div>
</li>
<li><a id="org46d64d8"></a>3️⃣ 為何 64-bit CPU 需要這麼大的位址空間？<br />
<div class="outline-text-7" id="text-org46d64d8">
<ul class="org-ul">
<li>支援更多記憶體 (Larger RAM Support)<br />
<ul class="org-ul">
<li>32-bit CPU 受限於 4GB 記憶體，無法支援大型應用 (如資料庫、影像處理、AI)。<br /></li>
<li>64-bit CPU 可支援遠大於 4GB 的記憶體空間，適合高效能運算。<br /></li>
</ul></li>
<li>記憶體隔離 (Memory Isolation)<br />
<ul class="org-ul">
<li>64-bit 架構允許更大的虛擬記憶體空間，使得應用程式彼此隔離，提高安全性。<br /></li>
</ul></li>
<li>更大位址空間可用於其他用途<br />
<ul class="org-ul">
<li>除了 RAM，作業系統還會將位址空間用於：<br />
<ul class="org-ul">
<li>記憶體映射 I/O (Memory-Mapped I/O, MMIO)。<br /></li>
<li>分頁表 (Page Tables)。<br /></li>
<li>作業系統核心與驅動程式。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0030561"></a>4️⃣ 為什麼 8-byte 位址長度表示 64-bit CPU？<br />
<div class="outline-text-7" id="text-org0030561">
<ul class="org-ul">
<li>1 byte = 8 bits，所以 8-byte 位址表示每個記憶體位址是 64 bits。<br /></li>
<li>這與 x86_64 架構 (Intel &amp; AMD) 一致，使得 CPU 能直接存取 64-bit 位址。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org436defe"></a>📌 結論<br />
<div class="outline-text-6" id="text-org436defe">
<ul class="org-ul">
<li>如果 CPU 使用 8 bytes (64 bits) 來存儲記憶體位址，它最多可以尋址 264264 bytes = 16 exabytes (EB) 記憶體。<br /></li>
<li>但實際上，因為硬體與作業系統限制，64-bit CPU 很少能真正使用 16EB 記憶體，目前大多支援數百 GB 至數 TB。<br /></li>
<li>64-bit 位址架構主要是為了擴展記憶體、提升效能與安全性。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2fdcc83" class="outline-5">
<h5 id="org2fdcc83">d) Suppose you are asked to develop a text editor and you want to implement an &ldquo;undo&rdquo; feature. What data structure should you use in this case?</h5>
<div class="outline-text-5" id="text-org2fdcc83">
</div>
<ul class="org-ul">
<li><a id="org777a373"></a>解<br />
<div class="outline-text-6" id="text-org777a373">
<p>
答案：使用「堆疊 (Stack)」實作 Undo 功能<br />
</p>

<p>
在開發文字編輯器 (Text Editor) 時，若要實作 「Undo (復原)」功能，最佳的資料結構是 「堆疊 (Stack)」。<br />
</p>
</div>
</li>
<li><a id="orgf8a7f92"></a>📌 詳細解析<br />
<ul class="org-ul">
<li><a id="orgf9692f5"></a>1️⃣ 為什麼使用「堆疊 (Stack)」？<br />
<div class="outline-text-7" id="text-orgf9692f5">
<p>
「Undo (復原)」的特性是：<br />
</p>
<ul class="org-ul">
<li>只有最新的操作能夠最先被撤銷 (LIFO, Last-In-First-Out)。<br /></li>
<li>操作歷史需要按順序儲存，並且需要能夠回到上一個狀態。<br /></li>
</ul>

<p>
這與 堆疊 (Stack) 的「後進先出 (LIFO, Last-In-First-Out)」特性完全匹配，因此 堆疊是最適合的資料結構。<br />
</p>
</div>
</li>
<li><a id="org4754958"></a>2️⃣ 堆疊 (Stack) 如何運作 Undo 功能<br />
<div class="outline-text-7" id="text-org4754958">
<p>
假設我們有一個文字編輯器，每次修改內容時，我們都將變更「推入 (push)」堆疊中：<br />
</p>
<ul class="org-ul">
<li>使用者編輯文字：「Hello」 → 「Hello, World!」<br />
<ul class="org-ul">
<li>Push &ldquo;Hello&rdquo; 到堆疊<br /></li>
<li>當前文字：&ldquo;Hello, World!&rdquo;<br /></li>
</ul></li>
<li>使用者按下 Undo<br />
<ul class="org-ul">
<li>Pop 堆疊，回復 &ldquo;Hello&rdquo;<br /></li>
<li>當前文字變為 &ldquo;Hello&rdquo;<br /></li>
</ul></li>
</ul>
<p>
這樣，每次 Undo，就能回到上一個狀態。<br />
</p>
</div>
</li>
<li><a id="org17750d3"></a>3️⃣ 具體的 Undo/Redo 機制<br />
<div class="outline-text-7" id="text-org17750d3">
<p>
如果還需要支援 Redo (重做)，我們可以使用「兩個堆疊」：<br />
</p>
<ul class="org-ul">
<li>undoStack：存放「可復原的動作」。<br /></li>
<li>redoStack：當執行 Undo 時，把已復原的狀態放進 redoStack，方便之後重做。<br /></li>
</ul>

<p>
🔹 步驟<br />
</p>
<ol class="org-ol">
<li>用戶進行變更 → undoStack.push(狀態)，清空 redoStack<br /></li>
<li>使用者按 Undo：<br />
<ul class="org-ul">
<li>undoStack.pop() → 取得上一步狀態<br /></li>
<li>redoStack.push(當前狀態) → 保存當前狀態以供 Redo<br /></li>
</ul></li>
<li>使用者按 Redo：<br />
<ul class="org-ul">
<li>redoStack.pop() → 取得 Redo 狀態<br /></li>
<li>undoStack.push(當前狀態) → 重新記錄<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orgc820991"></a>4️⃣ 相關程式碼<br />
<div class="outline-text-7" id="text-orgc820991">
<p>
C++ 版本<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stack&gt;</span>
<span class="linenr"> 3: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;string&gt;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #ECBE7B;">stack</span>&lt;<span style="color: #ECBE7B;">string</span>&gt; <span style="color: #dcaeea;">undoStack</span>, <span style="color: #dcaeea;">redoStack</span>;
<span class="linenr"> 8: </span><span style="color: #ECBE7B;">string</span> <span style="color: #dcaeea;">text</span> = <span style="color: #98be65;">""</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30446;&#21069;&#32232;&#36655;&#22120;&#20839;&#23481;</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">typeText</span>(<span style="color: #ECBE7B;">string</span> <span style="color: #dcaeea;">newText</span>) {
<span class="linenr">11: </span>    undoStack.push(text); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20786;&#23384;&#30070;&#21069;&#29376;&#24907;</span>
<span class="linenr">12: </span>    text = newText;
<span class="linenr">13: </span>    <span style="color: #51afef;">while</span> (<span style="color: #51afef; font-weight: bold;">!</span>redoStack.empty()) redoStack.pop(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28165;&#31354; redoStack</span>
<span class="linenr">14: </span>}
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">undo</span>() {
<span class="linenr">17: </span>    <span style="color: #51afef;">if</span> (<span style="color: #51afef; font-weight: bold;">!</span>undoStack.empty()) {
<span class="linenr">18: </span>        redoStack.push(text); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23559;&#30070;&#21069;&#29376;&#24907;&#23384;&#20837; redo</span>
<span class="linenr">19: </span>        text = undoStack.top();
<span class="linenr">20: </span>        undoStack.pop();
<span class="linenr">21: </span>    }
<span class="linenr">22: </span>}
<span class="linenr">23: </span>
<span class="linenr">24: </span><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">redo</span>() {
<span class="linenr">25: </span>    <span style="color: #51afef;">if</span> (<span style="color: #51afef; font-weight: bold;">!</span>redoStack.empty()) {
<span class="linenr">26: </span>        undoStack.push(text); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23559;&#30070;&#21069;&#29376;&#24907;&#23384;&#20837; undo</span>
<span class="linenr">27: </span>        text = redoStack.top();
<span class="linenr">28: </span>        redoStack.pop();
<span class="linenr">29: </span>    }
<span class="linenr">30: </span>}
<span class="linenr">31: </span>
<span class="linenr">32: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">33: </span>    typeText(<span style="color: #98be65;">"Hello"</span>);
<span class="linenr">34: </span>    typeText(<span style="color: #98be65;">"Hello, World!"</span>);
<span class="linenr">35: </span>    cout &lt;&lt; <span style="color: #98be65;">"Current Text: "</span> &lt;&lt; text &lt;&lt; endl; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Hello, World!</span>
<span class="linenr">36: </span>
<span class="linenr">37: </span>    undo();
<span class="linenr">38: </span>    cout &lt;&lt; <span style="color: #98be65;">"After Undo: "</span> &lt;&lt; text &lt;&lt; endl; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Hello</span>
<span class="linenr">39: </span>
<span class="linenr">40: </span>    redo();
<span class="linenr">41: </span>    cout &lt;&lt; <span style="color: #98be65;">"After Redo: "</span> &lt;&lt; text &lt;&lt; endl; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Hello, World!</span>
<span class="linenr">42: </span>
<span class="linenr">43: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">44: </span>}
</pre>
</div>
<p>
Python 版本<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">TextEditor</span>:
<span class="linenr"> 2: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__init__</span>(<span style="color: #51afef;">self</span>):
<span class="linenr"> 3: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">text</span> = <span style="color: #98be65;">""</span>
<span class="linenr"> 4: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">undoStack</span> = []
<span class="linenr"> 5: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">redoStack</span> = []
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">typeText</span>(<span style="color: #51afef;">self</span>, new_text):
<span class="linenr"> 8: </span>        <span style="color: #51afef;">self</span>.undoStack.append(<span style="color: #51afef;">self</span>.text)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#20786;&#23384;&#30070;&#21069;&#29376;&#24907;</span>
<span class="linenr"> 9: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">text</span> = new_text
<span class="linenr">10: </span>        <span style="color: #51afef;">self</span>.redoStack.clear()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#28165;&#31354; redoStack</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">undo</span>(<span style="color: #51afef;">self</span>):
<span class="linenr">13: </span>        <span style="color: #51afef;">if</span> <span style="color: #51afef;">self</span>.undoStack:
<span class="linenr">14: </span>            <span style="color: #51afef;">self</span>.redoStack.append(<span style="color: #51afef;">self</span>.text)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#30446;&#21069;&#29376;&#24907;&#23384;&#20837; redoStack</span>
<span class="linenr">15: </span>            <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">text</span> = <span style="color: #51afef;">self</span>.undoStack.pop()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#22238;&#24489;&#19978;&#19968;&#27493;</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">redo</span>(<span style="color: #51afef;">self</span>):
<span class="linenr">18: </span>        <span style="color: #51afef;">if</span> <span style="color: #51afef;">self</span>.redoStack:
<span class="linenr">19: </span>            <span style="color: #51afef;">self</span>.undoStack.append(<span style="color: #51afef;">self</span>.text)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#30446;&#21069;&#29376;&#24907;&#23384;&#20837; undoStack</span>
<span class="linenr">20: </span>            <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">text</span> = <span style="color: #51afef;">self</span>.redoStack.pop()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#24674;&#24489; redo &#29376;&#24907;</span>
<span class="linenr">21: </span>
<span class="linenr">22: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#28204;&#35430;</span>
<span class="linenr">23: </span><span style="color: #dcaeea;">editor</span> = TextEditor()
<span class="linenr">24: </span>editor.typeText(<span style="color: #98be65;">"Hello"</span>)
<span class="linenr">25: </span>editor.typeText(<span style="color: #98be65;">"Hello, World!"</span>)
<span class="linenr">26: </span><span style="color: #c678dd;">print</span>(<span style="color: #98be65;">"Current Text:"</span>, editor.text)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Hello, World!</span>
<span class="linenr">27: </span>
<span class="linenr">28: </span>editor.undo()
<span class="linenr">29: </span><span style="color: #c678dd;">print</span>(<span style="color: #98be65;">"After Undo:"</span>, editor.text)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Hello</span>
<span class="linenr">30: </span>
<span class="linenr">31: </span>editor.redo()
<span class="linenr">32: </span><span style="color: #c678dd;">print</span>(<span style="color: #98be65;">"After Redo:"</span>, editor.text)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Hello, World!</span>
</pre>
</div>
</div>
</li>
<li><a id="org8793ccb"></a>5️⃣ 時間與空間複雜度<br />
<div class="outline-text-7" id="text-org8793ccb">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">操作</th>
<th scope="col" class="org-left">時間複雜度</th>
<th scope="col" class="org-left">空間複雜度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Push (typeText)</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(n)</td>
</tr>

<tr>
<td class="org-left">Pop (Undo / Redo)</td>
<td class="org-left">O(1)</td>
<td class="org-left">O(n)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>時間複雜度 (Time Complexity)：因為 push() 和 pop() 皆為 O(1)O(1) 操作，Undo 和 Redo 速度極快。<br /></li>
<li>空間複雜度 (Space Complexity)：每個操作都會儲存一次完整狀態，若歷史操作非常多，則記憶體使用量約為 O(n)O(n)。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org23f02d0"></a>6️⃣ 其他可能的資料結構<br />
<ul class="org-ul">
<li><a id="org959a182"></a>(1) 連結串列 (Doubly Linked List)<br />
<div class="outline-text-7" id="text-org959a182">
<ul class="org-ul">
<li>適合場景：當編輯器支援「多步撤銷」，且需要節省記憶體時。<br /></li>
<li>作法：每次變更時，新增一個節點並雙向連接 (支援前後移動)。<br /></li>
<li>優勢：<br />
<ul class="org-ul">
<li>只需儲存「變更」，而非完整內容，節省記憶體。<br /></li>
<li>可從當前狀態直接回復到前一步或後一步。<br /></li>
</ul></li>
<li>劣勢：<br />
<ul class="org-ul">
<li>相較於 Stack，設計更複雜。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc22f35d"></a>(2) 永續資料結構 (Persistent Data Structures)<br />
<div class="outline-text-7" id="text-orgc22f35d">
<ul class="org-ul">
<li>適合場景：高效能編輯器，如 VS Code。<br /></li>
<li>作法：<br />
<ul class="org-ul">
<li>使用 Immutable Data Structures (如函數式編程中的持久性樹結構)。<br /></li>
<li>只存儲「變更」，而非完整狀態。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org009f624"></a>📌 總結<br />
<div class="outline-text-6" id="text-org009f624">
<ul class="org-ul">
<li>「Undo」功能的最佳資料結構是「堆疊 (Stack)」。<br /></li>
<li>使用兩個堆疊 (undoStack, redoStack) 可以同時支援「Undo / Redo」。<br /></li>
<li>時間複雜度 O(1)O(1)，空間複雜度 O(n)O(n)，可高效運行。<br /></li>
<li>若需節省記憶體，可改用「雙向連結串列 (Doubly Linked List)」或「永續資料結構 (Persistent Data Structure)」。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org29c5579" class="outline-5">
<h5 id="org29c5579">e) Write the 1-byte hex number A7 in binary, in unsigned decimal number, and in signed decimal number.</h5>
<div class="outline-text-5" id="text-org29c5579">
</div>
<ul class="org-ul">
<li><a id="org21a3ac3"></a>解<br />
<div class="outline-text-6" id="text-org21a3ac3">
<p>
答案<br />
</p>

<p>
給定 1-byte (8-bit) 十六進位數 A7，我們將其轉換為 二進位 (binary)、無符號整數 (unsigned decimal)、有符號整數 (signed decimal)。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">格式</th>
<th scope="col" class="org-right">值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">十六進位 (Hex)</td>
<td class="org-right">A7</td>
</tr>

<tr>
<td class="org-left">二進位 (Binary)</td>
<td class="org-right">10100111</td>
</tr>

<tr>
<td class="org-left">無符號整數 (Unsigned Decimal)</td>
<td class="org-right">167</td>
</tr>

<tr>
<td class="org-left">有符號整數 (Signed Decimal, 2&rsquo;s complement)</td>
<td class="org-right">-89</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org0507784"></a>📌 詳細解析<br />
<ul class="org-ul">
<li><a id="org5691670"></a>1️⃣ 十六進位 → 二進位<br />
<div class="outline-text-7" id="text-org5691670">
<p>
十六進位 (Hex) A7 轉換為二進位 (Binary)：<br />
</p>
<ul class="org-ul">
<li>A (十六進位) = 1010 (二進位)<br /></li>
<li>7 (十六進位) = 0111 (二進位)<br /></li>
</ul>

<p>
因此：<br />
</p>
<pre class="example" id="org1e4adf9">
A7 (Hex) = 1010 0111 (Binary)
</pre>
</div>
</li>
<li><a id="org2a7a374"></a>2️⃣ 無符號整數 (Unsigned Decimal)<br />
<div class="outline-text-7" id="text-org2a7a374">
<p>
在無符號整數 (Unsigned Integer) 表示法中，10100111 的值計算如下：<br />
1×2^7+0×2^6+1×2^5+0×2^4+0×2^3+1×2^2+1×2^1+1×2^0<br />
=128+32+4+2+1=167<br />
</p>

<p>
所以，無符號整數表示：<br />
</p>
<pre class="example" id="orgd921971">
A7 (Hex) = 167 (Unsigned Decimal)
</pre>
</div>
</li>
<li><a id="orgcb3af28"></a>3️⃣ 有符號整數 (Signed Decimal, Two&rsquo;s Complement)<br />
<div class="outline-text-7" id="text-orgcb3af28">
<p>
在有符號整數 (Signed Integer, 二補數) 表示法中：<br />
</p>
<ul class="org-ul">
<li>A7 的最高位 (1) 代表「負數」(Negative)。<br /></li>
<li>計算負數的方法：<br />
<ol class="org-ol">
<li>取反 (Invert)： 10100111 → 01011000<br /></li>
<li>加 1：01011000 + 1 = 01011001 (即 89)<br /></li>
<li>加上負號，結果為 -89。<br /></li>
</ol></li>
</ul>

<p>
所以，有符號整數表示：A7 (Hex) = -89 (Signed Decimal)<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgbf03952"></a>📌 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="org35e05d1"></a>1️⃣ 整數表示方式<br />
<div class="outline-text-7" id="text-org35e05d1">
<p>
在計算機系統中，1-byte (8-bit) 可以表示：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">表示法</th>
<th scope="col" class="org-left">範圍</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">無符號整數 (Unsigned Integer)</td>
<td class="org-left">0 ~ 255</td>
</tr>

<tr>
<td class="org-left">有符號整數 (Signed Integer, Two’s Complement)</td>
<td class="org-left">-128 ~ 127</td>
</tr>
</tbody>
</table>

<p>
二補數 (Two&rsquo;s Complement)：<br />
</p>
<ul class="org-ul">
<li>最高位 (MSB) 是 符號位 (0 = 正數, 1 = 負數)。<br /></li>
<li>計算負數時，需要 取補數 (Complement) + 1。<br /></li>
</ul>
</div>
</li>
<li><a id="orgbc8f842"></a>2️⃣ 二補數 (Two’s Complement) 運算<br />
<div class="outline-text-7" id="text-orgbc8f842">
<p>
為什麼使用二補數？<br />
</p>
<ul class="org-ul">
<li>統一加減法運算：減法可視為加法 (x - y 等價於 x + (-y))。<br /></li>
<li>減少硬體電路的複雜性。<br /></li>
<li>避免「雙零問題」(One’s Complement 問題)，例如 00000000 (正 0) 和 11111111 (負 0)。<br /></li>
</ul>
</div>
</li>
<li><a id="org9550084"></a>3️⃣ 轉換範例<br />
<div class="outline-text-7" id="text-org9550084">
<p>
假設有一個 8-bit 數：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Hex</th>
<th scope="col" class="org-right">Binary</th>
<th scope="col" class="org-right">Unsigned Decimal</th>
<th scope="col" class="org-right">Signed Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">7F</td>
<td class="org-right">01111111</td>
<td class="org-right">127</td>
<td class="org-right">127</td>
</tr>

<tr>
<td class="org-left">80</td>
<td class="org-right">10000000</td>
<td class="org-right">128</td>
<td class="org-right">-128</td>
</tr>

<tr>
<td class="org-left">FF</td>
<td class="org-right">11111111</td>
<td class="org-right">255</td>
<td class="org-right">-1</td>
</tr>

<tr>
<td class="org-left">A7</td>
<td class="org-right">10100111</td>
<td class="org-right">167</td>
<td class="org-right">-89</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
<li><a id="org6062217"></a>📌 總結<br />
<div class="outline-text-6" id="text-org6062217">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">格式</th>
<th scope="col" class="org-right">值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">十六進位 (Hex)</td>
<td class="org-right">A7</td>
</tr>

<tr>
<td class="org-left">二進位 (Binary)</td>
<td class="org-right">10100111</td>
</tr>

<tr>
<td class="org-left">無符號整數 (Unsigned Decimal)</td>
<td class="org-right">167</td>
</tr>

<tr>
<td class="org-left">有符號整數 (Signed Decimal, Two’s Complement)</td>
<td class="org-right">-89</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org37731fd" class="outline-5">
<h5 id="org37731fd">f) Suppose we have an array that is mostly sorted. Wyould insertion sort or selection sort be better, or would they have the same performance to obtain a totally sorted array? Why?</h5>
<div class="outline-text-5" id="text-org37731fd">
</div>
<ul class="org-ul">
<li><a id="org0dc4a18"></a>解<br />
<div class="outline-text-6" id="text-org0dc4a18">
<p>
答案：Insertion Sort 會比 Selection Sort 更快<br />
</p>

<p>
對於「幾乎排序好的陣列 (Mostly Sorted Array)」，Insertion Sort (插入排序) 會優於 Selection Sort (選擇排序)，因為 Insertion Sort 在最佳情況下能達到 O(n)O(n) 的時間複雜度，而 Selection Sort 總是 O(n2)O(n2)。<br />
</p>
</div>
</li>
<li><a id="org2e3d270"></a>📌 詳細解析<br />
<ul class="org-ul">
<li><a id="org658e47f"></a>1️⃣ Insertion Sort vs. Selection Sort<br />
<ul class="org-ul">
<li><a id="orgf6fdfc2"></a>📌 Insertion Sort（插入排序）<br />
<div class="outline-text-8" id="text-orgf6fdfc2">
<p>
基本原理：<br />
</p>
<ul class="org-ul">
<li>將數列分成「已排序部分」與「未排序部分」。<br /></li>
<li>逐一將未排序的元素插入到正確位置。<br /></li>
</ul>
<p>
時間複雜度：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">狀況</th>
<th scope="col" class="org-left">時間複雜度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">最壞情況 (逆序排列)</td>
<td class="org-left">O(n2)O(n2)</td>
</tr>

<tr>
<td class="org-left">最理想情況 (幾乎排序好)</td>
<td class="org-left">O(n)O(n)</td>
</tr>
</tbody>
</table>
<p>
特性：<br />
</p>
<ul class="org-ul">
<li>當陣列幾乎排序時，每個元素只需少量移動，接近 O(n)O(n) 時間複雜度。<br /></li>
<li>穩定排序 (Stable Sort)，相同數值的順序不變。<br /></li>
</ul>
</div>
</li>
<li><a id="org6efae16"></a>📌 Selection Sort（選擇排序）<br />
<div class="outline-text-8" id="text-org6efae16">
<p>
基本原理：<br />
</p>
<ul class="org-ul">
<li>在未排序部分找到最小元素，與目前最左側元素交換。<br /></li>
<li>持續進行，直到數列完全排序。<br /></li>
</ul>
<p>
時間複雜度：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">狀況</th>
<th scope="col" class="org-left">時間複雜度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">任何情況</td>
<td class="org-left">O(n2)O(n2)</td>
</tr>
</tbody>
</table>
<p>
特性：<br />
</p>
<ul class="org-ul">
<li>無論是否幾乎排序，都會進行 O(n2)O(n2) 次比較，因此無法利用幾乎排序好的特性來加速。<br /></li>
<li>不穩定排序 (Unstable Sort)，相同數值的相對順序可能改變。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org3834135"></a>2️⃣ 為何 Insertion Sort 更適合幾乎排序好的陣列？<br />
<div class="outline-text-7" id="text-org3834135">
<p>
在「幾乎排序」的情況下：<br />
</p>
<ul class="org-ul">
<li>Insertion Sort 每個元素只需少量位移<br />
<ul class="org-ul">
<li>Insertion Sort 只會在「錯位的部分」做小幅調整。<br /></li>
<li>如果每個元素只移動 kk 個位置，時間複雜度變成 O(nk)O(nk)，接近 O(n)O(n) 時間。<br /></li>
</ul></li>
<li>Selection Sort 無法受益於已排序性<br />
<ul class="org-ul">
<li>即使陣列已幾乎排序，Selection Sort 仍然要進行 O(n2)O(n2) 的比較，因為它總是尋找最小值，而不是考慮元素是否已接近正確位置。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc0a396a"></a>3️⃣ 具體範例<br />
<div class="outline-text-7" id="text-orgc0a396a">
<p>
📌 測試陣列<br />
</p>
<pre class="example" id="orgfd6b95b">
A = [1, 2, 3, 5, 4, 6, 7, 8]  // 幾乎排序完成
</pre>
<p>
📌 Insertion Sort 步驟<br />
</p>
<ol class="org-ol">
<li>1, 2, 3 (已排序)<br /></li>
<li>處理 5 (無須變動)<br /></li>
<li>處理 4：<br /></li>
<li>4 需要移動到 3 之後，執行 1 次移動。<br /></li>
<li>6, 7, 8 (無須變動)<br /></li>
<li>總計只做 1 次位移 → 時間接近 O(n)O(n)。<br /></li>
</ol>
<p>
📌 Selection Sort 步驟<br />
</p>
<ul class="org-ul">
<li>無論是否幾乎排序，仍然需要比較所有元素：<br />
<ul class="org-ul">
<li>找到最小值 → 交換<br /></li>
<li>找到次小值 → 交換<br /></li>
<li>這樣的步驟持續進行，直到結束。<br /></li>
</ul></li>
<li>總計 O(n2)O(n2) 的比較與交換 → 時間無法優化。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org0541517"></a>📌 相關計概知識整理<br />
<ul class="org-ul">
<li><a id="org60794d3"></a>1️⃣ Insertion Sort (插入排序)<br />
<div class="outline-text-7" id="text-org60794d3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">最佳情況時間</td>
<td class="org-left">O(n)O(n) (幾乎排序時)</td>
</tr>

<tr>
<td class="org-left">最壞情況時間</td>
<td class="org-left">O(n2)O(n2)</td>
</tr>

<tr>
<td class="org-left">穩定性</td>
<td class="org-left">穩定排序 (Stable)</td>
</tr>

<tr>
<td class="org-left">適合場景</td>
<td class="org-left">陣列幾乎排序、線上排序 (Online Sorting)</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org9c96f00"></a>2️⃣ Selection Sort (選擇排序)<br />
<div class="outline-text-7" id="text-org9c96f00">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">最佳情況時間</td>
<td class="org-left">O(n2)O(n2)</td>
</tr>

<tr>
<td class="org-left">最壞情況時間</td>
<td class="org-left">O(n2)O(n2)</td>
</tr>

<tr>
<td class="org-left">穩定性</td>
<td class="org-left">不穩定排序 (Unstable)</td>
</tr>

<tr>
<td class="org-left">適合場景</td>
<td class="org-left">小型資料集，或不考慮最佳化時</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgd833369"></a>3️⃣ 何時選擇 Insertion Sort？<br />
<div class="outline-text-7" id="text-orgd833369">
<ul class="org-ul">
<li>幾乎排序的陣列 → 因為 Insertion Sort 可以達到 O(n)O(n)<br /></li>
<li>小型資料集 (N &lt; 1000) → 簡單、快、不需要額外記憶體<br /></li>
<li>線上排序 (Online Sorting) → Insertion Sort 可以一邊讀取數據一邊排序<br /></li>
</ul>
</div>
</li>
<li><a id="org7bab799"></a>4️⃣ 何時選擇 Selection Sort？<br />
<div class="outline-text-7" id="text-org7bab799">
<ul class="org-ul">
<li>排序穩定性不重要<br /></li>
<li>記憶體受限 (無法使用額外空間) → 它是 原地排序 (In-Place Sort)。<br /></li>
<li>確保交換次數最少的場景 → Selection Sort 每次只交換 1 次，比 Bubble Sort 交換次數少。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org2d0575e"></a>📌 總結<br />
<div class="outline-text-6" id="text-org2d0575e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">排序演算法</th>
<th scope="col" class="org-left">時間複雜度 (Best)</th>
<th scope="col" class="org-left">時間複雜度 (Worst)</th>
<th scope="col" class="org-left">幾乎排序時表現</th>
<th scope="col" class="org-left">穩定性</th>
<th scope="col" class="org-left">適用場景</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Insertion Sort</td>
<td class="org-left">O(n)</td>
<td class="org-left">O(n^2)</td>
<td class="org-left">接近 O(n)</td>
<td class="org-left">穩定 (Stable)</td>
<td class="org-left">幾乎排序好、小型資料</td>
</tr>

<tr>
<td class="org-left">Selection Sort</td>
<td class="org-left">O(n^2)</td>
<td class="org-left">O(n^2)</td>
<td class="org-left">仍為 O(n^2)</td>
<td class="org-left">不穩定 (Unstable)</td>
<td class="org-left">小型資料，交換次數最少</td>
</tr>
</tbody>
</table>
<p>
結論：當陣列「幾乎排序好」，應使用 Insertion Sort，因為它可以達到** O(n) 時間，而 Selection Sort 仍然是 O(n^2) 。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org7b213f4" class="outline-4">
<h4 id="org7b213f4"><span class="section-number-4">7.3.10.</span> 5. For the following algorithms, express the running time using big-O notation and briefly explain your answer.</h4>
<div class="outline-text-4" id="text-7-3-10">
</div>
<div id="outline-container-org7e247c8" class="outline-5">
<h5 id="org7e247c8">a) Algorithm A1(n)</h5>
<div class="outline-text-5" id="text-org7e247c8">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #da8548; font-weight: bold;">1</span> &lt;- <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">2: </span><span style="color: #51afef;">while</span> i &lt; n
<span class="linenr">3: </span>   <span style="color: #51afef;">for</span> j = i to n <span style="color: #51afef;">do</span>
<span class="linenr">4: </span>       print(j)
<span class="linenr">5: </span>   i &lt;- i + <span style="color: #da8548; font-weight: bold;">2</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org959b220"></a>解<br />
<div class="outline-text-6" id="text-org959b220">
<p>
時間複雜度分析<br />
</p>
<ul class="org-ul">
<li>外層迴圈 (while i &lt; n, i += 2)<br />
<ul class="org-ul">
<li>i 每次增長 2，因此 迴圈執行次數 ≈ n/2 = O(n)。<br /></li>
</ul></li>
<li>內層迴圈 (for j = i to n)<br />
<ul class="org-ul">
<li>j 從 i 到 n，每次的執行次數是 (n - i + 1)。<br /></li>
<li>第一輪 i=1，執行 (n-1+1) = n 次。<br /></li>
<li>第二輪 i=3，執行 (n-3+1) = (n-2) 次。<br /></li>
<li>第三輪 i=5，執行 (n-5+1) = (n-4) 次。<br /></li>
<li>總計：  n+(n−2)+(n−4)+&#x2026;+1<br /></li>
<li>這是一個等差數列，總和為： O(n2)<br /></li>
</ul></li>
</ul>
<p>
最終時間複雜度: O(n^2)<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga84e005" class="outline-5">
<h5 id="orga84e005">b) Algorithm A2(n)</h5>
<div class="outline-text-5" id="text-orga84e005">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>i &lt;- <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">2: </span><span style="color: #51afef;">while</span> i &lt; n
<span class="linenr">3: </span>  print(i)
<span class="linenr">4: </span>  <span style="color: #ECBE7B;">i</span> &lt;- i + <span style="color: #da8548; font-weight: bold;">5</span>
<span class="linenr">5: </span><span style="color: #51afef;">while</span> i &gt; <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">6: </span>  print(i)
<span class="linenr">7: </span>  i &lt;- i / <span style="color: #da8548; font-weight: bold;">2</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgc54bd1b"></a>解<br />
<div class="outline-text-6" id="text-orgc54bd1b">
<p>
時間複雜度分析<br />
</p>
<ul class="org-ul">
<li>第一個 while 迴圈 (i += 5)<br />
<ul class="org-ul">
<li>i 從 1 增加到 n，每次加 5，總共執行約 n/5 = O(n) 次。<br /></li>
</ul></li>
<li>第二個 while 迴圈 (i /= 2)<br />
<ul class="org-ul">
<li>i 以指數遞減，每次除以 2，直到 i &lt;= 1。<br /></li>
<li>這是指數型遞減，執行次數約為：O(log⁡n)<br /></li>
</ul></li>
<li>最終時間複雜度<br />
<ul class="org-ul">
<li>第一部分 O(n)<br /></li>
<li>第二部分 O(log⁡n)<br /></li>
<li>總時間複雜度由最大項決定 → O(n)<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org566095f" class="outline-5">
<h5 id="org566095f">c) Algorithm A3(n)</h5>
<div class="outline-text-5" id="text-org566095f">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>i &lt;- <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">2: </span><span style="color: #51afef;">while</span> i &lt; n
<span class="linenr">3: </span>   <span style="color: #51afef;">for</span> j = <span style="color: #da8548; font-weight: bold;">1</span> to i <span style="color: #51afef;">do</span>
<span class="linenr">4: </span>      print(j)
<span class="linenr">5: </span>   i &lt;- i * <span style="color: #da8548; font-weight: bold;">2</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org873a4d4"></a>解<br />
<div class="outline-text-6" id="text-org873a4d4">
<p>
時間複雜度分析<br />
</p>
<ul class="org-ul">
<li>外層迴圈 (i *= 2)<br />
<ul class="org-ul">
<li>i 每次乘 2，所以總共執行 O(log⁡n) 次。<br /></li>
</ul></li>
<li>內層迴圈 (for j = 1 to i)<br />
<ul class="org-ul">
<li>j 從 1 到 i，每次執行 i 次。<br /></li>
<li>第一次：i = 1，執行 1 次。<br /></li>
<li>第二次：i = 2，執行 2 次。<br /></li>
<li>第三次：i = 4，執行 4 次。<br /></li>
<li>&#x2026;<br /></li>
<li>總共： 1+2+4+8+⋯+n<br /></li>
<li>這是一個等比數列，總和約為 O(n)。<br /></li>
</ul></li>
<li>最終時間複雜度O(n)<br /></li>
</ul>
</div>
</li>
<li><a id="orge99f8a8"></a>📌 總結<br />
<div class="outline-text-6" id="text-orge99f8a8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">演算法</th>
<th scope="col" class="org-left">時間複雜度</th>
<th scope="col" class="org-left">主要計算方式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A1(n)</td>
<td class="org-left">O(n^2)</td>
<td class="org-left">外層 O(n)，內層 O(n)</td>
</tr>

<tr>
<td class="org-left">A2(n)</td>
<td class="org-left">O(n)</td>
<td class="org-left">一部分 O(n)，一部分 O(logn)，取最大</td>
</tr>

<tr>
<td class="org-left">A3(n)</td>
<td class="org-left">O(n)</td>
<td class="org-left">內層總和形成等比數列，結果為 O(n)</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org31bdfcb" class="outline-4">
<h4 id="org31bdfcb"><span class="section-number-4">7.3.11.</span> 6 Write exactly one letter that best matches each item in the table below. No letter should be used more than once.</h4>
<div class="outline-text-4" id="text-7-3-11">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Feature vector</td>
<td class="org-left">Hierarchical clusteriing</td>
<td class="org-left">Depth first search</td>
<td class="org-left">Greedy algorithm</td>
<td class="org-left">Data abstraction</td>
</tr>

<tr>
<td class="org-left">(a)</td>
<td class="org-left">(b)</td>
<td class="org-left">(c)</td>
<td class="org-left">(d_)</td>
<td class="org-left">(e)</td>
</tr>

<tr>
<td class="org-left">Big-O notation</td>
<td class="org-left">Polymorphism</td>
<td class="org-left">Recursion</td>
<td class="org-left">Hashing</td>
<td class="org-left">Merge sort</td>
</tr>

<tr>
<td class="org-left">(f)</td>
<td class="org-left">(g)</td>
<td class="org-left">(h)</td>
<td class="org-left">(i)</td>
<td class="org-left">(j)</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A. Optimization</td>
<td class="org-left">B. Undirected graph</td>
<td class="org-left">C. Expected urnning time</td>
<td class="org-left">D. Mutability</td>
</tr>

<tr>
<td class="org-left">E. O(1)</td>
<td class="org-left">F. Local optima</td>
<td class="org-left">G. Induction</td>
<td class="org-left">H. Upper bound</td>
</tr>

<tr>
<td class="org-left">I. Specification</td>
<td class="org-left">J. O(log n)</td>
<td class="org-left">K. Inheritance</td>
<td class="org-left">L. Unit testing</td>
</tr>

<tr>
<td class="org-left">M. Normalization</td>
<td class="org-left">N. Lower bound</td>
<td class="org-left">O. Linkage criterion</td>
<td class="org-left">P. O(n)</td>
</tr>

<tr>
<td class="org-left">Q. Backtracking</td>
<td class="org-left">R. Standard deviation</td>
<td class="org-left">S. Divide and conquer</td>
<td class="org-left">T. Approximation</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org168a4f3" class="outline-5">
<h5 id="org168a4f3">解</h5>
<div class="outline-text-5" id="text-org168a4f3">
<p>
📌 答案對應<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">項目 (Item)</th>
<th scope="col" class="org-left">最佳匹配選項 (Matching Letter)</th>
<th scope="col" class="org-left">解析 (Explanation)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Feature vector</td>
<td class="org-left">M. Normalization</td>
<td class="org-left">特徵向量 (Feature Vector) 通常需要標準化 (Normalization) 來確保數據的可比較性，例如均值歸一化或 Z-score。</td>
</tr>

<tr>
<td class="org-left">Hierarchical clustering</td>
<td class="org-left">O. Linkage criterion</td>
<td class="org-left">階層式分群 (Hierarchical Clustering) 使用連結準則 (Linkage Criterion) 來決定如何合併或分割群集，例如單鏈 (Single Linkage)、完全鏈 (Complete Linkage)。</td>
</tr>

<tr>
<td class="org-left">Depth first search (DFS)</td>
<td class="org-left">Q. Backtracking</td>
<td class="org-left">深度優先搜尋 (DFS) 常用於回溯法 (Backtracking)，例如解決八皇后問題、迷宮問題等。</td>
</tr>

<tr>
<td class="org-left">Greedy algorithm</td>
<td class="org-left">F. Local optima</td>
<td class="org-left">貪婪演算法 (Greedy Algorithm) 透過局部最佳解 (Local Optima) 來構造全域解 (Global Solution)，但有時可能陷入局部最優解而非全域最優解。</td>
</tr>

<tr>
<td class="org-left">Data abstraction</td>
<td class="org-left">I. Specification</td>
<td class="org-left">資料抽象 (Data Abstraction) 強調規範 (Specification)，即提供高層級定義來隱藏具體實作細節，使程式碼更易讀和可擴展。</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">項目 (Item)</th>
<th scope="col" class="org-left">最佳匹配選項 (Matching Letter)</th>
<th scope="col" class="org-left">解析 (Explanation)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Big-O notation</td>
<td class="org-left">H. Upper bound</td>
<td class="org-left">大 O 記號 (Big-O Notation) 描述演算法的上界 (Upper Bound)，即最壞情況 (Worst Case) 的時間複雜度。</td>
</tr>

<tr>
<td class="org-left">Polymorphism</td>
<td class="org-left">K. Inheritance</td>
<td class="org-left">多型 (Polymorphism) 是物件導向程式設計 (OOP) 中的特性，通常透過繼承 (Inheritance) 來實現不同類別對相同介面 (Interface) 的不同實作。</td>
</tr>

<tr>
<td class="org-left">Recursion</td>
<td class="org-left">G. Induction</td>
<td class="org-left">遞迴 (Recursion) 是數學歸納法 (Induction) 的程式設計對應，因為遞迴函式的解法通常依賴於較小規模的相同問題解決方式。</td>
</tr>

<tr>
<td class="org-left">Hashing</td>
<td class="org-left">E. O(1)</td>
<td class="org-left">雜湊 (Hashing) 透過雜湊函數 (Hash Function) 將鍵 (Key) 映射到雜湊表，理想情況下查找 (Lookup) 只需O(1) 時間。</td>
</tr>

<tr>
<td class="org-left">Merge sort</td>
<td class="org-left">S. Divide and conquer</td>
<td class="org-left">合併排序 (Merge Sort) 是典型的分治法 (Divide and Conquer) 排序演算法，將陣列拆分並合併排序，時間複雜度為 O(nlog⁡n)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org1dba1c6" class="outline-5">
<h5 id="org1dba1c6">📌 相關計概知識整理</h5>
<div class="outline-text-5" id="text-org1dba1c6">
</div>
<ul class="org-ul">
<li><a id="orgd77b4b1"></a>1️⃣ 大 O 記號 (Big-O Notation)<br />
<div class="outline-text-6" id="text-orgd77b4b1">
<ul class="org-ul">
<li>描述演算法的最壞情況複雜度 (Worst Case Complexity)。<br /></li>
<li>時間複雜度範例：<br />
<ul class="org-ul">
<li>O(1)：雜湊查找 (Hash Lookup)<br /></li>
<li>O(logn)：二分搜尋 (Binary Search)<br /></li>
<li>O(n)：線性搜尋 (Linear Search)<br /></li>
<li>O(nlogn)：合併排序 (Merge Sort)、快速排序 (Quick Sort)<br /></li>
<li>O(n^2)：選擇排序 (Selection Sort)、氣泡排序 (Bubble Sort)<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0d2be7d"></a>2️⃣ 階層式分群 (Hierarchical Clustering)<br />
<div class="outline-text-6" id="text-org0d2be7d">
<p>
連結準則 (Linkage Criterion)：<br />
</p>
<ul class="org-ul">
<li>單鏈 (Single Linkage)：兩群最接近的點決定群組距離。<br /></li>
<li>完全鏈 (Complete Linkage)：兩群最遠的點決定群組距離。<br /></li>
<li>平均鏈 (Average Linkage)：兩群所有點的平均距離。<br /></li>
</ul>
</div>
</li>
<li><a id="org163b82c"></a>3️⃣ 深度優先搜尋 (DFS) 與回溯法 (Backtracking)<br />
<div class="outline-text-6" id="text-org163b82c">
<ul class="org-ul">
<li>DFS 適用於圖、樹的遍歷，使用堆疊 (Stack) 或遞迴 (Recursion)。<br /></li>
<li>回溯法 (Backtracking) 適用於：<br />
<ul class="org-ul">
<li>組合問題 (Subset Sum, N-Queens)<br /></li>
<li>搜尋問題 (迷宮求解)<br /></li>
<li>排列問題 (排列組合)<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org97fe93a"></a>4️⃣ 貪婪演算法 (Greedy Algorithm) 與局部最優解<br />
<div class="outline-text-6" id="text-org97fe93a">
<ul class="org-ul">
<li>局部最佳選擇 (Local Optima) 可能導致全域次佳解 (Suboptimal Global Solution)。<br /></li>
<li>適用貪婪演算法的問題：<br />
<ul class="org-ul">
<li>Huffman 編碼<br /></li>
<li>最小生成樹 (Kruskal, Prim)<br /></li>
<li>活動選擇問題 (Activity Selection Problem)<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org01a3287"></a>5️⃣ 物件導向程式設計 (OOP)<br />
<div class="outline-text-6" id="text-org01a3287">
<ul class="org-ul">
<li>多型 (Polymorphism)：<br />
<ul class="org-ul">
<li>繼承 (Inheritance) 允許子類別覆寫父類別行為。<br /></li>
<li>介面 (Interface) 允許不同類別共享相同方法定義。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc7e2763"></a>6️⃣ 遞迴與數學歸納法<br />
<div class="outline-text-6" id="text-orgc7e2763">
<p>
遞迴 (Recursion) 的基本結構：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">func</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">2: </span>        <span style="color: #51afef;">if</span> (n == <span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #51afef;">return</span>;
<span class="linenr">3: </span>        func(n - <span style="color: #da8548; font-weight: bold;">1</span>);
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>
</pre>
</div>
<p>
數學歸納法 (Induction) 與遞迴的關係<br />
</p>
<ul class="org-ul">
<li>歸納基礎 (Base Case)：確認最小規模問題成立。<br /></li>
<li>歸納假設 (Inductive Hypothesis)：假設較小問題成立。<br /></li>
<li>歸納步驟 (Inductive Step)：證明較大問題也成立。<br /></li>
</ul>
</div>
</li>
<li><a id="org6b3fc84"></a>7️⃣ Hashing 與 O(1) 查找<br />
<div class="outline-text-6" id="text-org6b3fc84">
<ul class="org-ul">
<li>雜湊函數 (Hash Function) 映射鍵 (Key) 到雜湊表 (Hash Table)。<br /></li>
<li>常見應用：<br />
<ul class="org-ul">
<li>雜湊集合 (Hash Set)<br /></li>
<li>雜湊映射 (Hash Map, Dictionary)<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf1f6a2c"></a>8️⃣ 合併排序 (Merge Sort) 與分治法 (Divide &amp; Conquer)<br />
<div class="outline-text-6" id="text-orgf1f6a2c">
<p>
合併排序時間複雜度 O(nlog⁡n)：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">mergeSort</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">arr</span>[], <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">l</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">r</span>) {
<span class="linenr">2: </span>        <span style="color: #51afef;">if</span> (l &gt;= r) <span style="color: #51afef;">return</span>;
<span class="linenr">3: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">mid</span> = (l + r) / <span style="color: #da8548; font-weight: bold;">2</span>;
<span class="linenr">4: </span>        mergeSort(arr, l, mid);
<span class="linenr">5: </span>        mergeSort(arr, mid + <span style="color: #da8548; font-weight: bold;">1</span>, r);
<span class="linenr">6: </span>        merge(arr, l, mid, r);
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>
</pre>
</div>
<p>
典型「分而治之」(Divide and Conquer) 問題：<br />
</p>
<ul class="org-ul">
<li>快速排序 (QuickSort)<br /></li>
<li>二分搜尋 (Binary Search)<br /></li>
<li>費波那契數列 (Fibonacci)<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3493e4b" class="outline-5">
<h5 id="org3493e4b">📌 總結</h5>
<div class="outline-text-5" id="text-org3493e4b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">項目</th>
<th scope="col" class="org-left">對應概念</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Feature Vector</td>
<td class="org-left">Normalization</td>
</tr>

<tr>
<td class="org-left">Hierarchical Clustering</td>
<td class="org-left">Linkage Criterion</td>
</tr>

<tr>
<td class="org-left">Depth First Search</td>
<td class="org-left">Backtracking</td>
</tr>

<tr>
<td class="org-left">Greedy Algorithm</td>
<td class="org-left">Local Optima</td>
</tr>

<tr>
<td class="org-left">Data Abstraction</td>
<td class="org-left">Specification</td>
</tr>

<tr>
<td class="org-left">Big-O Notation</td>
<td class="org-left">Upper Bound</td>
</tr>

<tr>
<td class="org-left">Polymorphism</td>
<td class="org-left">Inheritance</td>
</tr>

<tr>
<td class="org-left">Recursion</td>
<td class="org-left">Induction</td>
</tr>

<tr>
<td class="org-left">Hashing</td>
<td class="org-left">O(1)</td>
</tr>

<tr>
<td class="org-left">Merge Sort</td>
<td class="org-left">Divide and Conquer</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf842b13" class="outline-2">
<h2 id="orgf842b13"><span class="section-number-2">8.</span> 中央近五年計概</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgbcc8e6b" class="outline-3">
<h3 id="orgbcc8e6b"><span class="section-number-3">8.1.</span> 108</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-org3a53bc1" class="outline-4">
<h4 id="org3a53bc1"><span class="section-number-4">8.1.1.</span> 第一大題 (25分)：解釋名詞，每小題5分，共25分</h4>
<div class="outline-text-4" id="text-8-1-1">
</div>
<div id="outline-container-orgc6c9275" class="outline-5">
<h5 id="orgc6c9275">DSSS (Direct Sequence Spread Spectrum)</h5>
<div class="outline-text-5" id="text-orgc6c9275">
</div>
<ul class="org-ul">
<li><a id="org6fb2c2b"></a>解<br />
<div class="outline-text-6" id="text-org6fb2c2b">
<p>
直接序列展頻技術（DSSS）是一種擴頻通信技術，用於提高無線通信的抗干擾能力。DSSS 的基本原理是將原始信號與較高頻率的偽隨機碼（Pseudo-random Noise, PN）相乘，使訊號頻譜擴展到比原來更寬的頻帶，然後再透過接收端的同步解碼還原出原始訊號。<br />
</p>
</div>
</li>
<li><a id="org1ebc9f7"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org1ebc9f7">
<ul class="org-ul">
<li>擴頻技術（Spread Spectrum）：除 DSSS 外，還有 FHSS（Frequency Hopping Spread Spectrum，跳頻擴頻）。<br /></li>
<li>CDMA（Code Division Multiple Access）：DSSS 技術是 CDMA 的基礎，允許多個使用者同時傳輸數據，而不互相干擾。<br /></li>
<li>訊號調變技術：如 BPSK（Binary Phase Shift Keying）、QPSK（Quadrature Phase Shift Keying）。<br /></li>
<li>無線網路標準：IEEE 802.11b 採用 DSSS 作為主要的傳輸技術。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge6ac67c" class="outline-5">
<h5 id="orge6ac67c">PCM (Pulse-Code Modulation)</h5>
<div class="outline-text-5" id="text-orge6ac67c">
</div>
<ul class="org-ul">
<li><a id="org772fbf9"></a>解<br />
<div class="outline-text-6" id="text-org772fbf9">
<p>
脈衝編碼調變（PCM）是一種數位訊號編碼技術，將類比訊號（如聲音）轉換為數位訊號的標準方法。PCM 主要經歷三個步驟：<br />
</p>
<ul class="org-ul">
<li>取樣（Sampling）：按照奈奎斯特定理（Nyquist Theorem），以至少兩倍於訊號最大頻率的取樣率，將連續的類比訊號離散化。<br /></li>
<li>量化（Quantization）：將取樣值對應到有限數目的數值，使訊號可用有限比特表示。<br /></li>
<li>編碼（Encoding）：將量化後的訊號轉換為二進位碼，方便數位傳輸與存儲。<br /></li>
</ul>
</div>
</li>
<li><a id="org494366d"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org494366d">
<ul class="org-ul">
<li>類比與數位訊號：比較類比訊號與數位訊號的特性。<br /></li>
<li>取樣定理（Sampling Theorem）：奈奎斯特定理是 PCM 設計的重要依據。<br /></li>
<li>數位音訊格式：如 WAV、MP3、AAC，均基於 PCM 或其變種。<br /></li>
<li>音訊壓縮技術：如 μ-law 和 A-law 是 PCM 的變體，常見於電話通訊。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org52be2da" class="outline-5">
<h5 id="org52be2da">VLAN (Virtual Local Area Network)</h5>
<div class="outline-text-5" id="text-org52be2da">
</div>
<ul class="org-ul">
<li><a id="orge4b6b76"></a>解<br />
<div class="outline-text-6" id="text-orge4b6b76">
<p>
虛擬區域網路（VLAN）是一種透過邏輯分割網路的技術，即使裝置連接在同一台交換機，也能透過 VLAN 區分不同網段，提升網路安全性與管理性。VLAN 的主要特性包括：<br />
</p>
<ul class="org-ul">
<li>邏輯分割網路：可以將不同部門或用途的設備分隔，即使它們在相同的物理網路內。<br /></li>
<li>降低廣播流量：VLAN 可防止廣播訊息影響不相關的裝置，提升網路效能。<br /></li>
<li>增強安全性：不同 VLAN 之間的流量通常需要透過路由器或防火牆管控。<br /></li>
</ul>
</div>
</li>
<li><a id="orge0da63c"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-orge0da63c">
<ul class="org-ul">
<li>區域網路（LAN）技術：Ethernet、Wi-Fi 與 LAN 設計概念。<br /></li>
<li>網路層級架構：OSI 模型中 VLAN 屬於第二層（資料鏈結層）。<br /></li>
<li>交換機（Switch）技術：VLAN 主要由管理型交換機（Managed Switch）實現。<br /></li>
<li>802.1Q 標準：VLAN 標記技術，允許一條連接傳輸多個 VLAN。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6ea0c29" class="outline-5">
<h5 id="org6ea0c29">DMZ (Demilitarized Zone)</h5>
<div class="outline-text-5" id="text-org6ea0c29">
</div>
<ul class="org-ul">
<li><a id="org9d18275"></a>解<br />
<div class="outline-text-6" id="text-org9d18275">
<p>
非軍事區（DMZ） 是網路架構中一個受控的區域，通常位於內部網路（LAN）與外部網路（如 Internet）之間，主要用於公開提供網路服務，如 Web 伺服器、郵件伺服器或 DNS 伺服器。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgbec90ab"></a>DMZ 的設計<br />
<div class="outline-text-7" id="text-orgbec90ab">
<ul class="org-ul">
<li>隔離內部網路：外部使用者只能存取 DMZ 內的服務，無法直接進入內部 LAN。<br /></li>
<li>防火牆控制：DMZ 透過防火牆規則限制內部與外部的存取權限。<br /></li>
<li>雙防火牆架構：<br />
<ul class="org-ul">
<li>單防火牆 DMZ：使用一台防火牆區分內網、DMZ 與外部網路。<br /></li>
<li>雙防火牆 DMZ：外部防火牆限制 Internet 存取 DMZ，內部防火牆限制 DMZ 存取內部網路，安全性更高。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org8019772"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org8019772">
<ul class="org-ul">
<li>網路安全技術：如防火牆（Firewall）、入侵偵測系統（IDS）、入侵防禦系統（IPS）。<br /></li>
<li>TCP/IP 及網路服務：如 HTTP、HTTPS、DNS 及其安全性。<br /></li>
<li>VPN（Virtual Private Network）：透過 VPN 提供安全的遠端存取，但需要正確配置 DMZ 來管理 VPN 存取控制。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgbf531b8"></a>入侵偵測系統（IDS - Intrusion Detection System）<br />
<div class="outline-text-7" id="text-orgbf531b8">
<p>
概念與功能 入侵偵測系統（IDS）是一種監控網路或系統活動，以檢測可疑行為或潛在攻擊的安全設備。其主要目的是發現並告警潛在的安全威脅，而不會自動採取行動阻止攻擊。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org18505bd"></a>IDS 的分類<br />
<div class="outline-text-8" id="text-org18505bd">
<ul class="org-ul">
<li>網路型 IDS（NIDS - Network-based IDS）<br />
<ul class="org-ul">
<li>部署於網路節點（如路由器、交換機），監控整個網路的流量。<br /></li>
<li>優點：可全面監控網路中的所有通信。<br /></li>
<li>缺點：難以檢測加密通信內的攻擊。<br /></li>
</ul></li>
<li>主機型 IDS（HIDS - Host-based IDS）<br />
<ul class="org-ul">
<li>部署於單一主機或伺服器，監控該主機的操作與系統日誌。<br /></li>
<li>優點：能夠檢測主機內部的異常活動，如未經授權的文件修改。<br /></li>
<li>缺點：僅限於監控所在主機，無法偵測其他網路活動。<br /></li>
</ul></li>
</ul>
<p>
偵測方法<br />
</p>
<ul class="org-ul">
<li>特徵匹配（Signature-based Detection）<br />
<ul class="org-ul">
<li>利用已知攻擊的特徵（如病毒碼、特定封包模式）進行比對。<br /></li>
<li>優點：準確率高，對已知威脅反應迅速。<br /></li>
<li>缺點：無法偵測新型或未知攻擊。<br /></li>
</ul></li>
<li>異常偵測（Anomaly-based Detection）<br />
<ul class="org-ul">
<li>建立正常行為的基準（Baseline），並檢測異常行為。<br /></li>
<li>優點：能夠發現未知或新型攻擊。<br /></li>
<li>缺點：誤報率高，需定期更新基準。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgf39c068"></a>入侵防禦系統（IPS - Intrusion Prevention System）<br />
<div class="outline-text-7" id="text-orgf39c068">
<p>
概念與功能 入侵防禦系統（IPS）是一種在偵測攻擊的同時，自動採取行動以防止攻擊成功的安全設備。與 IDS 不同，IPS 具有主動防禦功能。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0e0ee4c"></a>IPS 的類型<br />
<div class="outline-text-8" id="text-org0e0ee4c">
<ul class="org-ul">
<li>網路型 IPS（NIPS - Network-based IPS）<br />
<ul class="org-ul">
<li>部署於網路邊界，主動攔截和阻止惡意流量。<br /></li>
<li>常見於企業網路邊界，以阻擋外部攻擊。<br /></li>
</ul></li>
<li>主機型 IPS（HIPS - Host-based IPS）<br />
<ul class="org-ul">
<li>部署於單一主機或伺服器，針對該主機的攻擊進行防禦。<br /></li>
<li>適用於高敏感性資料伺服器或關鍵基礎設施。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orga930d42"></a>防禦策略<br />
<div class="outline-text-8" id="text-orga930d42">
<ul class="org-ul">
<li>封包過濾（Packet Filtering）<br />
<ul class="org-ul">
<li>根據封包內容或規則集直接丟棄惡意封包。<br /></li>
</ul></li>
<li>連線重置（Connection Reset）<br />
<ul class="org-ul">
<li>主動終止攻擊者與受害者之間的連線。<br /></li>
</ul></li>
<li>警報與記錄（Alerting and Logging）<br />
<ul class="org-ul">
<li>在防禦攻擊的同時，發送警報並記錄相關資訊供事後分析。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orge287d60"></a>IPS 的挑戰<br />
<div class="outline-text-8" id="text-orge287d60">
<ul class="org-ul">
<li>需在不影響合法流量的情況下，迅速阻擋惡意行為。<br /></li>
<li>調整錯誤或過於嚴格的規則可能導致合法操作被誤判為攻擊。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org89981ab" class="outline-5">
<h5 id="org89981ab">CDN (Content Delivery Network)</h5>
<div class="outline-text-5" id="text-org89981ab">
<p>
非軍事區（DMZ） 是網路架構中一個受控的區域，通常位於內部網路（LAN）與外部網路（如 Internet）之間，主要用於公開提供網路服務，如 Web 伺服器、郵件伺服器或 DNS 伺服器。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org53538f0"></a>DMZ 的設計<br />
<div class="outline-text-6" id="text-org53538f0">
<ul class="org-ul">
<li>隔離內部網路：外部使用者只能存取 DMZ 內的服務，無法直接進入內部 LAN。<br /></li>
<li>防火牆控制：DMZ 透過防火牆規則限制內部與外部的存取權限。<br /></li>
<li>雙防火牆架構：<br />
<ul class="org-ul">
<li>單防火牆 DMZ：使用一台防火牆區分內網、DMZ 與外部網路。<br /></li>
<li>雙防火牆 DMZ：外部防火牆限制 Internet 存取 DMZ，內部防火牆限制 DMZ 存取內部網路，安全性更高。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org97ebc29"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org97ebc29">
<ul class="org-ul">
<li>網路安全技術：如防火牆（Firewall）、入侵偵測系統（IDS）、入侵防禦系統（IPS）。<br /></li>
<li>TCP/IP 及網路服務：如 HTTP、HTTPS、DNS 及其安全性。<br /></li>
<li>VPN（Virtual Private Network）：透過 VPN 提供安全的遠端存取，但需要正確配置 DMZ 來管理 VPN 存取控制。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga674fba" class="outline-4">
<h4 id="orga674fba"><span class="section-number-4">8.1.2.</span> 第二大題 (10分)：</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
在Relational Database裡，每個Table基本上都會有一欄當做Primary Key。許多情況下常使用auto increment 或UUID當作Primary Key，並列舉說明這樣做為primary key的優缺點<br />
</p>
</div>
<div id="outline-container-org764059b" class="outline-5">
<h5 id="org764059b">解</h5>
<div class="outline-text-5" id="text-org764059b">
<p>
在關聯式資料庫（Relational Database, RDB）中，每個表（Table）通常都有一個主鍵（Primary Key, PK）來唯一標識每一筆記錄。常見的 PK 產生方式有兩種：<br />
</p>
<ul class="org-ul">
<li>Auto Increment（自動遞增）<br /></li>
<li>UUID（通用唯一識別碼，Universally Unique Identifier）<br /></li>
</ul>
<p>
這兩種方式各有優缺點，在不同的應用場景下選擇合適的 PK 類型至關重要。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgbf34ae8"></a>Auto Increment 作為 Primary Key<br />
<div class="outline-text-6" id="text-orgbf34ae8">
<p>
Auto Increment 是一種常見的主鍵生成方式，資料庫會自動為新插入的資料分配一個遞增的數值。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>CREATE <span style="color: #ECBE7B;">TABLE</span> <span style="color: #c678dd;">users</span> (
<span class="linenr">2: </span>    id INT AUTO_INCREMENT <span style="color: #ECBE7B;">PRIMARY</span> <span style="color: #dcaeea;">KEY</span>,
<span class="linenr">3: </span>    <span style="color: #ECBE7B;">name</span> <span style="color: #dcaeea;">VARCHAR</span>(<span style="color: #da8548; font-weight: bold;">255</span>),
<span class="linenr">4: </span>    <span style="color: #ECBE7B;">email</span> <span style="color: #dcaeea;">VARCHAR</span>(<span style="color: #da8548; font-weight: bold;">255</span>)
<span class="linenr">5: </span>);
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org7f0c081"></a>優點<br />
<div class="outline-text-7" id="text-org7f0c081">
<ul class="org-ul">
<li>✅ 數值型索引效率高: 整數（INT, BIGINT）索引比字串（UUID）索引快，搜尋、排序、JOIN 操作效率較高。<br />
B+ 樹索引（如 InnoDB）適用遞增值，有助於保持索引的平衡與效能。<br /></li>
<li>✅ 空間效率高: 整數通常比 UUID 佔用的空間小（INT 佔 4 Bytes，BIGINT 佔 8 Bytes，而 UUID 通常為 16 Bytes）。<br /></li>
<li><p>
✅ 易讀性高: 記錄 ID 連續遞增，方便查詢與理解，例如：<br />
</p>
<pre class="example" id="org9ab789e">
  User ID: 1, 2, 3, 4, 5
</pre></li>
<li>✅ INSERT 操作更高效: 自增 ID 讓 INSERT 操作集中在索引的最後一個位置，降低分裂索引頁的機率，提高寫入效能。<br /></li>
</ul>
</div>
</li>
<li><a id="org33a464d"></a>缺點<br />
<div class="outline-text-7" id="text-org33a464d">
<ul class="org-ul">
<li>❌ 複製數據時可能會有 ID 衝突: 例如，將資料從一個數據庫複製到另一個時，兩邊的 ID 可能重複，導致衝突，特別是在分布式環境下。<br /></li>
<li>❌ 容易被猜測: 由於 ID 遞增，攻擊者可以預測下一筆記錄的 ID，進行 ID 爬取攻擊（如：/user/123、/user/124&#x2026;）。<br /></li>
<li>❌ 在分布式系統中擴展性較差: 在多個節點的數據庫中，確保不同節點間的 ID 唯一性需要額外的處理，例如透過 分區自增 ID 或 雪花算法（Snowflake ID） 來解決。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org8a4be61"></a>UUID 作為 Primary Key<br />
<div class="outline-text-6" id="text-org8a4be61">
<p>
UUID（通用唯一識別碼） 是一種全球唯一識別碼，格式通常為 36 個字元（包含 -）。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>CREATE <span style="color: #ECBE7B;">TABLE</span> <span style="color: #c678dd;">users</span> (
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">id</span> <span style="color: #dcaeea;">CHAR</span>(<span style="color: #da8548; font-weight: bold;">36</span>) <span style="color: #ECBE7B;">PRIMARY</span> <span style="color: #dcaeea;">KEY</span>,
<span class="linenr">3: </span>    <span style="color: #dcaeea;">name</span> VARCHAR(<span style="color: #da8548; font-weight: bold;">255</span>),
<span class="linenr">4: </span>    <span style="color: #dcaeea;">email</span> VARCHAR(<span style="color: #da8548; font-weight: bold;">255</span>)
<span class="linenr">5: </span>);
</pre>
</div>
<p>
UUID 主要有幾種類型：<br />
</p>
<ul class="org-ul">
<li>UUID v1：基於時間戳與機器 MAC 位址，適合時間順序排序。<br /></li>
<li>UUID v4：完全隨機生成，無法預測，適合隱私需求高的應用。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgc16adad"></a>優點<br />
<div class="outline-text-7" id="text-orgc16adad">
<ul class="org-ul">
<li>✅ 唯一性強: UUID 透過算法生成，即使在不同伺服器或資料庫節點，也能保證唯一性，適合 分布式架構 或 微服務。<br /></li>
<li>✅ 不易被猜測: 由於 UUID 並非連續數值，不容易被攻擊者預測，提升安全性。<br /></li>
<li>✅ 資料合併與同步更方便: 在多個資料來源合併時，不需要擔心主鍵衝突，適合 分布式資料庫 或 資料同步系統。<br /></li>
<li>✅ 支援跨伺服器生成: 例如，在微服務架構中，每個服務可以獨立生成 UUID，而不需要查詢數據庫獲取 ID。<br /></li>
</ul>
</div>
</li>
<li><a id="org04fc03b"></a>缺點<br />
<div class="outline-text-7" id="text-org04fc03b">
<ul class="org-ul">
<li>❌ 索引效能較差: UUID 是 字串（CHAR(36)） 或 16 Bytes 二進制數據（BINARY(16)），比起 整數（INT, BIGINT） 更佔空間，影響索引效能。<br /></li>
<li>❌ 存儲成本高: UUID 以 字串存儲（36 Bytes）或 二進制存儲（16 Bytes），相較於 INT（4 Bytes）或 BIGINT（8 Bytes），存儲效率較低。<br /></li>
<li>❌ 讀取效率較低: UUID 的隨機性會導致 索引分裂（Index Fragmentation），影響數據檢索效能，特別是在 B+ 樹索引 中。<br /></li>
<li><p>
❌ 可讀性差: UUID 難以手動輸入、理解和比較，例如：<br />
</p>
<pre class="example" id="org6380d15">
  550e8400-e29b-41d4-a716-446655440000
</pre></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org4354d55"></a>Auto Increment vs UUID 選擇指南<br />
<div class="outline-text-6" id="text-org4354d55">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">Auto Increment</th>
<th scope="col" class="org-left">UUID</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">唯一性</td>
<td class="org-left">只在單一資料庫唯一</td>
<td class="org-left">全球唯一</td>
</tr>

<tr>
<td class="org-left">索引效能</td>
<td class="org-left">高（整數索引效率佳）</td>
<td class="org-left">低（UUID 影響索引）</td>
</tr>

<tr>
<td class="org-left">存儲空間</td>
<td class="org-left">小（INT: 4 Bytes, BIGINT: 8 Bytes）</td>
<td class="org-left">大（CHAR(36): 36 Bytes, BINARY(16): 16 Bytes）</td>
</tr>

<tr>
<td class="org-left">INSERT 效能</td>
<td class="org-left">佳（遞增 ID 避免索引分裂）</td>
<td class="org-left">差（UUID 隨機性導致索引分裂）</td>
</tr>

<tr>
<td class="org-left">可讀性</td>
<td class="org-left">佳（1, 2, 3&#x2026;）</td>
<td class="org-left">差（550e8400-e29b&#x2026;）</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">易猜測、可被爬取</td>
<td class="org-left">不易猜測、較安全</td>
</tr>

<tr>
<td class="org-left">分布式支持</td>
<td class="org-left">需要特殊設計（如雪花算法）</td>
<td class="org-left">天生適合</td>
</tr>
</tbody>
</table>
</div>
<ul class="org-ul">
<li><a id="org4d08ebb"></a>適用場景<br />
<div class="outline-text-7" id="text-org4d08ebb">
<ul class="org-ul">
<li>✅ Auto Increment 適用於<br />
<ul class="org-ul">
<li>傳統單節點數據庫<br /></li>
<li>需要高效能查詢的應用（如報表、統計系統）<br /></li>
<li>需要可讀性佳的流水號（如訂單號）<br /></li>
</ul></li>
<li>✅ UUID 適用於<br />
<ul class="org-ul">
<li>分布式系統（如微服務架構、跨資料庫同步）<br /></li>
<li>安全性要求高的應用（如 API Token、用戶識別碼）<br /></li>
<li>避免 ID 爬取攻擊（防止猜測 ID）<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge44bf2f" class="outline-4">
<h4 id="orge44bf2f"><span class="section-number-4">8.1.3.</span> 第三大題 (3分)：</h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
簡單說明什麼是SQL Injection<br />
</p>
</div>
<div id="outline-container-orgf6eb3c1" class="outline-5">
<h5 id="orgf6eb3c1">解</h5>
<div class="outline-text-5" id="text-orgf6eb3c1">
<p>
SQL Injection（SQL 注入攻擊） 是一種 攻擊者利用惡意 SQL 語句操控資料庫 的攻擊方式。這類攻擊通常發生於 應用程式未對使用者輸入進行適當驗證，導致攻擊者可以插入惡意 SQL 查詢，進而竊取、修改、刪除數據，甚至控制整個資料庫。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0072d83"></a>SQL Injection 的運作原理<br />
<div class="outline-text-6" id="text-org0072d83">
<p>
當應用程式直接將 使用者輸入 插入 SQL 查詢時，若未經適當處理，攻擊者就能惡意構造輸入，使 SQL 語句的行為偏離預期。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org617d73b"></a>❌ 例：不安全的 SQL 查詢<br />
<div class="outline-text-7" id="text-org617d73b">
<p>
假設一個網站的登入系統接收使用者輸入的 帳號（username） 和 密碼（password），然後執行以下 SQL 語句：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">'</span><span style="color: #da8548; font-weight: bold;">123456</span><span style="color: #ECBE7B;">'</span>;
</pre>
</div>
<p>
如果程式直接將使用者輸入拼接到 SQL 查詢：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>query = <span style="color: #98be65;">"SELECT * FROM users WHERE username = '"</span> + user_input + <span style="color: #98be65;">"' AND password = '"</span> + password_input + <span style="color: #98be65;">"';"</span>
</pre>
</div>
<p>
攻擊者可以輸入：<br />
</p>
<ul class="org-ul">
<li>帳號：admin&rsquo; &#x2013;<br /></li>
<li>密碼：任何內容（因為後面會被註解掉）<br /></li>
</ul>
<p>
最終 SQL 語句變為：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> -- <span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">'</span><span style="color: #da8548; font-weight: bold;">123456</span><span style="color: #ECBE7B;">'</span>;
</pre>
</div>
<p>
其中 &#x2013; 是 SQL 的註解符號，使後面的 AND password = &rsquo;123456&rsquo; 變成註解，導致登入密碼檢查被繞過，攻擊者可以直接登入 admin 帳號。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org19dd71a"></a>SQL Injection 的類型<br />
<div class="outline-text-6" id="text-org19dd71a">
<p>
SQL 注入攻擊的類型可分為幾種：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgea76d90"></a>（1）Classic SQL Injection（傳統 SQL 注入）<br />
<div class="outline-text-7" id="text-orgea76d90">
<ul class="org-ul">
<li>利用 &rsquo; OR &rsquo;1&rsquo;=&rsquo;1 之類的條件繞過身份驗證。<br /></li>
<li>目標：繞過登入、讀取資料庫內容。<br /></li>
</ul>
<p>
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">''</span> OR <span style="color: #98be65;">'1'</span>=<span style="color: #98be65;">'1'</span> -- <span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">''</span>;
</pre>
</div>

<p>
此語句總是成立，導致所有使用者的資訊被查詢出來。<br />
</p>
</div>
</li>
<li><a id="orgb766624"></a>（2）Blind SQL Injection（盲目 SQL 注入）<br />
<div class="outline-text-7" id="text-orgb766624">
<p>
當應用程式不直接顯示錯誤訊息時，攻擊者可以透過邏輯推測資料庫的內容。<br />
常見技術<br />
</p>
<ul class="org-ul">
<li>布林盲注（Boolean-Based Blind SQL Injection）：攻擊者觀察網頁回應變化來判斷條件是否成立。<br /></li>
<li>時間盲注（Time-Based Blind SQL Injection）：利用 SLEEP() 來判斷資料庫是否執行了攻擊語句。<br /></li>
</ul>

<p>
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> AND IF(LENGTH(password)&gt;<span style="color: #da8548; font-weight: bold;">6</span>, SLEEP(<span style="color: #da8548; font-weight: bold;">5</span>), <span style="color: #da8548; font-weight: bold;">0</span>);
</pre>
</div>
<p>
如果 password 長度大於 6，查詢執行時間會延遲 5 秒，攻擊者可據此推測密碼長度。<br />
</p>
</div>
</li>
<li><a id="orgda9ff34"></a>（3）Union-Based SQL Injection（聯合查詢 SQL 注入）<br />
<div class="outline-text-7" id="text-orgda9ff34">
<p>
利用 UNION 語法將攻擊者的查詢結果與原查詢結果合併，竊取資料。<br />
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">SELECT</span> <span style="color: #dcaeea;">username</span>, <span style="color: #dcaeea;">password</span> FROM users WHERE id = <span style="color: #da8548; font-weight: bold;">1</span> UNION SELECT database(), <span style="color: #c678dd;">version</span>();
</pre>
</div>
<p>
如果應用程式回傳查詢結果，攻擊者可獲得資料庫名稱與版本資訊。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org939a2da"></a>3. SQL Injection 的影響<br />
<div class="outline-text-6" id="text-org939a2da">
<p>
SQL Injection 可能造成：<br />
</p>
<ul class="org-ul">
<li>未授權存取：攻擊者可以繞過登入系統，獲取管理員權限。<br /></li>
<li>資料竊取：攻擊者可讀取敏感資訊，如 用戶名、密碼、信用卡資訊。<br /></li>
<li>資料修改或刪除：攻擊者可刪除資料表或修改重要數據。<br /></li>
<li>系統破壞：透過 DROP TABLE 或 執行系統命令（在支援 xp_cmdshell 的 SQL Server 上）。<br /></li>
<li>進一步攻擊：攻擊者可植入惡意程式、取得伺服器控制權。<br /></li>
</ul>
</div>
</li>
<li><a id="org6df6d17"></a>4. 防範 SQL Injection<br />
<ul class="org-ul">
<li><a id="orgb50df4e"></a>✅ （1）使用 Prepared Statements（預處理語句）<br />
<div class="outline-text-7" id="text-orgb50df4e">
<p>
預防 SQL Injection 最有效的方法之一是 使用 Prepared Statements，確保 SQL 語句的結構不被用戶輸入影響。<br />
Python + MySQL<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>cursor.execute(<span style="color: #98be65;">"SELECT * FROM users WHERE username = %s AND password = %s"</span>, (username, password))
</pre>
</div>
<p>
這樣 username 和 password 會被安全地當作參數處理，而不會改變 SQL 結構。<br />
</p>
</div>
</li>
<li><a id="org68a59f4"></a>✅ （2）使用 ORM（Object-Relational Mapping）<br />
<div class="outline-text-7" id="text-org68a59f4">
<p>
ORM 框架（如 Django ORM、SQLAlchemy）內建安全機制，減少直接寫 SQL 語句的風險。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>User.objects.filter(username=username, password=password).first()
</pre>
</div>
</div>
</li>
<li><a id="org29572a3"></a>✅ （3）輸入驗證（Input Validation）<br />
<div class="outline-text-7" id="text-org29572a3">
<p>
限制使用者輸入的格式，拒絕包含 SQL 語法的輸入：<br />
</p>
<ul class="org-ul">
<li>過濾特殊字元（如 &rsquo;, ", &#x2013;, ;, /* */）。<br /></li>
<li>強制數字輸入（如 ID 應只能是數字）。<br /></li>
</ul>
</div>
</li>
<li><a id="org7160ad3"></a>✅ （4）最小權限原則（Least Privilege Principle）<br />
<div class="outline-text-7" id="text-org7160ad3">
<p>
應用程式使用的 資料庫帳號應有最小權限，例如：<br />
</p>
<ul class="org-ul">
<li>讀取操作：只授權 SELECT。<br /></li>
<li>寫入操作：只授權 INSERT、UPDATE，避免 DROP、DELETE。<br /></li>
</ul>
</div>
</li>
<li><a id="orgb3d69b9"></a>✅ （5）使用 Web Application Firewall（WAF）<br />
<div class="outline-text-7" id="text-orgb3d69b9">
<p>
WAF（網頁應用程式防火牆） 可攔截 SQL Injection 攻擊，如 ModSecurity 可偵測 SQL 注入模式。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org97c877d" class="outline-4">
<h4 id="org97c877d"><span class="section-number-4">8.1.4.</span> 第四大題 (12分)：</h4>
<div class="outline-text-4" id="text-8-1-4">
<p>
列舉與說明三個防範 SQL Injection 的方法<br />
</p>
</div>
<div id="outline-container-orgd201fbd" class="outline-5">
<h5 id="orgd201fbd">解</h5>
<div class="outline-text-5" id="text-orgd201fbd">
<p>
SQL Injection（SQL 注入）是一種嚴重的安全漏洞，攻擊者可以透過惡意 SQL 語句操控資料庫。為了防止 SQL Injection，開發者應該採取以下 三種主要防範方法：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org95edc6b"></a>1. 使用 Prepared Statements（預處理語句）<br />
<div class="outline-text-6" id="text-org95edc6b">
<p>
📌 原理: Prepared Statements（預處理語句）可確保使用者輸入的數據不會影響 SQL 語句的結構，而是作為純粹的參數處理。這種方式會將 SQL 語句與數據分開處理，避免惡意 SQL 語句被執行。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org5acb065"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-org5acb065">
<p>
Python（MySQL）<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">import</span> mysql.connector
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #dcaeea;">conn</span> = mysql.connector.connect(user=<span style="color: #98be65;">'root'</span>, password=<span style="color: #98be65;">'password'</span>, database=<span style="color: #98be65;">'test_db'</span>)
<span class="linenr">4: </span><span style="color: #dcaeea;">cursor</span> = conn.cursor(prepared=<span style="color: #a9a1e1;">True</span>)
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = %s AND password = %s"</span>
<span class="linenr">7: </span>cursor.execute(query, (username, password))
<span class="linenr">8: </span>
<span class="linenr">9: </span><span style="color: #dcaeea;">result</span> = cursor.fetchall()
</pre>
</div>
<p>
PHP（PDO）<br />
</p>
<div class="org-src-container">
<pre class="src src-php"><span class="linenr">1: </span>$<span style="color: #dcaeea;">stmt</span> = $<span style="color: #dcaeea;">pdo</span>-&gt;prepare<span style="color: #51afef;">(</span><span style="color: #98be65;">"SELECT * FROM users WHERE username = ? AND password = ?"</span><span style="color: #51afef;">)</span>;
<span class="linenr">2: </span>$<span style="color: #dcaeea;">stmt</span>-&gt;execute<span style="color: #51afef;">(</span><span style="color: #c678dd;">[</span>$<span style="color: #dcaeea;">username</span>, $<span style="color: #dcaeea;">password</span><span style="color: #c678dd;">]</span><span style="color: #51afef;">)</span>;
</pre>
</div>
<p>
這樣，即使攻擊者輸入 admin&rsquo; &#x2013;，數據庫也會將其視為 字串參數，而不是 SQL 語法，從而防止 SQL Injection。<br />
</p>
</div>
</li>
<li><a id="org00f2ded"></a>❌ 錯誤做法（易受 SQL Injection 攻擊）<br />
<div class="outline-text-7" id="text-org00f2ded">
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = '"</span> + username + <span style="color: #98be65;">"' AND password = '"</span> + password + <span style="color: #98be65;">"';"</span>
<span class="linenr">2: </span>cursor.execute(query)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#30452;&#25509;&#25340;&#25509; SQL&#65292;&#23481;&#26131;&#36973;&#21463;&#25915;&#25802;&#65281;</span>
</pre>
</div>
</div>
</li>
<li><a id="orga6c75d5"></a>🔹 優點<br />
<div class="outline-text-7" id="text-orga6c75d5">
<ul class="org-ul">
<li>✔ 完全防止 SQL Injection，因為 SQL 語句與數據分開處理<br /></li>
<li>✔ 可讀性高，寫法標準化，適用於各種程式語言（Python、Java、PHP）<br /></li>
<li>✔ 提升效能，因為 SQL 只需解析一次，之後只需替換變數<br /></li>
</ul>
</div>
</li>
<li><a id="org6213bdb"></a>🔻 缺點<br />
<div class="outline-text-7" id="text-org6213bdb">
<ul class="org-ul">
<li>❌ 需要資料庫支援（大多數現代資料庫如 MySQL、PostgreSQL、SQL Server 都支援）<br /></li>
<li>❌ 可能比單純的 SQL 拼接稍微增加開發複雜度<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org22402cd"></a>2. 使用 ORM（Object-Relational Mapping）<br />
<div class="outline-text-6" id="text-org22402cd">
<p>
📌 原理: ORM（物件關聯映射）允許開發者使用程式語言的物件來操作資料庫，而 不直接寫 SQL，從而減少 SQL Injection 風險。ORM 內建了 SQL Injection 防禦機制，自動處理 SQL 參數化。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgaf0457c"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-orgaf0457c">
<p>
Python（Django ORM）<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">from</span> myapp.models <span style="color: #51afef;">import</span> User
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #dcaeea;">user</span> = User.objects.get(username=username)
</pre>
</div>
<p>
Java（Hibernate ORM）<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Query query = session.createQuery(<span style="color: #98be65;">"FROM User WHERE username = :username"</span>);
<span class="linenr">2: </span>query.setParameter(<span style="color: #98be65;">"username"</span>, username);
<span class="linenr">3: </span>User user = (User) query.uniqueResult();
</pre>
</div>
<p>
在 ORM 中，輸入的數據會被自動轉換為參數，不會影響 SQL 結構，因此 無法被惡意 SQL 語法改變。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org3df497c"></a>🔹 優點<br />
<div class="outline-text-8" id="text-org3df497c">
<ul class="org-ul">
<li>✔ 防止 SQL Injection，因為 ORM 自動使用參數化查詢<br /></li>
<li>✔ 提高開發效率，開發者不需要直接寫 SQL<br /></li>
<li>✔ 支援多種資料庫，無需針對不同資料庫寫不同 SQL 語法<br /></li>
</ul>
</div>
</li>
<li><a id="org44227ff"></a>🔻 缺點<br />
<div class="outline-text-8" id="text-org44227ff">
<ul class="org-ul">
<li>❌ ORM 執行效率可能比原生 SQL 稍慢<br /></li>
<li>❌ 學習成本較高，需要熟悉 ORM 語法<br /></li>
<li>❌ 靈活性較低，對於複雜的 SQL 查詢（如 UNION、JOIN）可能不夠高效<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org0c147ac"></a>3. 限制使用者輸入（Input Validation &amp; Whitelisting）<br />
<ul class="org-ul">
<li><a id="org6ff7c41"></a>📌 原理<br />
<div class="outline-text-7" id="text-org6ff7c41">
<ul class="org-ul">
<li>限制輸入值的格式，確保使用者輸入內容符合預期。<br /></li>
<li>避免 SQL 特殊字符，如 &rsquo;, ", &#x2013;, ;, <i>* *</i> 等。<br /></li>
<li>使用 白名單（Whitelisting） 而不是黑名單（Blacklisting），因為黑名單容易被繞過。<br /></li>
</ul>
</div>
</li>
<li><a id="orge06af53"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-orge06af53">
<p>
限制輸入類型<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">import</span> re
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">is_valid_username</span>(username):
<span class="linenr">4: </span>    <span style="color: #51afef;">return</span> <span style="color: #c678dd;">bool</span>(re.<span style="color: #51afef;">match</span>(<span style="color: #98be65;">"^[a-zA-Z0-9_]+$"</span>, username))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#21482;&#20801;&#35377;&#33521;&#25991;&#23383;&#27597;&#12289;&#25976;&#23383;&#21644;&#24213;&#32218;</span>
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #51afef;">if</span> is_valid_username(user_input):
<span class="linenr">7: </span>    <span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = %s"</span>
<span class="linenr">8: </span>    cursor.execute(query, (user_input,))
</pre>
</div>
<p>
這樣，即使攻擊者輸入 admin&rsquo; OR &rsquo;1&rsquo;=&rsquo;1 也會被過濾掉，避免 SQL Injection。<br />
</p>

<p>
範例：只允許數字作為 ID<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">is_valid_id</span>(user_id):
<span class="linenr">2: </span>    <span style="color: #51afef;">return</span> user_id.isdigit()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#21482;&#20801;&#35377;&#25976;&#23383;</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #51afef;">if</span> is_valid_id(user_input):
<span class="linenr">5: </span>    <span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE id = %s"</span>
<span class="linenr">6: </span>    cursor.execute(query, (user_input,))
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org2a93898"></a>🔹 優點<br />
<div class="outline-text-8" id="text-org2a93898">
<ul class="org-ul">
<li>✔ 減少 SQL Injection 風險，確保輸入符合預期<br /></li>
<li>✔ 簡單易行，無需更改 SQL 語句，只需檢查輸入<br /></li>
</ul>
</div>
</li>
<li><a id="orgcc7eb42"></a>🔻 缺點<br />
<div class="outline-text-8" id="text-orgcc7eb42">
<ul class="org-ul">
<li>❌ 無法完全防止 SQL Injection，需要配合 Prepared Statements 或 ORM<br /></li>
<li>❌ 可能影響使用者體驗，如果輸入限制太嚴格，會導致合法使用者無法輸入符合需求的數據<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org9f0713c"></a>總結：三種 SQL Injection 防禦方法比較<br />
<div class="outline-text-6" id="text-org9f0713c">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">安全性</td>
<td class="org-left">易用性</td>
<td class="org-left">效能</td>
<td class="org-left">適用場景</td>
</tr>

<tr>
<td class="org-left">Prepared Statements</td>
<td class="org-left">✅✅✅（最安全）</td>
<td class="org-left">✅（稍需修改 SQL 語法）</td>
<td class="org-left">✅✅（SQL 優化）</td>
<td class="org-left">所有 SQL 應用</td>
</tr>

<tr>
<td class="org-left">ORM（物件關聯映射）</td>
<td class="org-left">✅✅（內建防 SQL Injection 機制）</td>
<td class="org-left">❌（需學習 ORM 框架）</td>
<td class="org-left">❌（有些情況較慢）</td>
<td class="org-left">需要簡化開發流程的應用</td>
</tr>

<tr>
<td class="org-left">輸入驗證（Whitelisting）</td>
<td class="org-left">✅（可降低風險）</td>
<td class="org-left">✅✅（簡單實現）</td>
<td class="org-left">✅✅（無額外效能開銷）</td>
<td class="org-left">簡單數據驗證，與其他方法搭配使用</td>
</tr>
</tbody>
</table>
<p>
最佳防禦策略<br />
</p>
<ul class="org-ul">
<li>優先使用 Prepared Statements（最佳選擇）<br /></li>
<li>若使用 ORM，確保 ORM 自帶的安全機制<br /></li>
<li>配合輸入驗證，過濾非預期輸入<br /></li>
</ul>
<p>
透過這些方法，我們可以有效防止 SQL Injection，提升應用的安全性！<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org33f7344" class="outline-4">
<h4 id="org33f7344"><span class="section-number-4">8.1.5.</span> 第五大題 (5分)：</h4>
<div class="outline-text-4" id="text-8-1-5">
<p>
說明 “downcast” 何時使用，並解釋為何可能造成runtime exception<br />
</p>
</div>
<div id="outline-container-org6a632e5" class="outline-5">
<h5 id="org6a632e5">解</h5>
<div class="outline-text-5" id="text-org6a632e5">
</div>
<ul class="org-ul">
<li><a id="org1f63d25"></a>📌 什麼是 Downcast？<br />
<div class="outline-text-6" id="text-org1f63d25">
<p>
在物件導向程式設計（Object-Oriented Programming, OOP）中，Downcasting（向下轉型） 指的是 將一個父類（superclass）引用的物件，轉型為子類（subclass）類型。這通常發生在 多態（polymorphism） 的場景下。<br />
</p>

<p>
示例: 假設有一個父類 Animal 和一個子類 Dog：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> Animal {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr"> 3: </span>        System.out.println(<span style="color: #98be65;">"Some sound..."</span>);
<span class="linenr"> 4: </span>    }
<span class="linenr"> 5: </span>}
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">class</span> Dog <span style="color: #51afef;">extends</span> Animal {
<span class="linenr"> 8: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">bark</span>() {
<span class="linenr"> 9: </span>        System.out.println(<span style="color: #98be65;">"Woof!"</span>);
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>}
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> DowncastExample {
<span class="linenr">14: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">15: </span>        Animal a = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Upcast&#65288;&#21521;&#19978;&#36681;&#22411;&#65289;&#65292;&#23433;&#20840;</span>
<span class="linenr">16: </span>        Dog d = (Dog) a;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast&#65288;&#21521;&#19979;&#36681;&#22411;&#65289;</span>
<span class="linenr">17: </span>        d.bark();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36889;&#35041;&#21487;&#20197;&#25104;&#21151;&#21628;&#21483;&#23376;&#39006;&#30340;&#26041;&#27861;</span>
<span class="linenr">18: </span>    }
<span class="linenr">19: </span>}
</pre>
</div>
<p>
在上例中，Animal a = new Dog(); 透過 向上轉型（Upcasting） 將 Dog 物件存入 Animal 型態的變數中。之後，我們執行 向下轉型（Downcasting），將 a 轉回 Dog，然後成功呼叫 bark()。<br />
</p>
</div>
</li>
<li><a id="org183fadf"></a>📌 何時使用 Downcast？<br />
<div class="outline-text-6" id="text-org183fadf">
<p>
通常情況下，當我們知道某個父類型的變數實際上是某個子類型的實例時，才會執行 Downcast。常見用途包括：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org5f28fcf"></a>1. 當多態方法傳回父類型時，需要存取子類特有的行為<br />
<div class="outline-text-7" id="text-org5f28fcf">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Animal getAnimal() {
<span class="linenr">2: </span>    <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22238;&#20659;&#23376;&#39006;</span>
<span class="linenr">3: </span>}
<span class="linenr">4: </span>
<span class="linenr">5: </span>Dog d = (Dog) getAnimal(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">6: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="orgae0b11e"></a>2. 當資料結構（如 List、Map）存放的是父類型時，需要轉型回子類型<br />
<div class="outline-text-7" id="text-orgae0b11e">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>List&lt;Animal&gt; animals = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">ArrayList</span>&lt;&gt;();
<span class="linenr">2: </span>animals.add(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>());
<span class="linenr">3: </span>
<span class="linenr">4: </span>Dog d = (Dog) animals.get(<span style="color: #da8548; font-weight: bold;">0</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">5: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="org37ea98f"></a>3. 在事件驅動架構（如 GUI 框架）中，事件處理器可能需要將父類轉型為具體的子類<br />
<div class="outline-text-7" id="text-org37ea98f">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    Object event = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">MouseEvent</span>();
<span class="linenr">2: </span>    MouseEvent me = (MouseEvent) event;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">3: </span>
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="org7b585b9"></a>📌 為何 Downcast 可能造成 Runtime Exception？<br />
<div class="outline-text-6" id="text-org7b585b9">
<p>
Downcast 並不保證一定安全，如果 父類型的變數實際上不是該子類的實例，則在運行時會發生 ClassCastException。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgb000e74"></a>❌ 錯誤示例<br />
<div class="outline-text-7" id="text-orgb000e74">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Animal a = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Animal</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#26159; Dog</span>
<span class="linenr">2: </span>Dog d = (Dog) a;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26371;&#25291;&#20986; ClassCastException</span>
<span class="linenr">3: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="org5ea6754"></a>📌 錯誤原因：<br />
<div class="outline-text-7" id="text-org5ea6754">
<ul class="org-ul">
<li>a 其實是 Animal 的實例，不是 Dog，但我們試圖把它強制轉型為 Dog，這會導致 ClassCastException。<br /></li>
</ul>
</div>
</li>
<li><a id="orgde895e4"></a>📌 如何避免 Downcast 發生 Runtime Exception？<br />
<div class="outline-text-7" id="text-orgde895e4">
<p>
以下幾種方法可以避免 Downcast 產生錯誤：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org05ca4be"></a>✅ 方法 1：使用 instanceof 先檢查<br />
<div class="outline-text-8" id="text-org05ca4be">
<p>
在 Java 和 C# 中，可以使用 instanceof（Java）或 is（C#）來檢查物件是否屬於特定類別：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">if</span> (a <span style="color: #51afef;">instanceof</span> <span style="color: #ECBE7B;">Dog</span>) {
<span class="linenr">2: </span>    Dog d = (Dog) a;
<span class="linenr">3: </span>    d.bark();
<span class="linenr">4: </span>} <span style="color: #51afef;">else</span> {
<span class="linenr">5: </span>    System.out.println(<span style="color: #98be65;">"&#19981;&#26159; Dog &#29289;&#20214;&#65292;&#28961;&#27861;&#36681;&#22411;"</span>);
<span class="linenr">6: </span>}
</pre>
</div>
<p>
優點：避免 ClassCastException，確保只有 Dog 物件才會進行轉型。<br />
</p>
</div>
</li>
<li><a id="org06d1ec7"></a>✅ 方法 2：使用 try-catch 捕捉異常<br />
<div class="outline-text-8" id="text-org06d1ec7">
<p>
如果 instanceof 不能滿足需求（如在不確定資料來源的情況下），可以使用 try-catch 來防止程式崩潰：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">try</span> {
<span class="linenr">2: </span>    Dog d = (Dog) a;
<span class="linenr">3: </span>    d.bark();
<span class="linenr">4: </span>} <span style="color: #51afef;">catch</span> (ClassCastException e) {
<span class="linenr">5: </span>    System.out.println(<span style="color: #98be65;">"&#36681;&#22411;&#22833;&#25943;&#65306;"</span> + e.getMessage());
<span class="linenr">6: </span>}
</pre>
</div>

<p>
優點：即使出錯，程式仍可繼續執行。<br />
</p>
</div>
</li>
<li><a id="orgeda49b7"></a>✅ 方法 3：使用泛型（Generics，推薦做法）<br />
<div class="outline-text-8" id="text-orgeda49b7">
<p>
如果應用程式使用 泛型，就能避免 Downcast。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> Box&lt;T&gt; {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">private</span> T value;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #51afef;">public</span> Box(T value) {
<span class="linenr"> 5: </span>        <span style="color: #a9a1e1;">this</span>.value = value;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #51afef;">public</span> T get() {
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> value;
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>}
<span class="linenr">12: </span>
<span class="linenr">13: </span>Box&lt;Dog&gt; dogBox = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Box</span>&lt;&gt;(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>());
<span class="linenr">14: </span>Dog d = dogBox.get();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#38656;&#35201; Downcast&#65292;&#39006;&#22411;&#23433;&#20840;</span>
<span class="linenr">15: </span>d.bark();
<span class="linenr">16: </span>
</pre>
</div>
<p>
優點：<br />
</p>
<ul class="org-ul">
<li>在 編譯期 就確保類型安全，不會發生 ClassCastException。<br /></li>
<li>提升程式碼的可讀性與可維護性。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgb9f42c5"></a>🔍 總結<br />
<div class="outline-text-6" id="text-orgb9f42c5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">概念</th>
<th scope="col" class="org-left">向上轉型（Upcast）</th>
<th scope="col" class="org-left">向下轉型（Downcast）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定義</td>
<td class="org-left">父類變數指向子類物件</td>
<td class="org-left">將父類變數轉回子類物件</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">✅ 安全</td>
<td class="org-left">⚠️ 可能導致 ClassCastException</td>
</tr>

<tr>
<td class="org-left">何時使用？</td>
<td class="org-left">當需要多態行為</td>
<td class="org-left">當確定變數實際類型並需存取子類功能</td>
</tr>

<tr>
<td class="org-left">如何避免錯誤？</td>
<td class="org-left">不需要特別處理</td>
<td class="org-left">✅ instanceof 檢查 ✅ try-catch ✅ 泛型</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org2f6dd0b" class="outline-4">
<h4 id="org2f6dd0b"><span class="section-number-4">8.1.6.</span> 第六大題 (20分)：</h4>
<div class="outline-text-4" id="text-8-1-6">
<p>
請用 Java 或 C++ 這兩種物件導向語言其中一種，並充分利用其物件導向程式重複使用 (reuse) 的特性來設計並撰寫下面程式：<br />
</p>
<ul class="org-ul">
<li>由使用者輸入開始日期和終止日期，然後由程式計算並輸出這段時間共有多少天（頭、尾兩天都要算，任何的年份都要適用）<br /></li>
<li>本程式規定至少要用到三個 Classes 來撰寫本程式，而且不能使用 Java 或 C++ 系統提供的內建日期函數，這些class都要有其特定的意義，並說明之。<br /></li>
<li>評分依據：程式是否符合物件導向原則，包含說明程式設計的物件導向原則，以及寫出你的程式的類別圖 (Class diagram)，該圖須包含屬性和重要方法。<br /></li>
</ul>
</div>
<div id="outline-container-orgdb48093" class="outline-5">
<h5 id="orgdb48093">解</h5>
<div class="outline-text-5" id="text-orgdb48093">
<p>
以下是完整的 C++ 物件導向設計與實作，符合物件導向 重複使用（reuse） 原則，並且 不使用內建日期函數，手動計算日期之間的天數。此程式設計了三個類別：<br />
</p>
<ol class="org-ol">
<li>Date：用來表示日期（年、月、日），並提供日期驗證、閏年判斷等功能。<br /></li>
<li>DateCalculator：計算兩個日期之間的天數，考慮閏年與不同月份天數。<br /></li>
<li>UserInterface：負責與使用者互動，接收輸入並顯示結果。<br /></li>
</ol>
</div>
<ul class="org-ul">
<li><a id="org79e9791"></a>🔹 設計概念與物件導向原則<br />
<div class="outline-text-6" id="text-org79e9791">
<p>
本設計符合以下 物件導向設計原則：<br />
</p>
<ul class="org-ul">
<li>封裝（Encapsulation）：Date、DateCalculator 和 UserInterface 各自負責不同的功能，並隱藏內部細節。<br /></li>
<li>責任分離（Separation of Concerns, SoC）：每個類別負責不同的功能：<br />
<ul class="org-ul">
<li>Date 只負責 日期的定義與處理。<br /></li>
<li>DateCalculator 負責 日期計算邏輯。<br /></li>
<li>UserInterface 負責 輸入輸出，不直接參與計算。<br /></li>
</ul></li>
<li>可重複使用（Reuse）：<br />
<ul class="org-ul">
<li>Date 類別可以在其他專案中 重複使用。<br /></li>
<li>DateCalculator 的計算方法可被擴展，例如用於未來的日期運算功能。<br /></li>
<li>UserInterface 可以在其他應用程式中使用（如時間計算應用）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org39e8e46"></a>🔹 類別圖（Class Diagram）<br />
<div class="outline-text-6" id="text-org39e8e46">
<pre class="example" id="org2068328">

+--------------------+
|      Date         |
+--------------------+
| - year: int       |
| - month: int      |
| - day: int        |
|--------------------|
| + isLeapYear(): bool  |
| + isValidDate(): bool |
| + daysInMonth(): int  |
+--------------------+

        ▲
        │
        │ 使用
        ▼

+----------------------+
|  DateCalculator      |
+----------------------+
| + calculateDaysBetween(d1: Date, d2: Date): int |
+----------------------+

        ▲
        │
        │ 使用
        ▼

+----------------------+
|  UserInterface      |
+----------------------+
| + getUserInput(): Date |
| + displayResult(): void |
+----------------------+
</pre>
</div>
</li>
<li><a id="org71522d0"></a>🔹 C++ 程式碼實作<br />
<ul class="org-ul">
<li><a id="orgcf2b5e5"></a>📌 Date 類別<br />
<div class="outline-text-7" id="text-orgcf2b5e5">
<p>
負責 日期存儲與驗證，包含：<br />
</p>
<ul class="org-ul">
<li>閏年判斷 (isLeapYear())<br /></li>
<li>檢查日期是否合法 (isValidDate())<br /></li>
<li>取得月份的天數 (daysInMonth())<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Date</span> {
<span class="linenr"> 5: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">year</span>, <span style="color: #dcaeea;">month</span>, <span style="color: #dcaeea;">day</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #c678dd;">Date</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">d</span>) {
<span class="linenr"> 9: </span>        year = y;
<span class="linenr">10: </span>        month = m;
<span class="linenr">11: </span>        day = d;
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">isLeapYear</span>() {
<span class="linenr">15: </span>        <span style="color: #51afef;">return</span> (year % <span style="color: #da8548; font-weight: bold;">4</span> == <span style="color: #da8548; font-weight: bold;">0</span> &amp;&amp; year % <span style="color: #da8548; font-weight: bold;">100</span> != <span style="color: #da8548; font-weight: bold;">0</span>) || (year % <span style="color: #da8548; font-weight: bold;">400</span> == <span style="color: #da8548; font-weight: bold;">0</span>);
<span class="linenr">16: </span>    }
<span class="linenr">17: </span>
<span class="linenr">18: </span>    <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">isValidDate</span>() {
<span class="linenr">19: </span>        <span style="color: #51afef;">if</span> (<span style="color: #ECBE7B;">month</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span> || month &gt; <span style="color: #da8548; font-weight: bold;">12</span>) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">20: </span>        <span style="color: #51afef;">if</span> (<span style="color: #ECBE7B;">day</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span> || day &gt; <span style="color: #dcaeea;">daysInMonth</span>()) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">21: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>;
<span class="linenr">22: </span>    }
<span class="linenr">23: </span>
<span class="linenr">24: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">daysInMonth</span>() {
<span class="linenr">25: </span>        <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">daysPerMonth</span>[<span style="color: #da8548; font-weight: bold;">12</span>] = {<span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">28</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>};
<span class="linenr">26: </span>        <span style="color: #51afef;">return</span> (month == <span style="color: #da8548; font-weight: bold;">2</span> &amp;&amp; isLeapYear()) ? <span style="color: #da8548; font-weight: bold;">29</span> : daysPerMonth[month - <span style="color: #da8548; font-weight: bold;">1</span>];
<span class="linenr">27: </span>    }
<span class="linenr">28: </span>};
</pre>
</div>
</div>
</li>
<li><a id="org51ac864"></a>📌 DateCalculator 類別<br />
<div class="outline-text-7" id="text-org51ac864">
<p>
負責 計算兩個日期之間的天數，考慮：<br />
</p>
<ul class="org-ul">
<li>計算完整年的天數<br /></li>
<li>計算部分年度的天數<br /></li>
<li>考慮閏年影響<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">DateCalculator</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">calculateDaysBetween</span>(<span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">d1</span>, <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">d2</span>) {
<span class="linenr"> 4: </span>        <span style="color: #51afef;">if</span> (<span style="color: #51afef; font-weight: bold;">!</span>d1.isValidDate() || <span style="color: #51afef; font-weight: bold;">!</span>d2.isValidDate()) {
<span class="linenr"> 5: </span>            cout &lt;&lt; <span style="color: #98be65;">"&#37679;&#35492;&#65306;&#36664;&#20837;&#30340;&#26085;&#26399;&#28961;&#25928;&#65281;"</span> &lt;&lt; endl;
<span class="linenr"> 6: </span>            <span style="color: #51afef;">return</span> -<span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 7: </span>        }
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30906;&#20445; d1 &#26159;&#36611;&#26089;&#30340;&#26085;&#26399;</span>
<span class="linenr">10: </span>        <span style="color: #51afef;">if</span> (d1.year &gt; d2.year || (d1.year == d2.year &amp;&amp; d1.month &gt; d2.month) ||
<span class="linenr">11: </span>            (d1.year == d2.year &amp;&amp; d1.month == d2.month &amp;&amp; d1.day &gt; d2.day)) {
<span class="linenr">12: </span>            swap(d1, d2);
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>
<span class="linenr">15: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">totalDays</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639;&#23436;&#25972;&#24180;&#20221;&#30340;&#22825;&#25976;</span>
<span class="linenr">18: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span> = d1.year; y &lt; d2.year; y++) {
<span class="linenr">19: </span>            totalDays += (Date(y, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">1</span>).isLeapYear()) ? <span style="color: #da8548; font-weight: bold;">366</span> : <span style="color: #da8548; font-weight: bold;">365</span>;
<span class="linenr">20: </span>        }
<span class="linenr">21: </span>
<span class="linenr">22: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639; d1 &#30070;&#24180;&#24230;&#21097;&#39192;&#22825;&#25976;</span>
<span class="linenr">23: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span> = d1.month; m &lt;= <span style="color: #da8548; font-weight: bold;">12</span>; m++) {
<span class="linenr">24: </span>            totalDays += Date(d1.year, m, <span style="color: #da8548; font-weight: bold;">1</span>).daysInMonth();
<span class="linenr">25: </span>        }
<span class="linenr">26: </span>        totalDays -= d1.day - <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28187;&#21435; d1 &#24050;&#32147;&#36942;&#21435;&#30340;&#22825;&#25976;</span>
<span class="linenr">27: </span>
<span class="linenr">28: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639; d2 &#30070;&#24180;&#24230;&#30340;&#24050;&#36942;&#22825;&#25976;</span>
<span class="linenr">29: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span> = <span style="color: #da8548; font-weight: bold;">1</span>; m &lt; d2.month; m++) {
<span class="linenr">30: </span>            totalDays += Date(d2.year, m, <span style="color: #da8548; font-weight: bold;">1</span>).daysInMonth();
<span class="linenr">31: </span>        }
<span class="linenr">32: </span>        totalDays += d2.day; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21152;&#19978; d2 &#30070;&#26376;&#22825;&#25976;</span>
<span class="linenr">33: </span>
<span class="linenr">34: </span>        <span style="color: #51afef;">return</span> totalDays;
<span class="linenr">35: </span>    }
<span class="linenr">36: </span>};
</pre>
</div>
</div>
</li>
<li><a id="org1b08686"></a>📌 UserInterface 類別<br />
<div class="outline-text-7" id="text-org1b08686">
<p>
負責 與使用者互動，包括：<br />
</p>
<ul class="org-ul">
<li>讀取使用者輸入<br /></li>
<li>顯示計算結果<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">UserInterface</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #c678dd;">getUserInput</span>() {
<span class="linenr"> 4: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>, <span style="color: #dcaeea;">m</span>, <span style="color: #dcaeea;">d</span>;
<span class="linenr"> 5: </span>        cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#26085;&#26399;&#65288;&#26684;&#24335;&#65306;&#24180; &#26376; &#26085;&#65289;&#65306;"</span>;
<span class="linenr"> 6: </span>        cin &gt;&gt; y &gt;&gt; m &gt;&gt; d;
<span class="linenr"> 7: </span>        <span style="color: #51afef;">return</span> Date(y, m, d);
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">displayResult</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">days</span>) {
<span class="linenr">11: </span>        <span style="color: #51afef;">if</span> (days != -<span style="color: #da8548; font-weight: bold;">1</span>) {
<span class="linenr">12: </span>            cout &lt;&lt; <span style="color: #98be65;">"&#20841;&#20491;&#26085;&#26399;&#30456;&#24046;&#22825;&#25976;&#65306;"</span> &lt;&lt; days &lt;&lt; <span style="color: #98be65;">" &#22825;"</span> &lt;&lt; endl;
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>};
</pre>
</div>
</div>
</li>
<li><a id="org92193ab"></a>📌 主函數 main()<br />
<div class="outline-text-7" id="text-org92193ab">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">UserInterface</span> <span style="color: #dcaeea;">ui</span>;
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">DateCalculator</span> <span style="color: #dcaeea;">calculator</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#38283;&#22987;&#26085;&#26399;&#65306;"</span> &lt;&lt; endl;
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">startDate</span> = ui.getUserInput();
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#32066;&#27490;&#26085;&#26399;&#65306;"</span> &lt;&lt; endl;
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">endDate</span> = ui.getUserInput();
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">days</span> = calculator.calculateDaysBetween(startDate, endDate);
<span class="linenr">12: </span>    ui.displayResult(days);
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">15: </span>}
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5253da4" class="outline-4">
<h4 id="org5253da4"><span class="section-number-4">8.1.7.</span> 第七大題 (8分)：</h4>
<div class="outline-text-4" id="text-8-1-7">
<p>
給定一個系統的 snapshot，包含 Allocation, Max, Available 等資訊，並要求使用 banker’s algorithm 回答下列問題<br />
：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Allocation</th>
<th scope="col" class="org-right">Max</th>
<th scope="col" class="org-right">Availabe</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>

<tr>
<th scope="col" class="org-left">A B C D</th>
<th scope="col" class="org-right">A B C D</th>
<th scope="col" class="org-right">A B C D</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P0</td>
<td class="org-right">2001</td>
<td class="org-right">4212</td>
<td class="org-right">3321</td>
</tr>

<tr>
<td class="org-left">P1</td>
<td class="org-right">3121</td>
<td class="org-right">5252</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P2</td>
<td class="org-right">2103</td>
<td class="org-right">2316</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P3</td>
<td class="org-right">1312</td>
<td class="org-right">1424</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P4</td>
<td class="org-right">1432</td>
<td class="org-right">3665</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
使用 banker&rsquo;s algorithm 回答下列問題：<br />
</p>
<ul class="org-ul">
<li>(a) If a request form process P1 arrives for (1, 1, 0, 0), can the request be granted immediately? Why?<br /></li>
<li>(b) If a request form process P4 arrives for (0, 0, 2, 0), can the request be granted immediately? Why?<br /></li>
</ul>
</div>
<div id="outline-container-org5088b2b" class="outline-5">
<h5 id="org5088b2b">解</h5>
<div class="outline-text-5" id="text-org5088b2b">
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">import</span> numpy <span style="color: #51afef;">as</span> np
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Given snapshot data</span>
<span class="linenr"> 4: </span><span style="color: #dcaeea;">allocation</span> = np.array([[<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>],
<span class="linenr"> 5: </span>                       [<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>],
<span class="linenr"> 6: </span>                       [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">3</span>],
<span class="linenr"> 7: </span>                       [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr"> 8: </span>                       [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">2</span>]])
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #dcaeea;">max_demand</span> = np.array([[<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr">11: </span>                        [<span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr">12: </span>                        [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">6</span>],
<span class="linenr">13: </span>                        [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">4</span>],
<span class="linenr">14: </span>                        [<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">5</span>]])
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #dcaeea;">available</span> = np.array([<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>])
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Compute the Need matrix (Max - Allocation)</span>
<span class="linenr">19: </span><span style="color: #dcaeea;">need</span> = max_demand - allocation
<span class="linenr">20: </span>
<span class="linenr">21: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Requests to check</span>
<span class="linenr">22: </span><span style="color: #dcaeea;">request_P1</span> = np.array([<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>])
<span class="linenr">23: </span><span style="color: #dcaeea;">request_P4</span> = np.array([<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">0</span>])
<span class="linenr">24: </span>
<span class="linenr">25: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Function to check if request can be granted immediately</span>
<span class="linenr">26: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">can_grant_request</span>(available, need, request, process_id):
<span class="linenr">27: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check if request is within the process's need</span>
<span class="linenr">28: </span>    <span style="color: #51afef;">if</span> np.<span style="color: #c678dd;">any</span>(request &gt; need[process_id]):
<span class="linenr">29: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>, <span style="color: #98be65;">"Request exceeds process's maximum need."</span>
<span class="linenr">30: </span>
<span class="linenr">31: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check if request is within available resources</span>
<span class="linenr">32: </span>    <span style="color: #51afef;">if</span> np.<span style="color: #c678dd;">any</span>(request &gt; available):
<span class="linenr">33: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>, <span style="color: #98be65;">"Not enough available resources to fulfill request."</span>
<span class="linenr">34: </span>
<span class="linenr">35: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">If both conditions are met, request can be granted</span>
<span class="linenr">36: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">True</span>, <span style="color: #98be65;">"Request can be granted immediately."</span>
<span class="linenr">37: </span>
<span class="linenr">38: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check both requests</span>
<span class="linenr">39: </span><span style="color: #dcaeea;">result_P1</span> = can_grant_request(available, need, request_P1, <span style="color: #da8548; font-weight: bold;">1</span>)
<span class="linenr">40: </span><span style="color: #dcaeea;">result_P4</span> = can_grant_request(available, need, request_P4, <span style="color: #da8548; font-weight: bold;">4</span>)
<span class="linenr">41: </span>
<span class="linenr">42: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Display results</span>
<span class="linenr">43: </span>result_P1, result_P4
<span class="linenr">44: </span>
</pre>
</div>
<p>
執行結果<br />
</p>
<pre class="example" id="org0e86cb9">
((True, 'Request can be granted immediately.'),
 (True, 'Request can be granted immediately.'))
</pre>
</div>
<ul class="org-ul">
<li><a id="org1ab7602"></a>解析 Banker&rsquo;s Algorithm<br />
<div class="outline-text-6" id="text-org1ab7602">
<p>
Banker&rsquo;s Algorithm 是 避免死鎖（Deadlock Avoidance） 的一種資源分配與安全性檢查算法，主要用來確保系統不會陷入不安全狀態。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org08392b5"></a>主要概念<br />
<div class="outline-text-7" id="text-org08392b5">
<ul class="org-ul">
<li>Allocation（已分配資源）：目前已分配給各進程的資源數量。<br /></li>
<li>Max（最大需求）：各進程執行所需的最大資源量。<br /></li>
<li>Need（尚需資源）：Need = Max - Allocation，表示各進程還需要多少資源才能完成。<br /></li>
<li>Available（可用資源）：目前系統可用的總資源數。<br /></li>
</ul>
</div>
</li>
<li><a id="orgc2fe910"></a>(a) Process P1 的請求 (1,1,0,0) 能否立即滿足？<br />
<div class="outline-text-7" id="text-orgc2fe910">
<p>
請求：P1 需要 (1,1,0,0)<br />
檢查步驟<br />
</p>
<ol class="org-ol">
<li>檢查 Request 是否超過 Need<br />
Need 計算：<br />
<ul class="org-ul">
<li><p>
Need=Max−Allocation<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>     <span style="color: #dcaeea;">Need</span>[P1] = (<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">2</span>) - (<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">1</span>) = (<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div></li>
<li>(1,1,0,0) &lt;= (2,1,3,1) ✅ 合法<br /></li>
</ul></li>

<li>檢查 Request 是否小於等於 Available<br />
<ul class="org-ul">
<li>Available (3,3,2,1)<br /></li>
<li>(1,1,0,0) &lt;= (3,3,2,1) ✅ 可用資源足夠<br /></li>
</ul></li>
</ol>
<p>
結論：P1 的請求 可以立即被滿足。<br />
</p>
</div>
</li>
<li><a id="org470590f"></a>(b) Process P4 的請求 (0,0,2,0) 能否立即滿足？<br />
<div class="outline-text-7" id="text-org470590f">
<p>
請求：P4 需要 (0,0,2,0)<br />
檢查步驟<br />
</p>
<ol class="org-ol">
<li>檢查 Request 是否超過 Need<br />
Need 計算：<br />
<ul class="org-ul">
<li>Need[P4] = (3,6,6,5) - (1,4,3,2) = (2,2,3,3)<br /></li>
<li>(0,0,2,0) &lt;= (2,2,3,3) ✅ 合法<br /></li>
</ul></li>
<li>檢查 Request 是否小於等於 Available<br />
<ul class="org-ul">
<li>Available (3,3,2,1)<br /></li>
<li>(0,0,2,0) &lt;= (3,3,2,1) ✅ 可用資源足夠<br /></li>
</ul></li>
</ol>
<p>
結論： P4 的請求 可以立即被滿足。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org6f9ef37"></a>最終結果<br />
<div class="outline-text-6" id="text-org6f9ef37">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Process</th>
<th scope="col" class="org-left">Request</th>
<th scope="col" class="org-left">Can be granted?</th>
<th scope="col" class="org-left">Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P1</td>
<td class="org-left">(1,1,0,0)</td>
<td class="org-left">✅ Yes</td>
<td class="org-left">Available 資源足夠，且需求符合 Need 限制</td>
</tr>

<tr>
<td class="org-left">P4</td>
<td class="org-left">(0,0,2,0)</td>
<td class="org-left">✅ Yes</td>
<td class="org-left">Available 資源足夠，且需求符合 Need 限制</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgfe69704" class="outline-4">
<h4 id="orgfe69704"><span class="section-number-4">8.1.8.</span> 第八大題 (8分)：</h4>
<div class="outline-text-4" id="text-8-1-8">
<p>
In a paging system, suppose that the hit ratio is 90% and it takes 10 ns to search the TLB and 100 ns to access memory.<br />
</p>
<ul class="org-ul">
<li>(a) What is the effective memory access time with single-level page table?<br /></li>
<li>(b) What is the effective memory access time with two-level page table?<br /></li>
</ul>
</div>
<div id="outline-container-org0423e77" class="outline-5">
<h5 id="org0423e77">解</h5>
<div class="outline-text-5" id="text-org0423e77">
</div>
<ul class="org-ul">
<li><a id="org78a6091"></a>🔹 Key Given Data<br />
<div class="outline-text-6" id="text-org78a6091">
<ul class="org-ul">
<li>TLB Search Time = 10 ns<br /></li>
<li>Memory Access Time = 100 ns<br /></li>
<li>Hit Ratio = 90% (i.e., 0.9)<br /></li>
<li>Miss Ratio = 1 - 0.9 = 0.1<br /></li>
</ul>
</div>
</li>
<li><a id="org09860b3"></a>(a) Effective Memory Access Time with Single-Level Page Table<br />
<ul class="org-ul">
<li><a id="orgf9aeebf"></a>📌 Concept<br />
<div class="outline-text-7" id="text-orgf9aeebf">
<p>
In a paging system, when a process needs to access memory:<br />
</p>
<ol class="org-ol">
<li>The TLB (Translation Lookaside Buffer) is checked first.<br /></li>
<li>If there&rsquo;s a hit, we can directly access the physical memory.<br /></li>
<li>If there&rsquo;s a miss, we need to:<br />
<ul class="org-ul">
<li>Access the page table in memory to find the frame number (cost: 100 ns).<br /></li>
<li>Then access the actual memory location (cost: 100 ns).<br /></li>
<li>Total cost in case of a miss: 200 ns.<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orgfa7d9d6"></a>📌 Formula<br />
<div class="outline-text-7" id="text-orgfa7d9d6">
<p>
Effective Memory Access Time=(TLB Hit Ratio×Hit Time)+(TLB Miss Ratio×Miss Time)<br />
=(0.9×(10+100))+(0.1×(10+100+100))<br />
</p>
</div>
</li>
<li><a id="org515699a"></a>📌 Calculation<br />
<div class="outline-text-7" id="text-org515699a">
<p>
=(0.9×110)+(0.1×210)<br />
=99+21<br />
=120 ns<br />
</p>
</div>
</li>
<li><a id="orgcd0d7a6"></a>🔹 Answer: The effective memory access time for a single-level page table is 120 ns.<br /></li>
</ul>
</li>
<li><a id="org948df83"></a>(b) Effective Memory Access Time with Two-Level Page Table<br />
<ul class="org-ul">
<li><a id="org48b562c"></a>📌 Concept<br />
<div class="outline-text-7" id="text-org48b562c">
<p>
In a two-level paging system, if a TLB miss occurs, we must perform:<br />
</p>
<ul class="org-ul">
<li>Page Table Lookup (First Level) = 100 ns<br /></li>
<li>Page Table Lookup (Second Level) = 100 ns<br /></li>
<li>Memory Access (Data Fetch) = 100 ns<br /></li>
</ul>
<p>
Thus, on a miss, we must access memory three times (300 ns total) instead of two times (200 ns total).<br />
</p>
</div>
</li>
<li><a id="org91f0bb9"></a>📌 Formula<br />
<div class="outline-text-7" id="text-org91f0bb9">
<p>
Effective Memory Access Time=(TLB Hit Ratio×Hit Time)+(TLB Miss Ratio×Miss Time)<br />
=(0.9×(10+100))+(0.1×(10+100+100+100))<br />
</p>
</div>
</li>
<li><a id="orgf51d0c0"></a>📌 Calculation<br />
<div class="outline-text-7" id="text-orgf51d0c0">
<p>
=(0.9×110)+(0.1×310)<br />
=99+31<br />
=130 ns<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org23ca479"></a>🔹 Summary of Results<br />
<div class="outline-text-6" id="text-org23ca479">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Paging System</th>
<th scope="col" class="org-left">Effective Memory Access Time (ns)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Single-Level Page Table</td>
<td class="org-left">120 ns</td>
</tr>

<tr>
<td class="org-left">Two-Level Page Table</td>
<td class="org-left">130 ns</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd1a24de" class="outline-4">
<h4 id="orgd1a24de"><span class="section-number-4">8.1.9.</span> 第九大題 (4 分)：</h4>
<div class="outline-text-4" id="text-8-1-9">
<p>
Consider a byte oriented logical address space of 8 pages of 1024 bytes each, mapped onto a physical memory of 32 frames.<br />
</p>
<ul class="org-ul">
<li>(a) How many bits are there in the logical address?<br /></li>
<li>(b) How many bits are there in the physical address?<br /></li>
</ul>
</div>
<div id="outline-container-org2cae6fb" class="outline-5">
<h5 id="org2cae6fb">解</h5>
<div class="outline-text-5" id="text-org2cae6fb">
<p>
在 分頁式記憶體管理（Paging Memory Management） 中，邏輯位址（Logical Address）由兩部分組成：<br />
</p>
<ul class="org-ul">
<li>頁號（Page Number, p）：用來索引頁表，找到對應的記憶體框架。<br /></li>
<li></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org291ffd5"></a>(a) 邏輯位址的位元數<br />
<ul class="org-ul">
<li><a id="orgb7d911b"></a>📌 已知條件<br />
<div class="outline-text-7" id="text-orgb7d911b">
<ul class="org-ul">
<li>邏輯位址空間（Logical Address Space）：<br />
<ul class="org-ul">
<li>共有 8 個頁（Pages）。<br /></li>
<li>每個頁 1024 個位元組（Bytes）。<br /></li>
</ul></li>
<li>頁內偏移量（Offset）：<br />
<ul class="org-ul">
<li>每個頁有 1024（= 2¹⁰）個位元組，所以頁內偏移量需要 10 bits 表示。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgdec4dc0"></a>📌 計算邏輯位址的位元數<br />
<div class="outline-text-7" id="text-orgdec4dc0">
<ul class="org-ul">
<li>頁號（Page Number, p）<br />
<ul class="org-ul">
<li>總共有 8 個頁（= 2³），因此 頁號需要 3 bits。<br /></li>
</ul></li>
<li>頁內偏移量（Offset, d）<br />
<ul class="org-ul">
<li>每個頁大小為 1024 Bytes（= 2¹⁰），因此 偏移量需要 10 bits。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0ebc2f4"></a>📌 總計<br />
<div class="outline-text-7" id="text-org0ebc2f4">
<p>
邏輯位址長度 = 頁號位元數 + 頁內偏移量位元數<br />
=3+10=13 bits<br />
</p>
</div>
</li>
<li><a id="org7516481"></a>🔹 答案：邏輯位址需要 13 bits。<br /></li>
</ul>
</li>
<li><a id="orgd235334"></a>(b) 物理位址的位元數<br />
<ul class="org-ul">
<li><a id="orga8f7a67"></a>📌 已知條件<br />
<div class="outline-text-7" id="text-orga8f7a67">
<ul class="org-ul">
<li>物理記憶體（Physical Memory）<br />
<ul class="org-ul">
<li>共有 32 個框架（Frames）。<br /></li>
<li>每個框架大小與頁大小相同，即 1024 Bytes。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orge7d0b71"></a>📌 計算物理位址的位元數<br />
<div class="outline-text-7" id="text-orge7d0b71">
<ul class="org-ul">
<li>框架號（Frame Number, f）<br />
<ul class="org-ul">
<li>物理記憶體有 32 個框架（= 2⁵），因此 框架號需要 5 bits。<br /></li>
</ul></li>
<li>頁內偏移量（Offset, d）<br />
<ul class="org-ul">
<li>與邏輯位址的 偏移量相同（10 bits），因為每個框架大小與頁大小一致。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org8b71844"></a>📌 總計<br />
<div class="outline-text-7" id="text-org8b71844">
<p>
物理位址長度 = 框架號位元數 + 偏移量位元數<br />
=5+10=15 bits<br />
</p>
</div>
</li>
<li><a id="org233ecbd"></a>🔹 答案：物理位址需要 15 bits。<br /></li>
</ul>
</li>
<li><a id="orga3d7e25"></a>🔹 最終結果<br />
<div class="outline-text-6" id="text-orga3d7e25">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">地址類型</th>
<th scope="col" class="org-left">所需位元數</th>
<th scope="col" class="org-left">組成部分</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">邏輯位址</td>
<td class="org-left">13 bits</td>
<td class="org-left">頁號（3 bits）+ 偏移量（10 bits）</td>
</tr>

<tr>
<td class="org-left">物理位址</td>
<td class="org-left">15 bits</td>
<td class="org-left">框架號（5 bits）+ 偏移量（10 bits）</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge626799" class="outline-4">
<h4 id="orge626799"><span class="section-number-4">8.1.10.</span> 第十大題 (5 分)：</h4>
<div class="outline-text-4" id="text-8-1-10">
<p>
Consider the two-dimensional array “A[100][100]”. If a paged memory system with pages of size 200, for two page frames, how many page faults are generated by the following array-initialization loops, using LRU replacement?<br />
</p>
<ul class="org-ul">
<li><p>
(a)  loop (a) 的程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i&lt;<span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;<span style="color: #da8548; font-weight: bold;">100</span>;j++) {
<span class="linenr">3: </span>      A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>  }
</pre>
</div></li>
<li><p>
(b) loop (b) 的程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;<span style="color: #da8548; font-weight: bold;">100</span>; j++)  {
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">ing</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">3: </span>      A[i][j]=<span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>  }
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org1bfa860" class="outline-5">
<h5 id="org1bfa860">解</h5>
<div class="outline-text-5" id="text-org1bfa860">
<p>
在這個問題中，我們要分析 二維陣列 A[100][100] 在 頁面置換策略（LRU, Least Recently Used） 下的 頁錯（Page Fault）數量，並比較不同的走訪順序對頁錯數的影響。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2855262"></a>📌 給定條件<br />
<div class="outline-text-6" id="text-org2855262">
<ul class="org-ul">
<li>陣列 A[100][100]（100 × 100 的整數陣列）。<br /></li>
<li>頁大小 = 200 Bytes。<br /></li>
<li>兩個頁框（Page Frames）。<br /></li>
<li>假設每個整數（int）佔 4 Bytes，則：<br />
<ul class="org-ul">
<li>每一行 A[i][j] 包含 100 個元素 × 4 Bytes = 400 Bytes。<br /></li>
<li>每個頁面大小為 200 Bytes，因此每個頁面能存 50 個整數（50 elements）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf7c3b39"></a>(a) 內迴圈掃描 A[i][j]<br />
<div class="outline-text-6" id="text-orgf7c3b39">
<p>
📌 程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">2: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; <span style="color: #da8548; font-weight: bold;">100</span>; j++) {
<span class="linenr">3: </span>    A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>}
</pre>
</div>
<p>
📌 記憶體訪問模式<br />
</p>
<ol class="org-ol">
<li>外層迴圈 i 先固定，內層迴圈 j 變化。<br /></li>
<li>依照 j 逐列 存取記憶體（Row-major order）。<br /></li>
<li>內部陣列 A[i][j] 是連續存取的。<br /></li>
</ol>
<p>
📌 記憶體分頁<br />
</p>
<ul class="org-ul">
<li>每行（A[i]）大小 = 400 Bytes（2 個頁面）。<br /></li>
<li>當 j 在 0 到 49 時，存取第一個頁面，50 到 99 時存取第二個頁面。<br /></li>
<li>只要 i 不變，j 遍歷時只需要 2 個頁面（正好符合兩個頁框），不會發生頁錯。<br /></li>
</ul>
<p>
📌 頁錯計算<br />
</p>
<ul class="org-ul">
<li>i=0 時，載入 A[0] 的 2 個頁面（2 次頁錯）。<br /></li>
<li>i=1 時，載入 A[1] 的 2 個頁面（2 次頁錯）。<br /></li>
<li>&#x2026; 共 100 次 i 迴圈。<br /></li>
</ul>

<p>
總頁錯數：100×2=200<br />
🔹 (a) 的總頁錯數 = 200 次。<br />
</p>
</div>
</li>
<li><a id="org0b37865"></a>(b) 內迴圈掃描 A[i][j]（反轉迴圈）<br />
<div class="outline-text-6" id="text-org0b37865">
<p>
📌 程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; <span style="color: #da8548; font-weight: bold;">100</span>; j++) {
<span class="linenr">2: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">3: </span>    A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>}
</pre>
</div>
<p>
📌 記憶體訪問模式<br />
</p>
<ul class="org-ul">
<li>外層迴圈 j 先固定，內層迴圈 i 變化。<br /></li>
<li>依照 i 逐欄 存取記憶體（Column-major order）。<br /></li>
<li>A[i][j] 每次跳 100*4=400 Bytes，直接跳到下一行的相同欄位。<br /></li>
</ul>
<p>
📌 記憶體分頁<br />
</p>
<ul class="org-ul">
<li>每列 A[i][j] 分佈在 不同的頁面。<br /></li>
<li>一次 j 迴圈，會掃描 100 個不同的頁面。<br /></li>
<li>因為只有 2 個頁框，LRU 會不斷換出頁面。<br /></li>
</ul>
<p>
📌 頁錯計算<br />
</p>
<ul class="org-ul">
<li>每次訪問 A[i][j]，它會落在新的頁面，因為 i 變化時 A[i][j] 橫跨 100 不同頁面。<br /></li>
<li>每次訪問 A[i][j]，由於只有 2 個頁框，造成頻繁換頁。<br /></li>
<li>總共 100 × 100 次訪問，每次幾乎都是頁錯。<br /></li>
</ul>

<p>
總頁錯數：100×100=10,000<br />
</p>

<p>
🔹 (b) 的總頁錯數 = 10,000 次（極大化頁錯）。<br />
</p>
</div>
</li>
<li><a id="org57c740b"></a>🔹 總結<br />
<div class="outline-text-6" id="text-org57c740b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方式</th>
<th scope="col" class="org-left">記憶體訪問模式</th>
<th scope="col" class="org-left">頁錯數</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) for (int i; int j)</td>
<td class="org-left">Row-major (逐列存取)</td>
<td class="org-left">200</td>
<td class="org-left">局部性高，不會頻繁換頁</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">(b) for (int j; int i)</td>
<td class="org-left">Column-major (逐欄存取)</td>
<td class="org-left">10,000</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">頁錯數極大化，因為跨頁存取</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
🔹 結論<br />
    (a) 的訪問模式符合記憶體的局部性原則（Locality Principle），頁錯較少（200 次）。<br />
    (b) 破壞了記憶體的局部性，造成嚴重的頁錯（10,000 次）。<br />
    分頁系統中，如何訪問記憶體會顯著影響效能。<br />
</p>
</div>
</li>
<li><a id="org4b8546c"></a>🔹 相關計算機概論知識<br />
<div class="outline-text-6" id="text-org4b8546c">
<p>
這個問題屬於 作業系統（Operating System） 和 記憶體管理（Memory Management），涉及：<br />
\[$ 這是作業系統的知識，計概裡應該有，不懂的話我再給看另一份比較基本的教材 \]$<br />
</p>
<ul class="org-ul">
<li>分頁記憶體（Paging Memory Management）<br />
<ul class="org-ul">
<li>物理記憶體被分成 固定大小的頁面。<br /></li>
<li>頁框（Page Frame）對應到邏輯記憶體的頁面。<br /></li>
</ul></li>
<li>頁面置換策略（Page Replacement Algorithms）<br />
<ul class="org-ul">
<li>LRU（Least Recently Used）：當頁框用完時，淘汰最久未使用的頁面。<br /></li>
<li>在 (b) 的訪問模式下，每次都會換出頁面，導致極高的頁錯數。<br /></li>
</ul></li>
<li>記憶體存取模式與局部性<br />
<ul class="org-ul">
<li>時間局部性（Temporal Locality）：最近存取的資料可能很快再次被存取。<br /></li>
<li>空間局部性（Spatial Locality）：與當前存取的資料相鄰的記憶體區塊可能會很快被存取。<br />
<ul class="org-ul">
<li>(a) 遵守局部性原則，因此頁錯數較低。<br /></li>
<li>(b) 破壞局部性，因此頁錯數極高。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5d44d3b" class="outline-3">
<h3 id="org5d44d3b"><span class="section-number-3">8.2.</span> 109</h3>
<div class="outline-text-3" id="text-8-2">
</div>
<div id="outline-container-org3aa5e47" class="outline-4">
<h4 id="org3aa5e47"><span class="section-number-4">8.2.1.</span> 第一題：解釋名詞 (每題 5 分，共 25 分)</h4>
<div class="outline-text-4" id="text-8-2-1">
</div>
<div id="outline-container-orgb42a6c8" class="outline-5">
<h5 id="orgb42a6c8">(A) CDMA ( Code Division Multiple Access )</h5>
<div class="outline-text-5" id="text-orgb42a6c8">
<p>
概念: CDMA 是一種無線通訊技術，允許多個使用者同時使用相同的頻率進行通訊。它的主要原理是利用獨特的碼序列（spreading code）來區分不同的使用者，而非像 TDMA 或 FDMA 那樣使用不同的時間槽或頻率。<br />
</p>
<ul class="org-ul">
<li>運作方式: 每個使用者被分配一個唯一的碼，發送的訊號會用這個碼進行編碼（spread）。接收端則利用相同的碼進行解碼，從混合的訊號中分離出目標使用者的資訊。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org6237c0c"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-org6237c0c">
<ul class="org-ul">
<li>多工技術: CDMA 屬於多工技術的一種，與 TDMA（時分多址）和 FDMA（頻分多址）並列。<br /></li>
<li>展頻技術: CDMA 運用展頻技術（Spread Spectrum），將訊號頻寬擴大，提高抗干擾能力。<br /></li>
<li>無線通訊: CDMA 常應用於行動通訊系統（如 3G 網路），允許更多使用者同時存取網路資源。<br /></li>
</ul>
</div>
</li>
<li><a id="org6424bf0"></a>CDMA, TDMA, FDMA<br />
<div class="outline-text-6" id="text-org6424bf0">
<p>
CDMA（Code Division Multiple Access）、TDMA（Time Division Multiple Access）、FDMA（Frequency Division Multiple Access）是三種不同的 多重存取技術（Multiple Access Technologies），主要應用於無線通訊系統，以允許多個使用者在同一頻譜中進行通訊。以下是三者的比較：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">特性</td>
<td class="org-left">CDMA（碼分多重存取）</td>
<td class="org-left">TDMA（時分多重存取）</td>
<td class="org-left">FDMA（頻分多重存取）</td>
</tr>

<tr>
<td class="org-left">工作原理</td>
<td class="org-left">每個用戶使用獨特的擴頻碼來區分訊號，所有用戶可在同一頻率和時間內傳輸</td>
<td class="org-left">時間被分成多個時槽，每個使用者輪流佔用時槽來傳輸訊號</td>
<td class="org-left">頻譜被分成多個頻段，每個使用者被分配一個固定的頻段進行傳輸</td>
</tr>

<tr>
<td class="org-left">頻譜使用效率</td>
<td class="org-left">高，所有用戶共享整個頻寬，透過擴頻碼區分</td>
<td class="org-left">中等，因時槽共享，可能有閒置時段</td>
<td class="org-left">低，每個使用者被分配固定頻率，頻譜利用率較低</td>
</tr>

<tr>
<td class="org-left">干擾性</td>
<td class="org-left">低，擴頻技術能降低干擾影響</td>
<td class="org-left">可能受鄰近時槽干擾（時鐘同步問題）</td>
<td class="org-left">易受鄰近頻道干擾（頻譜間干擾）</td>
</tr>

<tr>
<td class="org-left">數據傳輸</td>
<td class="org-left">可支援高數據速率，因為所有使用者可以同時傳輸</td>
<td class="org-left">數據傳輸速率受限於分配的時槽數量</td>
<td class="org-left">受限於可用頻寬，每個頻道傳輸速率固定</td>
</tr>

<tr>
<td class="org-left">同步需求</td>
<td class="org-left">低，不需要精確同步</td>
<td class="org-left">高，所有用戶必須與網路時鐘同步</td>
<td class="org-left">低，但需要精確的頻率規劃</td>
</tr>

<tr>
<td class="org-left">擴展性（Scalability）</td>
<td class="org-left">高，可動態分配用戶數量</td>
<td class="org-left">中等，固定時槽數量限制用戶數</td>
<td class="org-left">低，受限於固定頻率分配</td>
</tr>

<tr>
<td class="org-left">功耗</td>
<td class="org-left">低，因為可以以較低功率擴頻發送</td>
<td class="org-left">中等，需要同步開關發送訊號</td>
<td class="org-left">高，每個頻道需持續發射訊號</td>
</tr>

<tr>
<td class="org-left">應用</td>
<td class="org-left">3G（如 WCDMA、CDMA2000），軍事通信，衛星通訊</td>
<td class="org-left">2G（如 GSM），數位無線電話</td>
<td class="org-left">1G（如 AMPS 模擬通信），無線電廣播</td>
</tr>
</tbody>
</table>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>CDMA：最適合現代高速無線通信，頻譜利用率高，抗干擾能力強，擴展性好，但技術複雜度高。<br /></li>
<li>TDMA：在 2G 時期廣泛使用（如 GSM），需要精確同步，頻譜利用率中等。<br /></li>
<li>FDMA：最早的無線通訊技術，頻譜利用率低，現今較少用於蜂巢式網路，但仍適用於衛星通訊與無線電廣播。<br /></li>
</ul>

<p>
CDMA 由於其優越的頻譜利用效率和抗干擾能力，在 3G 和之後的無線通信技術中被廣泛採用，而 TDMA 和 FDMA 則逐漸被 CDMA 和 OFDMA（正交分頻多工）技術取代。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgaafe1db" class="outline-5">
<h5 id="orgaafe1db">(B) ARP poison attack</h5>
<div class="outline-text-5" id="text-orgaafe1db">
<ul class="org-ul">
<li>概念: ARP 欺騙是一種網路攻擊方式，攻擊者透過偽造 ARP 訊息，將自己的 MAC 位址與目標的 IP 位址關聯，達到攔截或竄改網路流量的目的<br /></li>
<li>運作方式: 攻擊者發送偽造的 ARP 回應，將自己的 MAC 位址對應到受害者的 IP 位址，當受害者發送數據時，會將數據發送到攻擊者的電腦，而非真正的目標。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org6bea3ee"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-org6bea3ee">
<ul class="org-ul">
<li>ARP (Address Resolution Protocol): ARP 是將 IP 位址轉換為 MAC 位址的網路協定。<br /></li>
<li>網路安全: ARP 欺騙屬於中間人攻擊（Man-in-the-Middle Attack）的一種，對網路安全造成威脅。<br /></li>
<li>網路協定: 了解 ARP 運作原理對於理解網路攻擊和防禦至關重要。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd71b167"></a>ARP（Address Resolution Protocol，位址解析協定）<br />
<div class="outline-text-6" id="text-orgd71b167">
<p>
ARP 是一種網路協定，用於在區域網路（LAN）中解析 IP 位址（網路層）對應的 MAC 位址（資料鏈路層）。當一台設備需要發送資料給同一子網內的另一台設備時，它需要知道對方的 MAC 地址，而 ARP 的作用就是負責獲取這個 MAC 位址。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orge08a8d8"></a>ARP 工作流程<br />
<div class="outline-text-7" id="text-orge08a8d8">
<ul class="org-ul">
<li>發送 ARP Request（請求）：<br />
<ul class="org-ul">
<li>當主機 A（例如 IP：192.168.1.10）需要與主機 B（IP：192.168.1.20）通訊，但不知道 B 的 MAC 位址時，它會發送一個 廣播（Broadcast）ARP 請求，詢問：「誰是 192.168.1.20？請提供你的 MAC 地址。」<br /></li>
<li>這個請求會傳送到子網內的所有設備。<br /></li>
</ul></li>
<li>接收 ARP Reply（回應）：<br />
<ul class="org-ul">
<li>目標設備（IP：192.168.1.20）收到 ARP Request 後，會回應自己的 MAC 位址，例如：「我是 192.168.1.20，我的 MAC 地址是 00:1A:2B:3C:4D:5E。」<br /></li>
<li>這個回應是 單播（Unicast） 回傳給發送者（192.168.1.10）。<br /></li>
</ul></li>
<li>更新 ARP 快取表（ARP Cache）：<br />
<ul class="org-ul">
<li>發送者 A 會將 B 的 MAC 地址存入自己的 ARP 快取表，未來直接使用，無需再次詢問。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org11df463"></a>ARP 欺騙（ARP Spoofing / ARP Poisoning）<br />
<div class="outline-text-6" id="text-org11df463">
<p>
ARP 欺騙 是一種網路攻擊技術，攻擊者透過發送 偽造的 ARP 回應，欺騙網路中的其他設備，使它們將攻擊者的 MAC 地址誤認為是合法設備的 MAC 地址，從而攔截或竄改資料流量。<br />
ARP 欺騙攻擊流程<br />
</p>
<ul class="org-ul">
<li>攻擊者發送偽造 ARP 回應<br />
<ul class="org-ul">
<li>假設受害者 A（IP：192.168.1.10）想要與網關（Gateway，IP：192.168.1.1）通訊。<br /></li>
<li>攻擊者 C（IP：192.168.1.100）偽造 ARP 回應，讓 A 誤以為網關的 MAC 位址是 C 的 MAC 地址。<br /></li>
<li>同時，C 也向網關偽造 ARP 回應，使網關認為 A 的 MAC 地址是 C 的 MAC。<br /></li>
</ul></li>
<li>攔截或修改資料<br />
<ul class="org-ul">
<li>受害者 A 會將所有資料發送到攻擊者 C，然後 C 再將資料轉發給真正的網關（這就是中間人攻擊（MITM，Man-in-the-Middle Attack））。<br /></li>
<li>攻擊者 C 可以：<br />
<ul class="org-ul">
<li>監聽封包（如竊取密碼、信用卡資訊）。<br /></li>
<li>修改數據（如竄改網站內容）。<br /></li>
<li>阻斷網路（不轉發封包，使受害者無法上網）。<br /></li>
</ul></li>
</ul></li>
<li>持續影響：<br />
<ul class="org-ul">
<li>由於 ARP 是無認證機制的，這種攻擊可以不斷發送 ARP 回應，使受害者的 ARP 快取表持續錯誤，導致長時間的流量劫持。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orga5a1ba6"></a>ARP 欺騙的防範方法<br />
<div class="outline-text-6" id="text-orga5a1ba6">
<ul class="org-ul">
<li>靜態 ARP 表（Static ARP Table）：<br />
<ul class="org-ul">
<li>在關鍵設備（如伺服器、網關）上手動設定 ARP 表，使其 IP-MAC 對應關係固定，不接受 ARP 更新。<br /></li>
</ul></li>
<li>使用 ARP 監控工具：<br />
<ul class="org-ul">
<li>工具如 ARPWatch、XArp 可以偵測異常的 ARP 變更。<br /></li>
</ul></li>
<li>啟用動態 ARP 檢測（DAI，Dynamic ARP Inspection）（適用於網管交換機）：<br />
<ul class="org-ul">
<li>限制未授權的 ARP 封包，防止非信任來源發送偽造 ARP 回應。<br /></li>
</ul></li>
<li>使用 VPN 或 HTTPS：<br />
<ul class="org-ul">
<li>確保資料傳輸是加密的，即使遭到攔截，攻擊者也無法直接解讀內容。<br /></li>
</ul></li>
<li>使用防火牆或 IPS（入侵防禦系統）：<br />
<ul class="org-ul">
<li>一些高級防火牆和 IPS 具備 ARP 欺騙防禦機制，可以偵測異常的 ARP 封包。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgfa43b78" class="outline-5">
<h5 id="orgfa43b78">(C) ICMP (Internet Control Message Protocol)</h5>
<div class="outline-text-5" id="text-orgfa43b78">
<ul class="org-ul">
<li>概念: ICMP 是一個網路協定，用於傳輸錯誤訊息和控制訊息<br /></li>
<li>它不是用於傳輸用戶數據，而是協助網路設備診斷和回報問題。<br /></li>
<li>運作方式: 當路由器或其他網路設備遇到問題時（如目標無法到達、逾時），會發送 ICMP 訊息給發送端，告知網路問題。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgae8d5ac"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-orgae8d5ac">
<ul class="org-ul">
<li>網路協定: ICMP 是 TCP/IP 協定族中的一個重要組成部分，與 IP 協定共同運作。<br /></li>
<li>網路診斷工具: 常用的網路診斷工具如 ping 和 traceroute 都基於 ICMP 協定。<br /></li>
<li>網路層: ICMP 運作在網路層，處理 IP 數據包的錯誤和控制訊息。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc6fc0b6" class="outline-5">
<h5 id="orgc6fc0b6">(D) MPLS (Multi-Protocol Label Switch)</h5>
<div class="outline-text-5" id="text-orgc6fc0b6">
<ul class="org-ul">
<li>概念: MPLS 是一種網路技術，用於加速數據包的轉發。它通過在數據包前添加標籤，讓路由器根據標籤快速轉發數據，而非像傳統 IP 路由那樣需要查詢路由表。<br /></li>
<li>運作方式: 進入 MPLS 網路的數據包會被賦予一個標籤，路由器根據標籤進行轉發，無需檢查 IP 位址，提高了轉發效率。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org19c4f35"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-org19c4f35">
<ul class="org-ul">
<li>網路路由: MPLS 是一種提升路由效率的技術，常應用於大型網路和電信網路。<br /></li>
<li>數據轉發: MPLS 利用標籤交換技術，減少路由器查找路由表的時間。<br /></li>
<li>網路效能: MPLS 有助於提高網路效能，降低延遲，提升 QoS（服務品質）。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org81fb604" class="outline-5">
<h5 id="org81fb604">(E) Reverse proxy server</h5>
<div class="outline-text-5" id="text-org81fb604">
<ul class="org-ul">
<li>概念: 反向代理伺服器是一種伺服器，部署在一個或多個伺服器之前，接收來自用戶端的請求，並將這些請求轉發到後端的伺服器。<br /></li>
<li>運作方式: 當用戶端發送請求時，請求首先到達反向代理伺服器，然後由代理伺服器根據規則將請求轉發到合適的後端伺服器，後端伺服器的回應也會通過反向代理伺服器返回用戶端。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgecc3b94"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-orgecc3b94">
<ul class="org-ul">
<li>網路架構: 反向代理伺服器常應用於網站伺服器，提供負載平衡、安全保護等功能。<br /></li>
<li>伺服器管理: 反向代理伺服器有助於管理多個伺服器，簡化部署和維護。<br /></li>
<li>網路安全: 反向代理伺服器可以隱藏後端伺服器的真實 IP 位址，提高安全性。<br /></li>
</ul>
</div>
</li>
<li><a id="org90d2b4f"></a>Proxy Server（代理伺服器）<br />
<div class="outline-text-6" id="text-org90d2b4f">
<p>
Proxy Server（代理伺服器） 是一種中介設備或軟體，負責在用戶（Client）與目標伺服器（Server）之間轉發網路請求。當用戶請求網頁或其他網路資源時，請求會先經過 Proxy Server，再由 Proxy Server 代表用戶與目標伺服器通訊，最後將結果回傳給用戶。<br />
</p>

<p>
簡單來說，代理伺服器就像是一個「中間人」，用來提高 安全性、隱私性、速度，或者繞過某些網路限制。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org3cc1da5"></a>Proxy Server 的運作方式<br />
<div class="outline-text-7" id="text-org3cc1da5">
<ol class="org-ol">
<li>用戶發出請求：例如，使用者希望存取 **<a href="https://example.com**，但瀏覽器的網路設置經過代理伺服器">https://example.com**，但瀏覽器的網路設置經過代理伺服器</a>。<br /></li>
<li>請求經過代理伺服器：代理伺服器收到請求後，可能會先檢查快取（Cache），如果先前已經存儲過該網頁，則直接提供快取內容，無需再次請求網頁。<br /></li>
<li>代理伺服器向目標伺服器請求：如果代理伺服器沒有快取，則它會代表用戶向 example.com 發送請求。<br /></li>
<li>目標伺服器回應：example.com 回傳內容給代理伺服器。<br /></li>
<li>代理伺服器回應用戶：代理伺服器收到回應後，可以進行處理（例如壓縮數據、過濾內容），然後將結果傳回用戶。<br /></li>
</ol>
</div>
</li>
<li><a id="orgddc8165"></a>Proxy Server 的類型<br />
<div class="outline-text-7" id="text-orgddc8165">
<ol class="org-ol">
<li>正向代理（Forward Proxy）<br />
<ul class="org-ul">
<li>用戶 → 代理伺服器 → 目標伺服器<br /></li>
<li>代理 客戶端，用來幫助使用者存取網路資源。<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>隱藏用戶 IP，保護隱私。<br /></li>
<li>突破網路封鎖（如中國防火長城）。<br /></li>
<li>快取內容，提升瀏覽速度。<br /></li>
</ul></li>
<li>例子：企業內部的 Proxy Server，限制員工只能存取特定網站。<br /></li>
</ul></li>
<li>反向代理（Reverse Proxy）<br />
<ul class="org-ul">
<li>用戶 → 反向代理伺服器 → 內部伺服器<br /></li>
<li>代理 伺服器，用來保護或強化後端伺服器的效能與安全性。<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>負載平衡（Load Balancing）：多台伺服器共同處理流量，提高效能。<br /></li>
<li>安全性：屏蔽內部伺服器的 IP，避免直接暴露於網際網路。<br /></li>
<li>內容快取：減少伺服器負擔，加快網站加載速度。<br /></li>
</ul></li>
<li>例子：Cloudflare 這類 CDN（內容傳遞網路）服務就是一種反向代理。<br /></li>
</ul></li>
<li>透明代理（Transparent Proxy）<br />
<ul class="org-ul">
<li>不需用戶設定，網路管理員強制使用<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>企業或學校監控員工或學生的網路活動。<br /></li>
<li>節省頻寬，透過快取技術提升網路效能。<br /></li>
</ul></li>
<li>缺點：無法隱藏 IP，因為請求仍然顯示使用者的原始 IP。<br /></li>
</ul></li>
<li>匿名代理（Anonymous Proxy）<br />
<ul class="org-ul">
<li>用來隱藏使用者的 IP 位址，提高匿名性。<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>繞過地區限制（如觀看 Netflix 美國限定內容）。<br /></li>
<li>提供額外的安全性，防止網站追蹤。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org629f19b"></a>Proxy Server 的主要用途<br />
<div class="outline-text-7" id="text-org629f19b">
<ol class="org-ol">
<li>網路安全與隱私保護<br />
<ul class="org-ul">
<li>隱藏用戶 IP，防止網站追蹤。<br /></li>
<li>防止駭客攻擊，保護內部伺服器不被直接攻擊。<br /></li>
</ul></li>
<li>加速網頁存取（快取）<br />
代理伺服器可以儲存（Cache）熱門的網站內容，當用戶再次存取時，直接提供快取內容，減少頻寬使用，提高瀏覽速度。<br /></li>
<li>繞過網路封鎖<br />
許多國家或機構（如學校、公司）會封鎖特定網站，使用代理伺服器可以繞過這些限制，如 Google、Facebook 在中國被封鎖，但透過代理伺服器仍可存取。<br /></li>
<li>負載平衡<br />
企業透過 反向代理 將請求分配到多台伺服器，防止單一伺服器過載，提高網站的可用性。<br /></li>
<li>網路監控與流量管理<br />
企業和學校可以透過 Proxy Server 限制員工或學生的網路使用，例如封鎖 YouTube 或社群媒體網站，以提高工作效率。<br /></li>
</ol>
</div>
</li>
<li><a id="orgf1b7714"></a>Proxy Server vs VPN 的差異<br />
<div class="outline-text-7" id="text-orgf1b7714">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">Proxy Server</th>
<th scope="col" class="org-left">VPN（虛擬私人網路）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">功能</td>
<td class="org-left">轉發網頁請求，隱藏 IP</td>
<td class="org-left">建立加密通道，確保安全與匿名</td>
</tr>

<tr>
<td class="org-left">隱私保護</td>
<td class="org-left">只適用於特定應用（如瀏覽器）</td>
<td class="org-left">全部流量加密，適用於所有應用程式</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">可能無加密，易受攻擊</td>
<td class="org-left">提供加密通訊，較安全</td>
</tr>

<tr>
<td class="org-left">速度</td>
<td class="org-left">可能較快（透過快取）</td>
<td class="org-left">可能較慢（因為加密處理）</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">翻牆、快取、負載平衡</td>
<td class="org-left">繞過政府審查、保護個人隱私</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org4ad8b4a"></a>總結<br />
<div class="outline-text-7" id="text-org4ad8b4a">
<ul class="org-ul">
<li>Proxy Server（代理伺服器） 是一種中介設備，幫助用戶與伺服器之間轉發請求，提升安全性、加速存取、繞過網路封鎖，或實現負載平衡等功能。<br /></li>
<li>根據不同用途，代理伺服器可以分為 正向代理、反向代理、透明代理、匿名代理 等。<br /></li>
<li>企業和個人使用代理伺服器來提高安全性、節省頻寬、監控網路流量，或繞過地區限制。<br /></li>
<li>VPN 提供更強的加密與匿名性，而 Proxy Server 主要用於快取與網路請求轉發。<br /></li>
</ul>
</div>
</li>
<li><a id="org985ec0f"></a>何時使用 Proxy？<br />
<div class="outline-text-7" id="text-org985ec0f">
<ul class="org-ul">
<li>✅ 想加速網站存取（快取）<br /></li>
<li>✅ 想隱藏 IP，但不在乎加密<br /></li>
<li>✅ 企業或學校需要網路監控與流量管理<br /></li>
<li>✅ 負載平衡，提高伺服器效能<br /></li>
</ul>
</div>
</li>
<li><a id="org1736241"></a>何時使用 VPN？<br />
<div class="outline-text-7" id="text-org1736241">
<ul class="org-ul">
<li>✅ 想 完全匿名，避免 ISP 或政府監控<br /></li>
<li>✅ 需要加密 上網流量，防止駭客攔截<br /></li>
<li>✅ 繞過網路審查，如中國的防火長城<br /></li>
<li>✅ 不只瀏覽器，而是所有網路流量都要隱藏<br /></li>
</ul>
<p>
如果你只是想要隱藏 IP，Proxy Server 可能就足夠，但如果你想要 完整的隱私保護與資料加密，那麼 VPN 會是更好的選擇。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org792661f" class="outline-4">
<h4 id="org792661f"><span class="section-number-4">8.2.2.</span> 第二題(共 25 分)：</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
Sometimes we wish to store passwords in a database. When storing passwords, we need to take extra considerations in the database design.<br />
</p>
</div>
<div id="outline-container-org4c942fc" class="outline-5">
<h5 id="org4c942fc">(A) (10 分) Read the following statements. Place a tick in the box if the statement is true, otherwise place a cross.</h5>
<div class="outline-text-5" id="text-org4c942fc">
<ol class="org-ol">
<li>Password hashing can protect the website from being breached.<br /></li>
<li>It’s possible for a hashing algorithm to have a collision or a clash.<br /></li>
<li>A hash is a string or number generated from a string of text.<br /></li>
<li>The best hashing algorithms are designed so that it’s impossible to turn a hash back into its original string.<br /></li>
<li>When a hash algorithm is given the same input, the same output is always produced.<br /></li>
<li>Password hashing must be done on the client-side where the user enters the password.<br /></li>
<li>Fast hashing functions such as MD5, SHA1 are safer than slow hashing algorithms.<br /></li>
<li>A copy of the plain password should be stored securely in the database in case the user forgets his/her password.<br /></li>
<li>If password hashing is done on the client-side, it must be done again on the server-side.<br /></li>
<li>Hashing and Encryption are the same.<br /></li>
</ol>
</div>
<ul class="org-ul">
<li><a id="org8257072"></a>解<br />
<div class="outline-text-6" id="text-org8257072">
<ol class="org-ol">
<li>密碼雜湊可以保護網站免於被入侵。 (錯誤)<br />
<ul class="org-ul">
<li>詳解： 密碼雜湊的主要目的是保護使用者密碼，而非直接保護網站本身。雖然良好的雜湊機制能降低密碼洩漏的風險，但網站仍可能因其他漏洞（如SQL注入、程式碼漏洞）而被入侵。<br /></li>
</ul></li>
<li>雜湊演算法可能發生碰撞（collision）或衝突（clash）。 (正確)<br />
<ul class="org-ul">
<li>詳解：  雜湊函數的特性是將任意長度的輸入轉換成固定長度的輸出。由於輸入的範圍可能大於輸出的範圍，不同的輸入有可能產生相同的輸出，這種情況就稱為碰撞或衝突。<br /></li>
</ul></li>
<li>雜湊是一個由文字字串產生的字串或數字。 (正確)<br />
<ul class="org-ul">
<li>詳解：  雜湊函數的輸出結果是一個固定長度的字串或數字，此輸出是從輸入的文字字串轉換而來，用來代表原始輸入<br /></li>
</ul></li>
<li>最佳的雜湊演算法設計成無法將雜湊值還原成原始字串。 (正確)<br />
<ul class="org-ul">
<li>詳解：  單向雜湊函數（one-way hash function） 的設計目標是 不可逆性，也就是無法從雜湊值反推出原始輸入。這是為了確保密碼在洩漏時，攻擊者無法輕易還原出原始密碼<br /></li>
</ul></li>
<li>當雜湊演算法給定相同的輸入時，永遠會產生相同的輸出。 (正確)<br />
<ul class="org-ul">
<li>詳解：  確定性雜湊函數 的重要特性之一就是，相同的輸入總是會產生相同的輸出。這確保了雜湊值的一致性和可比性。因此，這句話的敘述是正確的。<br /></li>
</ul></li>
<li>密碼雜湊必須在使用者輸入密碼的客戶端進行。 (錯誤)<br />
<ul class="org-ul">
<li>詳解：  雖然可以在客戶端進行雜湊，但為了安全性考量，密碼雜湊通常會在伺服器端進行。這是為了避免雜湊演算法在客戶端被洩漏或竄改<br /></li>
</ul></li>
<li>像MD5、SHA1這種快速雜湊函數比慢速雜湊函數更安全。 (錯誤)<br />
<ul class="org-ul">
<li>詳解：  快速雜湊函數（如MD5、SHA1）由於設計上的缺陷和容易被破解，反而安全性較低。現代的密碼雜湊應採用更強壯的算法（如SHA-256、bcrypt、scrypt等）<br /></li>
</ul></li>
<li>為了在使用者忘記密碼時使用，應該將明文密碼安全地儲存在資料庫中。 (錯誤)<br />
<ul class="org-ul">
<li>詳解：  絕對不應該儲存明文密碼，這是嚴重的安全漏洞。 應該使用雜湊處理後的密碼儲存在資料庫，忘記密碼時應透過密碼重設流程<br /></li>
</ul></li>
<li>如果密碼雜湊在客戶端進行，就必須在伺服器端再次進行。 (正確)<br />
<ul class="org-ul">
<li>詳解：  為了確保安全性，如果客戶端進行了雜湊，伺服器端必須再次進行雜湊，防止中間人攻擊或客戶端雜湊被破解<br /></li>
</ul></li>
<li>雜湊和加密是相同的。 (錯誤)<br />
<ul class="org-ul">
<li>詳解：  雜湊和加密是不同的概念。雜湊是單向的，不可逆；加密是雙向的，可逆。加密的目的是保護數據的機密性，而雜湊的目的是驗證數據的完整性或密碼的安全性。因此，這句話的敘述是錯誤的<br /></li>
</ul></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgd905e93" class="outline-5">
<h5 id="orgd905e93">(B) (15 分)</h5>
<div class="outline-text-5" id="text-orgd905e93">
<p>
What is a salt? And why it is important when hashing a password?<br />
</p>
<ul class="org-ul">
<li>Salt的定義：Salt是一個隨機產生的字串，在進行雜湊計算之前會附加到密碼上。這個Salt值是隨機產生且唯一的，每個使用者都應該有不同的Salt值<br /></li>
<li>Salt的重要性：防止彩虹表攻擊：彩虹表是一種預先計算好的雜湊值表，攻擊者可以透過查詢表來還原密碼。使用Salt可以使每個密碼的雜湊值都不同，即使是相同的密碼，因為Salt值不同產生的雜湊值也會不同，從而阻止攻擊者使用彩虹表<br /></li>
<li>增加雜湊的複雜度：Salt值可以使雜湊值更加複雜，增加破解難度。即使攻擊者獲取了雜湊值，也很難在沒有Salt值的情況下還原出原始密碼。<br /></li>
<li>強化密碼安全：使用Salt是現代密碼安全實踐的重要一環，可以顯著提高密碼的安全性。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9c040ce" class="outline-5">
<h5 id="org9c040ce">相關計概知識：</h5>
<div class="outline-text-5" id="text-org9c040ce">
<ul class="org-ul">
<li>雜湊函數（Hash Function）：<br />
<ul class="org-ul">
<li>將任意長度的輸入轉換為固定長度的輸出。<br /></li>
<li>具有確定性，相同的輸入產生相同的輸出。<br /></li>
<li>理想的雜湊函數具有單向性（不可逆）。<br /></li>
</ul></li>
<li>密碼雜湊（Password Hashing）：<br />
<ul class="org-ul">
<li>使用雜湊函數對密碼進行處理，以保護密碼安全。<br /></li>
<li>通常與鹽值一起使用，提高安全性。<br /></li>
</ul></li>
<li>彩虹表攻擊（Rainbow Table Attack）：<br />
<ul class="org-ul">
<li>一種預先計算好雜湊值的攻擊方式，透過查詢表來還原密碼。<br /></li>
<li>使用Salt可以有效防止此類攻擊。<br /></li>
</ul></li>
<li>單向函數（One-way Function）：<br />
<ul class="org-ul">
<li>一種易於計算但難以反向計算的函數。<br /></li>
<li>雜湊函數是一種單向函數。<br /></li>
</ul></li>
<li>現代密碼雜湊算法：<br />
<ul class="org-ul">
<li>SHA-256、SHA-512、bcrypt、scrypt等，這些算法都經過嚴格的設計和審查，能提供更高的安全性。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5981cc6" class="outline-4">
<h4 id="org5981cc6"><span class="section-number-4">8.2.3.</span> 第三題：(5 分)</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
Choose the correct answer(s) regarding interface and abstract class in Java. [single or multiple choices]<br />
</p>
<ul class="org-ul">
<li>(a) They are the same.<br /></li>
<li>(b) Both can have constants as their attributes.<br /></li>
<li>(c) An abstract class is used in Java to realize multiple inheritances.<br /></li>
<li>(d) An interface cannot define any method implementation, but an abstract class can.<br /></li>
<li>(e) To have any instance of their type instantiated, they both need other class(es).<br /></li>
</ul>
</div>
<div id="outline-container-orgc81903a" class="outline-5">
<h5 id="orgc81903a">解</h5>
<div class="outline-text-5" id="text-orgc81903a">
<ul class="org-ul">
<li>(a) 他們是相同的。 (錯誤)<br />
<ul class="org-ul">
<li>詳解： 介面和抽象類別在Java中是不同的概念，它們有不同的用途和特性。介面定義了類別必須實作的方法，而抽象類別則可以包含實作的方法以及抽象的方法。<br /></li>
</ul></li>
<li>(b) 兩者都可以有常數作為其屬性。 (正確)<br />
<ul class="org-ul">
<li>詳解： 介面中的屬性預設為 public static final，也就是常數。抽象類別中也可以定義 public static final 的常數屬性。因此，這個敘述是正確的。<br /></li>
</ul></li>
<li>(c) 抽象類別在Java中被用來實現多重繼承。 (錯誤)<br />
<ul class="org-ul">
<li>詳解： 在Java中，類別不支援多重繼承，但介面可以實現多重繼承。抽象類別的主要目的是作為一個基底類別，用於定義子類別的共同行為。因此，這個敘述是錯誤的。<br /></li>
</ul></li>
<li>(d) 介面不能定義任何方法的實作，但抽象類別可以。 (正確)<br />
<ul class="org-ul">
<li>詳解： 在Java 8之前，介面只能定義抽象方法（沒有實作）。而在Java 8之後，介面可以定義default方法，提供預設的實作。抽象類別可以包含抽象方法和具體實作的方法。因此，這個敘述是正確的。<br /></li>
</ul></li>
<li>(e) 要實例化它們的任何類型，它們都需要其他類別。 (正確)<br />
<ul class="org-ul">
<li>詳解：  介面和抽象類別都不能直接實例化。必須透過其他類別來實作介面或繼承抽象類別，並建立子類別的實例。因此，這個敘述是正確的。<br /></li>
</ul></li>
</ul>
<p>
正確答案：(b), (d), (e)<br />
</p>
</div>
</div>
<div id="outline-container-orgb3f242b" class="outline-5">
<h5 id="orgb3f242b">相關計概知識：</h5>
<div class="outline-text-5" id="text-orgb3f242b">
<ul class="org-ul">
<li>介面（Interface）：<br />
<ul class="org-ul">
<li>是一種完全抽象的類型，只定義方法簽名（沒有實作）。<br /></li>
<li>可以實現多重繼承。<br /></li>
<li>介面中的屬性預設是 public static final，也就是常數。<br /></li>
<li>從Java 8開始，介面可以使用default關鍵字定義預設實作的方法。<br /></li>
</ul></li>
<li>抽象類別（Abstract Class）：<br />
<ul class="org-ul">
<li>是一種不能直接實例化的類別。<br /></li>
<li>可以包含抽象方法和具體實作的方法。<br /></li>
<li>主要用作基底類別，用於定義子類別的共同行為。<br /></li>
<li>類別只能繼承一個抽象類別。<br /></li>
</ul></li>
<li>抽象方法（Abstract Method）：<br />
<ul class="org-ul">
<li>只有方法簽名，沒有方法實作。<br /></li>
<li>必須在子類別中實作。<br /></li>
</ul></li>
<li>多重繼承 (Multiple Inheritance)<br />
<ul class="org-ul">
<li>在Java中，類別無法直接繼承多個類別，但可以透過實作多個介面來達到類似的效果。<br /></li>
</ul></li>
<li>實例化（Instantiation）：<br />
<ul class="org-ul">
<li>創建一個類別的對象。<br /></li>
<li>抽象類別和介面都不能直接實例化。<br /></li>
</ul></li>
</ul>
<p>
總結: 理解介面和抽象類別的差異是Java程式設計中非常重要的一部分。介面提供了一種定義合約的方式，而抽象類別則提供了一種定義基底類別的方式。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7096d78" class="outline-4">
<h4 id="org7096d78"><span class="section-number-4">8.2.4.</span> 第四題：(20 分)</h4>
<div class="outline-text-4" id="text-8-2-4">
<p>
Many programs written with inheritance could be written with composition instead. Please provide an example of rewriting a program with inheritance to a program with composition, and compare the pro and cons of both approaches and examples. Your examples should be of the appropriate depth for illustration.<br />
</p>
</div>
<div id="outline-container-org7b6f35e" class="outline-5">
<h5 id="org7b6f35e">解</h5>
<div class="outline-text-5" id="text-org7b6f35e">
<p>
題目要求我們探討使用組合來替代繼承，並比較兩者的優缺點。以下我將提供一個範例說明，並比較兩種方式的利弊。<br />
範例：使用繼承與組合來設計一個「車輛」系統<br />
假設我們需要設計一個簡單的車輛系統，包含 Car（汽車）和 Engine（引擎）。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org6e3677a"></a>1. 使用繼承（Inheritance）的設計：<br />
<div class="outline-text-6" id="text-org6e3677a">
<p>
程式碼範例 (使用虛擬碼，概念為主):<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29238;&#39006;&#21029;&#65306;&#24341;&#25806;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Engine</span> {
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">start</span>() {
<span class="linenr"> 4: </span>        print(<span style="color: #98be65;">"Engine started."</span>);
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23376;&#39006;&#21029;&#65306;&#27773;&#36554; (&#32380;&#25215;&#24341;&#25806;)</span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Car</span> <span style="color: #ECBE7B;">extends</span> <span style="color: #dcaeea;">Engine</span> {
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">void</span> drive() {
<span class="linenr">11: </span>        start(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#32380;&#25215;&#20358;&#30340;&#24341;&#25806;&#21855;&#21205;&#26041;&#27861;</span>
<span class="linenr">12: </span>        print(<span style="color: #98be65;">"Car is driving."</span>);
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>}
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">void</span> main(<span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">args</span>[]){
<span class="linenr">17: </span>    <span style="color: #ECBE7B;">Car</span> <span style="color: #dcaeea;">myCar</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Car</span>();
<span class="linenr">18: </span>    myCar.drive();
<span class="linenr">19: </span>}
</pre>
</div>
<p>
說明：<br />
</p>
<ul class="org-ul">
<li>◦Car 類別繼承 Engine 類別，因此 Car 擁有 Engine 的 start() 方法。<br /></li>
<li>◦這種設計方式簡單直接，程式碼較短。<br /></li>
</ul>
</div>
</li>
<li><a id="org1746af3"></a>2. 使用組合（Composition）的設計：<br />
<div class="outline-text-6" id="text-org1746af3">
<p>
程式碼範例 (使用虛擬碼，概念為主):<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24341;&#25806;&#39006;&#21029;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Engine</span> {
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">start</span>() {
<span class="linenr"> 4: </span>        print(<span style="color: #98be65;">"Engine started."</span>);
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27773;&#36554;&#39006;&#21029; (&#32068;&#21512;&#24341;&#25806;)</span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Car</span> {
<span class="linenr">10: </span>    <span style="color: #51afef;">private</span> Engine engine; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27773;&#36554;&#21253;&#21547;&#19968;&#20491;&#24341;&#25806;</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #51afef;">public</span> Car(<span style="color: #ECBE7B;">Engine</span> <span style="color: #dcaeea;">engine</span>) {
<span class="linenr">13: </span>        <span style="color: #51afef;">this</span>.engine = engine;
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">drive</span>() {
<span class="linenr">17: </span>        engine.start(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#32068;&#21512;&#30340;&#24341;&#25806;&#21855;&#21205;&#26041;&#27861;</span>
<span class="linenr">18: </span>        print(<span style="color: #98be65;">"Car is driving."</span>);
<span class="linenr">19: </span>    }
<span class="linenr">20: </span>}
<span class="linenr">21: </span>
<span class="linenr">22: </span>
<span class="linenr">23: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">void</span> main(<span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">args</span>[]){
<span class="linenr">24: </span>  <span style="color: #ECBE7B;">Engine</span> <span style="color: #dcaeea;">myEngine</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Engine</span>();
<span class="linenr">25: </span>  <span style="color: #ECBE7B;">Car</span> <span style="color: #dcaeea;">myCar</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Car</span>(myEngine);
<span class="linenr">26: </span>  myCar.drive();
<span class="linenr">27: </span>}
</pre>
</div>
<p>
說明：<br />
</p>
<ul class="org-ul">
<li>Car 類別包含一個 Engine 物件，而不是繼承自 Engine。<br /></li>
<li>Car 透過呼叫 Engine 物件的 start() 方法來啟動引擎。<br /></li>
<li>這種設計方式更加靈活，可以更容易地更換或修改引擎。<br /></li>
</ul>
<p>
比較：繼承 vs. 組合<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">繼承 (Inheritance)</th>
<th scope="col" class="org-left">組合 (Composition)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">關係</td>
<td class="org-left">「is-a」（是一種）關係 例如: 汽車是一種引擎</td>
<td class="org-left">「has-a」（有一個）關係 例如: 汽車有一個引擎</td>
</tr>

<tr>
<td class="org-left">耦合性</td>
<td class="org-left">高耦合，子類別高度依賴父類別</td>
<td class="org-left">低耦合，類別間獨立性較高</td>
</tr>

<tr>
<td class="org-left">彈性</td>
<td class="org-left">彈性較低，不易修改和擴充</td>
<td class="org-left">彈性較高，易於修改和擴充</td>
</tr>

<tr>
<td class="org-left">程式碼重用</td>
<td class="org-left">透過繼承直接重用父類別的程式碼</td>
<td class="org-left">透過組合重用其他類別的功能</td>
</tr>

<tr>
<td class="org-left">多重繼承</td>
<td class="org-left">在Java等語言中不支援多重類別繼承</td>
<td class="org-left">可以透過組合多個物件實現類似效果</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">類別之間存在明顯的層級關係</td>
<td class="org-left">類別之間需要靈活組合或變更</td>
</tr>
</tbody>
</table>
<p>
優缺點分析：<br />
</p>
<ul class="org-ul">
<li>繼承的優點：<br />
<ul class="org-ul">
<li>程式碼較為簡潔，結構清晰。<br /></li>
<li>易於建立層次結構。<br /></li>
<li>能夠直接使用父類別的方法和屬性，減少重複程式碼。<br /></li>
</ul></li>
<li>繼承的缺點：<br />
<ul class="org-ul">
<li>耦合性高，子類別過於依賴父類別，修改父類別可能會影響子類別。<br /></li>
<li>彈性較低，難以在執行時動態變更繼承關係。<br /></li>
<li>可能導致「脆弱的基底類別」問題，基底類別的修改會影響許多子類別。<br /></li>
<li>在Java中，不支援多重繼承，限制了程式碼的擴展性。<br /></li>
</ul></li>
<li>組合的優點：<br />
<ul class="org-ul">
<li>耦合性低，類別間獨立性高，修改其中一個類別對其他類別影響較小。<br /></li>
<li>彈性高，易於在執行時動態變更組合關係。<br /></li>
<li>可以透過組合不同的類別，實現更複雜的功能。<br /></li>
<li>避免了繼承的「脆弱的基底類別」問題。<br /></li>
</ul></li>
<li>組合的缺點：<br />
<ul class="org-ul">
<li>程式碼可能較為繁瑣，需要處理物件之間的關係。<br /></li>
<li>需要建立額外的物件，可能會增加程式碼的複雜度。<br /></li>
</ul></li>
</ul>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>在設計系統時，應該根據實際情況選擇繼承或組合。<br /></li>
<li>當類別之間存在明顯的「is-a」關係時，可以使用繼承。 例如，汽車是一種交通工具。<br /></li>
<li>當類別之間需要靈活組合或變更時，應該使用組合。 例如，汽車包含引擎、輪胎等元件。<br /></li>
<li>在現代軟體設計中，組合通常比繼承更受推崇，因為它提供了更高的彈性和可維護性。<br /></li>
</ul>
<p>
相關計概知識：<br />
</p>
<ul class="org-ul">
<li>繼承 (Inheritance):<br />
<ul class="org-ul">
<li>一種物件導向程式設計的機制，允許一個類別（子類別）繼承另一個類別（父類別）的屬性和方法。<br /></li>
<li>有助於程式碼重用和建立層次結構。<br /></li>
</ul></li>
<li>組合 (Composition):<br />
<ul class="org-ul">
<li>一種物件導向程式設計的機制，允許一個類別包含另一個類別的物件，並使用該物件的功能。<br /></li>
<li>有助於提高彈性和可維護性，降低耦合性。<br /></li>
</ul></li>
<li>耦合性 (Coupling):<br />
<ul class="org-ul">
<li>衡量不同模組之間相互依賴程度的指標。<br /></li>
<li>高耦合表示模組之間依賴性高，修改一個模組可能影響其他模組。<br /></li>
<li>低耦合表示模組之間獨立性高，修改一個模組對其他模組影響較小。<br /></li>
</ul></li>
<li>物件導向程式設計 (Object-Oriented Programming, OOP):<br />
<ul class="org-ul">
<li>一種程式設計範式，以物件為中心，將資料和操作資料的方法封裝在一起。<br /></li>
<li>OOP 的主要概念包括：封裝、繼承和多型。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgdd27490" class="outline-4">
<h4 id="orgdd27490"><span class="section-number-4">8.2.5.</span> 第五題：(5 分)</h4>
<div class="outline-text-4" id="text-8-2-5">
<p>
Please draw the diagram of process state.<br />
</p>
<ul class="org-ul">
<li>直接把這篇看完，背起來，這是最基本的OS考題<br />
<a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html">https://chenhh.gitbooks.io/parallel_processing/content/process.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org815e1cf" class="outline-4">
<h4 id="org815e1cf"><span class="section-number-4">8.2.6.</span> 第六題：(4 分)</h4>
<div class="outline-text-4" id="text-8-2-6">
<p>
What is four conditions of deadlock occurring?<br />
</p>
<ul class="org-ul">
<li>看這篇：<a href="https://medium.com/algorithm-solving/os-deadlock-842b31602908">https://medium.com/algorithm-solving/os-deadlock-842b31602908</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org084cf56" class="outline-4">
<h4 id="org084cf56"><span class="section-number-4">8.2.7.</span> 第七題：(4 分)</h4>
<div class="outline-text-4" id="text-8-2-7">
<p>
Please explain the Belady’s Anomaly. Which page replacement algorithm will suffer this fatal problem?<br />
</p>
</div>
<div id="outline-container-orgd0c51f2" class="outline-5">
<h5 id="orgd0c51f2">解</h5>
<div class="outline-text-5" id="text-orgd0c51f2">
<p>
作業系統的記憶體管理，計概裡應該有<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2a1e517"></a>Belady&rsquo;s Anomaly (貝雷迪異常):<br />
<div class="outline-text-6" id="text-org2a1e517">
<p>
貝雷迪異常是指在某些情況下，當分頁置換演算法分配更多頁框 (page frames) 給程序時，反而導致頁面錯誤 (page faults) 的數量增加 [未在來源中提及]。這種現象違反直覺，因為一般來說，我們期望有更多的記憶體空間可以減少頁面錯誤的發生。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2d9f28b"></a>受 Belady&rsquo;s Anomaly 影響的頁面置換演算法<br />
<div class="outline-text-7" id="text-org2d9f28b">
<ul class="org-ul">
<li>先進先出 (First-In-First-Out, FIFO) 頁面置換演算法 是最常受 Belady&rsquo;s Anomaly 影響的演算法 [未在來源中提及]。<br />
<ul class="org-ul">
<li>FIFO 演算法會置換最早進入記憶體的頁面，而不管該頁面是否經常被使用。<br /></li>
<li>由於這種特性，FIFO 在某些特定的頁面引用順序下，可能會出現增加頁框數反而增加頁面錯誤的情況。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org5523425"></a>為什麼 FIFO 會受到 Belady&rsquo;s Anomaly 的影響？<br />
<div class="outline-text-7" id="text-org5523425">
<p>
FIFO 演算法的缺點在於它 沒有考慮到頁面的使用頻率或重要性。當增加頁框數量時，可能會出現以下情況：<br />
</p>
<ul class="org-ul">
<li>新的頁框可能被分配給了不常使用的頁面。<br /></li>
<li>原來經常使用的頁面，反而因為進入時間較早而被置換出去。<br /></li>
<li>導致後續對這些經常使用頁面的存取，必須再次從主記憶體載入，造成頁面錯誤增加。<br /></li>
</ul>
</div>
</li>
<li><a id="org02587fc"></a>其他頁面置換演算法<br />
<div class="outline-text-7" id="text-org02587fc">
<p>
以下是一些常見的頁面置換演算法，它們的設計目標是減少頁面錯誤，並且通常不會受到 Belady&rsquo;s Anomaly 的影響：<br />
</p>
<ul class="org-ul">
<li>最近最少使用 (Least Recently Used, LRU) 演算法 [未在來源中提及]：<br />
<ul class="org-ul">
<li>LRU 演算法會置換最近最少使用的頁面。<br /></li>
<li>它基於局部性原理，即最近被使用的頁面，在未來也很有可能被使用。<br /></li>
<li>LRU 通常比 FIFO 有更好的效能，且不會有 Belady&rsquo;s Anomaly 的問題。<br /></li>
</ul></li>
<li>最佳化 (Optimal) 演算法 [未在來源中提及]：<br />
<ul class="org-ul">
<li>最佳化演算法會置換未來最久不會被使用的頁面。<br /></li>
<li>它在理論上可以達到最小的頁面錯誤率，但實際中無法實現，因為我們無法預知未來頁面的存取模式。<br /></li>
<li>通常用於評估其他演算法的效能。<br /></li>
</ul></li>
<li>時鐘 (Clock) 演算法 [未在來源中提及]：<br />
<ul class="org-ul">
<li>時鐘演算法是一種近似 LRU 演算法，它使用一個環形緩衝區和一個指針。<br /></li>
<li>它在效能和實作複雜度之間取得了平衡。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org2a0863e"></a>相關計算機概論知識：<br />
<div class="outline-text-6" id="text-org2a0863e">
<ul class="org-ul">
<li>分頁 (Paging):<br />
<ul class="org-ul">
<li>一種記憶體管理技術，將程式的邏輯位址空間分割成固定大小的頁面，並將實體記憶體分割成大小相同的頁框 [未在來源中提及]。<br /></li>
<li>允許程式使用不連續的記憶體空間，提高記憶體的利用率。<br /></li>
</ul></li>
<li>頁框 (Page Frame):<br />
<ul class="org-ul">
<li>實體記憶體中固定大小的區塊，用於存放程式的頁面 [未在來源中提及]。<br /></li>
</ul></li>
<li>頁面錯誤 (Page Fault):<br />
<ul class="org-ul">
<li>當程式嘗試存取的頁面不在實體記憶體中時，會發生頁面錯誤 [未在來源中提及]。<br /></li>
<li>此時，操作系統必須從輔助儲存裝置（如硬碟）載入該頁面到記憶體中。<br /></li>
</ul></li>
<li>頁面置換 (Page Replacement):<br />
<ul class="org-ul">
<li>當實體記憶體中的頁框被佔滿，需要載入新的頁面時，必須選擇一個頁面置換出去 [未在來源中提及]。<br /></li>
<li>頁面置換演算法的目標是盡量減少頁面錯誤的發生。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org6f0c162"></a>總結<br />
<div class="outline-text-6" id="text-org6f0c162">
<ul class="org-ul">
<li>Belady&rsquo;s Anomaly 是一種違反直覺的現象，即增加頁框數量反而會增加頁面錯誤。<br /></li>
<li>FIFO 頁面置換演算法是主要的受害者。<br /></li>
<li>了解 Belady&rsquo;s Anomaly 可以幫助我們更好地選擇和設計有效的頁面置換演算法。<br /></li>
<li>理解分頁、頁框、頁面錯誤等概念，對於理解頁面置換演算法非常重要。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5d889d3" class="outline-4">
<h4 id="org5d889d3"><span class="section-number-4">8.2.8.</span> 第八題：(6 分)</h4>
<div class="outline-text-4" id="text-8-2-8">
<p>
Without any doubt, real-time scheduler must support preemptive and priority-based scheduling. For hard real-time scheduling must provide ability to meet deadlines. Given two processes P1 and P2, the periodic generated time of P1 and P2 are p1=50 and p2=80, respectively. And the processing time of P1 and P2 are t1=25 and t2=35, respectively. (A) Can these two processes be scheduled using rate-monotonic scheduling? Why? (B) Can these two processes be scheduled using earliest-deadline-first scheduling (EDF)? Why?<br />
</p>
</div>
<div id="outline-container-orgbacfa3e" class="outline-5">
<h5 id="orgbacfa3e">解</h5>
<div class="outline-text-5" id="text-orgbacfa3e">
</div>
<ul class="org-ul">
<li><a id="orge205de5"></a>即時排程 (Real-Time Scheduling)<br />
<div class="outline-text-6" id="text-orge205de5">
<p>
即時系統 (real-time system) 指的是那些對於時間有嚴格要求的系統 [未在來源中提及]。即時排程的目標是確保在規定的時間內完成任務。即時系統可分為硬即時 (hard real-time) 和軟即時 (soft real-time) 兩類 [未在來源中提及]：<br />
</p>
<ul class="org-ul">
<li>硬即時系統：必須絕對保證任務在截止時間 (deadline) 前完成，否則可能造成嚴重後果，例如飛機控制系統。<br /></li>
<li>軟即時系統：允許錯過一些截止時間，但會降低系統效能，例如影音串流。<br /></li>
</ul>
<p>
根據題目敘述，硬即時排程必須能夠滿足截止時間的要求。此外，即時排程必須支援搶佔式 (preemptive) 和基於優先權 (priority-based) 的排程<br />
</p>
</div>
</li>
<li><a id="org989f8b2"></a>速率單調排程 (Rate-Monotonic Scheduling, RMS)<br />
<div class="outline-text-6" id="text-org989f8b2">
<ul class="org-ul">
<li>RMS 是一種靜態優先權排程演算法，它根據任務的週期 (period) 來分配優先權 [未在來源中提及]。<br /></li>
<li>週期越短的任務，優先權越高 [未在來源中提及]。<br /></li>
<li>RMS 適用於週期性任務，並且具有易於實現的優點。<br /></li>
</ul>
</div>
</li>
<li><a id="orgeb4a139"></a>最早截止時間優先排程 (Earliest-Deadline-First Scheduling, EDF)<br />
<div class="outline-text-6" id="text-orgeb4a139">
<ul class="org-ul">
<li>EDF 是一種動態優先權排程演算法，它根據任務的截止時間 (deadline) 來分配優先權 [未在來源中提及]。<br /></li>
<li>截止時間越早的任務，優先權越高 [未在來源中提及]。<br /></li>
<li>EDF 在理論上可以達到 100% 的 CPU 使用率，並且在許多情況下比 RMS 更有效率，但實作上較複雜。<br /></li>
</ul>
</div>
</li>
<li><a id="org7c17a1d"></a>題目分析<br />
<div class="outline-text-6" id="text-org7c17a1d">
<p>
題目中給定兩個程序 P1 和 P2，它們的週期分別為 p1=50 和 p2=80，處理時間分別為 t1=25 和 t2=35。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgc268d63"></a>(A) 是否可以使用速率單調排程 (RMS)？<br />
<div class="outline-text-7" id="text-orgc268d63">
<p>
首先，根據 RMS 的原則，週期較短的 P1 的優先權較高。要判斷這兩個程序是否可以使用 RMS 排程，需要檢驗 CPU 使用率 (CPU utilization) 是否滿足可排程條件。RMS 的可排程條件可以通過以下公式來驗證：<br />
U &lt;= n * (2^(1/n) - 1)<br />
其中，U 是總的 CPU 使用率，n 是任務的數量。<br />
</p>
<ol class="org-ol">
<li>計算個別的 CPU 使用率:<br />
<ul class="org-ul">
<li>P1 的 CPU 使用率 (u1) = t1 / p1 = 25 / 50 = 0.5<br /></li>
<li>P2 的 CPU 使用率 (u2) = t2 / p2 = 35 / 80 = 0.4375<br /></li>
</ul></li>
<li>計算總 CPU 使用率:<br />
<ul class="org-ul">
<li>U = u1 + u2 = 0.5 + 0.4375 = 0.9375<br /></li>
</ul></li>
<li>檢驗可排程條件:<br />
<ul class="org-ul">
<li>當 n = 2 時，  n * (2^(1/n) - 1) = 2 * (2^(1/2) - 1) ≈ 0.828<br /></li>
<li>由於 U (0.9375) &gt; 0.828， 理論上這兩個程序無法保證用 RMS 排程在所有情況下都能滿足截止時間的要求 [未在來源中提及]。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org72d3e3b"></a>(B) 是否可以使用最早截止時間優先排程 (EDF)？<br />
<div class="outline-text-7" id="text-org72d3e3b">
<p>
EDF 的可排程條件比較簡單，只要總 CPU 使用率小於等於 1 即可：<br />
U &lt;= 1<br />
</p>
<ul class="org-ul">
<li>由於 U = 0.9375 &lt; 1，這兩個程序可以使用 EDF 排程 [未在來源中提及]。<br /></li>
<li>EDF 可以保證在任何情況下都能滿足截止時間的要求，只要總 CPU 使用率不超過 1。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org5252c9c"></a>相關計算機概論知識：<br />
<div class="outline-text-6" id="text-org5252c9c">
<ul class="org-ul">
<li>程序 (Process): 正在執行的程式的實例，包含程式碼、資料、堆疊、程式計數器等 [未在來源中提及]。<br /></li>
<li>排程 (Scheduling): 作業系統決定哪個程序應該在 CPU 上執行的過程 [未在來源中提及]。<br /></li>
<li>優先權 (Priority): 程序或任務被排程時的優先程度 [未在來源中提及]。<br /></li>
<li>搶佔式 (Preemptive): 指高優先權的任務可以中斷正在執行的低優先權任務 [未在來源中提及]。<br /></li>
<li>週期性任務 (Periodic Task): 每隔固定時間間隔重複執行的任務 [未在來源中提及]。<br /></li>
<li>截止時間 (Deadline): 任務必須完成的最晚時間 [未在來源中提及]。<br /></li>
<li>CPU 使用率 (CPU Utilization): CPU 被使用的時間比例 [未在來源中提及]。<br /></li>
</ul>
</div>
</li>
<li><a id="org1145c05"></a>總結<br />
<div class="outline-text-6" id="text-org1145c05">
<ul class="org-ul">
<li>硬即時系統必須滿足截止時間的要求，需要搶佔式和基於優先權的排程<br /></li>
<li>RMS 根據週期分配優先權，週期越短優先權越高 [未在來源中提及]。<br /></li>
<li>EDF 根據截止時間分配優先權，截止時間越早優先權越高 [未在來源中提及]。<br /></li>
<li>RMS 的可排程條件是 U &lt;= n * (2^(1/n) - 1)，EDF 的可排程條件是 U &lt;= 1 [未在來源中提及]。<br /></li>
<li>給定的兩個程序，理論上不能保證用 RMS 滿足截止時間的要求，可以使用 EDF 滿足截止時間的要求。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgccc45e4" class="outline-4">
<h4 id="orgccc45e4"><span class="section-number-4">8.2.9.</span> 第九題：(6 分)</h4>
<div class="outline-text-4" id="text-8-2-9">
<p>
In a paging system, suppose that the hit ratio is 80% and it takes 10 ns to search the TLB and 200 ns to access memory.<br />
</p>
<ul class="org-ul">
<li>(A) What is the effective memory access time with single-level page table?<br /></li>
<li>(B) What is the effective memory access time with three-level page table?<br /></li>
</ul>
</div>
<div id="outline-container-org3ca9eac" class="outline-5">
<h5 id="org3ca9eac">解:</h5>
<div class="outline-text-5" id="text-org3ca9eac">
</div>
<ul class="org-ul">
<li><a id="org973cb3b"></a>問題背景<br />
<div class="outline-text-6" id="text-org973cb3b">
<p>
在分頁系統中，為了加快記憶體存取速度，通常會使用轉譯後備緩衝區 (Translation Lookaside Buffer, TLB) 來快取最近使用的頁表條目。當 CPU 產生邏輯位址時，會先查詢 TLB，若 TLB 中存在該頁的實體位址，則稱為 TLB hit，反之則稱為 TLB miss。當 TLB miss 時，需要查詢記憶體中的頁表，才能找到對應的實體位址。<br />
</p>

<p>
題目給定的資訊如下：<br />
</p>
<ul class="org-ul">
<li>TLB hit ratio (命中率) = 80%<br /></li>
<li>TLB search time (搜尋時間) = 10 ns<br /></li>
<li>Memory access time (記憶體存取時間) = 200 ns<br /></li>
</ul>
</div>
</li>
<li><a id="org4235203"></a>有效記憶體存取時間 (Effective Memory Access Time)<br />
<div class="outline-text-6" id="text-org4235203">
<p>
有效記憶體存取時間是指在考慮 TLB hit 和 TLB miss 的情況下，平均存取記憶體所需的時間。其計算公式如下：<br />
有效記憶體存取時間 = (TLB hit ratio * TLB hit time) + (TLB miss ratio * TLB miss time)<br />
其中：<br />
</p>
<ul class="org-ul">
<li>TLB hit time：TLB 命中時的存取時間。<br /></li>
<li>TLB miss time：TLB 未命中時的存取時間。<br /></li>
<li>TLB miss ratio = 1 - TLB hit ratio<br /></li>
</ul>
</div>
</li>
<li><a id="orgc8bb276"></a>（A）單層頁表 (Single-Level Page Table) 的有效記憶體存取時間<br />
<div class="outline-text-6" id="text-orgc8bb276">
<p>
在單層頁表的情況下：<br />
</p>
<ul class="org-ul">
<li>TLB hit 時，只需存取 TLB，耗時 10 ns。<br /></li>
<li>TLB miss 時，需要先存取記憶體中的頁表以取得頁框號 (page frame number)，然後再存取記憶體中的目標資料。所以需要存取記憶體兩次。<br /></li>
</ul>
<p>
計算過程如下：<br />
</p>
<ol class="org-ol">
<li>計算 TLB miss ratio:<br />
<ul class="org-ul">
<li>TLB miss ratio = 1 - 0.8 = 0.2<br /></li>
</ul></li>
<li>計算 TLB hit time:<br />
<ul class="org-ul">
<li>TLB hit time = 10 ns<br /></li>
</ul></li>
<li>計算 TLB miss time:<br />
<ul class="org-ul">
<li>TLB miss time = 頁表存取時間 + 資料存取時間 = 200 ns + 200 ns = 400 ns<br /></li>
</ul></li>
<li>計算有效記憶體存取時間:<br />
<ul class="org-ul">
<li>有效記憶體存取時間 = (0.8 * 10 ns) + (0.2 * 400 ns) = 8 ns + 80 ns = 88 ns<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org9cf86e9"></a>（B）三層頁表 (Three-Level Page Table) 的有效記憶體存取時間<br />
<div class="outline-text-6" id="text-org9cf86e9">
<p>
在三層頁表的情況下：<br />
</p>
<ul class="org-ul">
<li>TLB hit 時，只需存取 TLB，耗時 10 ns。<br /></li>
<li>TLB miss 時，需要先存取記憶體中的三層頁表以取得頁框號，然後再存取記憶體中的目標資料。所以需要存取記憶體四次。<br /></li>
</ul>
<p>
計算過程如下：<br />
</p>
<ol class="org-ol">
<li>計算 TLB miss ratio:<br />
<ul class="org-ul">
<li>TLB miss ratio = 1 - 0.8 = 0.2<br /></li>
</ul></li>
<li>計算 TLB hit time:<br />
<ul class="org-ul">
<li>TLB hit time = 10 ns<br /></li>
</ul></li>
<li>計算 TLB miss time:<br />
<ul class="org-ul">
<li>TLB miss time = 三層頁表存取時間 + 資料存取時間 = 200 ns * 3 + 200 ns = 800 ns<br /></li>
</ul></li>
<li>計算有效記憶體存取時間:<br />
<ul class="org-ul">
<li>有效記憶體存取時間 = (0.8 * 10 ns) + (0.2 * 800 ns) = 8 ns + 160 ns = 168 ns<br /></li>
</ul></li>
</ol>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>單層頁表的有效記憶體存取時間為 88 ns。<br /></li>
<li>三層頁表的有效記憶體存取時間為 168 ns。<br /></li>
<li>使用多層頁表會增加 TLB miss 時的記憶體存取次數，從而增加有效記憶體存取時間。<br /></li>
</ul>
<p>
相關計算機概論知識：<br />
</p>
<ul class="org-ul">
<li>分頁 (Paging): 一種記憶體管理技術，將邏輯位址空間分割成固定大小的頁面，並將實體記憶體分割成大小相同的頁框 [未在來源中提及]。<br /></li>
<li>頁表 (Page Table): 儲存邏輯位址的頁面到實體記憶體頁框之間映射的資料結構 [未在來源中提及]。<br /></li>
<li>轉譯後備緩衝區 (TLB): 一種快取記憶體，用於儲存最近使用的頁表條目，以加速位址轉譯過程 [未在來源中提及]。<br /></li>
<li>TLB Hit/Miss: 當要存取的頁表條目存在於TLB中為TLB Hit，反之為TLB Miss [未在來源中提及]。<br /></li>
<li>有效記憶體存取時間 (Effective Memory Access Time): 考慮快取(TLB)命中率和未命中率後，平均存取記憶體所花費的時間 [未在來源中提及]。<br /></li>
</ul>
</div>
</li>
<li><a id="org0b6d994"></a>重要注意事項：<br />
<div class="outline-text-6" id="text-org0b6d994">
<ul class="org-ul">
<li>此計算假設每次記憶體存取時間都固定為 200 ns。<br /></li>
<li>實際情況中，記憶體存取時間可能因多種因素而有所變化。<br /></li>
<li>多層頁表可以減少頁表本身的大小，但在 TLB miss 時會增加記憶體存取次數。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd8d92c0" class="outline-3">
<h3 id="orgd8d92c0"><span class="section-number-3">8.3.</span> 110</h3>
<div class="outline-text-3" id="text-8-3">
</div>
<div id="outline-container-org42dfc2a" class="outline-4">
<h4 id="org42dfc2a"><span class="section-number-4">8.3.1.</span> 一、</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
網路流量一時過大會造成封包延遲或封包丟失等問題，面對此情況，網路管理者通常有下列三種策略：(1)Overprovisioning、(2)Priority、(3) Quality of Service Guarantees。請詳細說明此三種策略的意義及各自的優缺點。(15 分)<br />
</p>
</div>
<div id="outline-container-orga5be1bd" class="outline-5">
<h5 id="orga5be1bd">解</h5>
<div class="outline-text-5" id="text-orga5be1bd">
<p>
網路流量管理策略: 當網路流量過大時，可能導致網路壅塞，造成封包延遲或遺失。為了應對這種情況，網路管理者通常會採用以下三種策略<br />
：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd30356f"></a>1. 過度配置 (Overprovisioning)<br />
<div class="outline-text-6" id="text-orgd30356f">
<ul class="org-ul">
<li>意義： 增加網路資源（例如：頻寬、設備）的容量，使其遠大於預期的高峰流量，從而確保在正常情況下，網路不會出現壅塞。<br /></li>
<li>優點： 簡單直接，能有效降低網路壅塞的可能性，提升使用者體驗。<br /></li>
<li>缺點： 成本高昂，需要大量投資硬體設備，且資源利用率可能不高，因為大部分時間網路流量可能遠低於配置的容量。<br /></li>
</ul>
</div>
</li>
<li><a id="org72bcd93"></a>2. 優先權 (Priority)<br />
<div class="outline-text-6" id="text-org72bcd93">
<ul class="org-ul">
<li>意義： 為不同類型的網路流量設定優先級，確保高優先級的流量（例如：語音、視訊）能夠優先通過網路，減少延遲和遺失。<br /></li>
<li>優點： 可以在有限的資源下，確保重要流量的服務品質，提升使用者體驗。<br /></li>
<li>缺點： 可能導致低優先級的流量受到延遲或阻礙，可能造成不公平的資源分配。<br /></li>
</ul>
</div>
</li>
<li><a id="orgf27a4d3"></a>3. 服務品質保證 (Quality of Service Guarantees)<br />
<div class="outline-text-6" id="text-orgf27a4d3">
<ul class="org-ul">
<li>意義： 使用各種技術和機制（例如：流量塑形、流量監控、資源預留），確保特定類型的網路流量獲得預定的服務品質，例如：延遲、抖動、封包遺失率等方面的保證。<br /></li>
<li>優點： 可以為不同類型的流量提供客製化的服務品質，滿足不同應用程式的需求。<br /></li>
<li>缺點： 設定和管理複雜，需要專業的技術知識，實施成本較高<br /></li>
</ul>
</div>
</li>
<li><a id="org6938196"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org6938196">
<p>
為了更深入理解這些網路管理策略，以下列出一些相關的計算機概論知識點，這些知識點在研究所考試中也經常出現：<br />
</p>
<ul class="org-ul">
<li>網路協定： 了解 TCP/IP 協定族，特別是 TCP 和 UDP 的差異，以及它們如何處理網路流量。TCP 具有可靠的傳輸機制，適合需要資料完整性的應用程式（例如：網頁瀏覽），而 UDP 則較為快速，適合即時性較高的應用程式（例如：視訊串流）。<br /></li>
<li>網路壅塞控制： 了解網路壅塞控制的機制，例如：慢啟動、壅塞避免、快速重傳和快速恢復等，這些機制可以幫助網路適應流量變化，減少壅塞發生的機會。<br /></li>
<li>流量工程： 了解流量工程的概念和技術，例如：流量分類、流量標記、流量塑形和流量監控等，這些技術可以幫助網路管理者更好地控制和管理網路流量。<br /></li>
<li>服務品質 (QoS)： 了解服務品質的概念和指標，例如：延遲、抖動、封包遺失率和頻寬等，以及如何使用 QoS 機制來確保不同應用程式的服務品質。<br /></li>
<li>網路設備： 了解路由器、交換器等網路設備的功能和運作原理，它們在網路流量管理中扮演重要的角色。路由器負責選擇最佳路徑來傳輸封包，而交換器則負責在區域網路內轉發封包。<br /></li>
<li>排隊理論: 了解 M/M/1 模型等排隊理論，可以幫助分析網路流量的行為，並評估不同的網路管理策略的效果。<br /></li>
<li>網路安全: 了解 IPSec 協定，這是實現 VPN 的重要技術。IPSec 中的 AH 和 ESP 協定有不同的作用。<br /></li>
</ul>
<p>
總結: 網路流量管理是一個複雜的問題，需要綜合考慮網路的拓撲結構、流量特性和應用需求。上述的三種策略各有優缺點，網路管理者需要根據實際情況選擇最適合的策略。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf0760b6" class="outline-4">
<h4 id="orgf0760b6"><span class="section-number-4">8.3.2.</span> 二、</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
IPSec (Internet Protocol Security)協定組是實現 VPN(Virtual Private Network)的重要技術，請回答下列問題：<br />
</p>
<ol class="org-ol">
<li>IPSec 中的 AH(Authentication Header)協定和 ESP(Encapsulating Security Payload)協定的作用有何不同？ (5分)<br /></li>
<li>IPSec 中的 Transport mode 和 Tunnel mode 兩種操作方式及優缺點為何？ (5分)<br /></li>
</ol>
</div>
<div id="outline-container-orgce486eb" class="outline-5">
<h5 id="orgce486eb">解</h5>
<div class="outline-text-5" id="text-orgce486eb">
</div>
<ul class="org-ul">
<li><a id="orgeab2169"></a>IPSec 協定組<br />
<div class="outline-text-6" id="text-orgeab2169">
<p>
IPSec 是一套用於在網際網路協定 (IP) 網路中提供安全性的協定組。它主要用於建立安全的 VPN 連線，確保數據在傳輸過程中的機密性、完整性和身份驗證。IPSec 包括以下兩個主要的協定：<br />
</p>
<ol class="org-ol">
<li>AH (Authentication Header) 協定<br />
<ul class="org-ul">
<li>作用： AH 協定的主要作用是提供數據的完整性驗證和身份驗證。它會在 IP 封包中加入一個驗證標頭，使用加密雜湊函數來確保數據在傳輸過程中未被篡改。同時，它也驗證數據的發送者身份，防止偽造攻擊。<br /></li>
<li>特點： AH 協定不提供數據加密，只提供身份驗證和完整性驗證。<br /></li>
<li>優缺點：<br />
<ul class="org-ul">
<li>優點： 驗證速度快，開銷較小。<br /></li>
<li>缺點： 不提供數據加密，無法保證數據的機密性。<br /></li>
</ul></li>
</ul></li>
<li>ESP (Encapsulating Security Payload) 協定<br />
<ul class="org-ul">
<li>作用： ESP 協定的主要作用是提供數據的機密性、完整性驗證和身份驗證。它會將 IP 封包中的數據進行加密，並加入一個驗證標頭，以確保數據在傳輸過程中不被竊聽或篡改。<br /></li>
<li>特點： ESP 協定提供數據加密，並可選擇性提供完整性驗證和身份驗證。<br /></li>
<li>優缺點：<br />
<ul class="org-ul">
<li>優點： 提供數據加密，確保數據的機密性。<br /></li>
<li>缺點： 運算開銷較大，處理速度較慢。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org46c2bd1"></a>IPSec 的兩種操作模式<br />
<div class="outline-text-6" id="text-org46c2bd1">
<p>
IPSec 有兩種主要的操作模式：<br />
</p>
<ol class="org-ol">
<li>傳輸模式 (Transport Mode)<br />
<ul class="org-ul">
<li>運作方式： 在傳輸模式下，IPSec 只會保護 IP 封包中的數據部分（例如：TCP 或 UDP 封包），而原始的 IP 標頭則保持不變。<br /></li>
<li>適用情境： 適用於端對端的安全連線，例如：在同一網路上的兩台主機之間建立安全連線。<br /></li>
<li>優缺點：<br />
<ul class="org-ul">
<li>優點： 開銷較小，處理速度較快。<br /></li>
<li>缺點： 僅保護數據部分，IP 標頭中的資訊（例如：源地址、目標地址）仍然暴露在外，容易受到網路流量分析攻擊。<br /></li>
</ul></li>
</ul></li>
</ol>
<p>
2.隧道模式 (Tunnel Mode)<br />
</p>
<ul class="org-ul">
<li>運作方式： 在隧道模式下，IPSec 會將整個原始 IP 封包都加密，並將其封裝在一個新的 IP 封包中，形成一個安全隧道。<br /></li>
<li>適用情境： 適用於網路對網路的安全連線，例如：在兩個不同網路之間建立 VPN 連線。<br /></li>
<li>優缺點：<br />
<ul class="org-ul">
<li>優點： 保護整個 IP 封包，包括 IP 標頭，提供更全面的安全性。<br /></li>
<li>缺點： 開銷較大，處理速度較慢。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org03eb5f7"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org03eb5f7">
<p>
為了更深入理解 IPSec 和 VPN，以下列出一些相關的計算機概論知識點：<br />
</p>
<ul class="org-ul">
<li>加密技術： 了解對稱加密 (Symmetric Encryption) 和非對稱加密 (Asymmetric Encryption) 的原理和應用，以及各種加密演算法，例如：AES、RSA 等。<br /></li>
<li>雜湊函數 (Hash Function)： 了解雜湊函數的特性和用途，例如：訊息驗證碼 (MAC) 和數位簽章。<br /></li>
<li>網路安全： 了解各種網路安全威脅和攻擊，例如：竊聽、篡改、偽造、阻斷服務攻擊 (DoS) 等，以及如何使用安全協定和機制來保護網路安全。<br /></li>
<li>VPN (Virtual Private Network)： 了解 VPN 的原理和類型，例如：IPSec VPN、SSL VPN 等。<br /></li>
<li>網路協定： 了解 TCP/IP 協定族，特別是 IP 協定和 IP 封包的結構。<br /></li>
<li>金鑰管理： 了解如何安全地產生、儲存和交換加密金鑰，例如：Diffie-Hellman 金鑰交換演算法。<br /></li>
<li>認證 (Authentication)： 了解身份驗證的原理和方法，例如：密碼驗證、雙因素驗證等。<br /></li>
</ul>
</div>
</li>
<li><a id="org9f93a17"></a>VPN（虛擬私人網路，Virtual Private Network）<br />
<div class="outline-text-6" id="text-org9f93a17">
<p>
什麼是 VPN？VPN（Virtual Private Network，虛擬私人網路）是一種技術，允許用戶透過 加密隧道（Encrypted Tunnel） 安全地連接到遠端網路。它主要用來：<br />
</p>
<ul class="org-ul">
<li>保護隱私與安全：加密數據，防止駭客、網路監控。<br /></li>
<li>繞過網路限制：突破地域封鎖（如中國防火長城）、存取被封鎖的內容（如 Netflix 美國限定節目）。<br /></li>
<li>遠端辦公：讓企業員工可以安全地存取公司內部資源。<br /></li>
</ul>
<p>
VPN 的運作方式<br />
</p>
<ul class="org-ul">
<li>使用者連接 VPN 伺服器：透過 VPN 軟體或內建 VPN 功能，與 VPN 伺服器建立連線。<br /></li>
<li>加密資料：VPN 會對數據進行加密，使第三方（如 ISP、駭客）無法監視流量內容。<br /></li>
<li>VPN 伺服器轉發請求：VPN 伺服器將請求轉發至目標網站，網站認為請求來自 VPN 伺服器而非用戶真實 IP。<br /></li>
<li>返回結果：VPN 伺服器將網站回應加密後回傳給用戶，確保數據安全。<br /></li>
</ul>
<p>
VPN 的優勢與缺點<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">優勢</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">保護隱私與匿名性</td>
<td class="org-left">可能影響網速（加密與遠端伺服器）</td>
</tr>

<tr>
<td class="org-left">加密流量，提高安全性</td>
<td class="org-left">需要額外的 VPN 軟體或設定</td>
</tr>

<tr>
<td class="org-left">繞過地理限制與審查</td>
<td class="org-left">免費 VPN 可能不安全，容易洩漏數據</td>
</tr>

<tr>
<td class="org-left">遠端存取企業內部網路</td>
<td class="org-left">可能被政府或企業封鎖</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org68659e3"></a>IPSec VPN（基於 IP 安全協議的 VPN）<br />
<div class="outline-text-6" id="text-org68659e3">
<p>
什麼是 IPSec？: IPSec（Internet Protocol Security） 是一種安全協議套件，專門用來為 IP 層 的數據流量提供加密和驗證，確保通訊安全。它常用於企業內部的 站對站 VPN（Site-to-Site VPN） 或 遠端存取 VPN（Remote Access VPN）。<br />
</p>

<p>
IPSec VPN 的特點<br />
</p>
<ul class="org-ul">
<li>加密 IP 層流量：IPSec VPN 在 IP 層 加密數據包，提供更高的安全性。<br /></li>
<li>支援兩種模式：<br />
<ul class="org-ul">
<li>傳輸模式（Transport Mode）：只加密數據本身（適用於端對端的通訊）。<br /></li>
<li>隧道模式（Tunnel Mode）：加密整個 IP 封包，並包裹在新的 IP 封包中（常用於 VPN）。<br /></li>
</ul></li>
<li>雙向驗證：確保數據來自可信任來源，防止竄改與中間人攻擊（MITM）。<br /></li>
<li>適用於企業網路：<br />
<ul class="org-ul">
<li>企業內部員工遠端連接公司網路。<br /></li>
<li>企業之間的分支機構建立 站對站 VPN 連線。<br /></li>
</ul></li>
</ul>

<p>
IPSec VPN 的優勢與缺點<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">優勢</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">提供高度加密與完整性驗證</td>
<td class="org-left">設定較為複雜</td>
</tr>

<tr>
<td class="org-left">支援 站對站 VPN，適用於企業內網</td>
<td class="org-left">需要特殊的 VPN 軟體或設備</td>
</tr>

<tr>
<td class="org-left">適用於大規模企業 VPN 部署</td>
<td class="org-left">可能需要高效能路由器與防火牆支持</td>
</tr>
</tbody>
</table>

<p>
IPSec VPN 的常見應用<br />
 企業內部 VPN（遠端辦公使用）<br />
 站對站 VPN（Site-to-Site VPN）（企業總部與分公司連線）<br />
 政府機構、金融機構的安全通訊<br />
</p>
</div>
</li>
<li><a id="orgc91de58"></a>SSL VPN（基於 SSL/TLS 的 VPN）<br />
<div class="outline-text-6" id="text-orgc91de58">
<p>
什麼是 SSL VPN？: SSL VPN（Secure Sockets Layer VPN） 使用 SSL/TLS 加密 確保通訊安全，允許用戶透過 網頁瀏覽器 連接到 VPN，而 不需要安裝額外的 VPN 客戶端軟體。<br />
</p>

<p>
SSL VPN 的特點<br />
</p>
<ul class="org-ul">
<li>基於瀏覽器的 VPN：不需要額外的 VPN 軟體，用戶可以直接透過 HTTPS（SSL/TLS） 連接 VPN。<br /></li>
<li>更容易部署：不需要特定的 VPN 客戶端，任何支援 HTTPS 的裝置（如筆電、手機、平板）都能使用。<br /></li>
<li>提供應用層的安全性：不像 IPSec VPN 加密整個 IP 流量，SSL VPN 主要保護 應用層（Application Layer） 流量，如 Web 服務、遠端桌面等。<br /></li>
<li>支援部分應用程式：<br />
<ul class="org-ul">
<li>入口 VPN（Portal Mode）：使用 Web 介面提供企業內部應用服務（如郵件、文件）。<br /></li>
<li>全通道模式（Tunnel Mode）：類似傳統 VPN，提供更廣泛的應用支援，如 RDP、VoIP、ERP 系統。<br /></li>
</ul></li>
</ul>

<p>
SSL VPN 的優勢與缺點<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">優勢</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">使用方便，無需額外安裝 VPN 軟體</td>
<td class="org-left">可能無法支援所有應用（部分應用需特殊配置）</td>
</tr>

<tr>
<td class="org-left">只需透過 瀏覽器（HTTPS） 即可存取</td>
<td class="org-left">企業級 SSL VPN 需額外授權或設備支持</td>
</tr>

<tr>
<td class="org-left">支援遠端存取，適用於臨時使用者</td>
<td class="org-left">可能比 IPSec VPN 慢（受 TLS 處理影響）</td>
</tr>
</tbody>
</table>

<p>
SSL VPN 的常見應用<br />
</p>
<ul class="org-ul">
<li>遠端存取企業內部資源（如 Web 應用、郵件系統）<br /></li>
<li>行動辦公環境（適合不願安裝 VPN 軟體的設備）<br /></li>
<li>臨時存取企業內網（例如外部承包商或訪客使用）<br /></li>
</ul>

<p>
IPSec VPN vs SSL VPN 比較<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">IPSec VPN</th>
<th scope="col" class="org-left">SSL VPN</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">安全層級</td>
<td class="org-left">IP 層（整個流量加密）</td>
<td class="org-left">應用層（HTTPS）</td>
</tr>

<tr>
<td class="org-left">傳輸模式</td>
<td class="org-left">傳輸模式 / 隧道模式</td>
<td class="org-left">入口模式 / 隧道模式</td>
</tr>

<tr>
<td class="org-left">設備需求</td>
<td class="org-left">需要 VPN 軟體或路由器</td>
<td class="org-left">只需瀏覽器，無需額外軟體</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">企業內部、站對站連線</td>
<td class="org-left">遠端辦公、臨時存取</td>
</tr>

<tr>
<td class="org-left">連線速度</td>
<td class="org-left">更快（IP 層加密）</td>
<td class="org-left">可能較慢（TLS 負擔）</td>
</tr>

<tr>
<td class="org-left">設定難易度</td>
<td class="org-left">設定較複雜</td>
<td class="org-left">設定簡單</td>
</tr>

<tr>
<td class="org-left">應用程式支援</td>
<td class="org-left">適用於所有應用</td>
<td class="org-left">主要適用於 Web 應用</td>
</tr>
</tbody>
</table>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>VPN 透過加密技術保護數據，確保安全性、隱私性，並允許用戶遠端存取網路資源。<br /></li>
<li>IPSec VPN 適合企業內部網路，提供強大加密和驗證，但需要額外的 VPN 設備與軟體。<br /></li>
<li>SSL VPN 允許用戶透過瀏覽器存取企業內部應用，設定簡單，適合遠端存取，但可能無法支援所有應用。<br /></li>
</ul>
<p>
何時選擇哪種 VPN？<br />
</p>
<ul class="org-ul">
<li>✅ 需要全面保護、企業內網：選擇 IPSec VPN<br /></li>
<li>✅ 需要臨時存取、瀏覽器存取：選擇 SSL VPN<br /></li>
<li>✅ 一般用戶想繞過封鎖、保護隱私：選擇商用 VPN（如 NordVPN、ExpressVPN）<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga650c0f" class="outline-4">
<h4 id="orga650c0f"><span class="section-number-4">8.3.3.</span> 三、</h4>
<div class="outline-text-4" id="text-8-3-3">
<p>
在資料庫寫入或更新的過程中，為確保交易(transaction)可以正確執行，須確保滿足 ACID (Atomicity, Consistency, Isolation, Durability) property。請詳細說明此四個特性。(8%)<br />
</p>
</div>
<div id="outline-container-org1f611b3" class="outline-5">
<h5 id="org1f611b3">解</h5>
<div class="outline-text-5" id="text-org1f611b3">
<p>
ACID 特性: 在資料庫中，為了確保交易 (transaction) 的正確性和可靠性，必須滿足 ACID 特性。ACID 是指 Atomicity (原子性), Consistency (一致性), Isolation (隔離性), 和 Durability (持久性) 四個特性。<br />
</p>
<ol class="org-ol">
<li>原子性 (Atomicity)<br />
<ul class="org-ul">
<li>定義： 原子性指的是一個交易必須被視為一個不可分割的單位，交易中的所有操作要么全部成功完成，要么全部失敗回滾。換句話說，一個交易不能只完成一部分操作，而留下未完成的部分。<br /></li>
<li>例子： 假設一個銀行轉帳操作，從帳戶 A 轉帳 100 元到帳戶 B。這個轉帳操作包含兩個步驟：(1) 從帳戶 A 扣除 100 元；(2) 在帳戶 B 增加 100 元。如果這個轉帳交易滿足原子性，則這兩個步驟要么都成功完成，要么都失敗回滾。如果只扣除 A 帳戶的錢，而沒有增加 B 帳戶的錢，則違反原子性。<br /></li>
<li>重要性： 原子性確保交易的完整性，防止因部分操作失敗而導致資料庫狀態不一致。<br /></li>
</ul></li>
<li>一致性 (Consistency)<br />
<ul class="org-ul">
<li>定義： 一致性指的是一個交易必須將資料庫從一個一致的狀態轉換到另一個一致的狀態。所謂一致的狀態，是指資料庫的資料必須符合預先定義的規則和約束條件（例如：主鍵約束、外鍵約束、資料類型約束）。<br /></li>
<li>例子： 假設一個資料庫中，帳戶餘額必須大於等於零。在一個轉帳交易中，如果從帳戶 A 扣除 100 元後，導致 A 帳戶餘額變成負數，則違反一致性。<br /></li>
<li>重要性: 一致性確保資料庫的資料始終處於有效的狀態，防止資料庫中出現錯誤或不合理的資料。<br /></li>
</ul></li>
<li>隔離性 (Isolation)<br />
<ul class="org-ul">
<li>定義： 隔離性指的是多個交易同時執行時，必須相互隔離，互不干擾。一個交易的執行不應該受到其他交易的影響。每個交易都應該感覺自己是獨立操作資料庫，就像沒有其他交易在並行執行一樣。<br /></li>
<li>例子： 假設兩個交易同時執行，交易 T1 要讀取帳戶 A 的餘額，交易 T2 要從帳戶 A 轉帳 100 元到帳戶 B。如果沒有隔離性，T1 可能會讀取到 T2 還未完成轉帳時的餘額，導致讀取到不一致的資料。<br /></li>
<li>重要性： 隔離性確保並發交易的正確性，防止因多個交易同時執行而導致資料庫資料錯誤。隔離性有不同的隔離級別，例如：讀取未提交 (Read Uncommitted)、讀取提交 (Read Committed)、可重複讀取 (Repeatable Read) 和序列化 (Serializable)，不同的隔離級別在效能和資料一致性之間做權衡。<br /></li>
</ul></li>
<li>持久性 (Durability)<br />
<ul class="org-ul">
<li>定義： 持久性指的是一個交易成功提交後，對資料庫的變更必須永久保存下來，即使系統發生故障，例如：斷電或硬碟損壞，也必須能夠恢復這些變更。<br /></li>
<li>例子： 假設一個轉帳交易成功提交後，即使資料庫伺服器斷電，當伺服器重新啟動後，轉帳交易的結果仍然必須存在，帳戶餘額必須正確更新。<br /></li>
<li>重要性： 持久性確保資料的可靠性和安全性，防止資料遺失。通常使用交易日誌 (transaction log) 和資料庫備份來實現持久性。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org5d1a378" class="outline-5">
<h5 id="org5d1a378">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-org5d1a378">
<p>
為了更深入理解 ACID 特性，以下列出一些相關的計算機概論知識點：<br />
</p>
<ul class="org-ul">
<li>資料庫管理系統 (DBMS)： 了解資料庫管理系統的功能和架構，例如：交易管理器 (Transaction Manager)、鎖管理器 (Lock Manager)、日誌管理器 (Log Manager) 等。<br /></li>
<li>併發控制 (Concurrency Control)： 了解併發控制的機制，例如：鎖定 (Locking)、時間戳記 (Timestamping)、多版本併發控制 (MVCC) 等，這些機制用於實現交易的隔離性。<br /></li>
<li>交易日誌 (Transaction Log)： 了解交易日誌的原理和用途，交易日誌用於記錄交易的執行過程和資料變更，用於實現交易的原子性和持久性。<br /></li>
<li>資料庫備份和恢復： 了解資料庫備份和恢復的策略和方法，確保資料庫在系統故障時能夠恢復到一致的狀態。<br /></li>
<li>分散式資料庫: 了解分散式資料庫中的交易管理，包括如何保證分散式交易的 ACID 特性。<br /></li>
<li>NoSQL 資料庫: 了解 NoSQL 資料庫的特性及其在 ACID 方面的取捨。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0f12253" class="outline-4">
<h4 id="org0f12253"><span class="section-number-4">8.3.4.</span> 四、</h4>
<div class="outline-text-4" id="text-8-3-4">
<p>
請詳細說明 homogeneous distributed database 與 heterogeneous distributed database 兩者之差異。(10%)<br />
</p>
</div>
<div id="outline-container-org397ff67" class="outline-5">
<h5 id="org397ff67">解</h5>
<div class="outline-text-5" id="text-org397ff67">
</div>
<ul class="org-ul">
<li><a id="org3c6ef58"></a>同質分散式資料庫 (Homogeneous Distributed Database)<br />
<div class="outline-text-6" id="text-org3c6ef58">
<ul class="org-ul">
<li>定義： 同質分散式資料庫是指多個資料庫系統使用相同的資料庫管理系統 (DBMS) 軟體，並以相同的資料模型 (data model) 和綱要 (schema) 協同運作。也就是說，所有的資料庫節點都使用相同的資料庫軟體，並且具有相同的資料結構和格式。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>所有節點都使用相同的 DBMS 軟體，例如：全部都是 Oracle 資料庫，或全部都是 MySQL 資料庫。<br /></li>
<li>所有節點的資料結構和綱要都相同，資料格式也一致。<br /></li>
<li>管理和維護相對較為簡單，因為所有節點的環境都相同。<br /></li>
<li>查詢處理和資料存取較為直接，因為所有節點的資料都以相同的方式儲存和管理。<br /></li>
</ul></li>
<li>優點：<br />
<ul class="org-ul">
<li>易於設計和實施：因為所有節點都使用相同的技術，所以設計和實施相對簡單。<br /></li>
<li>查詢處理效率高：由於資料格式和結構相同，查詢處理可以在不同的節點之間高效地傳輸和合併。<br /></li>
<li>管理和維護成本較低：因為所有節點的環境都相同，所以管理和維護的成本較低。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>彈性較低：如果需要升級或更換 DBMS 軟體，則所有節點都需要同時進行更新，這可能造成不便。<br /></li>
<li>單點故障風險：如果某個關鍵節點發生故障，可能會影響整個系統的運行。<br /></li>
</ul></li>
<li>範例： 一個公司在多個分公司使用相同的 Oracle 資料庫系統來管理客戶資料，每個分公司都維護自己的資料庫，並且通過分散式資料庫技術將它們整合成一個邏輯上的整體。<br /></li>
</ul>
</div>
</li>
<li><a id="org7ecfa1d"></a>異質分散式資料庫 (Heterogeneous Distributed Database)<br />
<div class="outline-text-6" id="text-org7ecfa1d">
<ul class="org-ul">
<li>定義： 異質分散式資料庫是指多個資料庫系統使用不同的 DBMS 軟體，且可能使用不同的資料模型和綱要協同運作。也就是說，不同的資料庫節點可能使用不同的資料庫軟體，資料結構和格式也可能不同。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>不同的節點可能使用不同的 DBMS 軟體，例如：有些節點使用 Oracle 資料庫，有些節點使用 MySQL 資料庫，有些節點使用 PostgreSQL 資料庫。<br /></li>
<li>不同的節點可能具有不同的資料結構和綱要，資料格式也可能不一致。<br /></li>
<li>管理和維護較為複雜，因為不同節點的環境可能不同。<br /></li>
<li>查詢處理和資料存取可能需要使用額外的轉換機制，以確保不同格式的資料能夠互相理解。<br /></li>
</ul></li>
<li>優點：<br />
<ul class="org-ul">
<li>彈性較高：可以靈活地選擇最適合的 DBMS 軟體來管理不同類型的資料，並且可以更容易地整合現有的資料庫系統。<br /></li>
<li>可以整合不同來源的資料：可以整合不同部門、不同供應商或不同系統的資料，形成一個全面的資料視圖。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>設計和實施複雜：由於不同節點的技術和結構不同，設計和實施相對複雜。<br /></li>
<li>查詢處理效率較低：由於資料格式和結構不同，查詢處理可能需要較多的轉換和處理時間。<br /></li>
<li>管理和維護成本較高：因為不同節點的環境可能不同，管理和維護的成本較高。<br /></li>
</ul></li>
<li>範例： 一個企業可能有多個不同的部門，每個部門使用不同的資料庫系統來管理資料，例如：人事部門使用 Oracle 資料庫，財務部門使用 MySQL 資料庫，行銷部門使用 MongoDB 資料庫。企業使用異質分散式資料庫技術將這些不同的資料庫系統整合成一個統一的資料視圖，方便進行跨部門的分析和決策。<br /></li>
</ul>

<p>
兩者之差異總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">同質分散式資料庫</th>
<th scope="col" class="org-left">異質分散式資料庫</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DBMS 軟體</td>
<td class="org-left">所有節點使用相同的 DBMS 軟體</td>
<td class="org-left">不同節點可能使用不同的 DBMS 軟體</td>
</tr>

<tr>
<td class="org-left">資料結構/綱要</td>
<td class="org-left">所有節點具有相同的資料結構和綱要</td>
<td class="org-left">不同節點可能具有不同的資料結構和綱要</td>
</tr>

<tr>
<td class="org-left">管理和維護</td>
<td class="org-left">相對簡單</td>
<td class="org-left">相對複雜</td>
</tr>

<tr>
<td class="org-left">查詢處理</td>
<td class="org-left">較為直接，效率較高</td>
<td class="org-left">可能需要額外的轉換機制，效率較低</td>
</tr>

<tr>
<td class="org-left">彈性</td>
<td class="org-left">較低，不方便更換 DBMS 軟體</td>
<td class="org-left">較高，可以靈活選擇最適合的 DBMS 軟體</td>
</tr>

<tr>
<td class="org-left">複雜度</td>
<td class="org-left">設計和實施相對簡單</td>
<td class="org-left">設計和實施相對複雜</td>
</tr>

<tr>
<td class="org-left">整合難度</td>
<td class="org-left">整合相同技術的資料庫相對簡單</td>
<td class="org-left">整合不同技術的資料庫相對複雜</td>
</tr>

<tr>
<td class="org-left">資料一致性</td>
<td class="org-left">維持資料一致性相對容易</td>
<td class="org-left">維持資料一致性相對困難</td>
</tr>
</tbody>
</table>

<p>
相關計算機概論知識<br />
為了更深入理解同質和異質分散式資料庫，以下列出一些相關的計算機概論知識點：<br />
</p>
<ul class="org-ul">
<li>分散式資料庫管理系統 (DDBMS)： 了解分散式資料庫管理系統的功能和架構，包括資料分割 (data partitioning)、資料複寫 (data replication)、分散式查詢處理 (distributed query processing) 和分散式交易管理 (distributed transaction management)。<br /></li>
<li>資料庫綱要 (Database Schema)： 了解資料庫綱要的概念，包括邏輯綱要 (logical schema) 和實體綱要 (physical schema)，以及如何設計資料庫綱要。<br /></li>
<li>資料模型 (Data Model)： 了解不同的資料模型，例如：關聯式模型 (relational model)、階層式模型 (hierarchical model) 和網路模型 (network model)。<br /></li>
<li>中介軟體 (Middleware)： 了解中介軟體在異質資料庫整合中的作用，例如：資料轉換 (data transformation) 和資料整合 (data integration) 的機制。<br /></li>
<li>資料庫連結 (Database Link)： 了解如何在不同的資料庫系統之間建立連結，以實現跨資料庫的查詢和操作。<br /></li>
<li>分散式交易 (Distributed Transaction)： 了解如何確保分散式交易的 ACID 特性，例如：兩階段提交 (two-phase commit) 協定。<br /></li>
<li>資料倉儲 (Data Warehouse)： 了解資料倉儲的原理和架構，資料倉儲通常用於整合來自不同來源的資料，以方便進行決策分析。<br /></li>
<li>NoSQL 資料庫: 了解 NoSQL 資料庫的種類和特性，以及它們如何被用於分散式資料庫系統中。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgdba4cca" class="outline-4">
<h4 id="orgdba4cca"><span class="section-number-4">8.3.5.</span> 五、</h4>
<div class="outline-text-4" id="text-8-3-5">
<p>
何謂 NoSQL 資料庫？請詳細說明 NoSQL 資料庫所具有之特性。(7%)<br />
</p>
</div>
<div id="outline-container-org98487f6" class="outline-5">
<h5 id="org98487f6">解</h5>
<div class="outline-text-5" id="text-org98487f6">
</div>
<ul class="org-ul">
<li><a id="org16703ea"></a>NoSQL 資料庫（非關聯式資料庫，Not Only SQL）<br />
<div class="outline-text-6" id="text-org16703ea">
<ul class="org-ul">
<li>定義：NoSQL 資料庫是一種 非關聯式資料庫管理系統（Non-Relational Database Management System），不同於傳統的關聯式資料庫（RDBMS），NoSQL 資料庫不依賴固定的表格結構，通常不使用 SQL 作為查詢語言，而是根據應用場景提供更彈性的資料存儲方式。NoSQL 主要針對 大規模資料（Big Data） 和 分散式架構（Distributed Architecture） 進行優化，適用於高並發讀寫、非結構化或半結構化數據存儲需求。<br /></li>
<li>特性：<br />
<ul class="org-ul">
<li>彈性資料模型（Flexible Data Model）：<br />
<ul class="org-ul">
<li>無需固定的結構化模式（Schema-Free），允許不同的資料格式存儲在同一個資料庫中，例如 JSON、BSON、XML、Key-Value 等格式。<br /></li>
<li>適合處理 半結構化（Semi-Structured） 或 非結構化（Unstructured） 資料，如日誌、社群媒體貼文、感測器數據等。<br /></li>
</ul></li>
<li>高擴展性（High Scalability）：<br />
<ul class="org-ul">
<li>採用 水平方向擴展（Horizontal Scaling，Sharding），可以透過新增節點來提高處理能力，<br /></li>
<li>不同於 RDBMS 主要依賴 垂直擴展（Vertical Scaling），NoSQL 容易分佈於多台伺服器，降低單點故障風險。<br /></li>
</ul></li>
<li>高可用性（High Availability）與分散式架構（Distributed Architecture）：<br />
<ul class="org-ul">
<li>多數 NoSQL 資料庫內建 資料複寫（Replication） 機制，確保即使某些節點發生故障，仍可繼續提供服務。<br /></li>
<li>常見的 CAP 定理 指出：分散式系統中，一個資料庫無法同時滿足 一致性（Consistency）、可用性（Availability）、分區容錯性（Partition Tolerance），NoSQL根據需求選擇不同的平衡策略。<br /></li>
</ul></li>
<li>高效能（High Performance）：<br />
<ul class="org-ul">
<li>支援高吞吐量（Throughput），適合處理大量讀寫操作，如即時分析、即時訊息推送、日誌存儲等。<br /></li>
<li>部分 NoSQL 資料庫使用 記憶體儲存（In-Memory Storage） 提供極高速的讀取，如 Redis、Memcached。<br /></li>
</ul></li>
<li>適合大數據與雲端應用（Big Data &amp; Cloud Computing）：<br />
<ul class="org-ul">
<li>NoSQL 可與 Hadoop、Spark、Kafka 等大數據技術整合，處理大規模數據分析。<br /></li>
<li>許多 NoSQL 資料庫提供 雲端原生支援（Cloud-Native Support），如 AWS DynamoDB、Google Cloud Firestore。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgb10b76c"></a>NoSQL 資料庫的分類 NoSQL 根據資料存儲模型可分為以下四大類：<br />
<div class="outline-text-6" id="text-orgb10b76c">
<ol class="org-ol">
<li>鍵值型（Key-Value Stores）<br />
<ul class="org-ul">
<li>結構：以鍵（Key）對應值（Value）的方式存取，類似哈希表（Hash Table）。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>速度快，適用於快取、會話管理等場景。<br /></li>
<li>查詢只能透過鍵存取，無法進行複雜的條件篩選。<br /></li>
</ul></li>
<li>代表性資料庫：Redis、Memcached、Riak、DynamoDB。<br /></li>
</ul></li>
<li>文件型（Document Stores）<br />
<ul class="org-ul">
<li>結構：存儲 JSON、BSON、XML 等格式的文件，每個文件可能具有不同的欄位（Schema-Free）。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>適用於半結構化資料，如部落格文章、社交媒體貼文等。<br /></li>
<li>支援索引和複雜的查詢功能，比 Key-Value 型更靈活。<br /></li>
</ul></li>
<li>代表性資料庫：MongoDB、CouchDB、Firebase Firestore。<br /></li>
</ul></li>
<li>列存儲型（Wide Column Stores）<br />
<ul class="org-ul">
<li>結構：以 列（Column-Family） 為主的存儲方式，每個資料行（Row）內的欄位可以不同。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>適用於大量數據分析，特別是時間序列數據（Time-Series Data）。<br /></li>
<li>高效讀寫，可處理 PB 級數據，適合大數據應用。<br /></li>
</ul></li>
<li>代表性資料庫：Apache Cassandra、HBase、Google Bigtable。<br /></li>
</ul></li>
<li>圖形型（Graph Databases）<br />
<ul class="org-ul">
<li>結構：以 節點（Node） 和 關係（Edge） 來存儲和查詢資料，適合關係數據分析。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>適用於社交網路、推薦系統、知識圖譜等應用。<br /></li>
<li>支援圖演算法（如 Dijkstra 最短路徑）。<br /></li>
</ul></li>
<li>代表性資料庫：Neo4j、ArangoDB、JanusGraph。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org7d79bbb"></a>NoSQL 與關聯式資料庫（SQL）的比較<br />
<div class="outline-text-6" id="text-org7d79bbb">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">NoSQL 資料庫</th>
<th scope="col" class="org-left">關聯式資料庫（SQL）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">資料結構</td>
<td class="org-left">非結構化 / 半結構化（JSON、Key-Value）</td>
<td class="org-left">結構化（表格、欄位、主外鍵）</td>
</tr>

<tr>
<td class="org-left">資料結構</td>
<td class="org-left">非結構化 / 半結構化（JSON、Key-Value）</td>
<td class="org-left">結構化（表格、欄位、主外鍵）</td>
</tr>

<tr>
<td class="org-left">擴展方式</td>
<td class="org-left">水平擴展（Sharding, Replication）</td>
<td class="org-left">垂直擴展（Scaling Up）</td>
</tr>

<tr>
<td class="org-left">查詢語言</td>
<td class="org-left">依賴 API、NoSQL 查詢語言</td>
<td class="org-left">使用 SQL（結構化查詢語言）</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">高併發、大數據、分散式架構</td>
<td class="org-left">事務處理、關聯查詢、多表 JOIN</td>
</tr>

<tr>
<td class="org-left">交易一致性</td>
<td class="org-left">最終一致性（Eventual Consistency）</td>
<td class="org-left">ACID 事務（強一致性）</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org750064a"></a>相關計算機概論知識 為了準備研究所考試，考生應掌握以下與 NoSQL 相關的計概知識：<br />
<div class="outline-text-6" id="text-org750064a">
<ul class="org-ul">
<li>資料庫基本概念（Database Concepts）<br />
<ul class="org-ul">
<li>關聯式資料庫（Relational Database）與 NoSQL 的區別。<br /></li>
<li>NoSQL 資料庫的四種類型（鍵值、文件、列存儲、圖形）。<br /></li>
<li>CAP 定理（Consistency、Availability、Partition Tolerance）。<br /></li>
</ul></li>
<li>分散式系統（Distributed Systems）<br />
<ul class="org-ul">
<li>水平擴展（Sharding）、負載平衡（Load Balancing）。<br /></li>
<li>分散式資料存儲（Distributed Storage）、資料複寫（Replication）。<br /></li>
<li>兩階段提交（Two-Phase Commit, 2PC）、Paxos 協議、Raft 協議。<br /></li>
</ul></li>
<li>資料一致性與交易管理（Data Consistency &amp; Transactions）<br />
<ul class="org-ul">
<li>NoSQL 的最終一致性（Eventual Consistency）。<br /></li>
<li>BASE 模型（Basically Available, Soft state, Eventually consistent）。<br /></li>
<li>ACID（Atomicity, Consistency, Isolation, Durability）與 NoSQL 的應用場景。<br /></li>
</ul></li>
<li>雲端計算（Cloud Computing）<br />
<ul class="org-ul">
<li>伺服器無狀態（Stateless Architecture）。<br /></li>
<li>雲端 NoSQL 服務，如 AWS DynamoDB、Google Firestore、Azure Cosmos DB。<br /></li>
</ul></li>
<li>大數據與 AI 應用（Big Data &amp; AI Applications）<br />
<ul class="org-ul">
<li>NoSQL 在大數據中的應用（Hadoop、Spark）。<br /></li>
<li>NoSQL 在 AI 領域的應用（向量資料庫，如 FAISS、Milvus）。<br /></li>
<li>NoSQL 與機器學習（MongoDB、Elasticsearch）。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org7843a28" class="outline-4">
<h4 id="org7843a28"><span class="section-number-4">8.3.6.</span> 六、(10%)</h4>
<div class="outline-text-4" id="text-8-3-6">
<p>
To use Peterson’s solution to solve the critical-section problem between two processes Pi and Pj, please fill the blank (a), (b), (c), (d) and (e) in structure of Pi in Program 1.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">do</span> {
<span class="linenr">2: </span>    flag[i] = _(a)_;
<span class="linenr">3: </span>    turn = _(b)_;
<span class="linenr">4: </span>    <span style="color: #51afef;">while</span> (flag[j] == _(c)<span style="color: #ECBE7B;">_</span> &amp;&amp; <span style="color: #dcaeea;">turn</span> == _(d)_);
<span class="linenr">5: </span>       critical <span style="color: #ECBE7B;">section</span>
<span class="linenr">6: </span>    <span style="color: #dcaeea;">flag</span>[i] = _(e)_;
<span class="linenr">7: </span>    remainder section
<span class="linenr">8: </span>} <span style="color: #51afef;">while</span> (<span style="color: #a9a1e1;">true</span>);
</pre>
</div>
</div>
<div id="outline-container-org3a50d2a" class="outline-5">
<h5 id="org3a50d2a">解</h5>
<div class="outline-text-5" id="text-org3a50d2a">
<p>
Peterson 解法是一種經典的軟體同步機制，用來解決兩個進程的臨界區問題（Critical Section Problem）。它使用兩個共享變數來確保互斥（Mutual Exclusion）：<br />
</p>
<ul class="org-ul">
<li>flag[i]：表示進程 Pi 是否想進入臨界區，當 flag[i] = true 時，代表 Pi 想要進入臨界區。<br /></li>
<li>turn：用來決定哪個進程的優先權較高，當 turn = j 時，表示輪到 Pj 進入臨界區。<br /></li>
</ul>

<p>
Peterson 解法的 Pi 程式架構<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">do</span> {
<span class="linenr">2: </span>    flag[i] = <span style="color: #a9a1e1;">true</span>;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(a) &#34920;&#31034; Pi &#24819;&#35201;&#36914;&#20837;&#33256;&#30028;&#21312;</span>
<span class="linenr">3: </span>    turn = j;            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(b) &#23559;&#27402;&#38480;&#35731;&#32102; Pj</span>
<span class="linenr">4: </span>    <span style="color: #51afef;">while</span> (flag[j] == <span style="color: #a9a1e1;">true</span> &amp;&amp; turn == j);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(c) &amp; (d) &#31561;&#24453; Pj &#36914;&#20837;&#33256;&#30028;&#21312;</span>
<span class="linenr">5: </span>       critical <span style="color: #ECBE7B;">section</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36914;&#20837;&#33256;&#30028;&#21312;</span>
<span class="linenr">6: </span>    <span style="color: #dcaeea;">flag</span>[i] = <span style="color: #a9a1e1;">false</span>;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(e) Pi &#38626;&#38283;&#33256;&#30028;&#21312;&#65292;&#37323;&#25918;&#36039;&#28304;</span>
<span class="linenr">7: </span>    remainder section    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36914;&#20837;&#21097;&#39192;&#21312;</span>
<span class="linenr">8: </span>} <span style="color: #51afef;">while</span> (<span style="color: #a9a1e1;">true</span>);
</pre>
</div>
<p>
填入的空格<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">標記</th>
<th scope="col" class="org-left">填入值</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a)</td>
<td class="org-left">true</td>
<td class="org-left">設定 flag[i] = true，表示 Pi 想要進入臨界區</td>
</tr>

<tr>
<td class="org-left">(b)</td>
<td class="org-left">j</td>
<td class="org-left">設定 turn = j，讓 Pj 先執行</td>
</tr>

<tr>
<td class="org-left">(c)</td>
<td class="org-left">true</td>
<td class="org-left">檢查 flag[j] == true，如果 Pj 也想進入，則等待</td>
</tr>

<tr>
<td class="org-left">(d)</td>
<td class="org-left">j</td>
<td class="org-left">turn == j，如果 Pj 仍然有優先權，則 Pi 需等待</td>
</tr>

<tr>
<td class="org-left">(e)</td>
<td class="org-left">false</td>
<td class="org-left">Pi 離開臨界區後，將 flag[i] 設為 false，表示不再需要進入臨界區</td>
</tr>
</tbody>
</table>

<p>
Peterson 解法的核心機制<br />
</p>
<ol class="org-ol">
<li>互斥（Mutual Exclusion）<br />
<ul class="org-ul">
<li>當 Pi 進入臨界區時，Pj 必須等待，反之亦然。<br /></li>
<li>while 迴圈確保如果 Pj 也想進入臨界區並且 turn = j，則 Pi 會等待。<br /></li>
</ul></li>
<li>進度（Progress）<br />
<ul class="org-ul">
<li>如果沒有進程在臨界區，則不會有進程無限等待的情況，每個進程都可以最終獲得執行機會。<br /></li>
</ul></li>
<li>有限等待（Bounded Waiting）<br />
<ul class="org-ul">
<li>turn 變數確保進程不會無限等待，每個進程都能輪流進入臨界區。<br /></li>
</ul></li>
</ol>

<p>
Peterson 解法的優點與缺點<br />
</p>
<ul class="org-ul">
<li>✅ 優點：<br />
<ul class="org-ul">
<li>簡單且不依賴硬體支援，可用於一般軟體同步機制。<br /></li>
<li>適用於兩個進程（Pi、Pj） 的臨界區問題。<br /></li>
</ul></li>
</ul>
<p>
❌ 缺點：<br />
</p>
<ul class="org-ul">
<li>只能應用於兩個進程，無法擴展至多個進程。<br /></li>
<li>依賴於共享記憶體（Shared Memory），無法在分散式系統中應用。<br /></li>
<li>需要不斷檢查 while 迴圈（忙等待，Busy Waiting），可能影響效能。<br /></li>
</ul>

<p>
結論: Peterson 解法雖然不適合大規模多執行緒系統，但作為早期軟體互斥鎖的經典範例，仍然在學術領域具有重要意義，尤其是在作業系統與並行程式設計中，是理解**同步機制（Synchronization Mechanisms）**的重要基礎。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7afd480" class="outline-4">
<h4 id="org7afd480"><span class="section-number-4">8.3.7.</span> 七、(5%)</h4>
<div class="outline-text-4" id="text-8-3-7">
<p>
Please describe two strategies commonly being used in OS to allocate the kernel memory for structures of varying sizes.<br />
</p>
</div>
<div id="outline-container-org9c53e14" class="outline-5">
<h5 id="org9c53e14">解</h5>
<div class="outline-text-5" id="text-org9c53e14">
</div>
<ul class="org-ul">
<li><a id="orgb11a70e"></a>作業系統中的核心記憶體配置策略<br />
<div class="outline-text-6" id="text-orgb11a70e">
<p>
在作業系統（Operating System, OS）中，核心（Kernel）需要管理自身的記憶體，以便存放內部數據結構，如進程控制塊（Process Control Block, PCB）、檔案描述符（File Descriptors）等。由於這些數據結構的大小不固定，作業系統通常使用以下兩種策略來分配不同大小的核心記憶體（Kernel Memory Allocation）。<br />
</p>
</div>
</li>
<li><a id="orgdb30a2e"></a>策略 1：夾層分配器（Buddy System）<br />
<div class="outline-text-6" id="text-orgdb30a2e">
<ul class="org-ul">
<li>定義： 夾層分配器（Buddy System）是一種二元樹（Binary Tree）式的記憶體管理機制，透過遞迴方式將記憶體分割為兩個相等的部分（Buddy, 夥伴），直到找到最適合的區塊來滿足請求。<br /></li>
<li>運作方式：<br />
<ul class="org-ul">
<li>核心記憶體被劃分成大小為 2n2n 的區塊。<br /></li>
<li>若一個進程請求大小為 SS 的記憶體：<br />
<ul class="org-ul">
<li>找到一個最小的適當區塊 2k2k（其中 2k≥S2k≥S）。<br /></li>
<li>若區塊過大，則將其拆分成兩個相等的夥伴（Buddy）。<br /></li>
<li>直到找到適合大小的區塊並將其分配。<br /></li>
</ul></li>
<li>當區塊被釋放時，系統會檢查是否能與其 Buddy 合併，以減少記憶體碎片。<br /></li>
</ul></li>
<li>優點：<br />
<ul class="org-ul">
<li>快速分配與回收：因為使用二元分割，記憶體管理較為高效。<br /></li>
<li>簡單的管理機制：利用位圖或鏈結表追蹤空間分配狀況。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>內部碎片（Internal Fragmentation）：若請求的記憶體大小與 2k2k 不匹配，會浪費多餘的空間。<br /></li>
<li>可能產生外部碎片（External Fragmentation）：雖然 Buddy System 允許合併，但仍可能產生無法有效利用的小區塊。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org8433372"></a>策略 2：分頁緩存（Slab Allocation）<br />
<div class="outline-text-6" id="text-org8433372">
<ul class="org-ul">
<li>定義： 分頁緩存（Slab Allocation）是一種針對小型且固定大小的記憶體物件（如 PCB、檔案描述符等）設計的記憶體管理機制，可減少內部碎片並提高記憶體分配效率。<br /></li>
<li>運作方式：<br />
<ul class="org-ul">
<li>記憶體被劃分為「頁框（Pages）」，每個頁框會被進一步切割為大小相同的小區塊（Slabs）。<br /></li>
<li>Slab 會被組織成三種狀態：<br />
<ul class="org-ul">
<li>空閒（Empty）：該 Slab 內沒有任何已分配的物件。<br /></li>
<li>部分使用（Partial）：部分物件已分配，部分仍可使用。<br /></li>
<li>完全使用（Full）：所有物件都已被分配。<br /></li>
</ul></li>
<li>當核心需要分配記憶體時：<br />
<ul class="org-ul">
<li>若 Partial Slab 內有可用區塊，則直接分配。<br /></li>
<li>若沒有可用區塊，則從 Empty Slab 取用新區塊。<br /></li>
<li>若沒有 Empty Slab，則從系統獲取新的頁框。<br /></li>
</ul></li>
</ul></li>
<li>優點：<br />
<ul class="org-ul">
<li>減少內部碎片：每個 Slab 大小相同，不會浪費過多記憶體。<br /></li>
<li>適合固定大小物件：如進程控制塊（PCB）、inode 物件等。<br /></li>
<li>提升效能：Slab 會預先配置記憶體，因此分配與釋放時不需要進行額外的計算。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>不適用於變長結構：對於大小不固定的結構（如動態數據），Slab Allocation 效率較低。<br /></li>
<li>記憶體池管理較複雜：需要追蹤 Slab 狀態（Empty、Partial、Full）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc90989f"></a>夾層分配器 vs. 分頁緩存 比較<br />
<div class="outline-text-6" id="text-orgc90989f">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">夾層分配器（Buddy System）</th>
<th scope="col" class="org-left">分頁緩存（Slab Allocation）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">記憶體類型</td>
<td class="org-left">適用於變長記憶體分配</td>
<td class="org-left">適用於固定大小的物件</td>
</tr>

<tr>
<td class="org-left">內部碎片</td>
<td class="org-left">高（因為分配的區塊可能比需求大）</td>
<td class="org-left">低（物件大小固定）</td>
</tr>

<tr>
<td class="org-left">外部碎片</td>
<td class="org-left">可能發生，但可以透過 Buddy 合併降低</td>
<td class="org-left">無（因為頁框固定）</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">動態大小的結構，如用戶態請求的記憶體</td>
<td class="org-left">固定大小的核心物件，如 PCB、inode</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org1a62397"></a>相關計算機概論知識 為了準備研究所考試，考生應該掌握以下相關的計概知識：<br />
<div class="outline-text-6" id="text-org1a62397">
<ul class="org-ul">
<li>作業系統記憶體管理（Memory Management）<br />
<ul class="org-ul">
<li>記憶體分配策略：靜態分配（Static Allocation）、動態分配（Dynamic Allocation）<br /></li>
<li>虛擬記憶體（Virtual Memory）：Paging、Segmentation<br /></li>
<li>記憶體對齊（Memory Alignment） 與其對性能的影響<br /></li>
</ul></li>
<li>記憶體分配技術（Memory Allocation Techniques）<br />
<ul class="org-ul">
<li>夾層分配器（Buddy System）<br /></li>
<li>分頁緩存（Slab Allocation）<br /></li>
<li>堆積（Heap）與堆疊（Stack）記憶體管理<br /></li>
</ul></li>
<li>記憶體碎片管理（Memory Fragmentation Management）<br />
<ul class="org-ul">
<li>內部碎片（Internal Fragmentation）<br /></li>
<li>外部碎片（External Fragmentation）<br /></li>
<li>碎片回收技術（Compaction）<br /></li>
</ul></li>
<li>記憶體對核心的影響（Kernel Memory Impact）<br />
<ul class="org-ul">
<li>快取行為（Caching Behavior） 與其影響<br /></li>
<li>核心資料結構（如 PCB, inode, file descriptors） 的記憶體管理方式<br /></li>
</ul></li>
<li>現代作業系統記憶體管理演進<br />
<ul class="org-ul">
<li>Linux 如何使用 Slab 分配器（Slab Allocator） 來管理核心記憶體<br /></li>
<li>夾層分配器如何被應用於大規模系統，如 Linux Buddy Allocator<br /></li>
</ul></li>
</ul>

<p>
結論: 夾層分配器（Buddy System）和分頁緩存（Slab Allocation）是 OS 最常用的兩種核心記憶體分配策略，各自適用於不同場景：<br />
</p>
<ul class="org-ul">
<li>夾層分配器適合動態大小的記憶體請求，但可能產生內部碎片。<br /></li>
<li>分頁緩存適合固定大小的物件分配，有效減少記憶體浪費。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org3aea606" class="outline-4">
<h4 id="org3aea606"><span class="section-number-4">8.3.8.</span> 八、(5%)</h4>
<div class="outline-text-4" id="text-8-3-8">
<p>
Given a computer memory system with the page size 16KB, if the system guarantees that the TLB (Translation Look-ahead Buffer) reach is at least 32MB, how many TLB entries should this system have?<br />
</p>
</div>
<div id="outline-container-org4179536" class="outline-5">
<h5 id="org4179536">解</h5>
<div class="outline-text-5" id="text-org4179536">
<ul class="org-ul">
<li>題目分析<br />
<ul class="org-ul">
<li>頁面大小（Page Size, P）：16KB=16×1024=16,38416KB=16×1024=16,384 bytes<br /></li>
<li>TLB 影響範圍（TLB Reach）：至少 32MB=32×1024×1024=33,554,43232MB=32×1024×1024=33,554,432 bytes<br /></li>
<li>目標：求 TLB 至少需要多少個條目（Entries）<br /></li>
</ul></li>
<li>TLB 影響範圍（TLB Reach）計算<br />
<ul class="org-ul">
<li>TLB 影響範圍（TLB Reach）定義為：<br /></li>
<li>TLBReach=(TLB entries)×(Page Size)<br /></li>
<li>TLBReach=(TLB entries)×(Page Size)<br /></li>
</ul></li>
<li>令 E 為 TLB 的條目數（Number of TLB Entries），則：<br />
<ul class="org-ul">
<li>E×16,384≥33,554,432<br /></li>
</ul></li>
<li>解此不等式：<br />
<ul class="org-ul">
<li>\(E\ge\frac{33,554,432}{16,384}\)<br /></li>
</ul></li>
<li>計算：<br />
<ul class="org-ul">
<li>\(E\ge2048\)<br /></li>
</ul></li>
<li>所以，TLB 需要至少 2048 個條目（entries），才能達到 32MB 的影響範圍。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org55534e9" class="outline-5">
<h5 id="org55534e9">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-org55534e9">
<p>
為了更完整理解這個題目，考生應該掌握以下計算機組織與作業系統（Computer Organization &amp; OS） 相關知識：<br />
</p>
<ol class="org-ol">
<li>記憶體管理機制<br />
<ul class="org-ul">
<li>虛擬記憶體（Virtual Memory）：將虛擬地址對應到實體地址，允許程式擁有比物理記憶體更大的可用空間。<br /></li>
<li>分頁（Paging）：將記憶體分成固定大小的頁（Page）和框（Frame），透過頁表（Page Table）管理映射關係。<br /></li>
<li>TLB（Translation Lookaside Buffer）：存儲最近訪問的頁表映射關係，減少頁表查詢的時間。<br /></li>
</ul></li>
<li>TLB 的運作<br />
<ul class="org-ul">
<li>TLB 是快取（Cache），存儲最近訪問的頁表條目（Page Table Entries, PTEs），提高記憶體存取效率。<br /></li>
<li>TLB 命中（TLB Hit）：如果所需的頁表條目存在於 TLB，則直接返回物理地址。<br /></li>
<li>TLB 失敗（TLB Miss）：如果所需的頁表條目不在 TLB，則需查詢主頁表（Page Table）。<br /></li>
</ul></li>
<li>TLB 影響範圍（TLB Reach）<br />
<ul class="org-ul">
<li>TLB Reach = (TLB 條目數) × (頁大小)，表示 TLB 可快速轉譯的虛擬記憶體範圍。<br /></li>
<li>較大的 TLB Reach 可減少 TLB Miss，提高效能。<br /></li>
</ul></li>
<li>記憶體效能分析<br />
<ul class="org-ul">
<li>TLB Hit Ratio（命中率）：提高命中率可減少頁表存取時間。<br /></li>
<li>Page Table Walk：若 TLB Miss，則需查詢頁表，可能影響記憶體存取速度。<br /></li>
<li>多級頁表（Multi-Level Page Table）：大記憶體系統中常使用多級頁表以減少頁表大小。<br /></li>
</ul></li>
</ol>

<p>
結論:在本題中：<br />
</p>
<ul class="org-ul">
<li>頁大小 = 16KB<br /></li>
<li>TLB 影響範圍 = 32MB<br /></li>
<li>計算得 TLB 需要至少 2048 個條目<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org457a734" class="outline-4">
<h4 id="org457a734"><span class="section-number-4">8.3.9.</span> 九、(5%)</h4>
<div class="outline-text-4" id="text-8-3-9">
<p>
Suppose we a function P(x) = a + bx⁵ + cx¹⁰ + dx¹⁵. Given a x value, when deriving P(x) value, what is the minimum number of “add” operation? what is the minimum number of “multiply” operation?<br />
</p>
</div>
<div id="outline-container-org8eebcf1" class="outline-5">
<h5 id="org8eebcf1">解</h5>
<div class="outline-text-5" id="text-org8eebcf1">
</div>
<ul class="org-ul">
<li><a id="orgda5cff1"></a>題目分析<br />
<div class="outline-text-6" id="text-orgda5cff1">
<ul class="org-ul">
<li>目標：計算 \(P(x)=a+bx^5+cx^{10}+dx^{15^\)<br /></li>
<li>其中 a,b,c,da,b,c,d 是常數，最小化加法與乘法的操作次數。<br /></li>
</ul>
</div>
</li>
<li><a id="orge7b6bb7"></a>計算多項式時的加法與乘法操作<br />
<div class="outline-text-6" id="text-orge7b6bb7">
<ol class="org-ol">
<li>直接計算的乘法與加法次數<br />
最直接的方法是分別計算 \(x^5,x^{10},x^{15}\)，然後代入：<br />
<ul class="org-ul">
<li>乘法操作：<br />
<ul class="org-ul">
<li>\(x^5=x\times x\times x\times x\times x\)（4 次）<br /></li>
<li>\(x^{10}=x^5 \times x^5 \)（1 次）<br /></li>
<li>\(x^{15}=x^5 \times x^{10} \)（1 次）<br /></li>
<li>總共需要：4+1+1=6 次乘法<br /></li>
</ul></li>
<li>加法操作：<br />
<ul class="org-ul">
<li>計算 \(P(x)=a+bx^5+cx^{10}+dx^{15} \)需要 3 次加法。<br /></li>
</ul></li>
</ul></li>
<li>使用最少乘法的策略（快速冪運算）<br />
我們可以透過分解指數的方式來最小化乘法：<br />
<ol class="org-ol">
<li><p>
計算 x^5:<br />
</p>
<ul class="org-ul">
<li>\(x^2=x \times x \)(得到 x^2，1 次)<br /></li>
<li>\(x^4=x^2 \times x^2 \)(得到 x^4，1 次)<br /></li>
<li>\(x^5=x^4 \times × \) (得到 x^5，1 次)<br /></li>
</ul>
<p>
總共 3 次乘法。<br />
</p></li>
<li>計算 \(x^{10} \)\)<br />
<ul class="org-ul">
<li>\( x^{10} = x^5 \times x^5 \)(1 次)<br /></li>
</ul></li>
<li>計算 \(x^{15}\):<br />
\(x^{15} = x^5 \times x^{10} \)(1 次)<br /></li>
</ol></li>
</ol>
</div>
</li>
<li><a id="org7f58d8f"></a>最小運算次數<br />
<div class="outline-text-6" id="text-org7f58d8f">
<ul class="org-ul">
<li>最小乘法數：<br />
共 3（求 x^5）+ 1（求 \(x^{10}\) ）+ 1（求 \( x^{15}\) ）= 5 次乘法<br /></li>
<li>最小加法數：<br />
\( P(x) = a + bx^5 + cx^{1-0} + dx^{15} \)需要 3 次加法（每個項目與前一項相加）。<br /></li>
</ul>
<p>
總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">運算類型</th>
<th scope="col" class="org-left">最少操作數</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">加法（Add）</td>
<td class="org-left">3 次</td>
</tr>

<tr>
<td class="org-left">乘法（Multiply）</td>
<td class="org-left">5 次</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgdbb2991" class="outline-5">
<h5 id="orgdbb2991">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-orgdbb2991">
<p>
為了完整理解此題目，研究所考生應熟悉以下概念：<br />
</p>
<ol class="org-ol">
<li>數值計算（Numerical Computation）<br />
<ul class="org-ul">
<li>多項式計算優化（Polynomial Evaluation Optimization）<br />
<ul class="org-ul">
<li>Horner&rsquo;s Method（霍納法則）（適用於一般多項式）<br /></li>
<li>指數快速計算（Exponentiation by Squaring）<br /></li>
<li>乘法次數最少的展開策略<br /></li>
</ul></li>
</ul></li>
<li>時間複雜度分析（Time Complexity Analysis）<br />
<ul class="org-ul">
<li>多項式計算的 時間複雜度最佳化<br /></li>
<li>漸進時間複雜度（Big-O 計算），如：<br />
<ul class="org-ul">
<li>直接計算 O(n)<br /></li>
<li>快速冪算法 O(log⁡n)<br /></li>
</ul></li>
</ul></li>
<li>計算機架構與數值計算應用<br />
<ul class="org-ul">
<li>乘法和加法在 CPU 內部的實作<br /></li>
<li>乘法指令（Multiply Instruction）與 SIMD 指令集的加速<br /></li>
<li>GPU 如何加速多項式運算（例如 CUDA 使用並行計算）<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org189e3f0" class="outline-4">
<h4 id="org189e3f0"><span class="section-number-4">8.3.10.</span> 十、</h4>
<div class="outline-text-4" id="text-8-3-10">
<p>
What is runtime polymorphism or dynamic method dispatch in Java? (5 points). Provide example Java codes to explain this concept (5 points)<br />
</p>
</div>
<div id="outline-container-org376e08f" class="outline-5">
<h5 id="org376e08f">解</h5>
<div class="outline-text-5" id="text-org376e08f">
<p>
在 Java 中，運行時多型（Runtime Polymorphism），也稱為動態方法分派（Dynamic Method Dispatch），是一種 透過父類別的參考變數來調用子類別的覆寫方法（Overridden Method） 的技術。這種機制允許程式在執行期間決定調用哪個方法，而不是在編譯期間。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgfc910ef"></a>運行時多型的關鍵概念<br />
<div class="outline-text-6" id="text-orgfc910ef">
<ul class="org-ul">
<li>方法覆寫（Method Overriding）:子類別（Subclass）提供與父類別（Superclass）相同的方法名稱、參數列表與返回類型，來覆寫父類別的方法。<br /></li>
<li>父類別的參考指向子類別物件:SuperClass obj = new SubClass(); → 透過父類別的參考變數來存取子類別的覆寫方法。<br /></li>
<li>動態綁定（Dynamic Binding）: 在執行時決定調用的方法，而不是在編譯時。<br /></li>
</ul>
</div>
</li>
<li><a id="orgbf80a4e"></a>Java 範例<br />
<div class="outline-text-6" id="text-orgbf80a4e">
<p>
以下程式示範運行時多型，透過父類別 Animal 的參考變數來呼叫不同子類別 Dog 和 Cat 的 makeSound() 方法。<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29238;&#39006;&#21029; Animal</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> Animal {
<span class="linenr"> 3: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr"> 4: </span>        System.out.println(<span style="color: #98be65;">"Animal makes a sound"</span>);
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23376;&#39006;&#21029; Dog&#65292;&#35206;&#23531; makeSound &#26041;&#27861;</span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> Dog <span style="color: #51afef;">extends</span> Animal {
<span class="linenr">10: </span>    @Override
<span class="linenr">11: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr">12: </span>        System.out.println(<span style="color: #98be65;">"Dog barks"</span>);
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>}
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23376;&#39006;&#21029; Cat&#65292;&#35206;&#23531; makeSound &#26041;&#27861;</span>
<span class="linenr">17: </span><span style="color: #51afef;">class</span> Cat <span style="color: #51afef;">extends</span> Animal {
<span class="linenr">18: </span>    @Override
<span class="linenr">19: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr">20: </span>        System.out.println(<span style="color: #98be65;">"Cat meows"</span>);
<span class="linenr">21: </span>    }
<span class="linenr">22: </span>}
<span class="linenr">23: </span>
<span class="linenr">24: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28204;&#35430;&#39006;&#21029;</span>
<span class="linenr">25: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> RuntimePolymorphismExample {
<span class="linenr">26: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">27: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29238;&#39006;&#21029;&#30340;&#21443;&#32771;&#35722;&#25976;&#25351;&#21521;&#23376;&#39006;&#21029;&#29289;&#20214;</span>
<span class="linenr">28: </span>        Animal myAnimal;
<span class="linenr">29: </span>
<span class="linenr">30: </span>        myAnimal = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>();
<span class="linenr">31: </span>        myAnimal.makeSound();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22519;&#34892;&#26178;&#27770;&#23450;&#21628;&#21483; Dog &#30340; makeSound()</span>
<span class="linenr">32: </span>
<span class="linenr">33: </span>        myAnimal = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Cat</span>();
<span class="linenr">34: </span>        myAnimal.makeSound();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22519;&#34892;&#26178;&#27770;&#23450;&#21628;&#21483; Cat &#30340; makeSound()</span>
<span class="linenr">35: </span>    }
<span class="linenr">36: </span>}
</pre>
</div>
<p>
執行結果<br />
</p>
<pre class="example" id="org1f1e9f4">
Dog barks
Cat meows
</pre>
</div>
</li>
<li><a id="org8428c44"></a>解析<br />
<div class="outline-text-6" id="text-org8428c44">
<ol class="org-ol">
<li>父類別 Animal 定義了一個 makeSound() 方法。<br /></li>
<li>子類別 Dog 和 Cat 皆覆寫（Override）了 makeSound() 方法。<br /></li>
<li>在 main() 方法中：<br />
<ul class="org-ul">
<li>Animal myAnimal = new Dog(); → myAnimal.makeSound(); 會呼叫 Dog 版本。<br /></li>
<li>myAnimal = new Cat(); → myAnimal.makeSound(); 會呼叫 Cat 版本。<br /></li>
</ul></li>
<li>關鍵點：<br />
<ul class="org-ul">
<li>在編譯時，編譯器僅知道 myAnimal 是 Animal 型別。<br /></li>
<li>在執行時，Java 會根據物件的實際型別（Dog 或 Cat）來決定調用哪個 makeSound() 方法。<br /></li>
</ul></li>
</ol>

<p>
運行時多型的重要性<br />
</p>
<ul class="org-ul">
<li>✅ 提高程式的靈活性與可擴展性<br /></li>
<li>✅ 允許以統一的方式處理不同類別的物件<br /></li>
<li>✅ 適用於面向物件設計模式，如工廠模式（Factory Pattern）與策略模式（Strategy Pattern）<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org3bc9e31" class="outline-4">
<h4 id="org3bc9e31"><span class="section-number-4">8.3.11.</span> 十一、</h4>
<div class="outline-text-4" id="text-8-3-11">
<p>
The following programming method was written to determine whether its String parameter reads identically left-to-right and right-to-left (the so called palindrome 回文).<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">boolean</span> <span style="color: #c678dd;">isAPalindrome</span>(<span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">s</span>) {
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">j</span> = s.length() - <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">3: </span>    <span style="color: #51afef;">while</span> (i != j &amp;&amp; s.charAt(i) == s.charAt(j)) {
<span class="linenr">4: </span>        i++;
<span class="linenr">5: </span>        j--;
<span class="linenr">6: </span>    }
<span class="linenr">7: </span>    <span style="color: #51afef;">return</span> (i == j);
<span class="linenr">8: </span>}
</pre>
</div>
<p>
This method compiles fine; however, it contains a logic error, which may result in a run-time error, or wrong output.<br />
</p>
<ol class="org-ol">
<li>Find the error and explain what problem it will cause (5 points)<br /></li>
<li>Fix the error (write the correct statements) (5 points)<br /></li>
<li>Write an alternative, recursive implementation (5 points)<br /></li>
</ol>
</div>
<div id="outline-container-orgbc86649" class="outline-5">
<h5 id="orgbc86649">解</h5>
<div class="outline-text-5" id="text-orgbc86649">
<p>
給定一個 Java 方法 isAPalindrome(String s)，該方法應判斷輸入字串是否為回文（即從左至右和從右至左讀取結果相同）。然而，原始程式碼存在邏輯錯誤，可能導致運行時錯誤或錯誤輸出。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orge6bc2f9"></a>1. 找出錯誤並解釋（5 分）<br />
<div class="outline-text-6" id="text-orge6bc2f9">
<p>
原始程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">isAPalindrome</span>(String s) {
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">j</span> = s.length() - <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">3: </span>    <span style="color: #51afef;">while</span> (i != j &amp;&amp; s.charAt(i) == s.charAt(j)) {
<span class="linenr">4: </span>        i++;
<span class="linenr">5: </span>        j--;
<span class="linenr">6: </span>    }
<span class="linenr">7: </span>    <span style="color: #51afef;">return</span> (i == j);
<span class="linenr">8: </span>}
</pre>
</div>

<p>
錯誤點<br />
</p>
<ul class="org-ul">
<li>錯誤條件：while (i != j &amp;&amp; s.charAt(i) == s.charAt(j))<br />
<ul class="org-ul">
<li>i != j 條件錯誤，當 i 越過 j（如偶數長度字串）時，迴圈應該結束，但 i != j 仍為 true 時，會造成錯誤判斷。<br /></li>
<li>例如，對於 abba：<br />
<ul class="org-ul">
<li>i=0, j=3：檢查 a == a（✅）<br /></li>
<li>i=1, j=2：檢查 b == b（✅）<br /></li>
<li>i=2, j=1：錯誤條件仍為 true，導致錯誤結果<br /></li>
</ul></li>
</ul></li>
</ul>
<p>
錯誤後果<br />
</p>
<ul class="org-ul">
<li>錯誤輸出：對於偶數長度的回文字串（如 &ldquo;abba&rdquo;），應該回傳 true，但由於條件 i == j 不成立，會回傳 false。<br /></li>
<li>潛在運行時錯誤：當 i &gt; j 時，迴圈應該停止，否則可能導致存取 s.charAt(i) 或 s.charAt(j) 時出界（Out of Bounds）。<br /></li>
</ul>
</div>
</li>
<li><a id="org075c435"></a>2. 修正錯誤（5 分）<br />
<div class="outline-text-6" id="text-org075c435">
<p>
修正後的程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">isAPalindrome</span>(String s) {
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">j</span> = s.length() - <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 3: </span>    <span style="color: #51afef;">while</span> (i &lt; j) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20462;&#27491;&#26781;&#20214;&#65292;&#30906;&#20445; i &#19981;&#26371;&#36229;&#36942; j</span>
<span class="linenr"> 4: </span>        <span style="color: #51afef;">if</span> (s.charAt(i) != s.charAt(j)) {
<span class="linenr"> 5: </span>            <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#23383;&#31526;&#19981;&#21516;&#65292;&#21063;&#19981;&#26159;&#22238;&#25991;</span>
<span class="linenr"> 6: </span>        }
<span class="linenr"> 7: </span>        i++;
<span class="linenr"> 8: </span>        j--;
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25152;&#26377;&#23565;&#25033;&#23383;&#31526;&#37117;&#30456;&#31561;&#65292;&#28858;&#22238;&#25991;</span>
<span class="linenr">11: </span>}
</pre>
</div>
<p>
修正內容<br />
</p>
<ul class="org-ul">
<li>修正迴圈條件<br />
<ul class="org-ul">
<li>while (i != j) → while (i &lt; j)<br /></li>
<li>確保 i 不會超過 j，特別是對於偶數長度的字串。<br /></li>
</ul></li>
<li>改變回傳條件<br />
<ul class="org-ul">
<li>若 s.charAt(i) != s.charAt(j)，則立即回傳 false，無需繼續檢查。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgec7082f"></a>3. 遞迴（Recursive）實作（5 分）<br />
<div class="outline-text-6" id="text-orgec7082f">
<p>
遞迴方法可以使用字串的首尾比較，然後遞迴地檢查中間部分。<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">isAPalindromeRecursive</span>(String s) {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">return</span> checkPalindrome(s, <span style="color: #da8548; font-weight: bold;">0</span>, s.length() - <span style="color: #da8548; font-weight: bold;">1</span>);
<span class="linenr"> 3: </span>}
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36958;&#36852;&#36628;&#21161;&#20989;&#25976;</span>
<span class="linenr"> 6: </span><span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">checkPalindrome</span>(String s, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>, <span style="color: #ECBE7B;">int</span> j) {
<span class="linenr"> 7: </span>    <span style="color: #51afef;">if</span> (i &gt;= j) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36958;&#36852;&#32066;&#27490;&#26781;&#20214;</span>
<span class="linenr"> 8: </span>    <span style="color: #51afef;">if</span> (s.charAt(i) != s.charAt(j)) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#23383;&#31526;&#19981;&#30456;&#31561;&#21063;&#19981;&#26159;&#22238;&#25991;</span>
<span class="linenr"> 9: </span>    <span style="color: #51afef;">return</span> checkPalindrome(s, i + <span style="color: #da8548; font-weight: bold;">1</span>, j - <span style="color: #da8548; font-weight: bold;">1</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#32380;&#32396;&#27298;&#26597;&#20839;&#37096;&#23383;&#20803;</span>
<span class="linenr">10: </span>}
</pre>
</div>
<p>
遞迴版本的運作原理<br />
</p>
<ul class="org-ul">
<li>基礎條件：<br />
<ul class="org-ul">
<li>若 i &gt;= j（即字串長度為 1 或 i 超過 j），則回文檢查完成，回傳 true。<br /></li>
</ul></li>
<li>遞迴邏輯：<br />
<ul class="org-ul">
<li>若 s.charAt(i) != s.charAt(j)，則回傳 false。<br /></li>
<li>否則，繼續檢查 s[i+1] 到 s[j-1] 是否為回文（遞迴）。<br /></li>
</ul></li>
</ul>

<p>
總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">項目</th>
<th scope="col" class="org-left">原始程式碼</th>
<th scope="col" class="org-left">修正後版本</th>
<th scope="col" class="org-left">遞迴版本</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">迴圈條件</td>
<td class="org-left">i != j</td>
<td class="org-left">i &lt; j</td>
<td class="org-left">使用遞迴 checkPalindrome(s, i, j)</td>
</tr>

<tr>
<td class="org-left">停止條件</td>
<td class="org-left">錯誤（可能超過邊界）</td>
<td class="org-left">while (i &lt; j)</td>
<td class="org-left">if (i &gt;= j) return true</td>
</tr>

<tr>
<td class="org-left">回傳條件</td>
<td class="org-left">i == j</td>
<td class="org-left">若 s[i] != s[j] 則 return false</td>
<td class="org-left">若 s[i] != s[j] 則 return false</td>
</tr>

<tr>
<td class="org-left">效率</td>
<td class="org-left">O(n)O(n)</td>
<td class="org-left">O(n)O(n)</td>
<td class="org-left">O(n)O(n)（但需額外遞迴堆疊空間）</td>
</tr>

<tr>
<td class="org-left">適用性</td>
<td class="org-left">可能錯誤</td>
<td class="org-left">最佳化版本</td>
<td class="org-left">適合遞迴場景</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb18123c" class="outline-5">
<h5 id="orgb18123c">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-orgb18123c">
<p>
考生應熟悉以下演算法與程式設計概念：<br />
</p>
<ol class="org-ol">
<li>演算法設計<br />
<ul class="org-ul">
<li>雙指標技術（Two-Pointer Technique）<br />
<ul class="org-ul">
<li>適用於字串與陣列檢查，如回文檢查、區間搜索、排序。<br /></li>
</ul></li>
<li>時間與空間複雜度分析<br />
<ul class="org-ul">
<li>雙指標法的時間複雜度為 O(n)O(n)。<br /></li>
<li>遞迴方法的時間複雜度同樣為 O(n)O(n)，但可能造成額外的遞迴堆疊開銷（Stack Overhead）。<br /></li>
</ul></li>
</ul></li>
<li>記憶體管理與遞迴<br />
<ul class="org-ul">
<li>遞迴（Recursion）<br />
<ul class="org-ul">
<li>遞迴的函數調用會佔用函數呼叫堆疊（Call Stack），可能導致 Stack Overflow。<br /></li>
</ul></li>
<li>迴圈 vs 遞迴<br />
<ul class="org-ul">
<li>迴圈（Loop） 適合處理長度較大的字串，節省記憶體。<br /></li>
<li>遞迴（Recursion） 易於理解，適合用於分治法（Divide &amp; Conquer）。<br /></li>
</ul></li>
</ul></li>
<li>Java 字串處理<br />
<ul class="org-ul">
<li>String.charAt(i): 取字串 s 中的第 i 個字元，時間複雜度 O(1)O(1)。<br /></li>
<li>String.length(): 取字串長度，時間複雜度 O(1)O(1)。<br /></li>
<li>不可變性（Immutability）：<br />
<ul class="org-ul">
<li>String 是 immutable（不可變），所以在 charAt() 存取字元時，不會影響原始字串。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org94c2255" class="outline-3">
<h3 id="org94c2255"><span class="section-number-3">8.4.</span> 111</h3>
<div class="outline-text-3" id="text-8-4">
</div>
<div id="outline-container-org544cb4c" class="outline-4">
<h4 id="org544cb4c"><span class="section-number-4">8.4.1.</span> 1.(6%)</h4>
<div class="outline-text-4" id="text-8-4-1">
<p>
將下列的整數序列 9, 3, 4, 13, 16, 19, 1, 2, 7, 21, 23, 14, 11, 22 依序插入一個空的的二元搜尋樹 T 中。<br />
</p>
</div>
<div id="outline-container-orga2f5c6f" class="outline-5">
<h5 id="orga2f5c6f">(a) 請畫出插入完此序列後的二元搜尋樹 T。</h5>
</div>
<div id="outline-container-org25e9ed6" class="outline-5">
<h5 id="org25e9ed6">(b) 假設我們移出了樹 T 的根部節點 (root node)後，可以得到一個新的二元搜尋樹 T&rsquo;，請畫出二元搜尋樹 T&rsquo;。</h5>
</div>
<div id="outline-container-org2b444b0" class="outline-5">
<h5 id="org2b444b0">解</h5>
<div class="outline-text-5" id="text-org2b444b0">
<p>
BST T after Insertions<br />
</p>
<p width="500">
<img src="images/林北的考前猜題/BST-1.png" alt="BST-1.png" width="500" /><br />
BST T&rsquo; after Removing Root<br />
</p>
<p width="500">
<img src="images/林北的考前猜題/BST-2.png" alt="BST-2.png" width="500" /><br />
以上展示了 (a) 插入整數序列後的二元搜尋樹 TT 以及 (b) 移除根節點後的新二元搜尋樹 T′T′ 的結構。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgb97b64a"></a>(a) 插入後的二元搜尋樹 TT<br />
<div class="outline-text-6" id="text-orgb97b64a">
<p>
按照 二元搜尋樹（BST, Binary Search Tree） 的插入規則：<br />
</p>
<ul class="org-ul">
<li>左子樹的值 &lt; 當前節點的值<br /></li>
<li>右子樹的值 &gt; 當前節點的值<br /></li>
</ul>
<p>
將數列 9, 3, 4, 13, 16, 19, 1, 2, 7, 21, 23, 14, 11, 22 依序插入後，二元搜尋樹 TT 的結構如下：<br />
</p>
<pre class="example" id="orgf67de9a">
        9
       /  \
      3    13
     / \      \
    1   4      16
     \    \       \
      2    7       19
          /       /  \
        11       14   21
                      \
                      23
                     /
                    22
</pre>
</div>
</li>
<li><a id="org140febb"></a>(b) 移除根節點後的新二元搜尋樹 T′T′<br />
<div class="outline-text-6" id="text-org140febb">
<p>
根節點 99 被移除後，根據 BST 刪除節點規則：<br />
</p>
<ul class="org-ul">
<li>如果節點有兩個子節點，則使用**中序後繼（Inorder Successor）**來替代被刪除的節點。<br /></li>
<li>中序後繼 是大於當前節點的最小值，即右子樹中的最左節點。<br /></li>
<li>99 的中序後繼是 11，因此 11 取代 9 成為新的根節點。<br /></li>
</ul>
<p>
刪除後的新二元搜尋樹 T′T′ 結構：<br />
</p>
<pre class="example" id="org770e388">
       11
      /   \
     3     13
    / \       \
   1   4       16
    \    \       \
     2    7       19
                 /  \
                14   21
                     \
                     23
                    /
                   22
</pre>
</div>
</li>
<li><a id="org0c58772"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org0c58772">
<ol class="org-ol">
<li>二元搜尋樹（BST）的基本操作<br />
<ul class="org-ul">
<li>插入（Insertion）<br />
<ul class="org-ul">
<li>時間複雜度：O(h)O(h)，其中 hh 是樹的高度。<br /></li>
<li>最佳情況：當 BST 平衡時，h=O(log⁡n)h=O(logn)。<br /></li>
<li>最壞情況：若 BST 退化成單鏈結構，則 h=O(n)h=O(n)。<br /></li>
</ul></li>
<li>搜尋（Search）<br />
<ul class="org-ul">
<li>時間複雜度：O(h)O(h)<br /></li>
<li>目標：找出某個值是否存在於 BST。<br /></li>
</ul></li>
<li>刪除（Deletion）<br />
<ul class="org-ul">
<li>三種情況：<br />
<ul class="org-ul">
<li>葉節點（Leaf Node）：直接刪除。<br /></li>
<li>僅有一個子節點：直接用子節點取代。<br /></li>
<li>有兩個子節點：<br />
<ul class="org-ul">
<li>找出中序後繼（右子樹的最小值）。<br /></li>
<li>用中序後繼取代刪除的節點。<br /></li>
</ul></li>
</ul></li>
</ul></li>
<li>時間複雜度：O(h)O(h)<br /></li>
</ul></li>
<li>樹的性質與應用<br />
<ul class="org-ul">
<li>平衡二元搜尋樹（Balanced BST）<br />
<ul class="org-ul">
<li>例如 AVL 樹、紅黑樹（Red-Black Tree） 保持高度接近 O(log⁡n)O(logn)。<br /></li>
<li>普通 BST 若插入順序不佳，可能退化成鏈狀結構，影響查詢效率。<br /></li>
</ul></li>
<li>BST 的應用<br />
<ul class="org-ul">
<li>數據庫索引（Database Indexing）<br /></li>
<li>操作系統的記憶體管理（Memory Management）<br /></li>
<li>圖論中的最短路徑查找（Shortest Path Finding）<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org461e93e" class="outline-4">
<h4 id="org461e93e"><span class="section-number-4">8.4.2.</span> 2.(6%)</h4>
<div class="outline-text-4" id="text-8-4-2">
<p>
在 Linux 作業系統中，給一檔案資訊如下:<br />
-rw-rw-rw- 1 guest1 guest2 79 Jan 4 01:51 guest3<br />
</p>
</div>
<div id="outline-container-orgc537dde" class="outline-5">
<h5 id="orgc537dde">(a) 請問此檔案所屬群組為?</h5>
</div>
<div id="outline-container-orgff05f32" class="outline-5">
<h5 id="orgff05f32">(b) 請問此檔案的型態為?</h5>
</div>
<div id="outline-container-orgede0402" class="outline-5">
<h5 id="orgede0402">(c) 在執行 chmod 755 指令於此檔案後，請問該檔案的屬性顯示為何?</h5>
</div>
<div id="outline-container-org3dd19cb" class="outline-5">
<h5 id="org3dd19cb">解</h5>
</div>
</div>
<div id="outline-container-org55fd417" class="outline-4">
<h4 id="org55fd417"><span class="section-number-4">8.4.3.</span> 3.(5%)</h4>
<div class="outline-text-4" id="text-8-4-3">
<p>
假設一系統包含有四種硬體資源 A、B、C、D，現有五個行程 (process) P1、P2、P3、P4、P5 在此系統中，假設系統目前資源分配狀態如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Allocation</th>
<th scope="col" class="org-left">Request</th>
<th scope="col" class="org-left">Available</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">A B C D</td>
<td class="org-left">A B C D</td>
<td class="org-left">A B C D</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">P1</td>
<td class="org-left">1 0 0 1</td>
<td class="org-left">1 0 0 1</td>
<td class="org-left">1 1 0 1</td>
</tr>

<tr>
<td class="org-left">P2</td>
<td class="org-left">1 1 1 1</td>
<td class="org-left">0 1 1 1</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P3</td>
<td class="org-left">1 1 0 1</td>
<td class="org-left">1 0 1 0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P4</td>
<td class="org-left">1 1 0 0</td>
<td class="org-left">1 1 0 1</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P5</td>
<td class="org-left">1 1 1 1</td>
<td class="org-left">0 1 1 0</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org6054f1a" class="outline-5">
<h5 id="org6054f1a">(a) 請問每種硬體資源分別有多少實體(instance)?</h5>
</div>
<div id="outline-container-orgf1470e0" class="outline-5">
<h5 id="orgf1470e0">(b) 請解釋此系統目前是否存在死結(deadlock)? 如有死結，是哪些個行程所造成?</h5>
</div>
<div id="outline-container-org5a537e8" class="outline-5">
<h5 id="org5a537e8">解</h5>
<div class="outline-text-5" id="text-org5a537e8">
<p>
在 Linux 作業系統中，每個檔案都有特定的屬性與權限設定，以確保系統的安全性與存取控制。本題目提供的檔案資訊如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>-rw-rw-rw- <span style="color: #da8548; font-weight: bold;">1</span> guest1 guest2 <span style="color: #da8548; font-weight: bold;">79</span> Jan <span style="color: #da8548; font-weight: bold;">4</span> 01:51 guest3
</pre>
</div>
<p>
我們將根據此資訊回答問題，並補充相關計算機概論知識。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2d6452d"></a>(a) 此檔案所屬群組為?<br />
<div class="outline-text-6" id="text-org2d6452d">
<ul class="org-ul">
<li>在 Linux 檔案系統中，每個檔案都有一個擁有者（owner）與一個所屬群組（group）。<br /></li>
<li>該行資訊：<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>    -rw-rw-rw- <span style="color: #da8548; font-weight: bold;">1</span> guest1 guest2 <span style="color: #da8548; font-weight: bold;">79</span> Jan <span style="color: #da8548; font-weight: bold;">4</span> 01:51 guest3
</pre>
</div>
<ul class="org-ul">
<li>第一個欄位（-rw-rw-rw-）：檔案類型與權限。<br /></li>
<li>第二個欄位（1）：硬連結（hard link）數量。<br /></li>
<li>第三個欄位（guest1）：檔案的擁有者。<br /></li>
<li>第四個欄位（guest2）：檔案的所屬群組（group）。<br /></li>
<li>第五個欄位（79）：檔案大小（單位：byte）。<br /></li>
<li>第六個至第八個欄位（Jan 4 01:51）：最後修改時間。<br /></li>
<li>最後一個欄位（guest3）：檔案名稱。<br /></li>
</ul>
<p>
因此，此檔案的 所屬群組（group）為 guest2。<br />
</p>
</div>
</li>
<li><a id="orga0b92aa"></a>(b) 此檔案的型態為?<br />
<div class="outline-text-6" id="text-orga0b92aa">
<p>
在 ls -l 指令的輸出結果中，第一個字元 代表檔案的型態：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>-rw-rw-rw-
</pre>
</div>
<p>
第一個字元為 &ldquo;-&rdquo;，其可能值如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字元</th>
<th scope="col" class="org-left">類型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">-</td>
<td class="org-left">一般檔案（Regular file）</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-left">目錄（Directory）</td>
</tr>

<tr>
<td class="org-left">l</td>
<td class="org-left">符號連結（Symbolic link）</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-left">區塊裝置（Block device）</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left">字元裝置（Character device）</td>
</tr>

<tr>
<td class="org-left">p</td>
<td class="org-left">命名管道（Named pipe）</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">Socket 檔案</td>
</tr>
</tbody>
</table>
<p>
因此，該檔案的型態為「一般檔案（Regular file）」。<br />
</p>
</div>
</li>
<li><a id="org629265c"></a>(c) 在執行 chmod 755 指令於此檔案後，請問該檔案的屬性顯示為何？<br />
<div class="outline-text-6" id="text-org629265c">
<p>
chmod 指令<br />
</p>
<ul class="org-ul">
<li>chmod 用於變更檔案權限。<br /></li>
<li>755 為八進位（octal）格式，轉換為權限位元：<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span><span style="color: #da8548; font-weight: bold;">7</span> &#8594; rwx <span style="color: #51afef;">&#65288;</span>&#25793;&#26377;&#32773;&#21487;&#35712;&#12289;&#21487;&#23531;&#12289;&#21487;&#22519;&#34892;<span style="color: #51afef;">&#65289;</span>
<span class="linenr">2: </span><span style="color: #da8548; font-weight: bold;">5</span> &#8594; r-x <span style="color: #51afef;">&#65288;</span>&#32676;&#32068;&#21487;&#35712;&#12289;&#19981;&#21487;&#23531;&#12289;&#21487;&#22519;&#34892;<span style="color: #51afef;">&#65289;</span>
<span class="linenr">3: </span><span style="color: #da8548; font-weight: bold;">5</span> &#8594; r-x <span style="color: #51afef;">&#65288;</span>&#20854;&#20182;&#20351;&#29992;&#32773;&#21487;&#35712;&#12289;&#19981;&#21487;&#23531;&#12289;&#21487;&#22519;&#34892;<span style="color: #51afef;">&#65289;</span>
</pre>
</div>
<p>
變更前權限：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>-rw-rw-rw-
</pre>
</div>
<p>
變更後權限：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>    -rwxr-xr-x
</pre>
</div>

<p>
因此，執行 chmod 755 後，該檔案的屬性將顯示為 -rwxr-xr-x。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf745c49" class="outline-5">
<h5 id="orgf745c49">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-orgf745c49">
<ol class="org-ol">
<li><p>
Linux 檔案權限結構<br />
在 ls -l 顯示的第一欄位（如 -rw-rw-rw-），權限結構如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>   <span style="color: #51afef;">[</span>-<span style="color: #51afef;">]</span>   <span style="color: #51afef;">[</span>rw-<span style="color: #51afef;">]</span> <span style="color: #51afef;">[</span>rw-<span style="color: #51afef;">]</span> <span style="color: #51afef;">[</span>rw-<span style="color: #51afef;">]</span>
<span class="linenr">2: </span>    <span style="color: #da8548; font-weight: bold;">1</span>      <span style="color: #da8548; font-weight: bold;">2</span>      <span style="color: #da8548; font-weight: bold;">3</span>      <span style="color: #da8548; font-weight: bold;">4</span>
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">欄位</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">檔案類型（-：一般檔案，d：目錄）</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">擁有者（Owner）的權限</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">所屬群組（Group）的權限</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">其他使用者（Others）的權限</td>
</tr>
</tbody>
</table></li>
<li><p>
chmod 權限變更<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">八進位數字</th>
<th scope="col" class="org-left">權限</th>
<th scope="col" class="org-left">意義</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">---</td>
<td class="org-left">無權限</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#x2013;x</td>
<td class="org-left">執行權限</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">-w-</td>
<td class="org-left">寫入權限</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">-wx</td>
<td class="org-left">寫入 + 執行</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">r--</td>
<td class="org-left">讀取權限</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">r-x</td>
<td class="org-left">讀取 + 執行</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">rw-</td>
<td class="org-left">讀取 + 寫入</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">rwx</td>
<td class="org-left">讀取 + 寫入 + 執行</td>
</tr>
</tbody>
</table></li>
<li>變更檔案擁有者與群組<br />
<ul class="org-ul">
<li><p>
chown（Change Owner）：變更檔案的擁有者<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">chown</span> new_owner filename
</pre>
</div></li>
<li><p>
chgrp（Change Group）：變更檔案的所屬群組<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>    chgrp new_group filename
</pre>
</div></li>
</ul></li>
<li><p>
檔案型態與 ls 指令<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">檔案型態</th>
<th scope="col" class="org-left">符號</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">一般檔案</td>
<td class="org-left">-</td>
<td class="org-left">例如文字檔、程式碼檔案</td>
</tr>

<tr>
<td class="org-left">目錄</td>
<td class="org-left">d</td>
<td class="org-left">文件夾，如 <i>home</i></td>
</tr>

<tr>
<td class="org-left">符號連結</td>
<td class="org-left">l</td>
<td class="org-left">指向另一檔案的捷徑</td>
</tr>

<tr>
<td class="org-left">裝置檔案</td>
<td class="org-left">b/c</td>
<td class="org-left">b 為區塊裝置，c 為字元裝置</td>
</tr>

<tr>
<td class="org-left">命名管道</td>
<td class="org-left">p</td>
<td class="org-left">用於進程間通訊（IPC）</td>
</tr>

<tr>
<td class="org-left">套接字</td>
<td class="org-left">s</td>
<td class="org-left">網路通訊用的特殊檔案</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</div>
<div id="outline-container-org4c8993f" class="outline-5">
<h5 id="org4c8993f">LINUX基本知識</h5>
<div class="outline-text-5" id="text-org4c8993f">
</div>
<ul class="org-ul">
<li><a id="orgc449696"></a>LINUX 基本知識簡介<br />
<div class="outline-text-6" id="text-orgc449696">
<p>
定義：Linux 是一個類 Unix（Unix-like）的開源作業系統，廣泛應用於伺服器、桌面電腦、嵌入式系統等環境。其核心（Kernel）由 Linus Torvalds 於 1991 年開發，並且採用 GNU 工具組。<br />
</p>
</div>
</li>
<li><a id="org9274968"></a>Linux 檔案架構（File System Hierarchy） Linux 的檔案系統採用階層式結構，所有檔案與目錄均從根目錄 (/) 開始。以下是主要的目錄與用途：<br />
<div class="outline-text-6" id="text-org9274968">
<ul class="org-ul">
<li>/（根目錄）：系統的最上層，包含所有其他目錄。<br /></li>
<li>/bin（Binary）：存放基本可執行程式（例如 ls, cp, mv, cat）。<br /></li>
<li>/sbin（System Binary）：存放系統管理指令（如 shutdown, fdisk, ifconfig）。<br /></li>
<li>/home：用戶的家目錄，例如 /home/user1。<br /></li>
<li>/root：系統管理員（root）的家目錄。<br /></li>
<li>/etc：存放系統設定檔（如 /etc/passwd, /etc/fstab）。<br /></li>
<li>/var：變動資料，如日誌（/var/log）、郵件（/var/mail）。<br /></li>
<li>/tmp：暫存檔案目錄，重啟後可能會清除。<br /></li>
<li>/usr：用戶應用程式與程式庫（如 /usr/bin）。<br /></li>
<li>/dev：裝置檔案（如 /dev/sda1 表示第一個硬碟）。<br /></li>
<li>/proc：虛擬檔案系統，包含系統資訊（如 /proc/cpuinfo）。<br /></li>
<li>/mnt：手動掛載的磁碟裝置。<br /></li>
<li>/media：自動掛載的裝置（如 USB、CD/DVD）。<br /></li>
</ul>
</div>
</li>
<li><a id="orge3b5147"></a>Linux 基本指令 以下是 Linux 常見的基本指令，涵蓋檔案管理、使用者管理、系統管理等：<br />
<div class="outline-text-6" id="text-orge3b5147">
<ol class="org-ol">
<li><p>
檔案與目錄操作<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ls</td>
<td class="org-left">列出目錄內容 (ls -l, ls -a)</td>
</tr>

<tr>
<td class="org-left">cd</td>
<td class="org-left">切換目錄 (cd /home/user)</td>
</tr>

<tr>
<td class="org-left">pwd</td>
<td class="org-left">顯示當前路徑</td>
</tr>

<tr>
<td class="org-left">mkdir</td>
<td class="org-left">建立新目錄 (mkdir newdir)</td>
</tr>

<tr>
<td class="org-left">rmdir</td>
<td class="org-left">刪除空目錄 (rmdir olddir)</td>
</tr>

<tr>
<td class="org-left">rm</td>
<td class="org-left">刪除檔案或目錄 (rm -rf mydir)</td>
</tr>

<tr>
<td class="org-left">cp</td>
<td class="org-left">複製檔案 (cp file1 file2)</td>
</tr>

<tr>
<td class="org-left">mv</td>
<td class="org-left">移動或重新命名檔案 (mv old new)</td>
</tr>

<tr>
<td class="org-left">touch</td>
<td class="org-left">建立新檔案 (touch myfile.txt)</td>
</tr>

<tr>
<td class="org-left">find</td>
<td class="org-left">搜尋檔案 (find /home -name &ldquo;*.txt&rdquo;)</td>
</tr>
</tbody>
</table></li>
<li><p>
檔案權限與擁有者<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">chmod</td>
<td class="org-left">變更檔案權限 (chmod 755 file)</td>
</tr>

<tr>
<td class="org-left">chown</td>
<td class="org-left">變更檔案擁有者 (chown user:group file)</td>
</tr>

<tr>
<td class="org-left">ls -l</td>
<td class="org-left">顯示檔案權限與屬性</td>
</tr>
</tbody>
</table></li>
<li><p>
文字處理<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">cat</td>
<td class="org-left">顯示檔案內容 (cat file.txt)</td>
</tr>

<tr>
<td class="org-left">more / less</td>
<td class="org-left">分頁檢視 (less largefile.txt)</td>
</tr>

<tr>
<td class="org-left">head</td>
<td class="org-left">顯示前 10 行 (head -n 20 file.txt)</td>
</tr>

<tr>
<td class="org-left">tail</td>
<td class="org-left">顯示後 10 行 (tail -f log.txt)</td>
</tr>

<tr>
<td class="org-left">grep</td>
<td class="org-left">搜尋關鍵字 (grep &ldquo;error&rdquo; log.txt)</td>
</tr>
</tbody>
</table></li>
<li><p>
系統管理<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">df -h</td>
<td class="org-left">顯示磁碟使用情況</td>
</tr>

<tr>
<td class="org-left">du -sh</td>
<td class="org-left">計算目錄大小</td>
</tr>

<tr>
<td class="org-left">top / htop</td>
<td class="org-left">顯示系統處理程序</td>
</tr>

<tr>
<td class="org-left">free -m</td>
<td class="org-left">顯示記憶體使用狀況</td>
</tr>

<tr>
<td class="org-left">ps aux</td>
<td class="org-left">顯示進程清單</td>
</tr>

<tr>
<td class="org-left">kill</td>
<td class="org-left">終止進程 (kill -9 PID)</td>
</tr>
</tbody>
</table></li>
<li><p>
使用者與權限管理<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">whoami</td>
<td class="org-left">顯示當前使用者</td>
</tr>

<tr>
<td class="org-left">who</td>
<td class="org-left">顯示登入使用者</td>
</tr>

<tr>
<td class="org-left">id</td>
<td class="org-left">顯示用戶 UID、GID</td>
</tr>

<tr>
<td class="org-left">adduser</td>
<td class="org-left">新增使用者 (adduser user1)</td>
</tr>

<tr>
<td class="org-left">passwd</td>
<td class="org-left">變更密碼 (passwd user1)</td>
</tr>

<tr>
<td class="org-left">su</td>
<td class="org-left">切換使用者 (su - root)</td>
</tr>

<tr>
<td class="org-left">sudo</td>
<td class="org-left">以管理員身份執行指令 (sudo apt update)</td>
</tr>
</tbody>
</table></li>
<li><p>
程序與背景管理<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&amp;</td>
<td class="org-left">背景執行 (command &amp;)</td>
</tr>

<tr>
<td class="org-left">jobs</td>
<td class="org-left">列出背景工作</td>
</tr>

<tr>
<td class="org-left">fg</td>
<td class="org-left">恢復背景程序</td>
</tr>

<tr>
<td class="org-left">bg</td>
<td class="org-left">讓程序在背景執行</td>
</tr>

<tr>
<td class="org-left">nohup</td>
<td class="org-left">讓程序在登出後繼續執行 (nohup script.sh &amp;)</td>
</tr>
</tbody>
</table></li>
<li><p>
網路管理<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ifconfig / ip a</td>
<td class="org-left">顯示網路介面資訊</td>
</tr>

<tr>
<td class="org-left">ping</td>
<td class="org-left">測試網路連線 (ping 8.8.8.8)</td>
</tr>

<tr>
<td class="org-left">netstat</td>
<td class="org-left">顯示網路連線資訊</td>
</tr>

<tr>
<td class="org-left">curl / wget</td>
<td class="org-left">下載網頁或檔案 (curl -O <a href="http://example.com/file">http://example.com/file</a>)</td>
</tr>
</tbody>
</table></li>
<li><p>
軟體管理（Debian/Ubuntu）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">apt update</td>
<td class="org-left">更新軟體清單</td>
</tr>

<tr>
<td class="org-left">apt upgrade</td>
<td class="org-left">更新系統軟體</td>
</tr>

<tr>
<td class="org-left">apt install</td>
<td class="org-left">安裝軟體 (apt install vim)</td>
</tr>

<tr>
<td class="org-left">apt remove</td>
<td class="org-left">移除軟體 (apt remove nano)</td>
</tr>
</tbody>
</table></li>
<li><p>
壓縮與解壓縮<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">tar -cvf</td>
<td class="org-left">建立 tar 壓縮檔 (tar -cvf archive.tar folder)</td>
</tr>

<tr>
<td class="org-left">tar -xvf</td>
<td class="org-left">解壓 tar 檔 (tar -xvf archive.tar)</td>
</tr>

<tr>
<td class="org-left">gzip / gunzip</td>
<td class="org-left">壓縮/解壓 .gz 檔案</td>
</tr>

<tr>
<td class="org-left">zip / unzip</td>
<td class="org-left">壓縮/解壓 .zip 檔案</td>
</tr>
</tbody>
</table></li>
<li><p>
關機與重啟<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">指令</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">shutdown -h now</td>
<td class="org-left">立即關機</td>
</tr>

<tr>
<td class="org-left">reboot</td>
<td class="org-left">重新啟動</td>
</tr>

<tr>
<td class="org-left">shutdown -r +10</td>
<td class="org-left">10 分鐘後重新開機</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org16dd63d" class="outline-4">
<h4 id="org16dd63d"><span class="section-number-4">8.4.4.</span> 4.(8%)</h4>
<div class="outline-text-4" id="text-8-4-4">
<p>
將二進位小數 0.10101 轉換為十進位表示法。<br />
</p>
</div>
<div id="outline-container-orgf2e2a40" class="outline-5">
<h5 id="orgf2e2a40">解</h5>
<div class="outline-text-5" id="text-orgf2e2a40">
<ol class="org-ol">
<li>二進位小數的轉換方式與整數部分類似，只是權重是 負指數（即 \( 2 ^ {-n} \)）。<br />
\(0.b_1b_2b_3b_4b_5=b_1\times2^{-1}+b_2\times2^{-2}+b_3\times2^{-3}+b_4\times2^{-4}+b_5\times2^{-5} \)<br /></li>
<li>代入數值<br />
\(0.101012=(1\times2^{−1})+(0\times2^{−2})+(1\times2^{−3})+(0\times2^{−4})+(1\times2^{−5}) \)<br />
\( =\frac{1}{2} + \frac{0}{4} + \frac{1}{8} + \frac{0}{16} + \frac{1}{32} \)<br />
=0.5+0+0.125+0+0.03125<br />
=0.6562510​<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org190fa8b" class="outline-4">
<h4 id="org190fa8b"><span class="section-number-4">8.4.5.</span> 5.</h4>
<div class="outline-text-4" id="text-8-4-5">
<p>
Discuss the differences between an equi-join, natural join and outer join. (7%)<br />
</p>
</div>
<div id="outline-container-orgafddae6" class="outline-5">
<h5 id="orgafddae6">解</h5>
<div class="outline-text-5" id="text-orgafddae6">
<p>
qui-Join、Natural Join 與 Outer Join 的差異 在關聯式資料庫（RDBMS）中，JOIN 是用來將兩個或多個表格（tables）根據某些條件合併成一個結果集的操作。根據不同的合併條件，可以分為 Equi-Join（等值連接）、Natural Join（自然連接）、Outer Join（外連接） 等不同類型。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0b03fdd"></a>1. Equi-Join（等值連接）<br />
<div class="outline-text-6" id="text-org0b03fdd">
<ul class="org-ul">
<li>定義：<br />
<ul class="org-ul">
<li>Equi-Join 是 最基本的 JOIN，它使用 等號 (=) 來匹配兩個表格中的共同欄位。<br /></li>
<li>Equi-Join 需要 明確指定條件，並不會自動排除重複欄位。<br /></li>
</ul></li>
<li>SQL 語法：<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>SELECT A.*, B.*
<span class="linenr">2: </span>FROM TableA A
<span class="linenr">3: </span>JOIN TableB B
<span class="linenr">4: </span>ON A.<span style="color: #dcaeea;">common_column</span> = B.common_column;
</pre>
</div>
<ul class="org-ul">
<li>特點：<br />
<ul class="org-ul">
<li>只考慮 = 條件進行比對，不會主動排除重複欄位。<br /></li>
<li>結果集 包含來自兩個表格的所有欄位（包括重複欄位）。<br /></li>
<li><p>
可能使用 JOIN 或 WHERE 來實作：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>       SELECT A.*, B.*
<span class="linenr">2: </span>       FROM Employees A, Departments B
<span class="linenr">3: </span>       WHERE A.<span style="color: #dcaeea;">dept_id</span> = B.dept_id;
</pre>
</div></li>
</ul></li>
<li><p>
範例（匹配員工與其部門）：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>    SELECT Employees.name, Employees.dept_id, Departments.dept_name
<span class="linenr">2: </span>    FROM Employees
<span class="linenr">3: </span>    JOIN Departments
<span class="linenr">4: </span>    ON Employees.<span style="color: #dcaeea;">dept_id</span> = Departments.dept_id;
</pre>
</div></li>
<li>適用場景：<br />
<ul class="org-ul">
<li>需要保留所有欄位，且表格之間的匹配條件為 =。<br /></li>
<li>一般情況下，Equi-Join 是 JOIN 操作的基礎。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org98e49dd"></a>2. Natural Join（自然連接）<br />
<div class="outline-text-6" id="text-org98e49dd">
<ul class="org-ul">
<li>定義：Natural Join 是 Equi-Join 的變種，它會 自動尋找兩個表格中欄位名稱相同的欄位來進行匹配，並且 不會顯示重複欄位。<br /></li>
<li><p>
SQL 語法：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>  SELECT *
<span class="linenr">2: </span>  FROM TableA
<span class="linenr">3: </span>  NATURAL JOIN TableB;
</pre>
</div></li>
<li>特點：<br />
<ul class="org-ul">
<li>不需要明確指定條件，系統會自動比對相同名稱的欄位進行 JOIN。<br /></li>
<li>結果集 不包含重複的共同欄位。<br /></li>
</ul></li>
<li><p>
範例（匹配員工與其部門，假設 dept_id 存在於兩個表中）：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>  SELECT *
<span class="linenr">2: </span>  FROM Employees
<span class="linenr">3: </span>  NATURAL JOIN Departments;
</pre>
</div></li>
<li>適用場景：<br />
<ul class="org-ul">
<li>兩個表格中有相同名稱的欄位，且需要消除重複欄位。<br /></li>
<li>但是，如果表格中沒有相同欄位，則會導致錯誤，因此使用時需要特別小心。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org065262b"></a>3. Outer Join（外連接）<br />
<div class="outline-text-6" id="text-org065262b">
<ul class="org-ul">
<li>定義：<br />
<ul class="org-ul">
<li>Outer Join 用於保留 沒有匹配到的資料，即使某個表格中沒有對應的資料，也會填充 NULL 顯示。<br /></li>
<li>Outer Join 可分為：<br />
<ul class="org-ul">
<li>Left Outer Join（左外連接）：保留左表的所有資料，右表沒有匹配的則補 NULL。<br /></li>
<li>Right Outer Join（右外連接）：保留右表的所有資料，左表沒有匹配的則補 NULL。<br /></li>
<li>Full Outer Join（全外連接）：保留兩個表格的所有資料，沒有匹配的地方則補 NULL。<br /></li>
</ul></li>
</ul></li>
<li>SQL 語法：<br />
<ul class="org-ul">
<li><p>
左外連接（LEFT JOIN）：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>    SELECT A.*, B.*
<span class="linenr">2: </span>    FROM TableA A
<span class="linenr">3: </span>    LEFT JOIN TableB B
<span class="linenr">4: </span>    ON A.<span style="color: #dcaeea;">common_column</span> = B.common_column;
</pre>
</div></li>
<li><p>
右外連接（RIGHT JOIN）：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>    SELECT A.*, B.*
<span class="linenr">2: </span>    FROM TableA A
<span class="linenr">3: </span>    RIGHT JOIN TableB B
<span class="linenr">4: </span>    ON A.<span style="color: #dcaeea;">common_column</span> = B.common_column;
</pre>
</div></li>
<li><p>
全外連接（FULL JOIN）：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>    SELECT A.*, B.*
<span class="linenr">2: </span>    FROM TableA A
<span class="linenr">3: </span>    FULL JOIN TableB B
<span class="linenr">4: </span>    ON A.<span style="color: #dcaeea;">common_column</span> = B.common_column;
</pre>
</div></li>
</ul></li>
<li><p>
範例（找出所有員工，即使他們沒有被分配到部門）：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>      SELECT Employees.name, Employees.dept_id, Departments.dept_name
<span class="linenr">2: </span>      FROM Employees
<span class="linenr">3: </span>      LEFT JOIN Departments
<span class="linenr">4: </span>      ON Employees.<span style="color: #dcaeea;">dept_id</span> = Departments.dept_id;
</pre>
</div>
<p>
如果某個員工沒有 dept_id，則 dept_name 為 NULL。<br />
</p></li>
<li>適用場景：<br />
<ul class="org-ul">
<li>Left Join：保留所有主要表的資料，即使沒有匹配到。<br /></li>
<li>Right Join：保留所有次要表的資料，即使沒有匹配到。<br /></li>
<li>Full Join：確保兩個表格的所有資料都能被保留，即使沒有對應關聯。<br /></li>
</ul></li>
</ul>

<p>
Equi-Join、Natural Join 與 Outer Join 的比較<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Join 類型</th>
<th scope="col" class="org-left">匹配方式</th>
<th scope="col" class="org-left">重複欄位</th>
<th scope="col" class="org-left">保留未匹配資料</th>
<th scope="col" class="org-left">適用場景</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Equi-Join</td>
<td class="org-left">使用 = 來匹配兩表共同欄位</td>
<td class="org-left">保留</td>
<td class="org-left">否</td>
<td class="org-left">需要完整匹配</td>
</tr>

<tr>
<td class="org-left">Natural Join</td>
<td class="org-left">自動尋找相同名稱欄位進行匹配</td>
<td class="org-left">移除</td>
<td class="org-left">否</td>
<td class="org-left">相同名稱欄位的表格匹配</td>
</tr>

<tr>
<td class="org-left">Left Outer Join</td>
<td class="org-left">= 匹配，未匹配的左表數據補 NULL</td>
<td class="org-left">保留</td>
<td class="org-left">是（左表）</td>
<td class="org-left">保留主要表（左表）數據</td>
</tr>

<tr>
<td class="org-left">Right Outer Join</td>
<td class="org-left">= 匹配，未匹配的右表數據補 NULL</td>
<td class="org-left">保留</td>
<td class="org-left">是（右表）</td>
<td class="org-left">保留次要表（右表）數據</td>
</tr>

<tr>
<td class="org-left">Full Outer Join</td>
<td class="org-left">= 匹配，雙方未匹配數據補 NULL</td>
<td class="org-left">保留</td>
<td class="org-left">是（左右皆保留）</td>
<td class="org-left">確保所有數據都顯示</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8e53f6a" class="outline-5">
<h5 id="org8e53f6a">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-org8e53f6a">
<p>
為了完整理解 JOIN 的概念，考生應熟悉以下計算機概論知識：<br />
</p>
<ul class="org-ul">
<li>關聯式資料庫（Relational Database, RDBMS）<br />
<ul class="org-ul">
<li>表格（Table）、欄位（Column）、列（Row）<br /></li>
<li>主鍵（Primary Key, PK）、外鍵（Foreign Key, FK）<br /></li>
<li>SQL（結構化查詢語言）<br /></li>
</ul></li>
<li>SQL 查詢語法<br />
<ul class="org-ul">
<li>SELECT 基本語法<br /></li>
<li>WHERE 條件過濾<br /></li>
<li>GROUP BY 聚合查詢<br /></li>
<li>ORDER BY 排序<br /></li>
</ul></li>
<li>索引（Index）與效能最佳化<br />
<ul class="org-ul">
<li>JOIN 操作可能影響資料庫效能，因此了解 索引（Index） 如何影響查詢效率很重要。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbafef19" class="outline-4">
<h4 id="orgbafef19"><span class="section-number-4">8.4.6.</span> 6.</h4>
<div class="outline-text-4" id="text-8-4-6">
<p>
In relational model, what is an anomaly and what are the three types of anomalies? (8%)<br />
</p>
</div>
<div id="outline-container-org9d3df1d" class="outline-5">
<h5 id="org9d3df1d">解</h5>
<div class="outline-text-5" id="text-org9d3df1d">
</div>
<ul class="org-ul">
<li><a id="orgab5abcf"></a>關聯式資料模型中的異常（Anomalies）<br />
<div class="outline-text-6" id="text-orgab5abcf">
<ul class="org-ul">
<li>定義： 在 關聯式資料庫（Relational Database） 設計中，如果資料表的正規化（Normalization）不足，可能會導致 異常（Anomalies），使得插入、刪除或更新資料時產生 不一致性（Inconsistency），影響資料完整性（Data Integrity）。<br /></li>
<li>主要的三種異常：<br />
<ol class="org-ol">
<li>插入異常（Insertion Anomaly）<br /></li>
<li>刪除異常（Deletion Anomaly）<br /></li>
<li>更新異常（Update Anomaly）<br /></li>
</ol></li>
</ul>
</div>
</li>
<li><a id="orgf355da0"></a>(1) 插入異常（Insertion Anomaly）<br />
<div class="outline-text-6" id="text-orgf355da0">
<ul class="org-ul">
<li>定義：<br />
<ul class="org-ul">
<li>當新的資料無法插入資料庫，或是插入時需要填入多餘或不必要的資料，則稱為 插入異常。<br /></li>
<li>主要發生在 非正規化的表格，因為同一張表可能同時存放多種不同的資訊，導致無法直接插入部分資料。<br /></li>
</ul></li>
<li><p>
範例： 假設有一個「學生選課」表：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">學生編號</th>
<th scope="col" class="org-left">學生姓名</th>
<th scope="col" class="org-left">課程編號</th>
<th scope="col" class="org-left">課程名稱</th>
<th scope="col" class="org-left">教授</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">S001</td>
<td class="org-left">小明</td>
<td class="org-left">C101</td>
<td class="org-left">資料庫系統</td>
<td class="org-left">張教授</td>
</tr>

<tr>
<td class="org-left">S002</td>
<td class="org-left">小華</td>
<td class="org-left">C102</td>
<td class="org-left">作業系統</td>
<td class="org-left">王教授</td>
</tr>
</tbody>
</table></li>
<li>問題：<br />
<ul class="org-ul">
<li>假設學校要新增一門新課程 「人工智慧 C103」，但還沒有任何學生選修。<br /></li>
<li>由於 學生編號 為主鍵的一部分，我們無法在 學生選課 表中單獨插入該課程的資訊（因為沒有對應的學生資料）。<br /></li>
<li>這就是 插入異常。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org222cf63"></a>(2) 刪除異常（Deletion Anomaly）<br />
<div class="outline-text-6" id="text-org222cf63">
<ul class="org-ul">
<li>定義：<br />
<ul class="org-ul">
<li>當刪除某筆資料時，會導致其他重要資料 意外被刪除，則稱為 刪除異常。<br /></li>
<li>主要發生在 未正規化的表格，因為表格內存放多種資訊，刪除一條記錄時可能會影響其他無關資訊。<br /></li>
</ul></li>
<li><p>
範例： 仍然使用 「學生選課」表，若某位學生退選所有課程：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">學生編號</th>
<th scope="col" class="org-left">學生姓名</th>
<th scope="col" class="org-left">課程編號</th>
<th scope="col" class="org-left">課程名稱</th>
<th scope="col" class="org-left">教授</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">S001</td>
<td class="org-left">小明</td>
<td class="org-left">C101</td>
<td class="org-left">資料庫系統</td>
<td class="org-left">張教授</td>
</tr>

<tr>
<td class="org-left">S002</td>
<td class="org-left">小華</td>
<td class="org-left">C102</td>
<td class="org-left">作業系統</td>
<td class="org-left">王教授</td>
</tr>
</tbody>
</table></li>
<li>問題：<br />
<ul class="org-ul">
<li>如果 S001（小明）退選所有課程，則刪除該學生的資料時，連同課程資訊也會被刪除（因為課程資訊與學生資訊存放在同一個表中）。<br /></li>
<li>若 C101 這門課只有 S001 選修，那麼當 S001 退選後，這門課的記錄也會 被完全刪除，導致該課程資料遺失。<br />
這就是 刪除異常。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org553d845"></a>(3) 更新異常（Update Anomaly）<br />
<div class="outline-text-6" id="text-org553d845">
<ul class="org-ul">
<li>定義：<br />
<ul class="org-ul">
<li>當同一份資料存在多個重複的記錄，而更新其中一條時，可能導致其他記錄未同步更新，造成資料不一致性（Inconsistency），這稱為 更新異常。<br /></li>
<li>主要發生在 冗餘資料過多的表格。<br /></li>
</ul></li>
<li><p>
範例： 仍然使用 「學生選課」表，假設 「張教授」 改名為 「李教授」：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">學生編號</th>
<th scope="col" class="org-left">學生姓名</th>
<th scope="col" class="org-left">課程編號</th>
<th scope="col" class="org-left">課程名稱</th>
<th scope="col" class="org-left">教授</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">S001</td>
<td class="org-left">小明</td>
<td class="org-left">C101</td>
<td class="org-left">資料庫系統</td>
<td class="org-left">張教授</td>
</tr>

<tr>
<td class="org-left">S002</td>
<td class="org-left">小華</td>
<td class="org-left">C101</td>
<td class="org-left">資料庫系統</td>
<td class="org-left">張教授</td>
</tr>
</tbody>
</table></li>
<li>問題：<br />
<ul class="org-ul">
<li>C101 這門課程由 「張教授」 授課。<br /></li>
<li>如果 C101 在表格中出現多次，而 只更新其中一條記錄，那麼該教授的姓名在某些記錄中仍然是舊的名字（張教授）。<br /></li>
<li>這樣會造成 資料不一致，導致 更新異常。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org22fe0c7"></a>如何避免異常？（正規化 - Normalization）<br />
<div class="outline-text-6" id="text-org22fe0c7">
<p>
為了解決這些異常問題，資料庫設計應遵循 正規化（Normalization），主要透過 分解表格、建立關聯 來消除冗餘並保持數據一致性。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org689a42a"></a>解法：<br />
<div class="outline-text-7" id="text-org689a42a">
<p>
將「學生選課」表分解成以下三個表：<br />
</p>
<ul class="org-ul">
<li>學生表（Students）<br /></li>
<li>課程表（Courses）<br /></li>
<li>學生選課表（Enrollment）<br /></li>
</ul>
</div>
</li>
<li><a id="org04e743f"></a>表格設計<br />
<div class="outline-text-7" id="text-org04e743f">
<ul class="org-ul">
<li><p>
Students（學生表）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">學生編號</td>
<td class="org-left">學生姓名</td>
</tr>

<tr>
<td class="org-left">S001</td>
<td class="org-left">小明</td>
</tr>

<tr>
<td class="org-left">S002</td>
<td class="org-left">小華</td>
</tr>
</tbody>
</table></li>
<li><p>
Courses（課程表）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">課程編號</td>
<td class="org-left">課程名稱</td>
<td class="org-left">教授</td>
</tr>

<tr>
<td class="org-left">C101</td>
<td class="org-left">資料庫系統</td>
<td class="org-left">張教授</td>
</tr>

<tr>
<td class="org-left">C102</td>
<td class="org-left">作業系統</td>
<td class="org-left">王教授</td>
</tr>
</tbody>
</table></li>
<li><p>
Enrollment（選課表）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">學生編號</td>
<td class="org-left">課程編號</td>
</tr>

<tr>
<td class="org-left">S001</td>
<td class="org-left">C101</td>
</tr>

<tr>
<td class="org-left">S002</td>
<td class="org-left">C102</td>
</tr>
</tbody>
</table></li>
</ul>
<p>
這樣的設計能夠解決 插入、刪除、更新異常：<br />
</p>
<ul class="org-ul">
<li>插入新課程時，只需在 Courses 表中新增記錄，不受學生影響。<br /></li>
<li>刪除學生時，不會影響 Courses 的完整性。<br /></li>
<li>更新教授姓名時，只需修改 Courses 表中的一筆記錄。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgfc9569e" class="outline-5">
<h5 id="orgfc9569e">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-orgfc9569e">
<ol class="org-ol">
<li>關聯式資料庫（Relational Database, RDBMS）<br />
<ul class="org-ul">
<li>表（Table）、列（Row）、欄位（Column）。<br /></li>
<li>主鍵（Primary Key, PK）、外鍵（Foreign Key, FK）。<br /></li>
<li>參考完整性（Referential Integrity）。<br /></li>
</ul></li>
<li>資料庫正規化（Normalization）<br />
<ul class="org-ul">
<li>第一正規化（1NF）：消除重複欄位，確保每一個欄位只包含單一值。<br /></li>
<li>第二正規化（2NF）：確保非主鍵欄位完全依賴主鍵，避免部分依賴（Partial Dependency）。<br /></li>
<li>第三正規化（3NF）：確保非主鍵欄位不依賴於其他非主鍵欄位（消除遞移依賴 Transitive Dependency）。<br /></li>
</ul></li>
<li>SQL 操作<br />
<ul class="org-ul">
<li>CREATE TABLE 建立表格。<br /></li>
<li>INSERT INTO 插入資料。<br /></li>
<li>UPDATE 修改資料，避免更新異常。<br /></li>
<li>DELETE 刪除資料，避免刪除異常。<br /></li>
<li>JOIN 進行表格關聯查詢。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org0379733" class="outline-5">
<h5 id="org0379733">結論</h5>
<div class="outline-text-5" id="text-org0379733">
<ul class="org-ul">
<li>異常（Anomalies） 是關聯式資料庫未經正規化時產生的問題。<br /></li>
<li>三種異常：<br />
<ul class="org-ul">
<li>插入異常（Insertion Anomaly）：無法插入獨立資訊。<br /></li>
<li>刪除異常（Deletion Anomaly）：刪除一筆資料會影響其他無關資訊。<br /></li>
<li>更新異常（Update Anomaly）：重複資料導致更新困難，數據不一致。<br /></li>
</ul></li>
<li>解決方案：<br />
<ul class="org-ul">
<li>正規化（Normalization），分解表格，消除冗餘，提高資料完整性與一致性。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0750ef2" class="outline-4">
<h4 id="org0750ef2"><span class="section-number-4">8.4.7.</span> 7.</h4>
<div class="outline-text-4" id="text-8-4-7">
<p>
Discuss the advantages and disadvantages of database partitioning. (10%)<br />
</p>
</div>
<div id="outline-container-org4cab6c1" class="outline-5">
<h5 id="org4cab6c1">解</h5>
<div class="outline-text-5" id="text-org4cab6c1">
<ol class="org-ol">
<li>定義<br />
<ul class="org-ul">
<li>資料庫分割（Database Partitioning） 是將一個大型的資料表拆分為 多個較小的分區（Partitions），使資料可以 分佈儲存於不同的伺服器、磁碟或資料庫節點，以提高查詢效能、擴展性及管理彈性。<br /></li>
<li>分割方式主要有：<br />
<ul class="org-ul">
<li>水平方向分割（Horizontal Partitioning）：根據某些條件（如 id、日期）將不同範圍的資料存入不同的分區。<br /></li>
<li>垂直方向分割（Vertical Partitioning）：將表格的不同欄位拆分成不同的表，例如將頻繁存取的欄位與較少使用的欄位分開。<br /></li>
</ul></li>
</ul></li>
<li>優勢（Advantages）<br />
<ul class="org-ul">
<li>(1) 提高查詢效能<br />
<ul class="org-ul">
<li>只需查詢 部分分區 而非整張資料表，減少 I/O 開銷。<br /></li>
<li>例如，若查詢的是最近一年的交易紀錄，則只需掃描該年份的分區，而不是掃描整個交易表（比對所有年份）。<br /></li>
</ul></li>
<li>(2) 提升可擴展性（Scalability）<br />
<ul class="org-ul">
<li>當資料量不斷增長時，可以 動態新增分區，不需要重新設計整個資料庫。<br /></li>
<li>適用於 大數據應用，如電商、社交平台等。<br /></li>
</ul></li>
<li>(3) 增強並行處理能力<br />
<ul class="org-ul">
<li>不同的分區可以 分散到多個節點，允許不同的使用者同時存取不同的分區，降低鎖定（Locking）衝突。<br /></li>
<li>適用於 高併發的 OLTP（Online Transaction Processing）應用。<br /></li>
</ul></li>
<li>(4) 簡化資料管理與維護<br />
<ul class="org-ul">
<li>可以單獨 備份、恢復、壓縮 某個分區，而無需影響整個資料表。<br /></li>
<li>例如，歷史資料可以存入冷存儲（Cold Storage），而當前活躍資料則存於高速 SSD，提升效能並降低成本。<br /></li>
</ul></li>
<li>(5) 增強可用性與容錯能力<br />
<ul class="org-ul">
<li>在 分散式系統（Distributed Systems） 中，若某個分區的節點故障，其他分區仍然可以正常運作，提高系統的可用性（Availability）。<br /></li>
<li>適用於 NoSQL、雲端資料庫（如 Google BigQuery, Amazon Redshift）。<br /></li>
</ul></li>
</ul></li>
<li>劣勢（Disadvantages）<br />
<ul class="org-ul">
<li>(1) 增加管理與維護成本<br />
<ul class="org-ul">
<li>分區策略需要精心設計，否則可能導致某些分區 負載不均衡。<br /></li>
<li>若應用需求變更，可能需要重新設計分區規則。<br /></li>
</ul></li>
<li>(2) 交叉分區查詢（跨分區查詢）效能下降<br />
<ul class="org-ul">
<li>若查詢涉及多個分區，則可能會 降低查詢效能，因為資料庫需要在多個分區執行合併操作（Union、Join）。<br /></li>
<li>例如，若 2023 年的交易紀錄存放在 Partition_2023，但使用者查詢 2022~2023 期間的交易，則會導致 多個分區的數據合併，增加運算成本。<br /></li>
</ul></li>
<li>(3) 可能影響索引效能<br />
<ul class="org-ul">
<li>若某些查詢模式頻繁跨分區運行，則可能需要在多個分區中維護 多個索引，造成額外的儲存與維護成本。<br /></li>
<li>部分資料庫（如 MySQL）不支援跨分區的索引，導致某些查詢效能下降。<br /></li>
</ul></li>
<li>(4) 移動或合併分區成本高<br />
<ul class="org-ul">
<li>若分區策略變更，例如從 基於 id 分區改為基於 日期 分區，則可能需要進行大規模的資料搬移，導致系統性能下降。<br /></li>
<li>例如，若某分區的負載過重，則可能需要重新劃分分區，增加資料搬移的 I/O 負擔。<br /></li>
</ul></li>
<li>(5) 需要應用程式配合<br />
<ul class="org-ul">
<li>若應用程式開發人員不了解分區邏輯，則可能寫出 低效能 SQL 查詢，影響系統運行。<br /></li>
<li>例如，在不支援 JOIN 的分散式 NoSQL 資料庫（如 MongoDB, Cassandra）中，開發人員需要手動組合查詢結果，增加開發成本。<br /></li>
</ul></li>
</ul></li>
<li><p>
分割策略<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">分割類型</td>
<td class="org-left">說明</td>
<td class="org-left">適用場景</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">水平分割（Horizontal Partitioning）</td>
<td class="org-left">根據資料列（Row）進行拆分</td>
<td class="org-left">當數據量很大但查詢範圍明確，例如按 時間（日期）</td>
<td class="org-left">、地區、客戶 劃分</td>
</tr>

<tr>
<td class="org-left">垂直分割（Vertical Partitioning）</td>
<td class="org-left">根據欄位（Column）拆分</td>
<td class="org-left">適用於頻繁存取的欄位與不常用的欄位分開存儲，例如</td>
<td class="org-left">會員基本資料 vs 購買記錄</td>
</tr>

<tr>
<td class="org-left">範圍分割（Range Partitioning）</td>
<td class="org-left">根據某個範圍來劃分</td>
<td class="org-left">日期區間（例如 2022 vs 2023 資料）</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">清單分割（List Partitioning）</td>
<td class="org-left">根據特定的類別來劃分</td>
<td class="org-left">不同的地區、類別，如「北美」、「歐洲」</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">哈希分割（Hash Partitioning）</td>
<td class="org-left">透過雜湊函數（Hash Function）均勻分布資料</td>
<td class="org-left">負載均衡（Load Balancing）</td>
</tr>
</tbody>
</table></li>
<li><p>
結論<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">優勢</th>
<th scope="col" class="org-left">劣勢</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">提高查詢效能 - 減少掃描數據量</td>
<td class="org-left">增加維護成本 - 需要良好的規劃</td>
</tr>

<tr>
<td class="org-left">提升擴展性 - 可動態新增分區</td>
<td class="org-left">跨分區查詢效能下降</td>
</tr>

<tr>
<td class="org-left">增強並行處理能力 - 適用高併發系統</td>
<td class="org-left">可能影響索引效能</td>
</tr>

<tr>
<td class="org-left">簡化資料管理 - 可獨立備份/恢復分區</td>
<td class="org-left">資料搬移成本高</td>
</tr>

<tr>
<td class="org-left">提高可用性與容錯能力</td>
<td class="org-left">應用程式需要適應分區架構</td>
</tr>
</tbody>
</table>
<p>
資料庫分割適用於大型資料庫、高併發應用與分散式系統，但設計不當可能導致效能問題。考生應熟悉各種分割策略及其優缺點，並理解如何在不同情境下應用分區技術。<br />
</p></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org50eef9b" class="outline-4">
<h4 id="org50eef9b"><span class="section-number-4">8.4.8.</span> 8.</h4>
<div class="outline-text-4" id="text-8-4-8">
<p>
TCP 和 UDP 是重要的傳輸層協定，請回答下列兩個問題： (a) 請說明 TCP 和 UDP 特性上的不同。(5%) (b) 請先說明 TCP 上滑動視窗(sliding window)的設計目的，然後詳細說明滑動視窗的工作原理。(10%)<br />
</p>
</div>
<div id="outline-container-org342e626" class="outline-5">
<h5 id="org342e626">解</h5>
<div class="outline-text-5" id="text-org342e626">
</div>
<ul class="org-ul">
<li><a id="orgf367053"></a>(a)<br />
<div class="outline-text-6" id="text-orgf367053">
<p>
TCP（Transmission Control Protocol，傳輸控制協定）和 UDP（User Datagram Protocol，用戶資料報協定）是 傳輸層 的兩大主要通訊協定，適用於不同應用場景。以下是兩者的主要差異：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">TCP</th>
<th scope="col" class="org-left">UDP</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">連線導向（Connection-oriented）</td>
<td class="org-left">是，TCP 需要建立 連線（例如三次握手）</td>
<td class="org-left">否，UDP 是 無連線 協定</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">可靠性（Reliability）</td>
<td class="org-left">可靠，確保數據正確無誤到達</td>
<td class="org-left">不可靠，數據可能丟失、重複或順序錯誤</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">流量控制（Flow Control）</td>
<td class="org-left">有，使用滑動視窗（Sliding Window）來控制數據流量</td>
<td class="org-left">無，發送端不關心接收端是否能處理</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">擁塞控制（Congestion Control）</td>
<td class="org-left">有，會依據網路狀況動態調整傳輸速率</td>
<td class="org-left">無，發送端不會主動調整速率</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">數據排序（Ordering）</td>
<td class="org-left">有，TCP 會確保數據按序抵達</td>
<td class="org-left">無，接收端可能收到亂序數據</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">傳輸方式</td>
<td class="org-left">面向 連接流（Stream-oriented），數據像水流一樣被連續傳輸</td>
<td class="org-left">面向 資料報（Datagram-oriented），每個封</td>
<td class="org-left">包獨立發送</td>
</tr>

<tr>
<td class="org-left">應用場景</td>
<td class="org-left">適用於可靠傳輸，如 HTTP、FTP、Email</td>
<td class="org-left">適用於即時通訊，如 VoIP、視訊串流、DNS</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org235abbb"></a>(b) TCP 滑動視窗（Sliding Window）機制 (10%)<br />
<ul class="org-ul">
<li><a id="org0c1e206"></a>(1) 滑動視窗的設計目的<br />
<div class="outline-text-8" id="text-org0c1e206">
<p>
滑動視窗是 TCP 協定 中的一種 流量控制（Flow Control） 機制，其設計目的為：<br />
</p>
<ul class="org-ul">
<li>提高資料傳輸效率：允許發送端在等待確認（ACK）時繼續發送部分數據，而不是每發一個封包就等待確認。<br /></li>
<li>防止數據過載：防止發送端傳輸過多數據，超出接收端的緩衝區（Buffer）能力。<br /></li>
<li>減少網路擁塞：當網路擁塞時，發送端可以適當減少傳輸速率，以減輕網路負擔。<br /></li>
</ul>
</div>
</li>
<li><a id="org43d8508"></a>(2) 滑動視窗的工作原理<br />
<div class="outline-text-8" id="text-org43d8508">
<p>
滑動視窗機制允許發送端同時發送多個封包，而不需要逐一等待 ACK 確認，這樣可以 提高吞吐量。其主要概念如下：<br />
</p>
<ul class="org-ul">
<li>📌 1. 視窗大小（Window Size）<br />
<ul class="org-ul">
<li>發送視窗（Send Window）：發送端可以在未收到 ACK 的情況下 連續發送的最大數據量，由 TCP 接收端的 接收視窗（Receive Window） 決定。<br /></li>
<li>接收視窗（Receive Window）：接收端可以 一次接受的最大數據量，由接收端的緩衝區大小決定。<br /></li>
<li>通告視窗（Advertised Window）：接收端會定期通告其可用的緩衝區大小，發送端根據此值調整傳輸速率。<br /></li>
</ul></li>
<li>📌 2. 視窗的滑動機制<br />
當發送端傳送數據後，視窗會根據 ACK 向前滑動：<br />
<ul class="org-ul">
<li>發送端 將數據發送出去，但還未收到 ACK。<br /></li>
<li>當接收端確認收到數據後，會回傳 ACK，表示該數據已被接收並可釋放緩衝區。<br /></li>
<li>發送端收到 ACK 向前滑動視窗，釋放舊數據範圍，允許發送新的數據。<br /></li>
</ul></li>
<li><p>
📌 3. 滑動視窗的運作示意圖<br />
假設發送端允許的視窗大小為 4，數據包編號從 1 開始：<br />
</p>
<pre class="example" id="org37ed24a">
  [ 已確認 | 傳輸中 | 可發送 | 未允許 ]
    ←ACK1  ←2  3  4  5  → 未發送
</pre>
<ul class="org-ul">
<li><p>
若接收端收到 ACK 2，則視窗向前滑動：<br />
</p>
<pre class="example" id="org9bf2efd">
    [ 已確認 | 傳輸中 | 可發送 | 未允許 ]
      ←ACK2  ←3  4  5  6  → 未發送
</pre></li>
</ul></li>
</ul>
<p>
如此一來，發送端可以不必等候個別封包的 ACK，而是根據 滑動視窗機制 批次處理 傳輸。<br />
</p>
</div>
</li>
<li><a id="org5c28a9f"></a>(3) 滑動視窗的主要策略<br />
<div class="outline-text-8" id="text-org5c28a9f">
<ul class="org-ul">
<li>📌 1. 停等協議（Stop-and-Wait）<br />
<ul class="org-ul">
<li>每次發送 一個封包，等待 ACK 才能發送下一個。<br /></li>
<li>適用小型數據傳輸，但傳輸效率低。<br /></li>
</ul></li>
<li>📌 2. 回饋式視窗協議（Go-Back-N）<br />
<ul class="org-ul">
<li>允許發送多個封包，但若發生丟失，則會 重傳該封包後的所有數據。<br /></li>
<li>適用高頻寬網路，但可能造成較多重傳。<br /></li>
</ul></li>
<li>📌 3. 選擇性重傳（Selective Repeat, SR）<br />
<ul class="org-ul">
<li>允許發送多個封包，若發生丟失，只會重傳 丟失的封包，不影響其他數據。<br /></li>
<li>適用高吞吐量的應用場景，如視訊串流。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org5b5de6c"></a>(4) 滑動視窗的優勢<br />
<div class="outline-text-8" id="text-org5b5de6c">
<ul class="org-ul">
<li>✅ 提高傳輸效率：允許發送端持續發送數據，而不是每次發送都要等待 ACK。<br /></li>
<li>✅ 降低延遲：特別是在高延遲網路中（如衛星通信），可以顯著提升性能。<br /></li>
<li>✅ 減少封包丟失影響：如果發生數據丟失，特別是 選擇性重傳機制，只需要重傳特定封包，而不需要重傳所有數據。<br /></li>
</ul>
</div>
</li>
<li><a id="org566f5bd"></a>(5) 滑動視窗的缺點<br />
<div class="outline-text-8" id="text-org566f5bd">
<ul class="org-ul">
<li>❌ 需要額外的緩衝區：發送端與接收端都需要維護緩衝區，特別是高吞吐量應用，會消耗大量記憶體。<br /></li>
<li>❌ 複雜性提高：相較於 UDP，TCP 需要額外的 流量控制、擁塞控制、錯誤處理，導致系統設計較複雜。<br /></li>
<li>❌ 可能發生壅塞（Congestion）：若網路壅塞時，視窗大小可能會縮小，導致 TCP 速率降低，影響整體效能。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org32cbc97" class="outline-4">
<h4 id="org32cbc97"><span class="section-number-4">8.4.9.</span> 9.</h4>
<div class="outline-text-4" id="text-8-4-9">
<p>
請詳細說明 SQL Injection 攻擊原理。(10%)<br />
</p>
</div>
<div id="outline-container-orgf5ccdb2" class="outline-5">
<h5 id="orgf5ccdb2">解</h5>
<div class="outline-text-5" id="text-orgf5ccdb2">
</div>
<ul class="org-ul">
<li><a id="org47af3a3"></a>1. SQL Injection 攻擊原理<br />
<div class="outline-text-6" id="text-org47af3a3">
<p>
SQL Injection（SQL 注入攻擊） 是一種 代碼注入（Code Injection） 攻擊，攻擊者利用應用程式中 對 SQL 語句處理不當 的漏洞，在輸入欄位 插入惡意 SQL 語句，導致資料庫執行未預期的指令，可能造成：<br />
</p>
<ul class="org-ul">
<li>竊取資料（Data Theft）：讀取資料庫中的機密資訊（如帳號、密碼）。<br /></li>
<li>修改資料（Data Manipulation）：篡改、刪除或插入不合法的資料。<br /></li>
<li>繞過身份驗證（Authentication Bypass）：透過 SQL 語句操控登入機制，使攻擊者可登入受害者帳號。<br /></li>
<li>控制資料庫伺服器（Database Takeover）：利用 SQL 語句執行系統命令，取得伺服器權限。<br /></li>
</ul>
</div>
</li>
<li><a id="orgecc468f"></a>2. SQL Injection 攻擊範例<br />
<ul class="org-ul">
<li><a id="org19eec44"></a>(1) 基本 SQL Injection<br />
<div class="outline-text-7" id="text-org19eec44">
<p>
假設網站有一個 使用者登入功能，驗證 SQL 如下：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>SELECT * FROM users WHERE <span style="color: #dcaeea;">username</span> = <span style="color: #98be65;">'admin'</span> AND <span style="color: #dcaeea;">password</span> = <span style="color: #98be65;">'12345'</span>;
</pre>
</div>
<p>
攻擊者在 username 欄位輸入：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #83898d;">' OR '</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #83898d;">'='</span><span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>
<p>
導致 SQL 語句變為：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>SELECT * FROM users WHERE <span style="color: #dcaeea;">username</span> = <span style="color: #98be65;">''</span> OR <span style="color: #98be65;">'1'</span>=<span style="color: #98be65;">'1'</span> AND <span style="color: #dcaeea;">password</span> = <span style="color: #98be65;">'xxx'</span>;
</pre>
</div>
<p>
由於 &rsquo;1&rsquo;=&rsquo;1&rsquo; 恆為真，這段查詢將會 繞過密碼檢查，允許攻擊者登入 任意帳號。<br />
</p>
</div>
</li>
<li><a id="orgcf90879"></a>(2) 延伸攻擊 - 查詢資料庫結構<br />
<div class="outline-text-7" id="text-orgcf90879">
<p>
攻擊者可能利用 UNION SELECT 來竊取資料：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #83898d;">' UNION SELECT username, password FROM users --</span>
</pre>
</div>
<p>
若應用程式未適當檢查輸入，這將回傳整個 users 表的帳號密碼資訊。<br />
</p>
</div>
</li>
<li><a id="org9d4ec48"></a>(3) 延伸攻擊 - 刪除資料<br />
<div class="outline-text-7" id="text-org9d4ec48">
<p>
攻擊者可能會執行破壞性指令，例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #83898d;">'; DROP TABLE users; --</span>
</pre>
</div>
<p>
若應用程式未正確處理輸入，資料庫可能執行：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>SELECT * FROM users WHERE <span style="color: #dcaeea;">username</span> = <span style="color: #98be65;">''</span>; DROP TABLE users; --<span style="color: #98be65;">'</span>
</pre>
</div>
<p>
這將導致 users 表 被刪除，造成嚴重影響。<br />
</p>
</div>
</li>
<li><a id="org43a03a4"></a>(4) 延伸攻擊 - 執行系統命令<br />
<div class="outline-text-7" id="text-org43a03a4">
<p>
某些資料庫（如 MySQL、SQL Server）允許執行系統指令，攻擊者可利用：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #83898d;">'; EXEC xp_cmdshell('</span>whoami<span style="color: #83898d;">'); --</span>
</pre>
</div>
<p>
這可能讓攻擊者獲得 伺服器管理權限，進一步入侵整個系統。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgd5a48fc"></a>3. SQL Injection 的種類<br />
<div class="outline-text-6" id="text-orgd5a48fc">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">攻擊類型</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">影響</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">一般 SQL Injection</td>
<td class="org-left">插入惡意 SQL 語句，篡改 SQL 指令</td>
<td class="org-left">竊取或修改資料</td>
</tr>

<tr>
<td class="org-left">盲目 SQL Injection（Blind SQL Injection）</td>
<td class="org-left">伺服器不回應錯誤訊息，攻擊者透過時間延遲或邏輯測試獲取資訊</td>
<td class="org-left">逐步推測資料庫內容</td>
</tr>

<tr>
<td class="org-left">基於時間的 SQL Injection（Time-Based SQL Injection）</td>
<td class="org-left">透過 SLEEP() 等函數延遲查詢，確認是否存在漏洞</td>
<td class="org-left">用於盲目 SQL 注入</td>
</tr>

<tr>
<td class="org-left">基於錯誤的 SQL Injection（Error-Based SQL Injection）</td>
<td class="org-left">透過強制錯誤訊息來取得資料庫資訊</td>
<td class="org-left">泄露資料庫結構</td>
</tr>

<tr>
<td class="org-left">聯合查詢（UNION-Based SQL Injection）</td>
<td class="org-left">使用 UNION SELECT 讀取其他資料表</td>
<td class="org-left">竊取敏感資料</td>
</tr>

<tr>
<td class="org-left">堆疊查詢（Stacked Query SQL Injection）</td>
<td class="org-left">執行多條 SQL 語句，如 DROP TABLE</td>
<td class="org-left">刪除或修改資料</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org2f166e8"></a>4. SQL Injection 的防範方法<br />
<ul class="org-ul">
<li><a id="org24e4ebd"></a>(1) 使用預備語句（Prepared Statements）<br />
<div class="outline-text-7" id="text-org24e4ebd">
<p>
最佳做法是 使用預備語句（Prepared Statements） 或 參數化查詢（Parameterized Query），確保 SQL 查詢與使用者輸入分開：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">import</span> mysql.connector
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #dcaeea;">conn</span> = mysql.connector.connect(user=<span style="color: #98be65;">'root'</span>, password=<span style="color: #98be65;">'password'</span>, host=<span style="color: #98be65;">'localhost'</span>, database=<span style="color: #98be65;">'testdb'</span>)
<span class="linenr">4: </span><span style="color: #dcaeea;">cursor</span> = conn.cursor(prepared=<span style="color: #a9a1e1;">True</span>)
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = ? AND password = ?"</span>
<span class="linenr">7: </span>cursor.execute(query, (user_input, password_input))
</pre>
</div>
<p>
這種方式確保使用者輸入被視為 純文字，而非 SQL 語句，杜絕 SQL Injection。<br />
</p>
</div>
</li>
<li><a id="orgc74fc61"></a>(2) 使用 ORM（Object Relational Mapping）<br />
<div class="outline-text-7" id="text-orgc74fc61">
<p>
ORM 如 Django ORM、SQLAlchemy 等框架 內建防 SQL Injection 機制：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #dcaeea;">user</span> = User.objects.get(username=user_input)
</pre>
</div>
<p>
這種方式確保查詢語句由 框架自動處理，防止 SQL 注入。<br />
</p>
</div>
</li>
<li><a id="org5bb5052"></a>(3) 限制 SQL 權限<br />
<div class="outline-text-7" id="text-org5bb5052">
<ul class="org-ul">
<li>使用 最低權限 的資料庫帳號（Least Privilege Principle）。<br /></li>
<li>限制 DROP, DELETE, UPDATE 權限，避免惡意指令被執行。<br /></li>
</ul>
</div>
</li>
<li><a id="org239fe74"></a>(4) 避免回傳錯誤訊息<br />
<div class="outline-text-7" id="text-org239fe74">
<p>
隱藏 SQL 錯誤訊息，避免攻擊者獲得資料庫架構資訊：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>ini_set(<span style="color: #98be65;">'display_errors'</span>, <span style="color: #da8548; font-weight: bold;">0</span>);
</pre>
</div>
<p>
使用自訂錯誤頁面 來處理異常。<br />
</p>
</div>
</li>
<li><a id="orgbe062f3"></a>(5) 使用 Web Application Firewall（WAF）<br />
<div class="outline-text-7" id="text-orgbe062f3">
<p>
設置 WAF 來 過濾 SQL Injection 攻擊，如：<br />
</p>
<ul class="org-ul">
<li>ModSecurity（開源 WAF）<br /></li>
<li>Cloudflare（商業 WAF）<br /></li>
</ul>
</div>
</li>
<li><a id="org8c58f36"></a>(6) 檢查並清理使用者輸入<br />
<div class="outline-text-7" id="text-org8c58f36">
<p>
限制輸入格式，例如 使用 Regex 限制字元：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">if</span> (!preg_match(<span style="color: #98be65;">"/^[a-zA-Z0-9_]+$/"</span>, $username)) {
<span class="linenr">2: </span>    die(<span style="color: #98be65;">"Invalid input."</span>);
<span class="linenr">3: </span>}
</pre>
</div>
<p>
避免直接拼接 SQL 字串：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>$<span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = '$username'"</span>;
</pre>
</div>
<p>
上述方式容易被 SQL Injection 攻擊，應改為 參數化查詢。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org846f151" class="outline-4">
<h4 id="org846f151"><span class="section-number-4">8.4.10.</span> 10.(5%)</h4>
<div class="outline-text-4" id="text-8-4-10">
<p>
Choose correct answers regarding interface and abstract class in Java. [single or multiple choices]<br />
</p>
</div>
<div id="outline-container-org3b35f71" class="outline-5">
<h5 id="org3b35f71">甲、They are the same.</h5>
</div>
<div id="outline-container-org9d21353" class="outline-5">
<h5 id="org9d21353">乙、Interface cannot define any method implementation, but abstract class can.</h5>
</div>
<div id="outline-container-orgf5def97" class="outline-5">
<h5 id="orgf5def97">丙、Abstract class can have constant as attributes but interface cannot.</h5>
</div>
<div id="outline-container-orgd782912" class="outline-5">
<h5 id="orgd782912">丁、To have any instance of their type instantiated, they both need other class(es).</h5>
</div>
<div id="outline-container-org828f863" class="outline-5">
<h5 id="org828f863">戊、Abstract class is used in Java to realize multiple inheritance.</h5>
</div>
<div id="outline-container-org977e97f" class="outline-5">
<h5 id="org977e97f">解</h5>
<div class="outline-text-5" id="text-org977e97f">
</div>
<ul class="org-ul">
<li><a id="org11eed7b"></a>1. 正確選項解析<br />
<div class="outline-text-6" id="text-org11eed7b">
<ul class="org-ul">
<li>(X) 甲、They are the same.（它們是一樣的。）<br />
<ul class="org-ul">
<li>✅ 錯誤<br /></li>
<li>介面（Interface） 和 抽象類別（Abstract Class） 是 不同 的概念：<br />
<ul class="org-ul">
<li>Interface：定義規範，無法包含具體方法（Java 8 以前）。<br /></li>
<li>Abstract Class：可以包含 抽象方法與具體方法，允許部分行為定義。<br /></li>
</ul></li>
</ul></li>
<li>(✅) 乙、Interface cannot define any method implementation, but abstract class can.<br />
<ul class="org-ul">
<li>✅ 正確（適用於 Java 8 以前）<br /></li>
<li>Java 8 以前：<br />
<ul class="org-ul">
<li>介面（Interface） 只能 定義方法簽名，不能包含方法實作。<br /></li>
<li>抽象類別（Abstract Class） 可以包含 抽象方法與具體方法。<br /></li>
</ul></li>
<li>Java 8 之後：<br />
<ul class="org-ul">
<li>Interface 可以使用 default method 定義具體方法，但 仍無法有成員變數（except static final）。<br /></li>
</ul></li>
</ul></li>
<li>(X) 丙、Abstract class can have constant as attributes but interface cannot.<br />
<ul class="org-ul">
<li>✅ 錯誤<br /></li>
<li><p>
Interface 可以 擁有 常數（public static final 變數）：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    <span style="color: #51afef;">interface</span> Example {
<span class="linenr">2: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">MAX_VALUE</span> = <span style="color: #da8548; font-weight: bold;">100</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31561;&#21516;&#26044; public static final int MAX_VALUE = 100;</span>
<span class="linenr">3: </span>    }
</pre>
</div></li>
<li><p>
Abstract Class 也可以有 常數或實例變數：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>         <span style="color: #51afef;">abstract</span> <span style="color: #51afef;">class</span> Example {
<span class="linenr">2: </span>             <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">final</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">MAX_VALUE</span> = <span style="color: #da8548; font-weight: bold;">100</span>;
<span class="linenr">3: </span>             <span style="color: #51afef;">protected</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">value</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20801;&#35377;&#38750;&#38748;&#24907;&#35722;&#25976;</span>
<span class="linenr">4: </span>         }
</pre>
</div></li>
<li>不同點：<br />
<ul class="org-ul">
<li>Interface 的屬性 必須是 public static final。<br /></li>
<li>Abstract Class 可以有 一般實例變數。<br /></li>
</ul></li>
</ul></li>
<li>(✅) 丁、To have any instance of their type instantiated, they both need other class(es).<br />
<ul class="org-ul">
<li>✅ 正確<br /></li>
<li><p>
介面 和 抽象類別 都無法直接實例化：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>      <span style="color: #51afef;">interface</span> A { }
<span class="linenr">2: </span>      <span style="color: #51afef;">abstract</span> <span style="color: #51afef;">class</span> B { }
<span class="linenr">3: </span>      <span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> C <span style="color: #51afef;">extends</span> B { }  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38656;&#35201;&#23376;&#39006;&#21029;&#20358;&#23526;&#20316;</span>
</pre>
</div></li>
<li><p>
若要使用它們的類型，需透過子類別來實例化：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    A obj = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">SomeClass</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20171;&#38754;</span>
<span class="linenr">2: </span>    B obj2 = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">SubClass</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25277;&#35937;&#39006;&#21029;</span>
</pre>
</div></li>
</ul></li>
<li>(X) 戊、Abstract class is used in Java to realize multiple inheritance.<br />
<ul class="org-ul">
<li>✅ 錯誤<br /></li>
<li><p>
Java 不支援類別的多重繼承（Multiple Inheritance），但：介面 可以 實現多重繼承：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    <span style="color: #51afef;">interface</span> A { }
<span class="linenr">2: </span>    <span style="color: #51afef;">interface</span> B { }
<span class="linenr">3: </span>    <span style="color: #51afef;">class</span> C <span style="color: #51afef;">implements</span> A, B { }  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21487;&#23526;&#20316;&#22810;&#20491;&#20171;&#38754;</span>
</pre>
</div></li>
<li><p>
抽象類別 不能 多重繼承，但可以擁有子類：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>            <span style="color: #51afef;">abstract</span> <span style="color: #51afef;">class</span> A { }
<span class="linenr">2: </span>            <span style="color: #51afef;">class</span> B <span style="color: #51afef;">extends</span> A { }  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21482;&#33021;&#32380;&#25215;&#19968;&#20491;&#39006;&#21029;</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgfdfef78"></a>2. Java Interface vs Abstract Class 差異<br />
<div class="outline-text-6" id="text-orgfdfef78">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">介面（Interface）</th>
<th scope="col" class="org-left">抽象類別（Abstract Class）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">關鍵字</td>
<td class="org-left">interface</td>
<td class="org-left">abstract class</td>
</tr>

<tr>
<td class="org-left">是否可被實例化</td>
<td class="org-left">❌ 否</td>
<td class="org-left">❌ 否</td>
</tr>

<tr>
<td class="org-left">方法實作</td>
<td class="org-left">Java 8 以前：無具體方法</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Java 8 以後：default 方法可有實作</td>
<td class="org-left">✅ 可有部分方法具體實作</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">可否有實例變數</td>
<td class="org-left">❌ 只能 public static final 常數</td>
<td class="org-left">✅ 允許 實例變數</td>
</tr>

<tr>
<td class="org-left">是否支援多重繼承</td>
<td class="org-left">✅ 支援（可實作多個介面）</td>
<td class="org-left">❌ 不支援（只能繼承一個類別）</td>
</tr>

<tr>
<td class="org-left">建構子</td>
<td class="org-left">❌ 無</td>
<td class="org-left">✅ 可有建構子</td>
</tr>

<tr>
<td class="org-left">使用情境</td>
<td class="org-left">規範與行為契約（多型、多重繼承）</td>
<td class="org-left">基礎類別，提供基本功能與擴展</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org82d76b1" class="outline-4">
<h4 id="org82d76b1"><span class="section-number-4">8.4.11.</span> 11. (20%)</h4>
<div class="outline-text-4" id="text-8-4-11">
<p>
用 Java 或 C++，用物件導向的概念設計程式解下面的問題，而且要用到至少兩個 class 來設計你的程式。計分項目為(a)(b)(c)，只寫(c)沒有合理的(a)(b) 則(c)不予計分。(a)沒有合理的(a)說明，(b)不予計分。<br />
</p>
<ul class="org-ul">
<li>(a) 文字說明程式核心概念 (5%)<br /></li>
<li>(b) 畫出 class diagram 並簡易說明各 class 核心用途 (5%)<br /></li>
<li>(c) 程式本身 (含合理註解) (10%)<br /></li>
</ul>
<p>
程式問題: 讀取一組時間，然後計算出時針與分針的夾角。時間的格式是 0:00 到 12:00，小時數可能為 1 或 2 位數，分鐘數總是 2 位數，00 到 59 之間。輸出角度為 0 到 180 之間的 值，角度的精確度到千分之一。例如 9:00 是 90.000 度，不是-90，也不是 270 度。2:00 則是 60。<br />
</p>
</div>
<div id="outline-container-orgd09c97f" class="outline-5">
<h5 id="orgd09c97f">解</h5>
<div class="outline-text-5" id="text-orgd09c97f">
</div>
<ul class="org-ul">
<li><a id="org6b220d6"></a>(a) 文字說明程式核心概念<br />
<div class="outline-text-6" id="text-org6b220d6">
<p>
本程式的目標是 計算時鐘的時針與分針之間的夾角，並確保輸出範圍在 0 到 180 度 之間，且精確度為 千分之一（0.001）。<br />
為了實現此功能，採用 物件導向設計（OOP），透過以下方式封裝程式邏輯：<br />
</p>
<ul class="org-ul">
<li>建立 Time 類別：<br />
<ul class="org-ul">
<li>負責解析輸入的時間字串（如 &ldquo;9:00&rdquo;）。<br /></li>
<li>取得小時與分鐘的數值。<br /></li>
</ul></li>
<li>建立 ClockAngleCalculator 類別：<br />
<ul class="org-ul">
<li>計算時針與分針的夾角。<br /></li>
<li>確保輸出範圍為 0 到 180 度，避免超過 180 度的較大角度。<br /></li>
</ul></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orge08631a"></a>🔹 公式計算邏輯<br />
<div class="outline-text-7" id="text-orge08631a">
<ul class="org-ul">
<li>時針角度（Hour Angle）： Hour Angle=(h mod 12) × 30+m/60 × 30<br /></li>
<li>每小時時針轉動 30°，每分鐘影響時針 0.5°。<br /></li>
<li>分針角度（Minute Angle）： Minute Angle=m × 6<br /></li>
<li>每分鐘分針轉動 6°。<br /></li>
<li>夾角（Angle）： Angle=∣Hour Angle−Minute Angle∣<br /></li>
<li>確保最終結果為 0~180° 之間： Final Angle=min⁡(Angle,360−Angle)<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgb98ce95"></a>(b) Class Diagram 與簡易說明<br />
<div class="outline-text-6" id="text-orgb98ce95">
<p>
Class Diagram<br />
</p>
<pre class="example" id="org5a4783c">
+---------------------+
|       Time         |
+---------------------+
| - hour: int        |
| - minute: int      |
+---------------------+
| + Time(input: str) |  &lt;-- 解析時間字串
| + get_hour(): int  |
| + get_minute(): int|
+---------------------+

+--------------------------------+
|      ClockAngleCalculator      |
+--------------------------------+
| + calculate_angle(time: Time)  |  &lt;-- 計算時針與分針的夾角
+--------------------------------+
</pre>
</div>
<ul class="org-ul">
<li><a id="orgfe5bd98"></a>Class 說明<br />
<div class="outline-text-7" id="text-orgfe5bd98">
<ul class="org-ul">
<li>Time 類別<br />
<ul class="org-ul">
<li>負責解析輸入的時間字串 &ldquo;h:mm&rdquo;，並存儲 hour 和 minute。<br /></li>
<li>提供 get_hour() 和 get_minute() 方法來返回小時與分鐘。<br /></li>
</ul></li>
<li>ClockAngleCalculator 類別<br />
<ul class="org-ul">
<li>提供 calculate_angle() 方法來計算夾角，並確保輸出範圍為 0~180°。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org7707897"></a>(c) C++ 程式碼<br />
<div class="outline-text-6" id="text-org7707897">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iomanip&gt;</span>
<span class="linenr"> 3: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;cmath&gt;</span>
<span class="linenr"> 4: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;sstream&gt;</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Time &#39006;&#21029;&#65306;&#36000;&#36012;&#35299;&#26512;&#26178;&#38291;&#23383;&#20018;&#20006;&#25552;&#20379;&#23567;&#26178;&#33287;&#20998;&#37912;&#36039;&#35338;</span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Time</span> {
<span class="linenr">10: </span><span style="color: #51afef;">private</span>:
<span class="linenr">11: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">hour</span>;
<span class="linenr">12: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">minute</span>;
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #51afef;">public</span>:
<span class="linenr">15: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24314;&#27083;&#23376;&#65306;&#35299;&#26512;&#36664;&#20837;&#23383;&#20018; "h:mm"</span>
<span class="linenr">16: </span>    <span style="color: #c678dd;">Time</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">string</span>&amp; <span style="color: #dcaeea;">input</span>) {
<span class="linenr">17: </span>        <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">colon</span>;
<span class="linenr">18: </span>        <span style="color: #ECBE7B;">stringstream</span> <span style="color: #dcaeea;">ss</span>(input);
<span class="linenr">19: </span>        ss &gt;&gt; hour &gt;&gt; colon &gt;&gt; minute;
<span class="linenr">20: </span>    }
<span class="linenr">21: </span>
<span class="linenr">22: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">get_hour</span>() <span style="color: #51afef;">const</span> { <span style="color: #51afef;">return</span> hour; }
<span class="linenr">23: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">get_minute</span>() <span style="color: #51afef;">const</span> { <span style="color: #51afef;">return</span> minute; }
<span class="linenr">24: </span>};
<span class="linenr">25: </span>
<span class="linenr">26: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">ClockAngleCalculator &#39006;&#21029;&#65306;&#36000;&#36012;&#35336;&#31639;&#26178;&#37341;&#33287;&#20998;&#37341;&#30340;&#22846;&#35282;</span>
<span class="linenr">27: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">ClockAngleCalculator</span> {
<span class="linenr">28: </span><span style="color: #51afef;">public</span>:
<span class="linenr">29: </span>    <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">double</span> <span style="color: #c678dd;">calculate_angle</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Time</span>&amp; <span style="color: #dcaeea;">time</span>) {
<span class="linenr">30: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">h</span> = time.get_hour() % <span style="color: #da8548; font-weight: bold;">12</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36681;&#25563;&#28858; 12 &#23567;&#26178;&#21046;</span>
<span class="linenr">31: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span> = time.get_minute();
<span class="linenr">32: </span>
<span class="linenr">33: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639;&#26178;&#37341;&#33287;&#20998;&#37341;&#35282;&#24230;</span>
<span class="linenr">34: </span>        <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">hour_angle</span> = h * <span style="color: #da8548; font-weight: bold;">30.0</span> + (m / <span style="color: #da8548; font-weight: bold;">60.0</span>) * <span style="color: #da8548; font-weight: bold;">30.0</span>;
<span class="linenr">35: </span>        <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">minute_angle</span> = m * <span style="color: #da8548; font-weight: bold;">6.0</span>;
<span class="linenr">36: </span>        <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">angle</span> = fabs(hour_angle - minute_angle);
<span class="linenr">37: </span>
<span class="linenr">38: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30906;&#20445;&#35282;&#24230;&#31684;&#22285;&#22312; 0~180 &#20043;&#38291;</span>
<span class="linenr">39: </span>        <span style="color: #51afef;">return</span> min(angle, <span style="color: #da8548; font-weight: bold;">360.0</span> - angle);
<span class="linenr">40: </span>    }
<span class="linenr">41: </span>};
<span class="linenr">42: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20027;&#20989;&#24335;</span>
<span class="linenr">43: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">44: </span>    <span style="color: #ECBE7B;">string</span> <span style="color: #dcaeea;">input</span>;
<span class="linenr">45: </span>    cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#26178;&#38291; (&#26684;&#24335; h:mm&#65292;&#22914; 9:00) : "</span>;
<span class="linenr">46: </span>    cin &gt;&gt; input;
<span class="linenr">47: </span>
<span class="linenr">48: </span>    <span style="color: #ECBE7B;">Time</span> <span style="color: #dcaeea;">time</span>(input);
<span class="linenr">49: </span>    <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">angle</span> = <span style="color: #a9a1e1;">ClockAngleCalculator</span>::calculate_angle(time);
<span class="linenr">50: </span>
<span class="linenr">51: </span>    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35373;&#23450;&#23567;&#25976;&#40670;&#31934;&#24230;&#21040;&#21315;&#20998;&#20043;&#19968;</span>
<span class="linenr">52: </span>    cout &lt;&lt; fixed &lt;&lt; setprecision(<span style="color: #da8548; font-weight: bold;">3</span>);
<span class="linenr">53: </span>    cout &lt;&lt; <span style="color: #98be65;">"&#26178;&#37341;&#33287;&#20998;&#37341;&#30340;&#22846;&#35282;: "</span> &lt;&lt; angle &lt;&lt; <span style="color: #98be65;">" &#24230;"</span> &lt;&lt; endl;
<span class="linenr">54: </span>
<span class="linenr">55: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">56: </span>}
</pre>
</div>
<p>
輸出範例<br />
</p>
<pre class="example" id="orgda6e3da">
請輸入時間 (格式 h:mm，如 9:00) : 9:00
時針與分針的夾角: 90.000 度

請輸入時間 (格式 h:mm，如 9:00) : 2:00
時針與分針的夾角: 60.000 度

請輸入時間 (格式 h:mm，如 9:00) : 3:15
時針與分針的夾角: 7.500 度
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4ea8936" class="outline-3">
<h3 id="org4ea8936"><span class="section-number-3">8.5.</span> 112</h3>
<div class="outline-text-3" id="text-8-5">
</div>
<div id="outline-container-org7302f73" class="outline-4">
<h4 id="org7302f73"><span class="section-number-4">8.5.1.</span> 1. (3%)</h4>
<div class="outline-text-4" id="text-8-5-1">
<p>
小明在Linux時若要達到下列，請回答如何編輯/etc/crontab檔案，以達到他想要的效果？<br />
</p>
<ul class="org-ul">
<li>(1) (3%)在每天早上六點 2 點以root身分執行bash /backup.sh，請問他該如何編輯/etc/crontab 檔案，以達到他想要的效果？<br /></li>
<li>(2) (3%)架設網站須每個月的10號晚間10點30分以root身分輸入certbot renew以更新https 證書，請問他該如何編輯/etc/crontab檔案，以達到他想要的效果？<br /></li>
</ul>
</div>
<div id="outline-container-org3422ea4" class="outline-5">
<h5 id="org3422ea4">解</h5>
<div class="outline-text-5" id="text-org3422ea4">
</div>
<ul class="org-ul">
<li><a id="orgdb9d3bf"></a>(a) 文字說明 crontab 核心概念<br />
<div class="outline-text-6" id="text-orgdb9d3bf">
<p>
Crontab（cron table） 是 Linux 排程管理工具，用於定期執行腳本或指令。<br />
Linux 透過 cron 服務來讀取 /etc/crontab 或 crontab -e 設定的排程，並在特定時間點自動執行指令。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2214edb"></a>📌 排程格式：<br />
<div class="outline-text-7" id="text-org2214edb">
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>&#20998;&#37912;<span style="color: #51afef;">&#65288;</span>0-59<span style="color: #51afef;">&#65289;</span> &#23567;&#26178;<span style="color: #51afef;">&#65288;</span>0-23<span style="color: #51afef;">&#65289;</span> &#26085;&#26399;<span style="color: #51afef;">&#65288;</span>1-31<span style="color: #51afef;">&#65289;</span> &#26376;&#20221;<span style="color: #51afef;">&#65288;</span>1-12<span style="color: #51afef;">&#65289;</span> &#26143;&#26399;<span style="color: #51afef;">&#65288;</span>0-7<span style="color: #51afef;">&#65289;</span> &#20351;&#29992;&#32773; &#25351;&#20196;
</pre>
</div>
<ul class="org-ul">
<li>分鐘（0-59）：設定在每小時的哪一分鐘執行。<br /></li>
<li>小時（0-23）：設定在一天的哪一小時執行（24 小時制）。<br /></li>
<li>日期（1-31）：設定在每個月的哪一天執行。<br /></li>
<li>月份（1-12）：設定在哪個月份執行。<br /></li>
<li>星期（0-7）：設定在星期幾執行（0 或 7 代表星期天）。<br /></li>
<li>使用者：指定要執行該排程的 Linux 使用者。<br /></li>
<li>指令：指定要執行的 Shell 指令或腳本。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgfbbec8e"></a>(b) 設定 /etc/crontab 來滿足小明的需求<br />
<ul class="org-ul">
<li><a id="orgcd00b39"></a>(1) 在每天早上 6:02 以 root 身分執行 /backup.sh<br />
<div class="outline-text-7" id="text-orgcd00b39">
<ul class="org-ul">
<li><p>
✅ 對應的 crontab 設定：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>  <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">6</span> * * * root bash /backup.sh
</pre>
</div></li>
<li>📌 解析：<br />
<ul class="org-ul">
<li>2：代表 第 2 分鐘執行（即 6:02 AM）。<br /></li>
<li>6：代表 早上 6 點執行。<br /></li>
<li>* * *：表示 每天、每月、每年執行。<br /></li>
<li>root：指定 root 身分執行。<br /></li>
<li>bash /backup.sh：執行 /backup.sh 腳本。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgf558760"></a>(2) 在每月 10 號 晚上 10:30 以 root 身分執行 certbot renew<br />
<div class="outline-text-6" id="text-orgf558760">
<ul class="org-ul">
<li><p>
✅ 對應的 crontab 設定：<br />
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="linenr">1: </span>  <span style="color: #da8548; font-weight: bold;">30</span> <span style="color: #da8548; font-weight: bold;">22</span> <span style="color: #da8548; font-weight: bold;">10</span> * * root certbot renew
</pre>
</div></li>
<li>📌 解析：<br />
<ul class="org-ul">
<li>30：代表 30 分鐘執行。<br /></li>
<li>22：代表 晚上 10 點執行。<br /></li>
<li>10：代表 每月 10 號執行。<br /></li>
<li>* *：月份、星期皆為 *，代表不限制，適用每個月的 10 號。<br /></li>
<li>root：指定 root 身分執行。<br /></li>
<li>certbot renew：執行 certbot 來更新 HTTPS 憑證。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc1a3695"></a>(c) 相關計算機概論知識<br />
<div class="outline-text-6" id="text-orgc1a3695">
<ul class="org-ul">
<li>(1) Linux 相關概念<br />
<ul class="org-ul">
<li>Crontab 排程管理<br />
<ul class="org-ul">
<li>crontab -e：編輯使用者專屬的 crontab。<br /></li>
<li>crontab -l：列出當前 crontab 設定。<br /></li>
<li>systemctl restart cron：重新啟動 cron 服務。<br /></li>
</ul></li>
<li>系統管理<br />
<ul class="org-ul">
<li>sudo：賦予使用者 root 權限。<br /></li>
<li>/etc/crontab：系統全域 crontab 設定。<br /></li>
</ul></li>
</ul></li>
<li><p>
(2) cron 排程特殊符號<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">符號</th>
<th scope="col" class="org-left">含義</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">*</td>
<td class="org-left">任何時間皆執行</td>
</tr>

<tr>
<td class="org-left">,</td>
<td class="org-left">指定多個值（如 1,15 表示 1 號與 15 號執行）</td>
</tr>

<tr>
<td class="org-left">-</td>
<td class="org-left">範圍（如 1-5 代表 1 到 5）</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org9fd8907" class="outline-4">
<h4 id="org9fd8907"><span class="section-number-4">8.5.2.</span> 2. (5%)</h4>
<div class="outline-text-4" id="text-8-5-2">
<p>
給定一10進位數字為 237.8125.<br />
</p>
<ul class="org-ul">
<li>(1) 請問其二進位定點表示法為何？<br /></li>
<li>(2) (5%) IEEE 727(excess-127 system) 單精準度(32-bits single precision)浮點表示法為何？<br /></li>
<li>(3) (3%)機械常數(machine epsilon)為多少？<br /></li>
</ul>
</div>
<div id="outline-container-org58e7957" class="outline-5">
<h5 id="org58e7957">解</h5>
<div class="outline-text-5" id="text-org58e7957">
</div>
<ul class="org-ul">
<li><a id="orga946f12"></a>(a) 文字說明相關核心概念<br />
<div class="outline-text-6" id="text-orga946f12">
<p>
IEEE 754 是現代電腦中 浮點數表示 的標準，單精度（32-bit）表示法使用：<br />
</p>
<ol class="org-ol">
<li>1 位元符號位（Sign Bit）：<br />
<ul class="org-ul">
<li>0 代表正數，1 代表負數。<br /></li>
</ul></li>
<li>8 位元指數位（Exponent）：<br />
<ul class="org-ul">
<li>採 excess-127（偏移 127） 的編碼方式。<br /></li>
</ul></li>
<li>23 位元尾數（Mantissa）：<br />
<ul class="org-ul">
<li>只存 隱藏的小數部分（不含隱含的 1）。<br /></li>
</ul></li>
</ol>

<p>
機械常數（Machine Epsilon）：<br />
</p>
<ul class="org-ul">
<li>用於測試浮點數系統中 相鄰數值之間的最小間隔。<br /></li>
<li>在 IEEE 754 單精度（single precision, 32-bit） 中：<br /></li>
<li>Machine Epsilon=2−23<br /></li>
<li>Machine Epsilon=2−23<br /></li>
</ul>
</div>
</li>
<li><a id="org00fd9fe"></a>(b) 題目解答<br />
<ul class="org-ul">
<li><a id="org5d783d9"></a>(1) 237.8125 的二進位定點表示法<br />
<div class="outline-text-7" id="text-org5d783d9">
<p>
將 237.8125 轉為 二進位整數部分 與 小數部分：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgb8e1b3c"></a>(a) 237 的二進位轉換<br />
<div class="outline-text-8" id="text-orgb8e1b3c">
<p>
237 除 2 取餘數：<br />
</p>
<pre class="example" id="org57a844c">
237 ÷ 2 = 118 餘 1
118 ÷ 2 =  59 餘 0
 59 ÷ 2 =  29 餘 1
 29 ÷ 2 =  14 餘 1
 14 ÷ 2 =   7 餘 0
  7 ÷ 2 =   3 餘 1
  3 ÷ 2 =   1 餘 1
  1 ÷ 2 =   0 餘 1
</pre>
<p>
結果： 237_{10} = 11101101_{2}<br />
</p>
</div>
</li>
<li><a id="orgcebdde2"></a>(b) 0.8125 的二進位轉換<br />
<div class="outline-text-8" id="text-orgcebdde2">
<p>
將 0.8125 乘 2 取整數部分：<br />
</p>
<pre class="example" id="org40d4b21">
0.8125 × 2 = 1.625 → 取整數 1
0.625  × 2 = 1.25  → 取整數 1
0.25   × 2 = 0.5   → 取整數 0
0.5    × 2 = 1.0   → 取整數 1
</pre>
<p>
結果： 0.8125_{10} = 0.1101_{2}<br />
</p>
</div>
</li>
<li><a id="org4d692e9"></a>(c) 最終二進位定點表示<br />
<div class="outline-text-8" id="text-org4d692e9">
<p>
237.812510=11101101.11012<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org3b59362"></a>(2) IEEE 754 單精度（32-bit）浮點表示法<br />
<ul class="org-ul">
<li><a id="org1357fd9"></a>(a) 正規化（Normalization）<br />
<div class="outline-text-8" id="text-org1357fd9">
<p>
將 二進位數 轉換為 標準浮點表示法：<br />
11101101.11012=1.110110111012×27<br />
</p>
<ul class="org-ul">
<li>尾數（Mantissa）： 1.11011011101（隱藏 1）<br /></li>
<li>指數（Exponent）： 7<br /></li>
<li>偏移 127（Excess-127）：<br /></li>
<li>127+7=13410=100001102<br /></li>
</ul>
</div>
</li>
<li><a id="orgfe344c3"></a>(b) IEEE 754 組成<br />
<div class="outline-text-8" id="text-orgfe344c3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Bit 位數</th>
<th scope="col" class="org-right">值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">符號位</td>
<td class="org-right">0（正數）</td>
</tr>

<tr>
<td class="org-left">指數位（8-bit）</td>
<td class="org-right">10000110</td>
</tr>

<tr>
<td class="org-left">尾數（23-bit）</td>
<td class="org-right">11011011101000000000000</td>
</tr>
</tbody>
</table>
<p>
✅ 最終 IEEE 754 單精度表示（32-bit）：<br />
</p>
<pre class="example" id="orgdcba8af">
0 10000110 11011011101000000000000
</pre>
<p>
十六進位表示法（Hex）：<br />
</p>
<pre class="example" id="org4c86f92">
0x46DD5000
</pre>
</div>
</li>
</ul>
</li>
<li><a id="org7aa6599"></a>(3) 機械常數（Machine Epsilon）<br />
<div class="outline-text-7" id="text-org7aa6599">
<p>
機械常數是最小可區分的浮點數增量：<br />
\(ϵ=2^{−23}=1.1920929×10^{−7}\)<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org7a73f2e"></a>(c) 相關計算機概論知識<br />
<ul class="org-ul">
<li><a id="org538052c"></a>(1) 浮點數表示法<br />
<div class="outline-text-7" id="text-org538052c">
<ul class="org-ul">
<li>IEEE 754 規範<br />
<ul class="org-ul">
<li>單精度（32-bit）： 1 符號位 + 8 指數位 + 23 尾數位。<br /></li>
<li>雙精度（64-bit）： 1 符號位 + 11 指數位 + 52 尾數位。<br /></li>
</ul></li>
<li>偏移編碼（Excess-k Encoding）<br />
<ul class="org-ul">
<li>指數使用 Excess-127（單精度）或 Excess-1023（雙精度）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org746018e"></a>(2) IEEE 754 浮點數的精度<br />
<div class="outline-text-7" id="text-org746018e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">類型</th>
<th scope="col" class="org-left">位元數</th>
<th scope="col" class="org-left">精確度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">單精度</td>
<td class="org-left">32-bit</td>
<td class="org-left">約 7 位十進位</td>
</tr>

<tr>
<td class="org-left">雙精度</td>
<td class="org-left">64-bit</td>
<td class="org-left">約 15-16 位十進位</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgaa12dee"></a>(3) 機械常數（Machine Epsilon）<br />
<div class="outline-text-7" id="text-orgaa12dee">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">位元長度</th>
<th scope="col" class="org-left">機械常數（ε）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">32-bit（單精度）</td>
<td class="org-left">2^{−23} ≈ 1.192×10^{−7}</td>
</tr>

<tr>
<td class="org-left">64-bit（雙精度）</td>
<td class="org-left">2^{ −52} ≈ 2.220×10^{−16}</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org13fadac" class="outline-4">
<h4 id="org13fadac"><span class="section-number-4">8.5.3.</span> 3. (15%)</h4>
<div class="outline-text-4" id="text-8-5-3">
<p>
在64-bits的定址區流排電腦上，給定一個以Byte(B)為最小單位(byte-oriented)的記憶體分頁(memory paging)管理系統，每個頁大小4 MB，假設去除了作業系統常駐後可用的記憶體空間為 24 GB。若某行程(process)有32-bits 的邏輯位置(logical address)空間，請問此行程的 分頁表(page table)大小為多少Byte(B)？<br />
</p>
</div>
<div id="outline-container-orgfc620e4" class="outline-5">
<h5 id="orgfc620e4">解</h5>
<div class="outline-text-5" id="text-orgfc620e4">
</div>
<ul class="org-ul">
<li><a id="org3c9f953"></a>(a) 文字說明相關核心概念<br />
<div class="outline-text-6" id="text-org3c9f953">
<p>
在 64-bit 定址 的電腦上，記憶體管理通常採用 分頁（Paging）機制，允許作業系統以 固定大小的頁面（Page） 來管理記憶體，以提高記憶體分配效率與虛擬記憶體的運作效能。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orge1cd819"></a>📌 核心概念<br />
<div class="outline-text-7" id="text-orge1cd819">
<ul class="org-ul">
<li>分頁（Paging）：<br />
-g作業系統將邏輯位址（Logical Address） 切割為「頁（Page）」。<br />
-g物理記憶體則對應到「框架（Frame）」。<br />
-g邏輯位址 = 頁號（Page Number） + 偏移量（Offset）。<br /></li>
<li>頁表（Page Table）：<br />
<ul class="org-ul">
<li>存放「邏輯頁（Page Number）」與「物理頁框（Frame Number）」的對應關係。<br /></li>
<li>每個分頁表項目（PTE, Page Table Entry） 存放：<br />
<ul class="org-ul">
<li>頁框號（Frame Number）<br /></li>
<li>存取權限（R/W/X）<br /></li>
<li>快取控制位元<br /></li>
<li>有效/無效位元<br /></li>
</ul></li>
</ul></li>
<li>計算分頁表大小的公式<br />
Page Table Size=Number of Pages×Size of Each Page Table Entry (PTE)<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org1375306"></a>(b) 題目解答<br />
<ul class="org-ul">
<li><a id="org902453f"></a>(1) 計算邏輯地址空間的總頁數<br />
<div class="outline-text-7" id="text-org902453f">
<ul class="org-ul">
<li>📌 題目條件：<br />
<ul class="org-ul">
<li>邏輯地址空間（Logical Address Space）= 32-bit<br /></li>
<li>頁大小（Page Size）= 4 MB = 222B222B（因為 4MB=2224MB=222）<br /></li>
<li>一個頁表項目（PTE）大小 = 8 Bytes（一般64-bit系統）<br /></li>
</ul></li>
<li>📌 計算總頁數 邏輯地址空間為 32-bit，代表其可定址範圍為：<br />
<ul class="org-ul">
<li>\(2^32\) bytes<br /></li>
</ul></li>
<li>每個頁面大小為 222222：<br />
<ul class="org-ul">
<li>Total Pages=\({2^{32} / 2^{22}=2^{10}=1024\) pages<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org5c083b2"></a>(2) 計算分頁表大小<br />
<div class="outline-text-7" id="text-org5c083b2">
<ul class="org-ul">
<li>📌 分頁表大小計算公式<br />
<ul class="org-ul">
<li>Page Table Size=Number of Pages×Size of Each Page Table Entry (PTE)<br />
=1024×8<br />
=8192 bytes=8KB<br /></li>
</ul></li>
<li>✅ 最終答案：分頁表大小 = 8 KB<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org6f6cc83"></a>(c) 相關計算機概論知識<br />
<ul class="org-ul">
<li><a id="orgf82d8f5"></a>(1) 記憶體管理機制<br />
<div class="outline-text-7" id="text-orgf82d8f5">
<ul class="org-ul">
<li>分頁機制（Paging）<br />
<ul class="org-ul">
<li>固定大小的頁（Page）+ 對應的物理框架（Frame）。<br /></li>
<li>需要 頁表（Page Table） 來管理邏輯位址到物理位址的對應。<br /></li>
<li>優點：<br />
<ul class="org-ul">
<li>提供記憶體保護，避免一個行程影響到另一個行程的記憶體。<br /></li>
<li>支援虛擬記憶體，允許行程使用超過實體記憶體的空間。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>每個行程需要維護一張頁表，若邏輯位址空間很大，則頁表會變得過大（解決方案：多級頁表）。<br /></li>
</ul></li>
</ul></li>
<li>分段機制（Segmentation）<br />
<ul class="org-ul">
<li>記憶體分為變長的區段（Segment），不同區段有不同的權限與大小。<br /></li>
<li>但會造成外部碎片（External Fragmentation） 問題。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org47326e9"></a>(2) 多級分頁（Multi-level Paging）<br />
<div class="outline-text-7" id="text-org47326e9">
<p>
若頁表過大，會導致單層頁表（Single-Level Page Table） 無法一次載入整個頁表，解決方法：<br />
</p>
<ul class="org-ul">
<li>二級頁表（Two-Level Page Table）<br />
<ul class="org-ul">
<li>先查找 頁目錄（Page Directory），再進入 第二級頁表（Page Table）。<br /></li>
</ul></li>
<li>多級頁表（Multi-Level Page Table）<br />
<ul class="org-ul">
<li>使用 樹狀結構（Tree Structure） 減少單層頁表的大小。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgdc1dfd3" class="outline-4">
<h4 id="orgdc1dfd3"><span class="section-number-4">8.5.4.</span> 4. (15%)</h4>
<div class="outline-text-4" id="text-8-5-4">
<p>
請詳細說明http cookies的功用和工作原理。然後畫圖說明&ldquo;First-party cookie&rdquo; 和&ldquo;Third-party cookie&rdquo; 的意義。<br />
</p>
</div>
<div id="outline-container-org839b6eb" class="outline-5">
<h5 id="org839b6eb">解</h5>
<div class="outline-text-5" id="text-org839b6eb">
</div>
<ul class="org-ul">
<li><a id="org6fb82f3"></a>(a) HTTP Cookies 介紹<br />
<div class="outline-text-6" id="text-org6fb82f3">
<ul class="org-ul">
<li>📌 Cookies 是什麼？ HTTP Cookies 是由伺服器（Server）發送並存儲於使用者瀏覽器（Browser）內的小型文字檔案。它們用來記錄用戶狀態、提供個人化體驗，在 HTTP 無狀態（stateless）的環境下保持連線資訊。<br /></li>
<li>📌 Cookies 的主要功能<br />
<ul class="org-ul">
<li>身份驗證（Authentication）<br />
<ul class="org-ul">
<li>網站透過 Cookies 存儲登入憑證，使用戶不需每次重新登入。<br /></li>
</ul></li>
<li>會話管理（Session Management）<br />
<ul class="org-ul">
<li>維持使用者狀態，如購物車、網站偏好設定。<br /></li>
</ul></li>
<li>追蹤與分析（Tracking &amp; Analytics）<br />
<ul class="org-ul">
<li>追蹤使用者瀏覽行為，用於廣告投放、網站分析等。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org600d989"></a>(b) HTTP Cookies 的工作原理<br />
<div class="outline-text-6" id="text-org600d989">
<ul class="org-ul">
<li>📌 Cookies 的運作流程<br />
<ol class="org-ol">
<li><p>
客戶端（Client）向伺服器發送 HTTP 請求<br />
</p>
GET /index.html HTTP/1.1
Host: example.com</li>
<li><p>
伺服器回應時設定 Cookie<br />
</p>
HTTP/1.1 200 OK
Set-Cookie: session_id=abc123; Path=/; HttpOnly
<ul class="org-ul">
<li>session_id=abc123：儲存會話識別碼<br /></li>
<li>Path=/：Cookie 適用於整個網站<br /></li>
<li>HttpOnly：限制 JavaScript 存取，提升安全性<br /></li>
</ul></li>
<li><p>
客戶端儲存 Cookie 並在後續請求中傳回<br />
</p>
GET /dashboard HTTP/1.1
Host: example.com
Cookie: session_id=abc123</li>
<li><p>
伺服器驗證 Cookie 並回應適當內容<br />
</p>
HTTP/1.1 200 OK</li>
</ol></li>
</ul>

<p>
📌 Cookies 的屬性<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">屬性</th>
<th scope="col" class="org-left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Domain</td>
<td class="org-left">指定 Cookie 適用的網域</td>
</tr>

<tr>
<td class="org-left">Path</td>
<td class="org-left">限制 Cookie 的有效路徑</td>
</tr>

<tr>
<td class="org-left">Secure</td>
<td class="org-left">只允許 HTTPS 連線傳送</td>
</tr>

<tr>
<td class="org-left">HttpOnly</td>
<td class="org-left">阻止 JavaScript 存取</td>
</tr>

<tr>
<td class="org-left">SameSite</td>
<td class="org-left">限制跨站請求（防止 CSRF 攻擊）</td>
</tr>

<tr>
<td class="org-left">Max-Age / Expires</td>
<td class="org-left">設定 Cookie 何時過期</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgabe0f34"></a>(c) First-Party Cookie vs. Third-Party Cookie<br />
<div class="outline-text-6" id="text-orgabe0f34">
<p>
📌 First-Party Cookie（第一方 Cookie）<br />
</p>
<ul class="org-ul">
<li>定義：由使用者瀏覽的網站（如 example.com）設定。<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>儲存使用者偏好（如語言、主題）<br /></li>
<li>管理登入狀態<br /></li>
<li>維持購物車資訊<br /></li>
</ul></li>
</ul>
<p>
🔹 圖示：<br />
</p>
<pre class="example" id="org5386ca7">
使用者 → example.com（主網站）
  ⬆️                ⬇️
  🔹 請求網頁        🔹 設置 First-Party Cookie
  ⬆️                ⬇️
  🔹 帶 Cookie 回傳  🔹 個人化回應
</pre>
<p>
📌 Third-Party Cookie（第三方 Cookie）<br />
</p>
<ul class="org-ul">
<li>定義：由非使用者訪問的網站（如 adnetwork.com）設定。<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>跨網站追蹤（Tracking）<br /></li>
<li>廣告投放與推薦<br /></li>
<li>用戶行為分析<br /></li>
</ul></li>
</ul>
<p>
🔹 圖示：<br />
</p>
<pre class="example" id="org211f917">
使用者 → example.com（主網站）
  ⬆️                ⬇️
  🔹 請求內容        🔹 嵌入第三方元件（如廣告）
  ⬆️                ⬇️
  🔹 來自 adnetwork.com 的請求
  ⬆️                ⬇️
  🔹 設置 Third-Party Cookie
</pre>
<p>
📌 Third-Party Cookie 的問題<br />
</p>
<ul class="org-ul">
<li>隱私問題：跨網站追蹤可能洩露使用者行為。<br /></li>
<li>瀏覽器封鎖：主流瀏覽器（Chrome、Firefox、Safari）正逐步淘汰 Third-Party Cookies。<br /></li>
</ul>
</div>
</li>
<li><a id="org02d0909"></a>(d) 相關計算機概論知識<br />
<div class="outline-text-6" id="text-org02d0909">
<ul class="org-ul">
<li>(1) HTTP 與無狀態性<br />
<ul class="org-ul">
<li>HTTP 是無狀態的（Stateless）<br />
<ul class="org-ul">
<li>每個請求獨立處理，不記錄過去狀態。<br /></li>
<li>Cookies、Session、Token 用來維持用戶狀態。<br /></li>
</ul></li>
</ul></li>
<li>(2) 網站追蹤技術<br />
<ul class="org-ul">
<li>Cookies：追蹤使用者瀏覽行為。<br /></li>
<li>LocalStorage / SessionStorage：瀏覽器內建存儲機制。<br /></li>
<li>Fingerprinting（指紋辨識）：透過設備資訊、IP、瀏覽器設定追蹤使用者。<br /></li>
</ul></li>
<li>(3) 隱私與安全<br />
<ul class="org-ul">
<li>SameSite 屬性 防止 CSRF（跨站請求偽造）。<br /></li>
<li>Secure 屬性 限制 HTTP 傳輸，避免中間人攻擊。<br /></li>
<li>HttpOnly 屬性 阻擋 JavaScript 存取，避免 XSS 攻擊。<br /></li>
</ul></li>
<li>(e) 結論<br />
<ul class="org-ul">
<li>HTTP Cookies 是 Web 追蹤與會話管理的關鍵技術。<br /></li>
<li>First-Party Cookie 負責站內個人化，Third-Party Cookie 用於跨站追蹤。<br /></li>
<li>瀏覽器逐步封鎖 Third-Party Cookie，隱私保護成為趨勢。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6a5b17e" class="outline-4">
<h4 id="org6a5b17e"><span class="section-number-4">8.5.5.</span> 5. (10%)</h4>
<div class="outline-text-4" id="text-8-5-5">
<p>
網路安全領域中有所謂&ldquo;Kill-chain&rdquo;，請詳細說明其內容以及其對網路安全防禦的意義。<br />
</p>
</div>
<div id="outline-container-org3592f4f" class="outline-5">
<h5 id="org3592f4f">解</h5>
<div class="outline-text-5" id="text-org3592f4f">
</div>
<ul class="org-ul">
<li><a id="org641faa6"></a>(a) 什麼是 Kill Chain？<br />
<div class="outline-text-6" id="text-org641faa6">
<p>
Kill Chain（攻擊鏈）是一種 描述網路攻擊過程的模型，最早由 美國洛克希德馬丁公司（Lockheed Martin） 提出，原始概念來自於軍事上的「殺傷鏈」（Kill Chain）。<br />
</p>
<ul class="org-ul">
<li>📌 核心概念：攻擊者必須依序執行 一連串的步驟 才能成功入侵系統，安全專家可以透過 識別、阻斷或干擾這些步驟 來提升防禦能力。<br /></li>
</ul>
</div>
</li>
<li><a id="org7cfca06"></a>(b) Kill Chain 的七個階段<br />
<div class="outline-text-6" id="text-org7cfca06">
<p>
Lockheed Martin 提出的 Cyber Kill Chain 共有 七個步驟，描述從攻擊準備到最終達成目標的整個過程。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">階段</th>
<th scope="col" class="org-left">內容</th>
<th scope="col" class="org-left">防禦策略</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">1. 偵察（Reconnaissance）</td>
<td class="org-left">攻擊者蒐集目標資訊，如社交工程、網路掃描等。</td>
<td class="org-left">限制公開資訊、監控異常存取、使用欺騙技術（Honeypot）。</td>
</tr>

<tr>
<td class="org-left">2. 武器化（Weaponization）</td>
<td class="org-left">開發惡意攻擊工具，如製作惡意程式、攻擊腳本等。</td>
<td class="org-left">使用防毒軟體、分析攻擊行為、定期更新系統。</td>
</tr>

<tr>
<td class="org-left">3. 投遞（Delivery）</td>
<td class="org-left">攻擊者將惡意程式傳送到受害者端，如透過電子郵件、惡意網站等。</td>
<td class="org-left">電子郵件過濾、DNS 過濾、惡意 URL 阻擋。</td>
</tr>

<tr>
<td class="org-left">4. 利用（Exploitation）</td>
<td class="org-left">利用系統漏洞來執行惡意程式，如 Zero-day 漏洞攻擊。</td>
<td class="org-left">強化系統安全、應用程式沙箱（Sandbox）、修補漏洞。</td>
</tr>

<tr>
<td class="org-left">5. 安裝（Installation）</td>
<td class="org-left">安裝後門（Backdoor）或木馬，確保長期存取權限。</td>
<td class="org-left">使用 EDR（Endpoint Detection &amp; Response）、行為分析。</td>
</tr>

<tr>
<td class="org-left">6. 指揮與控制（C2, Command &amp; Control）</td>
<td class="org-left">攻擊者遠端控制受害系統，如建立 Botnet。</td>
<td class="org-left">網路監控、封鎖惡意 IP、使用行為分析來發現異常通訊。</td>
</tr>

<tr>
<td class="org-left">7. 行動目標（Actions on Objectives）</td>
<td class="org-left">竊取資料、破壞系統或發動勒索攻擊。</td>
<td class="org-left">設定最小權限原則（Least Privilege）、即時偵測異常活動。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org2705e89"></a>(c) Kill Chain 在網路安全防禦中的意義<br />
<div class="outline-text-6" id="text-org2705e89">
<ul class="org-ul">
<li>📌 1. 早期偵測（Early Detection）<br />
Kill Chain 模型能夠協助資安專家在攻擊初期識別惡意活動，如：<br />
<ul class="org-ul">
<li>異常網路存取（偵察階段）<br /></li>
<li>可疑的檔案與郵件（投遞階段）<br /></li>
<li>漏洞攻擊行為（利用階段）<br /></li>
</ul></li>
<li>📌 2. 分層防禦（Defense-in-Depth）<br />
不同的攻擊階段需要不同的防禦策略：<br />
<ul class="org-ul">
<li>偵察 → 防止資訊洩露<br /></li>
<li>投遞 → 攔截惡意郵件與檔案<br /></li>
<li>C2 → 阻擋遠端指揮控制<br /></li>
</ul></li>
<li>📌 3. 事件回應與威脅情報（Incident Response &amp; Threat Intelligence）<br />
資安團隊可以根據 Kill Chain 模型來分析攻擊模式，加快應變與修復：<br />
<ul class="org-ul">
<li>SOC（Security Operation Center）監測可疑活動<br /></li>
<li>SIEM（Security Information &amp; Event Management）記錄與分析事件<br /></li>
<li>威脅情報（Threat Intelligence）比對惡意行為<br /></li>
</ul></li>
<li>📌 4. 阻斷攻擊鏈（Breaking the Kill Chain）<br />
<ul class="org-ul">
<li>只要攻擊鏈中 任一環節遭到阻斷，攻擊便無法繼續進行：<br />
<ul class="org-ul">
<li>在投遞階段攔截惡意郵件 → 避免系統被感染<br /></li>
<li>在 C2 階段封鎖惡意 IP → 讓攻擊者無法遠端控制<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0edf445"></a>(d) 相關計算機概論知識<br />
<div class="outline-text-6" id="text-org0edf445">
<ul class="org-ul">
<li>(1) 網路攻擊與防禦<br />
<ul class="org-ul">
<li>APT（Advanced Persistent Threat，高級持續性攻擊）<br />
<ul class="org-ul">
<li>Kill Chain 特別適用於分析 APT，這類攻擊針對特定目標進行長期滲透。<br /></li>
</ul></li>
<li>MITRE ATT&amp;CK 框架<br />
<ul class="org-ul">
<li>更細緻描述攻擊手法，如權限提升、橫向移動、資料外洩。<br /></li>
</ul></li>
</ul></li>
<li>(2) 惡意軟體與威脅偵測<br />
<ul class="org-ul">
<li>勒索軟體（Ransomware） → 透過 惡意投遞（Delivery） 入侵系統。<br /></li>
<li>殭屍網路（Botnet） → 依賴 C2 指揮控制 遠端操控受害者裝置。<br /></li>
</ul></li>
<li>(3) 企業資安防禦策略<br />
<ul class="org-ul">
<li>SOC（Security Operation Center）<br />
<ul class="org-ul">
<li>監控攻擊行為，利用 Kill Chain 進行威脅分析。<br /></li>
</ul></li>
<li>EDR（Endpoint Detection &amp; Response）<br />
<ul class="org-ul">
<li>針對終端設備進行行為偵測與即時回應。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgefdb981"></a>(e) 結論<br />
<div class="outline-text-6" id="text-orgefdb981">
<ul class="org-ul">
<li>Kill Chain 是網路安全攻防的重要概念，幫助資安專家識別並阻斷攻擊行為。<br /></li>
<li>透過分析攻擊過程，可以建立有效的資安防禦機制，從 偵察、攻擊、控制到最終行動，每個階段都可進行攔截。<br /></li>
<li>資安專業人士應掌握 Kill Chain 模型，並結合 SIEM、SOC、EDR 等技術，來強化防禦能力。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org60b8c43" class="outline-4">
<h4 id="org60b8c43"><span class="section-number-4">8.5.6.</span> 6. (5%)</h4>
<div class="outline-text-4" id="text-8-5-6">
<p>
What are the common ways to provide persistence to objects using relational databases?<br />
</p>
</div>
<div id="outline-container-org72c92a4" class="outline-5">
<h5 id="org72c92a4">解</h5>
<div class="outline-text-5" id="text-org72c92a4">
</div>
<ul class="org-ul">
<li><a id="org1321af9"></a>(a) 何謂物件持久化（Object Persistence）？<br />
<div class="outline-text-6" id="text-org1321af9">
<ul class="org-ul">
<li>📌 物件持久化的定義<br />
物件持久化是指 將程式中的物件（Object）永久儲存到資料庫中，即使應用程式結束運行，這些資料仍然存在，當應用程式重新啟動時，可以再次載入這些物件。<br /></li>
<li>📌 為何需要物件持久化？<br />
<ul class="org-ul">
<li>持久儲存（Persistent Storage）：保留重要資訊，如使用者帳戶、交易紀錄等。<br /></li>
<li>系統重啟後可恢復狀態：避免資料丟失。<br /></li>
<li>支援資料共享：不同使用者可存取相同資料。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org58a657b"></a>(b) 物件持久化的常見方法<br />
<div class="outline-text-6" id="text-org58a657b">
<p>
-📌 目前，使用關聯式資料庫（RDBMS）來存儲物件的方法主要有以下幾種：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org1ef6a00"></a>1. 直接使用 SQL（手寫 SQL）<br />
<div class="outline-text-7" id="text-org1ef6a00">
<ul class="org-ul">
<li>📌 方法：開發者直接撰寫 SQL 語句來進行資料的存取與更新，如 INSERT、SELECT、UPDATE、DELETE 等。<br /></li>
<li>📌 範例（Java + JDBC）<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Connection conn = DriverManager.getConnection(<span style="color: #98be65;">"jdbc:mysql://localhost:3306/db"</span>, <span style="color: #98be65;">"user"</span>, <span style="color: #98be65;">"password"</span>);
<span class="linenr">2: </span>PreparedStatement stmt = conn.prepareStatement(<span style="color: #98be65;">"INSERT INTO Users (id, name) VALUES (?, ?)"</span>);
<span class="linenr">3: </span>stmt.setInt(<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">1</span>);
<span class="linenr">4: </span>stmt.setString(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #98be65;">"John"</span>);
<span class="linenr">5: </span>stmt.executeUpdate();
</pre>
</div>
<p>
📌 優點<br />
</p>
<ul class="org-ul">
<li>靈活性高：開發者可以完全控制 SQL 查詢的優化與效能。<br /></li>
<li>適用於簡單應用：如果應用程式很小且查詢語句不複雜，可以直接使用 SQL。<br /></li>
</ul>
<p>
📌 缺點<br />
</p>
<ul class="org-ul">
<li>開發成本高：程式碼中混雜 SQL，使得維護困難。<br /></li>
<li>可攜性低：不同資料庫的 SQL 語法可能不同，導致遷移困難。<br /></li>
<li>手動轉換物件：需要手動將資料庫查詢結果轉換為物件，增加開發負擔。<br /></li>
</ul>
</div>
</li>
<li><a id="org8a54ca5"></a>2. 使用 ORM（Object-Relational Mapping）<br />
<div class="outline-text-7" id="text-org8a54ca5">
<ul class="org-ul">
<li>📌 方法：透過 ORM 框架（如 Hibernate、JPA、MyBatis）將程式中的物件自動對應到關聯式資料庫表。<br /></li>
<li>📌 範例（Java + Hibernate）<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>@Entity
<span class="linenr"> 2: </span>@Table(name = <span style="color: #98be65;">"Users"</span>)
<span class="linenr"> 3: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> User {
<span class="linenr"> 4: </span>    @Id
<span class="linenr"> 5: </span>    @GeneratedValue(strategy = GenerationType.IDENTITY)
<span class="linenr"> 6: </span>    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">id</span>;
<span class="linenr"> 7: </span>    <span style="color: #51afef;">private</span> String name;
<span class="linenr"> 8: </span>}
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992; Hibernate &#23384;&#20786;&#29289;&#20214;</span>
<span class="linenr">11: </span>Session session = sessionFactory.openSession();
<span class="linenr">12: </span>Transaction tx = session.beginTransaction();
<span class="linenr">13: </span>User user = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">User</span>();
<span class="linenr">14: </span>user.setName(<span style="color: #98be65;">"John"</span>);
<span class="linenr">15: </span>session.save(user);
<span class="linenr">16: </span>tx.commit();
<span class="linenr">17: </span>session.close();
</pre>
</div>
<ul class="org-ul">
<li>📌 優點<br />
物件與資料庫映射自動化：開發者無需手動撰寫 SQL 查詢。<br />
增強可移植性：ORM 框架可適應不同的資料庫系統。<br />
提高開發效率：簡化 CRUD（Create, Read, Update, Delete）操作。<br /></li>
<li>📌 缺點<br />
<ul class="org-ul">
<li>學習曲線較高：需要學習 ORM 框架的 API 與設定方式。<br /></li>
<li>效能問題：ORM 產生的 SQL 可能不是最佳化的，需要額外調校。<br /></li>
<li>較難進行複雜查詢：如果應用需要高度最佳化的 SQL 查詢，ORM 可能不夠靈活。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org68ff5eb"></a>3. 使用 Data Access Object（DAO）模式<br />
<div class="outline-text-7" id="text-org68ff5eb">
<ul class="org-ul">
<li>📌 方法：DAO 層封裝資料存取邏輯，提供統一 API 操作資料庫。<br /></li>
<li>📌 範例（Java + DAO + JDBC）<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> UserDAO {
<span class="linenr">2: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">insertUser</span>(User user) <span style="color: #51afef;">throws</span> SQLException {
<span class="linenr">3: </span>        Connection conn = DriverManager.getConnection(<span style="color: #98be65;">"jdbc:mysql://localhost:3306/db"</span>, <span style="color: #98be65;">"user"</span>, <span style="color: #98be65;">"password"</span>);
<span class="linenr">4: </span>        PreparedStatement stmt = conn.prepareStatement(<span style="color: #98be65;">"INSERT INTO Users (name) VALUES (?)"</span>);
<span class="linenr">5: </span>        stmt.setString(<span style="color: #da8548; font-weight: bold;">1</span>, user.getName());
<span class="linenr">6: </span>        stmt.executeUpdate();
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>}
</pre>
</div>
<ul class="org-ul">
<li>📌 優點<br />
<ul class="org-ul">
<li>可維護性高：將資料存取邏輯封裝起來，應用程式的其他部分不需要關心 SQL 細節。<br /></li>
<li>適合與 ORM 結合使用：可以搭配 Hibernate、JPA 來簡化存取操作。<br /></li>
</ul></li>
<li>📌 缺點<br />
<ul class="org-ul">
<li>仍需要手動撰寫 SQL：如果不搭配 ORM，開發者仍需處理 SQL 語法。<br /></li>
<li>與 ORM 相比功能有限：DAO 主要用於 CRUD 操作，不如 ORM 提供豐富的物件管理功能。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orga4d82bf"></a>4. 使用 NoSQL + 關聯式資料庫（Hybrid Approach）<br />
<div class="outline-text-7" id="text-orga4d82bf">
<ul class="org-ul">
<li>📌 方法：將關聯式資料庫與 NoSQL（如 MongoDB、Redis）結合，利用關聯式資料庫存儲結構化資料，NoSQL 存儲非結構化或快取資料。<br /></li>
<li>📌 範例<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992; Redis &#20316;&#28858;&#24555;&#21462;</span>
<span class="linenr">2: </span>Jedis jedis = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Jedis</span>(<span style="color: #98be65;">"localhost"</span>);
<span class="linenr">3: </span>jedis.set(<span style="color: #98be65;">"user:1"</span>, <span style="color: #98be65;">"{id:1, name:'John'}"</span>);
<span class="linenr">4: </span>
<span class="linenr">5: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35712;&#21462; Redis &#24555;&#21462;</span>
<span class="linenr">6: </span>String userData = jedis.get(<span style="color: #98be65;">"user:1"</span>);
<span class="linenr">7: </span>System.out.println(userData);
</pre>
</div>
<ul class="org-ul">
<li>📌 優點<br />
<ul class="org-ul">
<li>提高查詢效能：可以將常用的資料快取在 NoSQL，提高存取速度。<br /></li>
<li>適應大數據應用：結合關聯式資料庫與 NoSQL，處理大量資料時更具彈性。<br /></li>
</ul></li>
<li>📌 缺點<br />
<ul class="org-ul">
<li>系統架構較為複雜：需要處理資料一致性與同步問題。<br /></li>
<li>開發成本較高：需要管理多種不同的資料存儲系統。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org8d42a94"></a>(c) 相關計算機概論知識<br />
<div class="outline-text-6" id="text-org8d42a94">
<ul class="org-ul">
<li>(1) 資料庫基礎<br />
<ul class="org-ul">
<li>關聯式資料庫（RDBMS）：MySQL、PostgreSQL、Oracle、SQL Server。<br /></li>
<li>NoSQL 資料庫：MongoDB（文件型）、Redis（鍵值型）、Cassandra（列式）。<br /></li>
<li>SQL vs. NoSQL：SQL 適合結構化資料，NoSQL 適合非結構化與高擴展性應用。<br /></li>
</ul></li>
<li>(2) 物件導向與資料存取<br />
<ul class="org-ul">
<li>ORM（Object-Relational Mapping）：<br />
<ul class="org-ul">
<li>Hibernate（Java）、JPA、Entity Framework（.NET）、SQLAlchemy（Python）。<br /></li>
</ul></li>
<li>DAO（Data Access Object）模式：<br />
<ul class="org-ul">
<li>將資料存取封裝為類別，提供統一 API。<br /></li>
</ul></li>
</ul></li>
<li>(3) 資料庫最佳化技術<br />
<ul class="org-ul">
<li>快取技術（Caching）：使用 Redis、Memcached 減少資料庫負擔。<br /></li>
<li>索引（Index）優化：使用 B-Tree、Hash Index 加速查詢。<br /></li>
<li>分割（Sharding）:將大型資料庫拆分為多個分區，提高讀取效能。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc0aa54f" class="outline-4">
<h4 id="orgc0aa54f"><span class="section-number-4">8.5.7.</span> 7.  (7%) 連題目都能出錯，這間學校也太隨便&#x2026;..</h4>
<div class="outline-text-4" id="text-8-5-7">
<p>
What are the common ways to provide persistence to objects using relational databases?<br />
</p>
</div>
<div id="outline-container-org795c22e" class="outline-5">
<h5 id="org795c22e">解</h5>
</div>
</div>
<div id="outline-container-orgadefedb" class="outline-4">
<h4 id="orgadefedb"><span class="section-number-4">8.5.8.</span> 8. (10%)</h4>
<div class="outline-text-4" id="text-8-5-8">
<p>
Please explain when to use total specialization and when to use partial specialization.<br />
</p>
</div>
<div id="outline-container-org308738f" class="outline-5">
<h5 id="org308738f">解</h5>
<div class="outline-text-5" id="text-org308738f">
</div>
<ul class="org-ul">
<li><a id="org8eba24d"></a>(a) 何謂特殊化（Specialization）？<br />
<div class="outline-text-6" id="text-org8eba24d">
<ul class="org-ul">
<li>📌 特殊化（Specialization） 是物件導向設計中的概念，指的是 從一個更一般的類別（超類別，Superclass）衍生出較具體的子類別（Subclass）。這些子類別可以繼承父類別的屬性和方法，並根據需求覆寫（Override）或擴充（Extend）功能。<br /></li>
<li>📌 為何需要特殊化？<br />
<ul class="org-ul">
<li>提升可讀性與可維護性：讓類別結構更清晰，避免程式碼重複（Code Duplication）。<br /></li>
<li>彈性化與擴充性：可以根據不同需求設計多個子類別，提供不同的行為。<br /></li>
<li>符合物件導向原則：如 開放封閉原則（OCP, Open-Closed Principle），允許擴充但不修改既有類別。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgecdd99b"></a>(b) 何謂「完全特殊化（Total Specialization）」？<br />
<div class="outline-text-6" id="text-orgecdd99b">
<ul class="org-ul">
<li>📌 定義 完全特殊化指的是 在繼承過程中，父類別的所有實例都必須屬於某個子類別，亦即「父類別的所有成員都屬於某個具體子類別」，不允許存在「只屬於父類別但不屬於子類別」的成員。<br /></li>
<li>📌 適用情境<br />
<ul class="org-ul">
<li>當 所有物件 都應該被進一步分類，而 不允許直接建立父類別的實例。<br /></li>
<li>例如：動物（Animal）類別必須是具體的某種動物（如狗、貓、鳥），不能只是「抽象的動物」。<br /></li>
</ul></li>
<li><p>
📌 範例<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>  <span style="color: #51afef;">abstract</span> <span style="color: #51afef;">class</span> Animal {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25277;&#35937;&#39006;&#21029;&#65292;&#19981;&#33021;&#30452;&#25509;&#23526;&#20363;&#21270;</span>
<span class="linenr"> 2: </span>      String name;
<span class="linenr"> 3: </span>      <span style="color: #51afef;">abstract</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>();
<span class="linenr"> 4: </span>  }
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  <span style="color: #51afef;">class</span> Dog <span style="color: #51afef;">extends</span> Animal {
<span class="linenr"> 7: </span>      <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr"> 8: </span>          System.out.println(<span style="color: #98be65;">"Woof! Woof!"</span>);
<span class="linenr"> 9: </span>      }
<span class="linenr">10: </span>  }
<span class="linenr">11: </span>
<span class="linenr">12: </span>  <span style="color: #51afef;">class</span> Cat <span style="color: #51afef;">extends</span> Animal {
<span class="linenr">13: </span>      <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr">14: </span>          System.out.println(<span style="color: #98be65;">"Meow! Meow!"</span>);
<span class="linenr">15: </span>      }
<span class="linenr">16: </span>  }
</pre>
</div></li>
<li>📌 關鍵點<br />
<ul class="org-ul">
<li>Animal 是抽象類別，不能直接實例化，所有動物物件都必須是 Dog 或 Cat，這就是完全特殊化的概念。<br /></li>
<li><p>
若試圖建立 Animal 物件，會發生編譯錯誤：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    Animal a = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Animal</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#10060; &#37679;&#35492;&#65306;&#25277;&#35937;&#39006;&#21029;&#28961;&#27861;&#34987;&#23526;&#20363;&#21270;</span>
</pre>
</div></li>
<li><p>
必須具體到「貓」或「狗」：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    Animal dog = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#20801;&#35377;</span>
</pre>
</div></li>
</ul></li>
<li>📌 何時使用完全特殊化？<br />
<ul class="org-ul">
<li>當基礎類別應該是抽象的（Abstract）<br />
<ul class="org-ul">
<li>如 Animal、Shape（形狀）等概念，應該只能作為「模板」，而不能直接實例化。<br /></li>
</ul></li>
<li>當所有子類別都能夠完整涵蓋父類別的概念<br />
<ul class="org-ul">
<li><p>
例如「支付方式（PaymentMethod）」的概念，所有交易都必須透過某種支付方式完成：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>      <span style="color: #51afef;">abstract</span> <span style="color: #51afef;">class</span> PaymentMethod {}
<span class="linenr">2: </span>      <span style="color: #51afef;">class</span> CreditCard <span style="color: #51afef;">extends</span> PaymentMethod {}
<span class="linenr">3: </span>      <span style="color: #51afef;">class</span> PayPal <span style="color: #51afef;">extends</span> PaymentMethod {}
</pre>
</div></li>
<li>在這種情況下，「支付方式」本身沒有實際用途，而必須是某種特定支付方式（如信用卡或 PayPal）。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org87bbfcc"></a>(c) 何謂「部分特殊化（Partial Specialization）」？<br />
<div class="outline-text-6" id="text-org87bbfcc">
<ul class="org-ul">
<li>📌 定義 部分特殊化指的是 允許父類別的部分實例仍然屬於父類別本身，而不一定屬於某個具體的子類別。換句話說，可以直接建立父類別的物件，但某些子類別用來表示特殊情境。<br /></li>
<li>📌 適用情境<br />
<ul class="org-ul">
<li>當基礎類別（父類別）仍然可以獨立運作，但有些特定場合下可以使用子類別來做更細緻的分類。<br /></li>
<li>例如：「員工（Employee）」可能分成「正職（FullTimeEmployee）」與「兼職（PartTimeEmployee）」，但仍允許一般 Employee 存在。<br /></li>
</ul></li>
<li><p>
📌 範例<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>  <span style="color: #51afef;">class</span> Employee {
<span class="linenr"> 2: </span>      String name;
<span class="linenr"> 3: </span>      <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">salary</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>      Employee(String name, <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">salary</span>) {
<span class="linenr"> 6: </span>          <span style="color: #a9a1e1;">this</span>.name = name;
<span class="linenr"> 7: </span>          <span style="color: #a9a1e1;">this</span>.salary = salary;
<span class="linenr"> 8: </span>      }
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>      <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">displayInfo</span>() {
<span class="linenr">11: </span>          System.out.println(<span style="color: #98be65;">"Employee: "</span> + name + <span style="color: #98be65;">", Salary: "</span> + salary);
<span class="linenr">12: </span>      }
<span class="linenr">13: </span>  }
<span class="linenr">14: </span>
<span class="linenr">15: </span>  <span style="color: #51afef;">class</span> FullTimeEmployee <span style="color: #51afef;">extends</span> Employee {
<span class="linenr">16: </span>      FullTimeEmployee(String name, <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">salary</span>) {
<span class="linenr">17: </span>          <span style="color: #51afef;">super</span>(name, salary);
<span class="linenr">18: </span>      }
<span class="linenr">19: </span>
<span class="linenr">20: </span>      <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">displayInfo</span>() {
<span class="linenr">21: </span>          System.out.println(<span style="color: #98be65;">"Full-Time Employee: "</span> + name + <span style="color: #98be65;">", Salary: "</span> + salary);
<span class="linenr">22: </span>      }
<span class="linenr">23: </span>  }
<span class="linenr">24: </span>
<span class="linenr">25: </span>  <span style="color: #51afef;">class</span> PartTimeEmployee <span style="color: #51afef;">extends</span> Employee {
<span class="linenr">26: </span>      PartTimeEmployee(String name, <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">salary</span>) {
<span class="linenr">27: </span>          <span style="color: #51afef;">super</span>(name, salary);
<span class="linenr">28: </span>      }
<span class="linenr">29: </span>
<span class="linenr">30: </span>      <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">displayInfo</span>() {
<span class="linenr">31: </span>          System.out.println(<span style="color: #98be65;">"Part-Time Employee: "</span> + name + <span style="color: #98be65;">", Salary: "</span> + salary);
<span class="linenr">32: </span>      }
<span class="linenr">33: </span>  }
</pre>
</div></li>
<li>📌 關鍵點<br />
<ul class="org-ul">
<li><p>
Employee 可以直接被實例化：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    Employee e1 = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Employee</span>(<span style="color: #98be65;">"Alice"</span>, <span style="color: #da8548; font-weight: bold;">50000</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#9989; &#20801;&#35377;</span>
</pre>
</div></li>
<li><p>
但我們也可以創建「正職員工」或「兼職員工」：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>        Employee e2 = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">FullTimeEmployee</span>(<span style="color: #98be65;">"Bob"</span>, <span style="color: #da8548; font-weight: bold;">60000</span>);
<span class="linenr">2: </span>        Employee e3 = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">PartTimeEmployee</span>(<span style="color: #98be65;">"Charlie"</span>, <span style="color: #da8548; font-weight: bold;">30000</span>);
</pre>
</div></li>
</ul></li>
<li>📌 何時使用部分特殊化？<br />
<ul class="org-ul">
<li>當基礎類別仍有意義並可獨立使用<br />
<ul class="org-ul">
<li>例如 Employee 可以存在於公司裡，即使我們不明確標記它為「正職」或「兼職」。<br /></li>
</ul></li>
<li>當子類別是可選的<br />
<ul class="org-ul">
<li>有些類別只是在特定情境下提供更精細的分類，如 ElectricCar extends Car，但 Car 本身仍然可以獨立存在。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0e5e91e"></a>(d) 總結：完全 vs. 部分特殊化<br />
<div class="outline-text-6" id="text-org0e5e91e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特殊化類型</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">完全特殊化</td>
<td class="org-left">父類別為抽象類別，不能被直接實例化，所有物件都必須屬於某個子類別</td>
</tr>

<tr>
<td class="org-left">部分特殊化</td>
<td class="org-left">父類別仍可被實例化，但子類別用於提供特定的功能或分類</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>📌 如何判斷應該用哪一種？<br />
<ul class="org-ul">
<li>如果 父類別應該只能作為「概念」存在，不能直接實例化 → 使用完全特殊化（定義為 abstract class）。<br /></li>
<li>如果 父類別本身仍然可以有實例，但可以被細分 → 使用部分特殊化（可直接 new 父類別）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf46729b"></a>(e) 相關計算機概論知識<br />
<div class="outline-text-6" id="text-orgf46729b">
<ul class="org-ul">
<li>物件導向程式設計（OOP）<br />
<ul class="org-ul">
<li>類別（Class）、繼承（Inheritance）、封裝（Encapsulation）、多型（Polymorphism）。<br /></li>
</ul></li>
<li>抽象類別 vs. 介面（Abstract Class vs. Interface）<br />
<ul class="org-ul">
<li>何時使用抽象類別？何時使用介面？<br /></li>
</ul></li>
<li>UML 類別圖（Class Diagram）<br />
<ul class="org-ul">
<li>使用 UML 圖表示類別的關係，如 泛化（Generalization） 和 特殊化（Specialization）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc3fa917"></a>(f) 結論<br />
<div class="outline-text-6" id="text-orgc3fa917">
<ul class="org-ul">
<li>📌 完全特殊化 適用於「基礎類別本身不應存在，所有實例都應該是具體類別」。<br /></li>
<li>📌 部分特殊化 適用於「基礎類別本身仍可獨立運作，但子類別用於更精細的分類」。<br /></li>
<li>📌 選擇特殊化類型時，需考量父類別是否仍具有獨立存在的價值。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org08ffc00" class="outline-4">
<h4 id="org08ffc00"><span class="section-number-4">8.5.9.</span> 9. (15%)請寫出下面java 程式的執行結果</h4>
<div class="outline-text-4" id="text-8-5-9">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> Count {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">A</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) {
<span class="linenr"> 3: </span>        <span style="color: #51afef;">if</span> (x&lt;<span style="color: #da8548; font-weight: bold;">30</span>) x=A(x+<span style="color: #da8548; font-weight: bold;">5</span>)+B(x);
<span class="linenr"> 4: </span>        <span style="color: #51afef;">return</span> x;
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">B</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) {
<span class="linenr"> 7: </span>        System.out.print(<span style="color: #98be65;">"*"</span>);
<span class="linenr"> 8: </span>        <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">4</span>*x;
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">C</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) {
<span class="linenr">11: </span>        System.out.print(<span style="color: #98be65;">"#"</span>);
<span class="linenr">12: </span>        <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">3</span>*A(x-<span style="color: #da8548; font-weight: bold;">4</span>);
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">15: </span>        System.out.println(A(<span style="color: #da8548; font-weight: bold;">4</span>));
<span class="linenr">16: </span>        System.out.println(B(<span style="color: #da8548; font-weight: bold;">4</span>));
<span class="linenr">17: </span>        System.out.println(C(<span style="color: #da8548; font-weight: bold;">4</span>));
<span class="linenr">18: </span>    }
<span class="linenr">19: </span>}
</pre>
</div>
</div>
<div id="outline-container-org3cc61eb" class="outline-5">
<h5 id="org3cc61eb">解</h5>
</div>
</div>
<div id="outline-container-org5581e9c" class="outline-4">
<h4 id="org5581e9c"><span class="section-number-4">8.5.10.</span> 10. (10%)請問下面 java 程式是否可以執行，如果你判定可以執行的話，請寫出執行結果。如果你判 定無法執行的話，請指出錯誤的地方，並將其改正及寫出你預期的執行結果</h4>
<div class="outline-text-4" id="text-8-5-10">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> MyParser {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">parse</span>(String str) {
<span class="linenr"> 3: </span>        <span style="color: #51afef;">try</span> {
<span class="linenr"> 4: </span>            Float f = Float.parseFloat(str);
<span class="linenr"> 5: </span>        } <span style="color: #51afef;">catch</span> (NumberFormatException nfe) {
<span class="linenr"> 6: </span>           f=<span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 7: </span>        } <span style="color: #51afef;">finally</span> {
<span class="linenr"> 8: </span>            System.out.println(f);
<span class="linenr"> 9: </span>        }
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">12: </span>        parse(<span style="color: #98be65;">"invalid"</span>);
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>}
</pre>
</div>
</div>
<div id="outline-container-orgf61a466" class="outline-5">
<h5 id="orgf61a466">解</h5>
<div class="outline-text-5" id="text-orgf61a466">
</div>
<ul class="org-ul">
<li><a id="org505d52d"></a>程式碼解析<br />
<div class="outline-text-6" id="text-org505d52d">
<p>
程式包含三個靜態方法：<br />
</p>
<ul class="org-ul">
<li>A(int x)<br />
<ul class="org-ul">
<li>若 x &lt; 30，則 A(x) 會遞迴呼叫 A(x+5)，並加上 B(x) 的回傳值。<br /></li>
<li>若 x &gt;= 30，則直接回傳 x。<br /></li>
</ul></li>
<li>B(int x)<br />
<ul class="org-ul">
<li>每次呼叫 B(x) 都會輸出 *，然後回傳 4*x。<br /></li>
</ul></li>
<li>C(int x)<br />
<ul class="org-ul">
<li>每次呼叫 C(x) 都會輸出 #，然後回傳 3 * A(x-4)。<br /></li>
</ul></li>
<li>main 方法<br />
<ul class="org-ul">
<li>依序呼叫 A(4), B(4), C(4) 並印出結果。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org4c51468"></a>分析 A(4) 的執行<br />
<div class="outline-text-6" id="text-org4c51468">
<p>
執行 A(4) 會觸發遞迴呼叫：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>A(<span style="color: #da8548; font-weight: bold;">4</span>) = A(<span style="color: #da8548; font-weight: bold;">9</span>) + B(<span style="color: #da8548; font-weight: bold;">4</span>)
<span class="linenr">2: </span>A(<span style="color: #da8548; font-weight: bold;">9</span>) = A(<span style="color: #da8548; font-weight: bold;">14</span>) + B(<span style="color: #da8548; font-weight: bold;">9</span>)
<span class="linenr">3: </span>A(<span style="color: #da8548; font-weight: bold;">14</span>) = A(<span style="color: #da8548; font-weight: bold;">19</span>) + B(<span style="color: #da8548; font-weight: bold;">14</span>)
<span class="linenr">4: </span>A(<span style="color: #da8548; font-weight: bold;">19</span>) = A(<span style="color: #da8548; font-weight: bold;">24</span>) + B(<span style="color: #da8548; font-weight: bold;">19</span>)
<span class="linenr">5: </span>A(<span style="color: #da8548; font-weight: bold;">24</span>) = A(<span style="color: #da8548; font-weight: bold;">29</span>) + B(<span style="color: #da8548; font-weight: bold;">24</span>)
<span class="linenr">6: </span>A(<span style="color: #da8548; font-weight: bold;">29</span>) = A(<span style="color: #da8548; font-weight: bold;">34</span>) + B(<span style="color: #da8548; font-weight: bold;">29</span>)
<span class="linenr">7: </span>A(<span style="color: #da8548; font-weight: bold;">34</span>) = <span style="color: #da8548; font-weight: bold;">34</span>  (&#22240;&#28858; x &gt;= <span style="color: #da8548; font-weight: bold;">30</span> &#30452;&#25509;&#22238;&#20659;)
</pre>
</div>
<p>
然後回溯：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>A(<span style="color: #da8548; font-weight: bold;">29</span>) = <span style="color: #da8548; font-weight: bold;">34</span> + B(<span style="color: #da8548; font-weight: bold;">29</span>) = <span style="color: #da8548; font-weight: bold;">34</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">29</span>) = <span style="color: #da8548; font-weight: bold;">34</span> + <span style="color: #da8548; font-weight: bold;">116</span> = <span style="color: #da8548; font-weight: bold;">150</span>
<span class="linenr">2: </span>A(<span style="color: #da8548; font-weight: bold;">24</span>) = <span style="color: #da8548; font-weight: bold;">150</span> + B(<span style="color: #da8548; font-weight: bold;">24</span>) = <span style="color: #da8548; font-weight: bold;">150</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">24</span>) = <span style="color: #da8548; font-weight: bold;">150</span> + <span style="color: #da8548; font-weight: bold;">96</span> = <span style="color: #da8548; font-weight: bold;">246</span>
<span class="linenr">3: </span>A(<span style="color: #da8548; font-weight: bold;">19</span>) = <span style="color: #da8548; font-weight: bold;">246</span> + B(<span style="color: #da8548; font-weight: bold;">19</span>) = <span style="color: #da8548; font-weight: bold;">246</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">19</span>) = <span style="color: #da8548; font-weight: bold;">246</span> + <span style="color: #da8548; font-weight: bold;">76</span> = <span style="color: #da8548; font-weight: bold;">322</span>
<span class="linenr">4: </span>A(<span style="color: #da8548; font-weight: bold;">14</span>) = <span style="color: #da8548; font-weight: bold;">322</span> + B(<span style="color: #da8548; font-weight: bold;">14</span>) = <span style="color: #da8548; font-weight: bold;">322</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">14</span>) = <span style="color: #da8548; font-weight: bold;">322</span> + <span style="color: #da8548; font-weight: bold;">56</span> = <span style="color: #da8548; font-weight: bold;">378</span>
<span class="linenr">5: </span>A(<span style="color: #da8548; font-weight: bold;">9</span>) = <span style="color: #da8548; font-weight: bold;">378</span> + B(<span style="color: #da8548; font-weight: bold;">9</span>) = <span style="color: #da8548; font-weight: bold;">378</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">9</span>) = <span style="color: #da8548; font-weight: bold;">378</span> + <span style="color: #da8548; font-weight: bold;">36</span> = <span style="color: #da8548; font-weight: bold;">414</span>
<span class="linenr">6: </span>A(<span style="color: #da8548; font-weight: bold;">4</span>) = <span style="color: #da8548; font-weight: bold;">414</span> + B(<span style="color: #da8548; font-weight: bold;">4</span>) = <span style="color: #da8548; font-weight: bold;">414</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">4</span>) = <span style="color: #da8548; font-weight: bold;">414</span> + <span style="color: #da8548; font-weight: bold;">16</span> = <span style="color: #da8548; font-weight: bold;">430</span>
</pre>
</div>
<p>
輸出 A(4) = 430，並且 B(x) 會輸出 * 六次。<br />
</p>
</div>
</li>
<li><a id="org8eb9eb3"></a>分析 B(4) 的執行<br />
<div class="outline-text-6" id="text-org8eb9eb3">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>B(<span style="color: #da8548; font-weight: bold;">4</span>) = print(<span style="color: #98be65;">"*"</span>) + <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">4</span>
</pre>
</div>
<p>
輸出 *，回傳 16。<br />
</p>
</div>
</li>
<li><a id="org1ee1d82"></a>分析 C(4) 的執行<br />
<div class="outline-text-6" id="text-org1ee1d82">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>C(<span style="color: #da8548; font-weight: bold;">4</span>) = print(<span style="color: #98be65;">"#"</span>) + <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">3</span> * A(<span style="color: #da8548; font-weight: bold;">0</span>)
</pre>
</div>
<p>
A(0)：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>A(<span style="color: #da8548; font-weight: bold;">0</span>) = A(<span style="color: #da8548; font-weight: bold;">5</span>) + B(<span style="color: #da8548; font-weight: bold;">0</span>)
<span class="linenr">2: </span>A(<span style="color: #da8548; font-weight: bold;">5</span>) = A(<span style="color: #da8548; font-weight: bold;">10</span>) + B(<span style="color: #da8548; font-weight: bold;">5</span>)
<span class="linenr">3: </span>A(<span style="color: #da8548; font-weight: bold;">10</span>) = A(<span style="color: #da8548; font-weight: bold;">15</span>) + B(<span style="color: #da8548; font-weight: bold;">10</span>)
<span class="linenr">4: </span>A(<span style="color: #da8548; font-weight: bold;">15</span>) = A(<span style="color: #da8548; font-weight: bold;">20</span>) + B(<span style="color: #da8548; font-weight: bold;">15</span>)
<span class="linenr">5: </span>A(<span style="color: #da8548; font-weight: bold;">20</span>) = A(<span style="color: #da8548; font-weight: bold;">25</span>) + B(<span style="color: #da8548; font-weight: bold;">20</span>)
<span class="linenr">6: </span>A(<span style="color: #da8548; font-weight: bold;">25</span>) = A(<span style="color: #da8548; font-weight: bold;">30</span>) + B(<span style="color: #da8548; font-weight: bold;">25</span>)
<span class="linenr">7: </span>A(<span style="color: #da8548; font-weight: bold;">30</span>) = <span style="color: #da8548; font-weight: bold;">30</span>
</pre>
</div>
<p>
回溯：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>A(<span style="color: #da8548; font-weight: bold;">25</span>) = <span style="color: #da8548; font-weight: bold;">30</span> + B(<span style="color: #da8548; font-weight: bold;">25</span>) = <span style="color: #da8548; font-weight: bold;">30</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">25</span>) = <span style="color: #da8548; font-weight: bold;">30</span> + <span style="color: #da8548; font-weight: bold;">100</span> = <span style="color: #da8548; font-weight: bold;">130</span>
<span class="linenr">2: </span>A(<span style="color: #da8548; font-weight: bold;">20</span>) = <span style="color: #da8548; font-weight: bold;">130</span> + B(<span style="color: #da8548; font-weight: bold;">20</span>) = <span style="color: #da8548; font-weight: bold;">130</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">20</span>) = <span style="color: #da8548; font-weight: bold;">130</span> + <span style="color: #da8548; font-weight: bold;">80</span> = <span style="color: #da8548; font-weight: bold;">210</span>
<span class="linenr">3: </span>A(<span style="color: #da8548; font-weight: bold;">15</span>) = <span style="color: #da8548; font-weight: bold;">210</span> + B(<span style="color: #da8548; font-weight: bold;">15</span>) = <span style="color: #da8548; font-weight: bold;">210</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">15</span>) = <span style="color: #da8548; font-weight: bold;">210</span> + <span style="color: #da8548; font-weight: bold;">60</span> = <span style="color: #da8548; font-weight: bold;">270</span>
<span class="linenr">4: </span>A(<span style="color: #da8548; font-weight: bold;">10</span>) = <span style="color: #da8548; font-weight: bold;">270</span> + B(<span style="color: #da8548; font-weight: bold;">10</span>) = <span style="color: #da8548; font-weight: bold;">270</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">10</span>) = <span style="color: #da8548; font-weight: bold;">270</span> + <span style="color: #da8548; font-weight: bold;">40</span> = <span style="color: #da8548; font-weight: bold;">310</span>
<span class="linenr">5: </span>A(<span style="color: #da8548; font-weight: bold;">5</span>) = <span style="color: #da8548; font-weight: bold;">310</span> + B(<span style="color: #da8548; font-weight: bold;">5</span>) = <span style="color: #da8548; font-weight: bold;">310</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">5</span>) = <span style="color: #da8548; font-weight: bold;">310</span> + <span style="color: #da8548; font-weight: bold;">20</span> = <span style="color: #da8548; font-weight: bold;">330</span>
<span class="linenr">6: </span>A(<span style="color: #da8548; font-weight: bold;">0</span>) = <span style="color: #da8548; font-weight: bold;">330</span> + B(<span style="color: #da8548; font-weight: bold;">0</span>) = <span style="color: #da8548; font-weight: bold;">330</span> + (<span style="color: #da8548; font-weight: bold;">4</span>*<span style="color: #da8548; font-weight: bold;">0</span>) = <span style="color: #da8548; font-weight: bold;">330</span> + <span style="color: #da8548; font-weight: bold;">0</span> = <span style="color: #da8548; font-weight: bold;">330</span>
</pre>
</div>
<p>
C(4) = 3 * 330 = 990，並且 B(x) 輸出 * 六次，C(4) 輸出 # 一次。<br />
</p>
</div>
</li>
<li><a id="orge5f2f87"></a>最終輸出<br />
<div class="outline-text-6" id="text-orge5f2f87">
<p>
程式最終輸出的結果：<br />
</p>
<pre class="example" id="org7fa97e4">
******430
*16
#******990
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org56034ed" class="outline-2">
<h2 id="org56034ed"><span class="section-number-2">9.</span> 中山近三年考題及詳解</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org11ee973" class="outline-3">
<h3 id="org11ee973"><span class="section-number-3">9.1.</span> 110: 中山管理資訊系統</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-org066d7e6" class="outline-4">
<h4 id="org066d7e6"><span class="section-number-4">9.1.1.</span> 1. 人工智慧(Artificial Intelligence)是近年來相當受到注目的資訊發展，而其中的發展理論可以分為兩大學派，分別為法則學派(Rule-based Approach)與機器學習學派(Machine Learning Approach)。</h4>
<div class="outline-text-4" id="text-9-1-1">
</div>
<div id="outline-container-org8b17d33" class="outline-5">
<h5 id="org8b17d33">(1)機器學習學派有四種不同類型，分別為非監督式學習(Unsupervised)、半監督式學習(Semi-supervised)、監督式學習(Supervised)與增強式學習(Reinforcements Learning)，試說明這四種不同類型，並舉例說明之。<code>[12%]</code></h5>
<div class="outline-text-5" id="text-org8b17d33">
</div>
<ul class="org-ul">
<li><a id="orgd10201c"></a>解答<br />
<div class="outline-text-6" id="text-orgd10201c">
<ol class="org-ol">
<li>非監督式學習 (Unsupervised Learning): 此類學習的特點是沒有標籤的數據，模型需要自行從數據中找出模式或結構。例如：分群算法 (clustering) 可以將數據分為不同的組別，但事先並不知道這些組別的意義。<br /></li>
<li>半監督式學習 (Semi-supervised Learning): 此類學習使用部分標籤的數據來訓練模型。它介於監督式學習和非監督式學之間，利用少量標籤數據來輔助訓練，提高模型的泛化能力。<br /></li>
<li>監督式學習 (Supervised Learning): 此類學習使用標籤數據來訓練模型，讓模型學習輸入和輸出之間的關係。例如：分類 (classification) 和迴歸 (regression) 問題都屬於監督式學習的範疇。<br /></li>
<li>增強式學習 (Reinforcement Learning): 此類學習通過與環境互動，根據獎勵或懲罰來學習最佳策略。模型會嘗試不同的行動，並根據結果調整策略，以最大化累積獎勵。例如：訓練機器人行走、玩遊戲等。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org61b1691" class="outline-5">
<h5 id="org61b1691">(2)機器學習學派與法則學派兩者的特性與區別在哪？ 兩者與傳統的統計學方法差別又在哪？ <code>[13%]</code></h5>
<div class="outline-text-5" id="text-org61b1691">
</div>
<ul class="org-ul">
<li><a id="orgdc848d8"></a>解<br />
<div class="outline-text-6" id="text-orgdc848d8">
<ul class="org-ul">
<li>法則學派 (Rule-based Approach):<br />
<ul class="org-ul">
<li>特性： 依賴人為事先定義好的規則來解決問題。專家需要將領域知識編寫成明確的規則，然後讓系統根據這些規則進行推理和決策。<br /></li>
<li>優點： 容易理解和解釋，適用於規則明確且不複雜的問題。<br /></li>
<li>缺點： 需要大量人工編寫規則，難以處理複雜和不確定的情況。<br /></li>
</ul></li>
<li>機器學習學派 (Machine Learning Approach):<br />
<ul class="org-ul">
<li>特性： 通過從數據中學習來解決問題。模型會自動找出數據中的模式，並根據這些模式進行預測和決策，不需要事先編寫規則。<br /></li>
<li>優點： 能夠處理複雜和不確定的情況，能夠從大量數據中學習，並隨著數據增加不斷提升性能。<br /></li>
<li>缺點： 模型難以解釋，需要大量的訓練數據。<br /></li>
</ul></li>
<li>與傳統統計學方法的差別：<br />
<ul class="org-ul">
<li>傳統統計學： 注重數據分析和假設檢驗，目標是理解數據背後的規律。<br /></li>
<li>機器學習： 注重預測和決策，目標是從數據中建立模型並進行應用。機器學習更多的是從數據中學習模型，統計學則更關注對數據的分析。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org96e2e4b" class="outline-4">
<h4 id="org96e2e4b"><span class="section-number-4">9.1.2.</span> 2.</h4>
<div class="outline-text-4" id="text-9-1-2">
</div>
<div id="outline-container-org81c8c17" class="outline-5">
<h5 id="org81c8c17">(1)新興技術區塊鏈(Blockchain)在現今產業應用越來越多，請問區塊鏈是什麼？ 有哪些特性呢？ <code>[10%]</code></h5>
<div class="outline-text-5" id="text-org81c8c17">
</div>
<ul class="org-ul">
<li><a id="orge27675f"></a>解<br />
<div class="outline-text-6" id="text-orge27675f">
<ul class="org-ul">
<li>定義： 區塊鏈是一種分散式帳本技術，以區塊為單位記錄交易信息，並將這些區塊按時間順序連接成鏈。每個區塊都包含前一個區塊的哈希值，形成一個不可篡改的鏈條.<br /></li>
<li>特性：<br /></li>
<li>去中心化： 沒有單一的控制者，數據由網絡中的多個節點共同維護。<br /></li>
<li>不可篡改： 區塊鏈的數據一旦記錄就難以更改，因為任何修改都會導致後續區塊的哈希值改變。<br /></li>
<li>透明度： 區塊鏈上的交易記錄是公開的，任何人都可以查看。<br /></li>
<li>安全性： 使用密碼學技術來確保數據的安全性和完整性。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org4da489b" class="outline-5">
<h5 id="org4da489b">(2)區塊鏈除了比特幣(Bitcoin)、以太幣(Ether)等數位貨幣外，就你所知，還有哪些產業應用？試舉例說明這些應用。而這些區塊鏈應用，原來是想解決產業什麼樣的問題呢？為什麼會需要使用到區塊鏈技術呢？如果靠其他方法或是其他資訊技術，有沒有辦法解決相同的問題呢？ <code>[15%]</code></h5>
<div class="outline-text-5" id="text-org4da489b">
</div>
<ul class="org-ul">
<li><a id="orgf05414a"></a>解<br />
<div class="outline-text-6" id="text-orgf05414a">
<ul class="org-ul">
<li>產業應用： 除了比特幣 (Bitcoin) 和以太幣 (Ether) 等數位貨幣之外，區塊鏈還被應用於許多其他領域，例如：<br />
<ol class="org-ol">
<li>供應鏈管理： 追蹤商品從生產到消費的整個過程，確保商品的真實性和品質。<br /></li>
<li>數位身份驗證： 建立安全可靠的數位身份系統，保護用戶的隱私。<br /></li>
<li>智能合約： 自動執行合約條款，提高交易的效率和透明度。<br /></li>
<li>版權保護： 追蹤數位內容的版權，防止盜版。<br /></li>
<li>醫療健康： 安全地管理病患數據，方便醫療機構共享信息。<br /></li>
</ol></li>
<li>解決問題：<br />
<ol class="org-ol">
<li>信任問題： 區塊鏈透過分散式帳本和密碼學技術建立信任機制，解決傳統中心化系統的信任問題。<br /></li>
<li>資訊不透明： 區塊鏈的透明特性可以增加資訊的公開性，讓交易記錄可追溯。<br /></li>
<li>效率低下： 區塊鏈的智能合約可以自動執行交易，提高效率。<br /></li>
<li>其他解決方案： 某些情境中，可能可以使用其他方法或是資訊科技來解決產業問題。像是傳統的資料庫系統，可以用來管理數據，或是透過數位簽章來確保數位內容的真偽。但是區塊鏈的去中心化、不可篡改等特性，在需要高度信任的場景下，有其獨特的優勢。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org0b7e2fb" class="outline-4">
<h4 id="org0b7e2fb"><span class="section-number-4">9.1.3.</span> 3. 目前全球市值最高的前七大公司例如Facebook, Amazon, Google 大都是所謂的「平台經營模式」，請問，何謂平台經營模式？ 其與傳統經營模式相比有何特色？ 其在經營上與傳統模式相比，又有哪些優勢？ <code>[25%]</code></h4>
<div class="outline-text-4" id="text-9-1-3">
</div>
<div id="outline-container-org2026eae" class="outline-5">
<h5 id="org2026eae">解</h5>
<div class="outline-text-5" id="text-org2026eae">
<ul class="org-ul">
<li>平台經營模式的定義：<br />
<ul class="org-ul">
<li>平台經營模式指的是一種以建立平台為核心的商業模式，它不直接提供產品或服務，而是提供一個連接不同用戶群體的場所，讓他們能夠互動、交易或共享資源。<br /></li>
<li>平台通常會利用網絡效應，讓更多用戶的加入使得平台的價值不斷增加。<br /></li>
<li>典型的平台包括像是：Amazon, Facebook, Google 等等。<br /></li>
</ul></li>
<li>平台經營模式與傳統經營模式的特色比較：<br />
<ul class="org-ul">
<li>傳統經營模式：<br />
<ul class="org-ul">
<li>特性： 專注於生產和銷售產品或服務，企業通常直接與客戶互動。<br /></li>
<li>組織結構： 偏向垂直整合，強調內部效率和控制。<br /></li>
<li>收入來源： 主要來自銷售產品或服務。<br /></li>
</ul></li>
<li>平台經營模式：<br />
<ul class="org-ul">
<li>特性： 專注於建立和維護平台，並連接不同的用戶群體。<br /></li>
<li>組織結構： 偏向水平分工，強調協作和網絡效應。<br /></li>
<li>收入來源： 多元化，可能來自廣告、佣金、會員費等。<br /></li>
</ul></li>
<li>平台經營模式的優勢：<br />
<ul class="org-ul">
<li>網絡效應： 用戶越多，平台價值越高，形成正向循環。<br /></li>
<li>規模經濟： 平台可以服務大量用戶，降低單位成本。<br /></li>
<li>多元化收入來源： 平台可以從多個方面獲取收入，降低風險。<br /></li>
<li>創新： 平台可以促進創新，讓第三方開發者在其上開發應用和服務。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org195bd66" class="outline-4">
<h4 id="org195bd66"><span class="section-number-4">9.1.4.</span> 4.資訊安全目前一直是所有組織最關心與擔憂的議題，一個組織要能夠有效率的資訊安全管理，必須要由組織的許多面向與層次(例如政策、組織、人員、制度、科技等)同時來建立，請問，如果你是一個資安顧問，你會如何建立一個完整的資訊安全管理架構，來嚇阻、預防與偵測資安的威脅？ (提示：ISO 27001) <code>[25%]</code></h4>
<div class="outline-text-4" id="text-9-1-4">
</div>
<div id="outline-container-orgb686449" class="outline-5">
<h5 id="orgb686449">解</h5>
<div class="outline-text-5" id="text-orgb686449">
<p>
建立資訊安全管理架構：<br />
</p>
<ul class="org-ul">
<li>全面性： 資訊安全需要考量組織的許多面向與層次，不能只專注在單一技術或措施。<br /></li>
<li>政策： 制定明確的資訊安全政策，規範員工的行為，並確保與法規要求一致。<br /></li>
<li>組織： 建立資訊安全組織，明確人員的責任和權限。<br /></li>
<li>人員： 對員工進行資訊安全培訓，提高安全意識。<br /></li>
<li>制度： 建立完善的資訊安全管理制度，例如：風險評估、存取控制、事件回應等。<br /></li>
<li>科技： 導入必要的資訊安全技術，例如：防火牆、入侵偵測系統、資料加密等。<br /></li>
<li>符合 ISO 27001 標準： 參考 ISO 27001 標準，建立符合國際標準的資訊安全管理系統。<br /></li>
<li>嚇阻、預防、偵測： 建立完善的資訊安全管理架構來達到這三個目的。<br />
<ul class="org-ul">
<li>嚇阻： 建立嚴格的規範與制度，讓潛在的攻擊者知難而退。<br /></li>
<li>預防： 採取主動的防禦措施，降低資安事件發生的可能性。<br /></li>
<li>偵測： 建立監控機制，及早發現資安威脅。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orga8a3aed" class="outline-3">
<h3 id="orga8a3aed"><span class="section-number-3">9.2.</span> 110: 中山資料結構</h3>
<div class="outline-text-3" id="text-9-2">
</div>
<div id="outline-container-orge604a3f" class="outline-4">
<h4 id="orge604a3f"><span class="section-number-4">9.2.1.</span> 1. AVL tree operations. (16%; 4% for each)</h4>
<div class="outline-text-4" id="text-9-2-1">
</div>
<div id="outline-container-orga165353" class="outline-5">
<h5 id="orga165353">(A) Please draw the result of inserting the keys 6, 5, 3, 9, 10 into an empty AVL tree.</h5>
<div class="outline-text-5" id="text-orga165353">
</div>
<ul class="org-ul">
<li><a id="org5730aad"></a>解: 插入鍵值 6, 5, 3, 9, 10<br />
<div class="outline-text-6" id="text-org5730aad">
<ol class="org-ol">
<li><p>
插入 6：建立一個只有根節點的樹：<br />
</p>
<pre class="example" id="org70ba9e2">
  6
</pre></li>
<li><p>
插入 5：插入左子樹，平衡性仍然維持：<br />
</p>
<pre class="example" id="org795378d">
  6
 /
5
</pre></li>
<li><p>
插入 3：插入 5 的左子樹後導致失衡，執行右旋：<br />
</p>
<pre class="example" id="org61b5d68">
    5
   / \
  3   6
</pre></li>
<li><p>
插入 9：插入 6 的右子樹：<br />
</p>
<pre class="example" id="org464546a">
    5
   / \
  3   6
       \
        9
</pre></li>
<li><p>
插入 10：插入 9 的右子樹後導致失衡，執行左旋：<br />
</p>
<pre class="example" id="orgf59d815">
    5
   / \
  3   9
     / \
    6  10
</pre></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org73a56a3" class="outline-5">
<h5 id="org73a56a3">(B) Please draw the result after inserting the keys 7, 8, 11 into the AVL tree from (A).</h5>
<div class="outline-text-5" id="text-org73a56a3">
</div>
<ul class="org-ul">
<li><a id="org107636e"></a>解: 插入鍵值 7, 8, 11<br />
<div class="outline-text-6" id="text-org107636e">
<ol class="org-ol">
<li><p>
插入 7：插入 6 的右子樹：<br />
</p>
<pre class="example" id="orgb5d6abc">
    5
   / \
  3   9
     / \
    6  10
     \
      7
</pre></li>
<li><p>
插入 8：插入 7 的右子樹後導致失衡，對 6 節點執行左旋：<br />
</p>
<pre class="example" id="org06531b3">
    5
   / \
  3   9
     / \
    7  10
   / \
  6   8
</pre></li>
<li><p>
插入 11：插入 10 的右子樹後無需調整：<br />
</p>
<pre class="example" id="org5dacd5f">
        5
       / \
      3   9
         / \
        7  10
       / \    \
      6   8    11
</pre></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3e19104" class="outline-5">
<h5 id="org3e19104">(C) Please draw the result after removing the key 6 from the AVL tree from (B).</h5>
<div class="outline-text-5" id="text-org3e19104">
</div>
<ul class="org-ul">
<li><a id="org775a6f3"></a>解:刪除鍵值 6<br />
<div class="outline-text-6" id="text-org775a6f3">
<p>
移除葉節點 6，不影響平衡性：<br />
</p>
<pre class="example" id="org249e5cc">
    5
   / \
  3   9
     / \
    7  10
     \    \
      8    11
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-org42ab772" class="outline-5">
<h5 id="org42ab772">(D) Please draw the result after removing the key 11 from the AVL tree from (C).</h5>
<div class="outline-text-5" id="text-org42ab772">
</div>
<ul class="org-ul">
<li><a id="org8170c21"></a>解: 刪除鍵值 11<br />
<div class="outline-text-6" id="text-org8170c21">
<p>
移除葉節點 11，不影響平衡性：<br />
</p>
<pre class="example" id="org9726db8">
    5
   / \
  3   9
     / \
    7  10
     \
      8
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org16e901c" class="outline-4">
<h4 id="org16e901c"><span class="section-number-4">9.2.2.</span> 2. (10%; 5% for each)</h4>
<div class="outline-text-4" id="text-9-2-2">
</div>
<div id="outline-container-org444b2a0" class="outline-5">
<h5 id="org444b2a0">(A) What is the minimum number of nodes in an AVL tree to achieve the height = 9?</h5>
<div class="outline-text-5" id="text-org444b2a0">
</div>
<ul class="org-ul">
<li><a id="orge72b700"></a>解<br />
<div class="outline-text-6" id="text-orge72b700">
<p>
高度 h=9h=9，最小節點數公式為： N(h)=1+N(h−1)+N(h−2)N(h)=1+N(h−1)+N(h−2) 初始條件：<br />
N(0)=1,N(1)=2<br />
N(0)=1,N(1)=2<br />
</p>

<p>
逐步計算：<br />
N(2)=1+2+1=4,N(3)=1+4+2=7<br />
N(2)=1+2+1=4,N(3)=1+4+2=7<br />
</p>

<p>
&#x2026;<br />
N(9)=1+N(8)+N(7)=1+88+56=145<br />
N(9)=1+N(8)+N(7)=1+88+56=145<br />
</p>

<p>
答案：145<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8683426" class="outline-5">
<h5 id="org8683426">(B) What is the maximum number of nodes in an AVL tree with height = 8? Note that the height is 1 for a tree with only one node.</h5>
<div class="outline-text-5" id="text-org8683426">
</div>
<ul class="org-ul">
<li><a id="orgb723160"></a>解:<br />
<div class="outline-text-6" id="text-orgb723160">
<p>
高度為 8 的 AVL Tree 最大節點數<br />
</p>

<p>
高度 h=8h=8，滿二叉樹節點數為：<br />
N=2^(h+1)−1=29−1=511<br />
</p>

<p>
答案：511<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4e6fbc1" class="outline-4">
<h4 id="org4e6fbc1"><span class="section-number-4">9.2.3.</span> 3.(4%)</h4>
<div class="outline-text-4" id="text-9-2-3">
</div>
<div id="outline-container-org0f8f9fd" class="outline-5">
<h5 id="org0f8f9fd">(A) Dijkstra&rsquo;s algorithm will fail in what kind of situation? (4%)</h5>
<div class="outline-text-5" id="text-org0f8f9fd">
</div>
<ul class="org-ul">
<li><a id="org567efd2"></a>解:Dijkstra 演算法失效情況<br />
<div class="outline-text-6" id="text-org567efd2">
<p>
Dijkstra 演算法在圖中存在 負邊權重 時失效。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1708a42" class="outline-5">
<h5 id="org1708a42">(B) Floyd-Warshall algorithm will fail in what kind of situation? (6%)</h5>
<div class="outline-text-5" id="text-org1708a42">
</div>
<ul class="org-ul">
<li><a id="orgbbf092e"></a>解:Floyd-Warshall 演算法失效情況<br />
<div class="outline-text-6" id="text-orgbbf092e">
<p>
Floyd-Warshall 在圖中存在 負權重環 (Negative Weight Cycle) 時無法計算正確結果。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbc0bd48" class="outline-5">
<h5 id="orgbc0bd48">(C) Complete the following pseudo code of Floyd-Warshall algorithm.</h5>
<div class="outline-text-5" id="text-orgbc0bd48">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>let dist be a |V| x |V| array of minimum distances initialized to &#8734;
<span class="linenr">2: </span><span style="color: #51afef;">for</span> each vertex v
<span class="linenr">3: </span>    dist[v][v] &#8592; <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">4: </span><span style="color: #51afef;">for</span> each edge (u,v)
<span class="linenr">5: </span>    dist[u][v] &#8592; weight(u,v)
<span class="linenr">6: </span>    <span style="color: #51afef;">for</span> k from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">7: </span>        <span style="color: #51afef;">for</span> i from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">8: </span>            <span style="color: #51afef;">for</span> j from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">9: </span>                <span style="color: #51afef;">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org01f4126"></a>解: Floyd-Warshall 演算法的偽代碼補全<br />
<div class="outline-text-6" id="text-org01f4126">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:
<span class="linenr">2: </span>    dist[i][j] = dist[i][k] + dist[k][j]
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd84a037" class="outline-4">
<h4 id="orgd84a037"><span class="section-number-4">9.2.4.</span> 4. (10%) Given the frequencies of characters shown in the following table, please encode these characters to binary codes using Huffman coding.</h4>
<div class="outline-text-4" id="text-9-2-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">A</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">C</th>
<th scope="col" class="org-right">D</th>
<th scope="col" class="org-right">E</th>
<th scope="col" class="org-right">F</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">45</td>
<td class="org-right">13</td>
<td class="org-right">12</td>
<td class="org-right">16</td>
<td class="org-right">9</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org530a22a" class="outline-5">
<h5 id="org530a22a">解</h5>
<div class="outline-text-5" id="text-org530a22a">
</div>
<ul class="org-ul">
<li><a id="org8309cdd"></a>步驟：<br />
<div class="outline-text-6" id="text-org8309cdd">
<ol class="org-ol">
<li>合併最低頻率：F(5)+E(9)=14F(5)+E(9)=14<br /></li>
<li>合併結果與 C：C(12)+14=26C(12)+14=26<br /></li>
<li>合併 B 與 D：B(13)+D(16)=29B(13)+D(16)=29<br /></li>
<li>合併 AA 與 2626：A(45)+26=71A(45)+26=71<br /></li>
<li>合併 2929 與 7171：29+71=10029+71=100<br /></li>
</ol>
</div>
</li>
<li><a id="orgcf288d9"></a>編碼結果如下：<br />
<div class="outline-text-6" id="text-orgcf288d9">
<ul class="org-ul">
<li>A: 0<br /></li>
<li>B: 101<br /></li>
<li>C: 1001<br /></li>
<li>D: 11<br /></li>
<li>E: 10001<br /></li>
<li>F: 10000<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6904b59" class="outline-3">
<h3 id="org6904b59"><span class="section-number-3">9.3.</span> 110: 中山資料結構</h3>
<div class="outline-text-3" id="text-9-3">
<p>
科目名稱： 【資管系碩士班乙組】 題號：442002 ※本科目依簡章規定「不可以」使用計算機(問答申論題) 共 2 頁 第 2 頁<br />
</p>
</div>
<div id="outline-container-org57c9e2c" class="outline-4">
<h4 id="org57c9e2c"><span class="section-number-4">9.3.1.</span> 5.(24%)</h4>
<div class="outline-text-4" id="text-9-3-1">
</div>
<div id="outline-container-org67d663c" class="outline-5">
<h5 id="org67d663c">(A) Write a procedure to reverse an array of integers.</h5>
<div class="outline-text-5" id="text-org67d663c">
</div>
<ul class="org-ul">
<li><a id="orgf95dd19"></a>解: 反轉整數陣列<br />
<div class="outline-text-6" id="text-orgf95dd19">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">reverse_array</span>(arr):
<span class="linenr">2: </span>    left, right = <span style="color: #da8548; font-weight: bold;">0</span>, len(arr) - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">while</span> left &lt; right:
<span class="linenr">4: </span>        arr[left], arr[right] = arr[right], arr[left]
<span class="linenr">5: </span>        left += <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">6: </span>        right -= <span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge5ba682" class="outline-5">
<h5 id="orge5ba682">(B) Analyze the time complexity (runtime formula) of your answer in (A)?</h5>
<div class="outline-text-5" id="text-orge5ba682">
<p>
時間複雜度：O(n)<br />
</p>
</div>
</div>
<div id="outline-container-org9dddf7c" class="outline-5">
<h5 id="org9dddf7c">(C) Write a procedure to calculate n! for a given integer n and analyze the time complexity of your procedure?</h5>
<div class="outline-text-5" id="text-org9dddf7c">
</div>
<ul class="org-ul">
<li><a id="org3fd9b30"></a>解: 計算 n!<br />
<div class="outline-text-6" id="text-org3fd9b30">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">factorial</span>(n):
<span class="linenr">2: </span>    <span style="color: #51afef;">if</span> n == <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #51afef;">or</span> n == <span style="color: #da8548; font-weight: bold;">1</span>:
<span class="linenr">3: </span>        <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">4: </span>    <span style="color: #51afef;">return</span> n * factorial(n - <span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div>
<p>
時間複雜度：O(n)<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge2a3297" class="outline-5">
<h5 id="orge2a3297">(D) How many disk moves are needed in the recursive procedure for solving the n-disk Hanoi tower problem? Prove your answer.</h5>
<div class="outline-text-5" id="text-orge2a3297">
</div>
<ul class="org-ul">
<li><a id="orgcb9b3bf"></a>解: 河內塔問題移動次數<br />
<div class="outline-text-6" id="text-orgcb9b3bf">
<p>
公式為：<br />
\[ T(n)=2^n−1 \]<br />
</p>

<p>
證明：遞迴式 T(n)=2T(n−1)+1T(n)=2T(n−1)+1 解為 \(2^n−1\)。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgef83f64" class="outline-4">
<h4 id="orgef83f64"><span class="section-number-4">9.3.2.</span> 6. (26%) For a graph G = (V, E), V = {1, 2, 3, 4, 5, 6, 7}, E = {(1, 2), (2, 3), (3, 4), (1, 5), (2, 5), (1, 6), (1, 7), (5, 4), (6, 7)}, and the cost for above edges are {11, 5, 12, 18, 20, 6, 11, 14, 23}, respectively.</h4>
<div class="outline-text-4" id="text-9-3-2">
</div>
<div id="outline-container-org0fabbd7" class="outline-5">
<h5 id="org0fabbd7">(A) Use Prim’s algorithm to find the minimum spanning tree of G and give the cost.</h5>
<div class="outline-text-5" id="text-org0fabbd7">
</div>
<ul class="org-ul">
<li><a id="org2d3cb95"></a>解:Prim 演算法找最小生成樹<br />
<div class="outline-text-6" id="text-org2d3cb95">
<ul class="org-ul">
<li>起點：節點 1<br /></li>
<li>選邊順序：(1,2)→(2,3)→(3,4)→(1,5)→(1,6)→(1,7)<br /></li>
<li>總成本：11+5+12+18+6+11=63<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgfc8aa81" class="outline-5">
<h5 id="orgfc8aa81">(B) How to detect a cycle in the above algorithm?</h5>
<div class="outline-text-5" id="text-orgfc8aa81">
</div>
<ul class="org-ul">
<li><a id="orgbd8dfec"></a>解: 如何檢測環<br />
<div class="outline-text-6" id="text-orgbd8dfec">
<ul class="org-ul">
<li>在加入邊時，使用 並查集 (Union-Find) 判斷兩端點是否已連通。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org4b1f95d" class="outline-5">
<h5 id="org4b1f95d">(C) Starting from node 1, use Depth First Search (DFS) and Breadth First Search (BFS) to determine the minimum spanning tree of graph G.</h5>
<div class="outline-text-5" id="text-org4b1f95d">
</div>
<ul class="org-ul">
<li><a id="orgabc26c2"></a>解: DFS 與 BFS 的最小生成樹<br />
<div class="outline-text-6" id="text-orgabc26c2">
<ul class="org-ul">
<li>DFS 和 BFS 找出的生成樹不一定是最小生成樹，因為這兩者不考慮邊的權重。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgd6b04c5" class="outline-5">
<h5 id="orgd6b04c5">(D) Can DFS or BFS guarantee to find the optimal solution? Why?</h5>
<div class="outline-text-5" id="text-orgd6b04c5">
</div>
<ul class="org-ul">
<li><a id="orgaf5a75b"></a>解<br />
<div class="outline-text-6" id="text-orgaf5a75b">
<ul class="org-ul">
<li>不能，因為最優解取決於邊權重，而 DFS 和 BFS 並未考慮此條件。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbc063e2" class="outline-5">
<h5 id="orgbc063e2">(E) Write a procedure to find (list) all connected components of a graph.</h5>
<div class="outline-text-5" id="text-orgbc063e2">
</div>
<ul class="org-ul">
<li><a id="org0d3b8b4"></a>解:<br />
<div class="outline-text-6" id="text-org0d3b8b4">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">connected_components</span>(graph):
<span class="linenr"> 2: </span>    visited = set()
<span class="linenr"> 3: </span>    components = []
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    def dfs(node, component):
<span class="linenr"> 6: </span>        visited.add(node)
<span class="linenr"> 7: </span>        component.append(node)
<span class="linenr"> 8: </span>        <span style="color: #51afef;">for</span> neighbor in graph[node]:
<span class="linenr"> 9: </span>            <span style="color: #51afef;">if</span> neighbor <span style="color: #51afef;">not</span> in visited:
<span class="linenr">10: </span>                dfs(neighbor, component)
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #51afef;">for</span> node in graph:
<span class="linenr">13: </span>        <span style="color: #51afef;">if</span> node <span style="color: #51afef;">not</span> in visited:
<span class="linenr">14: </span>            component = []
<span class="linenr">15: </span>            dfs(node, component)
<span class="linenr">16: </span>            components.append(component)
<span class="linenr">17: </span>
<span class="linenr">18: </span>    <span style="color: #51afef;">return</span> components
<span class="linenr">19: </span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org506bb31" class="outline-3">
<h3 id="org506bb31"><span class="section-number-3">9.4.</span> 110: 中山計概</h3>
<div class="outline-text-3" id="text-9-4">
<ol class="org-ol">
<li>In Python 3, which of the following is used to define a block of code (e.g. body of loop)? A. Curly braces B. Indentation C. Semicolon D. Parenthesis<br />
<ul class="org-ul">
<li>解答：B. Indentation<br /></li>
<li>Python 使用 縮排 (Indentation) 來定義代碼塊，例如 for 或 if 的內容，這與其他語言的花括號 ({}) 不同。<br /></li>
</ul></li>
<li>Which of the following is NOT considered the reason for the recent AI boom? A. The global investment of AI B. The accessibility of cheap computation C. The exponential growth of data D. The advances of learning algorithms<br />
<ul class="org-ul">
<li>解答：A. The global investment of AI<br /></li>
<li>雖然 AI 的投資確實在增加，但這並非 AI 爆炸的直接技術性原因，而是技術的普及結果。其他選項 (計算能力、數據增長、演算法進步) 才是 AI 發展的核心推動力。<br /></li>
</ul></li>
<li>Which of the following about split-apply-combine strategy of data analytics is FALSE? A. It can be implemented by SQL B. It should not be used to replace loops C. It can help parallelize computations D. It is widely used in daily data management tasks<br />
<ul class="org-ul">
<li>解答：B. It should not be used to replace loops<br /></li>
<li>解釋：Split-apply-combine 策略常用於數據分析中，用來分割數據，應用函數，並將結果結合。它通常可以替代迴圈，提高計算效率，特別是在使用 pandas 或 SQL 等工具時。<br /></li>
</ul></li>
<li>Which of the following about Deep Neural Network is FALSE? A. The trained models are usually called black-box models B. Compared to traditional machine learning algorithms, it has more hyperparameters to tune C. It takes more time to do manual feature engineering D. It usually requires comparatively more computing resources to train a model<br />
<ul class="org-ul">
<li>解答：C. It takes more time to do manual feature engineering<br /></li>
<li>解釋： 深度神經網路的特點是可以自動提取特徵，因此通常 不需要 花大量時間進行手動特徵工程。<br /></li>
</ul></li>
<li>Which of the following is NOT a common feature of object-oriented programming languages? A. Parallelism B. Polymorphism C. Encapsulation D. Inheritance<br />
<ul class="org-ul">
<li>解答：A. Parallelism<br /></li>
<li>解釋： 物件導向程式語言 (OOP) 的核心特性是 多型 (Polymorphism)、封裝 (Encapsulation) 和 繼承 (Inheritance)。平行運算並非 OOP 的內建特性。<br /></li>
</ul></li>
<li>Which of the following is NOT a common feature of functional programming languages? A. Lazy Evaluation B. Higher-order functions C. Recursion D. Inheritance<br />
<ul class="org-ul">
<li>解答：D. Inheritance<br /></li>
<li>解釋：繼承是物件導向的特性，而 惰性求值 (Lazy Evaluation)、高階函數 (Higher-order functions) 和 遞迴 (Recursion) 是函數式程式設計的核心特性。<br /></li>
</ul></li>
<li>Which of the following about cloud, fog, and edge computing is FALSE? A. Cloud computing is often used to process urgent requests in the local network B. To improve response times, fog computing can be used to process computation-intensive requests C. They help promote decentralized storages and computations D. Amazon Web Services can be considered cloud computing platforms<br />
<ul class="org-ul">
<li>解答：A. Cloud computing is often used to process urgent requests in the local network<br /></li>
<li>解釋：雲端運算通常處理集中式的非即時性計算需求，而本地網絡中的即時請求更適合邊緣運算或霧運算處理。<br /></li>
</ul></li>
<li>Which of the following about data structures is TRUE? A. Arrays are dynamic data structures able to increase their sizes at runtime B. The length of a linked list is usually fixed C. Data elements in a linked list must be stored in adjacent memory space D. Linked lists can be used to implement stacks<br />
<ul class="org-ul">
<li>解答：D. Linked lists can be used to implement stacks<br /></li>
<li>解釋：連結串列 (Linked List) 可以用來實現堆疊 (Stack)，而其他選項皆為錯誤：<br />
<ul class="org-ul">
<li>陣列大小是靜態的，不能在執行期增長 (A 錯)。<br /></li>
<li>連結串列長度不固定 (B 錯)。<br /></li>
<li>連結串列節點不需要儲存在連續的記憶體空間 (C 錯)。<br /></li>
</ul></li>
</ul></li>
<li>Suppose we have a table in the third normal form (3NF) in a relational database. Which of the following statement is FALSE? A. The table is also in the 2NF B. The table may have multiple candidate keys C. Every non-prime attribute is non-transitively dependent on every key of the table D. For each of the functional dependency A-&gt;B that exists, A is the super key of the table<br />
<ul class="org-ul">
<li>解答：D. For each of the functional dependency A-&gt;B that exists, A is the super key of the table<br /></li>
<li>解釋：在 3NF 中，函數依賴的屬性 AA 不一定是超鍵，只要 BB 是主鍵或候選鍵的非傳遞依賴即可。<br /></li>
</ul></li>
<li><p>
Consider the following tables, A and B, in a relational database:<br />
A:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
</tr>
</tbody>
</table>
<p>
B:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table>
<p>
Which of the following SQL statement can be used to concatenate A and B?<br />
</p>
<ul class="org-ul">
<li>A. SELECT * FROM A UNION ALL SELECT * FROM B<br /></li>
<li>B. SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id<br /></li>
<li>C. SELECT * FROM A INNER JOIN B ON A.id = B.id<br /></li>
<li>D. SELECT * FROM A LEFT JOIN B ON A.id = B.id<br /></li>
<li>解: 題目要求的是將兩張表 A 和 B 串接，這裡的 串接 指的是結合兩張表的所有數據，而非進行條件配對。仔細分析每個選項後，可以看出符合要求的正確語句。<br /></li>
<li>選項分析:<br />
<ol class="org-ol">
<li>SELECT * FROM A UNION ALL SELECT * FROM B<br />
<ul class="org-ul">
<li>說明：UNION ALL 是直接將兩張表的數據合併，不會過濾重複的記錄。在這裡，A 和 B 的結合將包含兩張表的所有數據，不需要關聯條件。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table></li>
<li>結論： 符合 串接 (concatenate) 的要求。<br /></li>
</ul></li>
<li>SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明：FULL OUTER JOIN 將返回兩張表中所有記錄，並將 匹配的 id 行合併。對於沒有匹配的記錄，將使用 NULL 填充缺失的列。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">NULL</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table></li>
<li>結論： 這是進行關聯操作，不符合單純串接兩張表的需求。<br /></li>
</ul></li>
<li>SELECT * FROM A INNER JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明：INNER JOIN 只返回 A 和 B 中 id 匹配的記錄。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>
</tbody>
</table></li>
<li>結論： 僅返回兩表中匹配的部分，不符合串接需求。<br /></li>
</ul></li>
<li>SELECT * FROM A LEFT JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明： LEFT JOIN 返回 A 中的所有記錄，並將匹配 B 的行合併；對於 B 中沒有匹配的部分，填充 NULL。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>
</tbody>
</table></li>
<li>結論： 這是進行關聯操作，不符合單純串接兩張表的需求。<br /></li>
</ul></li>
<li>正確解答 答案：A. SELECT * FROM A UNION ALL SELECT * FROM B<br /></li>
<li>補充說明<br />
<ul class="org-ul">
<li>UNION 和 UNION ALL 的區別：<br />
<ul class="org-ul">
<li>UNION 會移除重複的記錄。<br /></li>
<li>UNION ALL 不會移除重複記錄，速度更快，適合需要保留重複值的場合。<br /></li>
</ul></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT considered a kind of NoSQL databases? A. Graph database B. Document database C. Object-relational database D. Key-value database<br /></li>
<li>Which of the following is the postfix expression of math representation A * B / C + D - E? A. A B * C / D + E -<br />
<ol class="org-ol">
<li>A B * C / D + - E<br /></li>
<li>* A B / C + D - E<br /></li>
<li>- / + * A B C D E<br /></li>
</ol></li>
<li><p>
Which of the following is the post-order traversal of the below binary search tree?<br />
</p>
<pre class="example" id="org66de767">
            45
           /  \
          /    \
         27    55
        /        \
      18          58
        \          \
         19         60
</pre>
<ol class="org-ol">
<li>18 19 27 45 55 58 60<br /></li>
<li>45 27 18 19 55 58 60<br /></li>
<li>19 18 27 55 58 60 45<br /></li>
<li>19 18 27 60 58 55 45<br /></li>
</ol>
<p>
解： 後序遍歷步驟<br />
</p>
<ol class="org-ol">
<li><p>
遍歷左子樹<br />
節點 27 的左子樹為：<br />
</p>
<pre class="example" id="org088ccfb">

            27
           /
          18
           \
            19

</pre>
<p>
後序遍歷順序：<br />
</p>
<ul class="org-ul">
<li>遍歷左子樹 18（沒有左子樹，直接看右子樹）。<br /></li>
<li>遍歷右子樹的 19。<br /></li>
<li>訪問根節點 27。<br /></li>
</ul>
<p>
結果：18 → 19 → 27<br />
</p></li>
<li><p>
遍歷右子樹<br />
節點 55 的右子樹為：<br />
</p>
<pre class="example" id="org5639a28">
            55
              \
               58
                 \
                  60
</pre>
<p>
後序遍歷順序：<br />
</p>
<ul class="org-ul">
<li>遍歷左子樹（55 無左子樹，直接看右子樹）。<br /></li>
<li>遍歷右子樹的 58，接著是其右子樹的 60。<br /></li>
<li>訪問根節點 55。<br /></li>
</ul>
<p>
結果：60 → 58 → 55<br />
</p></li>
<li>訪問根節點<br />
最後訪問根節點 45。<br />
後序遍歷結果<br />
將步驟 1、2、3 的結果結合：<br />
18 → 19 → 27 → 60 → 58 → 55 → 45<br /></li>
</ol>
<p>
解答：D. 19 18 27 60 58 55 45<br />
</p></li>
</ol>
</div>
</div>
<div id="outline-container-org71e0378" class="outline-3">
<h3 id="org71e0378"><span class="section-number-3">9.5.</span> 110: 中山計概</h3>
<div class="outline-text-3" id="text-9-5">
</div>
<div id="outline-container-org23e4493" class="outline-4">
<h4 id="org23e4493"><span class="section-number-4">9.5.1.</span> 單選題，每題 2.5 分</h4>
<div class="outline-text-4" id="text-9-5-1">
<ol class="org-ol">
<li>Which of the following statements about memory is FALSE? A. Static RAM is an example of volatile memory B. Flash memory is a type of nonvolatile memory that can be erased electronically and rewritten C. Dynamic RAM is faster than static RAM D. Read-only memory (ROM) is a type of nonvolatile memory<br />
<ul class="org-ul">
<li>解答：C. Dynamic RAM is faster than static RAM<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>Static RAM (SRAM) 是揮發性記憶體，比動態 RAM (DRAM) 更快，但成本也更高。<br /></li>
<li>Dynamic RAM (DRAM) 雖然更慢，但每單位存儲空間成本更低，常用於主記憶體。<br /></li>
<li>其他選項正確，因為 Flash 是非揮發性、ROM 是非揮發性記憶體。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following best describes the principle of least privilege? A. Data access restrictions are lifted to ensure data integrity B. Data is encrypted and passwords are used C. Users should not share access details with others D. Users’ access privileges are limited to the lowest level necessary to perform required tasks<br />
<ul class="org-ul">
<li>解答：D. Users’ access privileges are limited to the lowest level necessary to perform required tasks<br /></li>
<li>詳解：<br />
最小權限原則 (Principle of Least Privilege) 是一種安全策略，確保用戶只能存取完成工作所需的最小權限，減少安全風險。<br /></li>
</ul></li>
<li>Which of the following about the binary search algorithm is TRUE? A. It is not possible for a binary search to find the value 2 in the array of B. The maximum number of comparisons required to perform a binary search of a 1000 element array is 9 C. The best-case time complexity of a binary search is O(log N), with N the number of elements in an array D. An iterative implementation of the binary search has a space complexity of O(N), with N the number of elements in an array<br />
解答：B. The maximum number of comparisons required to perform a binary search of a 1000 element array is 9<br />
<ul class="org-ul">
<li>詳解：<br />
<ul class="org-ul">
<li>二分搜尋的時間複雜度為 O(log⁡N)O(logN)。對於 1000 個元素的陣列，最多需要比較 ⌈log⁡21000⌉=10⌈log2​1000⌉=10 次，因此選項 B 是正確的。<br /></li>
<li>最佳情況下（找到目標元素），時間複雜度為 O(1)O(1)，所以選項 C 錯誤。<br /></li>
<li>二分搜尋的迭代實現的空間複雜度是 O(1)O(1)，非 O(N)O(N)。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following about web application development is FALSE? A. CSS allows web designers to change the layout and appearance of the webpage B. HTML stands for hypertext markup language and used hashtags to specify the content of webpages C. JavaScript can be used to display a prompt box that prompts the user to input some text D. JavaScript adds interactivity to webpages<br />
<ul class="org-ul">
<li>解答：B. HTML stands for hypertext markup language and used hashtags to specify the content of webpages<br /></li>
<li>詳解：<br />
HTML 是超文字標記語言，使用標籤 (tags)，而非井號 (hashtags)，來描述網頁內容。<br /></li>
</ul></li>
<li>Which of the following provides remote users with a secure connection to the organization network? A. VPN B. https C. Ethernet D. FTP<br />
<ul class="org-ul">
<li>解答：A. VPN<br /></li>
<li>詳解：<br />
VPN (Virtual Private Network) 提供安全的遠端連線，通常用於保護敏感數據在公共網路上的傳輸。<br /></li>
</ul></li>
<li>Which of the following about deep learning frameworks is FALSE? A. PyTorch uses dynamic computation graphs B. Tensorflow is an open-source deep learning framework developed by Google C. Keras is officially integrated with PyTorch in the latest release of PyTorch D. TensorFlow 2.x supports dynamic computation graphs<br />
<ul class="org-ul">
<li>解答：C. Keras is officially integrated with PyTorch in the latest release of PyTorch<br /></li>
<li>詳解：<br />
Keras 是 TensorFlow 的高階 API，並非與 PyTorch 整合的框架。<br /></li>
</ul></li>
<li>Which of the following about IP addresses and domain names is FALSE? A. A DNS server translates an IP address to its corresponding domain name B. An IPv6 address is 128 bits in length and written as a string of hexadecimal digits C. An IPv4 address is 32 bits and often written in dotted decimal notation D. A domain name is a text-based name of a computer or server that is easier for humans to memorize<br />
<ul class="org-ul">
<li>解答：A. A DNS server translates an IP address to its corresponding domain name<br /></li>
<li>詳解：<br />
DNS (Domain Name System) 的作用是將域名轉換為對應的 IP 位址，而不是將 IP 位址轉換為域名。<br /></li>
</ul></li>
<li>The Hamming distance between two binary strings is defined as the number of bit positions in which two bits are different. Which of the following can be used to find the differences between two binary strings in computing Hamming distance? A. OR B. XOR C. AND D. NOT<br />
<ul class="org-ul">
<li>解答：B. XOR<br /></li>
<li>詳解：<br />
XOR (異或運算) 可以標識兩個二進位串不同的位置，然後統計結果中 1 的數量即可得到漢明距離。<br /></li>
</ul></li>
<li>Which of the following is NOT an advantage of solid-state drives (SSDs) over traditional hard disks? A. Faster transfer rates B. Less power consumption C. Lighter weight D. Lower cost per gigabyte<br />
<ul class="org-ul">
<li>解答：D. Lower cost per gigabyte<br /></li>
<li>詳解：<br />
SSD 的成本較高，特別是在每 GB 的價格上，通常比傳統硬碟 (HDD) 貴。<br /></li>
</ul></li>
<li>Amazon EC2 is an example of <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. A. IaaS B. PaaS C. SaaS D. DaaS<br />
<ul class="org-ul">
<li>解答：A. IaaS (Infrastructure as a Service)<br /></li>
<li>詳解：<br />
Amazon EC2 提供虛擬伺服器實例，讓用戶能建立和管理基礎設施，屬於 IaaS 類型服務。<br /></li>
</ul></li>
<li>Consider an operating system that uses paging for virtual memory management. Assume that there are 4 page frames which are initially empty. Given the page reference string 1, 2, 3, 4, 5, 1, 3, 1, 1, 6, 3, 2, 5, how many page faults occur if the optimal page replacement is used? A. 5 B. 6 C. 8 D. 9<br />
<ul class="org-ul">
<li>解答：C. 8<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>頁面參考字串：1, 2, 3, 4, 5, 1, 3, 1, 1, 6, 3, 2, 5<br /></li>
<li>初始頁框數：4<br /></li>
<li>遵循最佳頁替換策略，每次替換時選擇將來最晚被使用的頁。<br /></li>
<li>具體計算可得到 8 次頁錯誤。<br /></li>
</ul></li>
</ul></li>
<li>Consider the addition of two 8-bit 2’s complement integers. Which of the following is the binary representation of 6 + (-8)? A. 00000010 B. 11111110 C. 11110001 D. 11111110<br />
<ul class="org-ul">
<li>解答：B. 11111110<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>6=000001106=00000110，−8=11111000−8=11111000（以 2 的補碼表示）。<br /></li>
<li>計算 6+(−8)6+(−8)：00000110+11111000=1111111000000110+11111000=11111110。<br /></li>
</ul></li>
</ul></li>
<li>Given two vertices, s and t, in a graph, which of the two traversals, breadth-first search (BFS) and depth-first search (DFS), can be used to determine if there is a path from s to t? A. Only BFS B. Only DFS C. Both BFS and DFS D. Neither BFS nor DFS<br />
<ul class="org-ul">
<li>解答：C. Both BFS and DFS<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>BFS 和 DFS 都可用於判斷是否存在從 ss 到 tt 的路徑。<br /></li>
<li>BFS 適合尋找最短路徑，DFS 適合完整探索。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following about Wi-Fi networks is FALSE? A. Most Wi-Fi is based on the 802.15 standards developed by IEEE B. Wi-Fi accesses the network in conjunction with the TCP/IP standard C. Most devices support multiple Wi-Fi standards D. Wi-Fi is often used to provide hot spots<br />
<ul class="org-ul">
<li>解答：A. Most Wi-Fi is based on the 802.15 standards developed by IEEE<br /></li>
<li>詳解：<br />
Wi-Fi 是基於 IEEE 802.11 標準，而 802.15 是藍牙標準。<br /></li>
</ul></li>
<li>Which of the following about network architectures is TRUE? A. Only one computer can act as a server on the client/server network B. Each device on a peer-to-peer network can share its resources with other devices C. One client computer crashing can affect the other computers on a client/server network D. A computer can act as either a client or a server, but not both, on a peer-to-peer network<br />
<ul class="org-ul">
<li>解答：B. Each device on a peer-to-peer network can share its resources with other devices<br /></li>
<li>詳解：<br />
P2P 網路允許每個設備共享資源，而其他選項的描述均不正確。<br /></li>
</ul></li>
<li>In 2020, Amazon Web Services was hit by an attack that floods the target with massive amounts of data to disrupt normal traffic. What is this attack called? A. Phishing B. Ransomware C. Malware attack D. DDoS<br />
<ul class="org-ul">
<li>解答：D. DDoS<br /></li>
<li>詳解：<br />
DDoS (Distributed Denial-of-Service) 是一種透過大規模數據請求癱瘓伺服器的攻擊方式。<br /></li>
</ul></li>
<li>Which of the following about drones is TRUE? A. The flight of drones cannot operate by an onboard computer or an autopilot B. A drone is an aircraft that operates by a human on board C. A drone is also known as an unmanned aerial vehicle (UAV) D. Drones are for hobbyists and cannot be used to monitor crop growth<br />
<ul class="org-ul">
<li>解答：C. A drone is also known as an unmanned aerial vehicle (UAV)<br /></li>
<li>詳解：<br />
無人機 (Drone) 是無人駕駛航空器 (UAV)，可由自動駕駛或人遠程操作。<br /></li>
</ul></li>
<li>Which of the following is a small, high-speed storage location within a processor that temporarily hold data and instructions? A. ALU B. CU C. register D. RAM<br />
<ul class="org-ul">
<li>解答：C. register<br /></li>
<li>詳解：<br />
寄存器 (register) 是處理器內部的高速存儲位置，用於臨時保存數據和指令。<br /></li>
</ul></li>
<li>Wearable devices, such as smartwatches, can monitor blood pressure and heart rates and send alerts in case of emergency, which is an example of <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. A. big data B. wireless communication C. cloud computing D. internet of things<br />
<ul class="org-ul">
<li>解答：D. internet of things<br /></li>
<li>詳解：<br />
穿戴裝置屬於物聯網 (IoT) 應用的一部分，將感測數據連接至網路進行處理。<br /></li>
</ul></li>
<li>Which of the following about RAID is TRUE? A. RAID 0 writes data to two drives at the same time to duplicate the data B. RAID 1 provides data reliability via redundancy C. Mirroring splits data and instructions across multiple drives in the array D. RAID stands for reliable array of inexpensive disks<br />
<ul class="org-ul">
<li>解答：B. RAID 1 provides data reliability via redundancy<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>RAID 1 透過鏡像技術提供冗餘數據保護。<br /></li>
<li>RAID 0 並未提供數據保護。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following is a last-in fast-out data structure? A. array B. stack C. queue D. tree<br />
<ul class="org-ul">
<li>解答：B. stack<br /></li>
<li>詳解：<br />
堆疊 (stack) 遵循後進先出 (LIFO) 原則，其他選項均不符。<br /></li>
</ul></li>
<li>In C/C++ programming, it requires at least <span class="underline"><span class="underline"><span class="underline">__</span></span></span> byte(s) when an integer number 32768 is stored as characters in computer memory. A. 2 B. 4 C. 5 D. 8<br />
<ul class="org-ul">
<li>解答：C. 5<br /></li>
<li>詳解：<br />
32768 作為字元需轉為 ASCII 表示，包括 3, 2, 7, 6, 8 共 5 個字元。<br /></li>
</ul></li>
<li>Which of the following is NOT a common data format/structure to save and describe network data? A. adjacency matrix B. hash table C. adjacency list D. edge list<br />
<ul class="org-ul">
<li>解答：B. hash table<br /></li>
<li>詳解：<br />
雖然哈希表常用於查詢，但不是保存網路數據的標準結構。<br /></li>
</ul></li>
<li>Consider the below C/C++ statement: int i = 1; const int *iPtr = &amp;i; Which of the following is FALSE? A. iPtr is a variable that stores a memory address B. Statement *iPtr = 10 is invalid C. iPtr is a pointer variable that points to an object of type int D. The data value of the object that iPtr points to can be modified<br />
<ul class="org-ul">
<li>解答：D. The data value of the object that iPtr points to can be modified<br /></li>
<li>詳解：<br />
const int *iPtr 指向的值不可修改。<br /></li>
</ul></li>
<li><p>
Consider the below C/C++ program:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">    #include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span> (){
<span class="linenr">3: </span>      <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">aStr</span>[] = <span style="color: #98be65;">"A string"</span>;
<span class="linenr">4: </span>      <span style="color: #ECBE7B;">void</span> <span style="color: #dcaeea;">pPtr</span> = &amp;aStr;
<span class="linenr">5: </span>      printf(<span style="color: #98be65;">"%s\n"</span>, ((<span style="color: #ECBE7B;">char</span>) aPtr));
<span class="linenr">6: </span>    }
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following statement is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show &ldquo;A string&rdquo; D. It will show &ldquo;A&rdquo;<br />
</p>
<ul class="org-ul">
<li>解答：A. It will show compilation errors<br /></li>
<li>詳解：<br />
void pPtr = &amp;aStr; 是錯誤的，void 不能直接用於指針。<br /></li>
</ul></li>
<li><p>
Consider the below C/C++ program:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">    #include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span>    <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span>{ <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>; <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>; };
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">passXY</span>(<span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span> *<span style="color: #dcaeea;">xy</span>){
<span class="linenr"> 4: </span>      xy -&gt; x = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 5: </span>      xy -&gt; y = <span style="color: #da8548; font-weight: bold;">2</span>;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>(<span style="color: #ECBE7B;">void</span>){
<span class="linenr"> 8: </span>      <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span> <span style="color: #dcaeea;">s</span>;
<span class="linenr"> 9: </span>      s.x = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">10: </span>      s.y = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">11: </span>      passXY(&amp;s);
<span class="linenr">12: </span>      printf(<span style="color: #98be65;">"x = %d, y = %d\n"</span>, s.x, s.y);
<span class="linenr">13: </span>    }
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following statement is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show &ldquo;x = 0, y = 0&rdquo; D. It will show &ldquo;x = 1, y = 2&rdquo;<br />
</p>
<ul class="org-ul">
<li>解答：D. It will show &ldquo;x = 1, y = 2&rdquo;<br /></li>
<li>詳解：<br />
指針 &amp;s 被傳遞，函數 passXY 成功修改了結構的成員值。<br /></li>
</ul></li>
<li>Which of the following about recursion is TRUE? A. We should always replace iterations with recursions if possible B. Recursion usually uses less memory than iteration as the code is more concise and clearer C. Recursion usually has higher algorithm performance D. Any problems that can be solved by recursions can also be solved by iterations<br />
<ul class="org-ul">
<li>解答：D. Any problems that can be solved by recursions can also be solved by iterations<br /></li>
<li>詳解：<br />
任何遞迴問題都可以轉換為迭代解法，雖然代碼可能更冗長。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org55ea3f5" class="outline-3">
<h3 id="org55ea3f5"><span class="section-number-3">9.6.</span> 111: 中山計概</h3>
<div class="outline-text-3" id="text-9-6">
</div>
<div id="outline-container-orge173f24" class="outline-4">
<h4 id="orge173f24"><span class="section-number-4">9.6.1.</span> 第一题：</h4>
<div class="outline-text-4" id="text-9-6-1">
<p>
Which data structure is often used when implementing the depth first search algorithm? A. Heap B. Queue C. Stack D. Tree E. None of the above<br />
</p>
</div>
<div id="outline-container-orgc52caab" class="outline-5">
<h5 id="orgc52caab">答案：C. Stack</h5>
<div class="outline-text-5" id="text-orgc52caab">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>深度優先搜尋（DFS）演算法的實作通常依賴 堆疊（Stack） 來追蹤遞迴過程中的節點。<br /></li>
<li>遞迴（Recursive）版本的 DFS 直接利用函式呼叫堆疊。<br /></li>
<li>非遞迴版本的 DFS 使用明確的 堆疊 來存放即將探索的節點。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Heap → 堆積（Heap）通常用於優先隊列（如 Dijkstra）。<br /></li>
<li>Queue → 廣度優先搜尋（BFS）使用佇列（Queue），而不是 DFS。<br /></li>
<li>Stack → 正確答案，DFS 依賴堆疊。<br /></li>
<li>Tree → 樹是一種資料結構，而非 DFS 主要依賴的結構。<br /></li>
<li>None of the above → 錯誤，DFS 依賴 Stack。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8d5d4b2" class="outline-4">
<h4 id="org8d5d4b2"><span class="section-number-4">9.6.2.</span> 第二題：</h4>
<div class="outline-text-4" id="text-9-6-2">
<p>
Which of the following best describes a NAND gate? A. An AND followed by a NOT B. A NOT followed by an AND C. An OR followed by a NOT D. A NOT followed by an OR E. An OR followed by a NOT<br />
</p>
</div>
<div id="outline-container-orgadd0133" class="outline-5">
<h5 id="orgadd0133">答案：A. An AND followed by a NOT</h5>
<div class="outline-text-5" id="text-orgadd0133">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>NAND（Not AND）閘 是 AND 閘 接上 NOT 閘，輸出是 AND 結果的反向：<br /></li>
<li>NAND(A,B)=¬(A∧B)<br /></li>
<li>NAND(A,B)=¬(A∧B)<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>An AND followed by a NOT → 正確，NAND 是 AND 的反向。<br /></li>
<li>A NOT followed by an AND → 錯誤，這表示先對輸入 NOT，再做 AND，不符合 NAND。<br /></li>
<li>An OR followed by a NOT → 這是 NOR 閘的定義，不是 NAND。<br /></li>
<li>A NOT followed by an OR → 這是 NOR 的另一種錯誤描述。<br /></li>
<li>An OR followed by a NOT → 再次描述 NOR，不是 NAND。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org67f3a7d" class="outline-4">
<h4 id="org67f3a7d"><span class="section-number-4">9.6.3.</span> 第三題：</h4>
<div class="outline-text-4" id="text-9-6-3">
<p>
What is the 8-bit 2&rsquo;s complement representation of the decimal number -5? A. 00000101 B. 11111010 C. 11111011 D. 10000101 E. None of the above<br />
</p>
</div>
<div id="outline-container-orgb450e55" class="outline-5">
<h5 id="orgb450e55">答案：C. 11111011</h5>
<div class="outline-text-5" id="text-orgb450e55">
<p>
解析：<br />
</p>
<ol class="org-ol">
<li>先求 +5 的二進位（8-bit）：00000101<br /></li>
<li>取反（1&rsquo;s 補數）：11111010<br /></li>
<li>加 1（2&rsquo;s 補數）：    11111011<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>00000101 → 這是 +5，不是 -5。<br /></li>
<li>11111010 → 這是 -5 的 1&rsquo;s 補數，不是 2&rsquo;s 補數。<br /></li>
<li>11111011 → 正確，這是 -5 的 2&rsquo;s 補數。<br /></li>
<li>10000101 → 這是錯誤的表示法。<br /></li>
<li>None of the above → 錯，C 是正確答案。<br /></li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgef06ef6" class="outline-4">
<h4 id="orgef06ef6"><span class="section-number-4">9.6.4.</span> 第四題：</h4>
<div class="outline-text-4" id="text-9-6-4">
<p>
Which of the following best describes paging? A. The process a computer goes through when dividing data into disk sectors. B. The technique of swapping items between memory and storage. C. When a computer or mobile device executes instructions. D. The conversion of data into readable, usable information. E. None of the above<br />
</p>
</div>
<div id="outline-container-orgb579116" class="outline-5">
<h5 id="orgb579116">答案：B. The technique of swapping items between memory and storage</h5>
<div class="outline-text-5" id="text-orgb579116">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>分頁（Paging） 是記憶體管理技術，用來 在 RAM 和磁碟之間交換頁面，以模擬更大的可用記憶體。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>The process a computer goes through when dividing data into disk sectors. → 這是磁碟管理，而非 Paging。<br /></li>
<li>The technique of swapping items between memory and storage. → 正確，Paging 將資料在 RAM 和磁碟間交換。<br /></li>
<li>When a computer or mobile device executes instructions. → 這是 CPU 執行程序，不是 Paging。<br /></li>
<li>The conversion of data into readable, usable information. → 這是資料處理，不是 Paging。<br /></li>
<li>None of the above. → 錯，B 是正確答案。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd45f414" class="outline-4">
<h4 id="orgd45f414"><span class="section-number-4">9.6.5.</span> 第五題：</h4>
<div class="outline-text-4" id="text-9-6-5">
<p>
Which of the following statements about storage devices/media is FALSE? A. A group of two or more integrated hard drives is called a RAID. B. Solid-state drives have less power consumption than traditional hard disks. C. Defragmentation is not required for solid-state drives. D. USB flash drives normally run faster than solid-state drives. E. None of the above<br />
</p>
</div>
<div id="outline-container-org6f12c43" class="outline-5">
<h5 id="org6f12c43">答案：D. USB flash drives normally run faster than solid-state drives.</h5>
<div class="outline-text-5" id="text-org6f12c43">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>SSD（固態硬碟） 的速度 遠超過 USB 隨身碟，特別是 PCIe NVMe SSD，速度比 USB 3.0 隨身碟快數十倍。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>RAID 是多顆硬碟組合的存儲陣列。 ✅ 正確<br /></li>
<li>SSD 比傳統 HDD 耗電低。 ✅ 正確<br /></li>
<li>SSD 不需要磁碟重組（defragmentation）。 ✅ 正確<br /></li>
<li>USB 隨身碟比 SSD 快。 ❌ 錯誤，SSD 明顯更快。<br /></li>
<li>None of the above. ❌ 因為 D 錯誤。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8144844" class="outline-4">
<h4 id="org8144844"><span class="section-number-4">9.6.6.</span> 第六題：</h4>
<div class="outline-text-4" id="text-9-6-6">
<p>
Consider the below C program.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">getSteps</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>);
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 5: </span>  <span style="color: #51afef;">if</span> (<span style="color: #da8548; font-weight: bold;">1</span>==n) <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 6: </span>  <span style="color: #51afef;">if</span> (<span style="color: #da8548; font-weight: bold;">0</span>== n % <span style="color: #da8548; font-weight: bold;">2</span>)
<span class="linenr"> 7: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span> + getSteps(n/<span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr"> 8: </span>  <span style="color: #51afef;">else</span>
<span class="linenr"> 9: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span> + getSteps(<span style="color: #da8548; font-weight: bold;">3</span>*n+<span style="color: #da8548; font-weight: bold;">1</span>);
<span class="linenr">10: </span>}
</pre>
</div>
<ul class="org-ul">
<li>We would like to compile and run the program. Which of the following is TRUE?<br /></li>
</ul>
<ol class="org-ol">
<li>It will show compilation errors<br /></li>
<li>It will show run-time errors<br /></li>
<li>It will show 6<br /></li>
<li>It will show 7<br /></li>
<li>It will show 8<br /></li>
</ol>
</div>
<div id="outline-container-org44625cf" class="outline-5">
<h5 id="org44625cf">答案：A. It will show compilation errors</h5>
<div class="outline-text-5" id="text-org44625cf">
<p>
解析：if (1==n) return 0; 中，變數 n 未定義，導致 編譯錯誤。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2b2d356" class="outline-4">
<h4 id="org2b2d356"><span class="section-number-4">9.6.7.</span> 第七題：</h4>
<div class="outline-text-4" id="text-9-6-7">
<p>
Consider the relation Product(pNo, pName, unitPrice, category). Which attribute(s) is the best choice to be used as a search key to build a B+ tree for efficiently evaluating the following SQL statement?<br />
</p>
<pre class="example" id="org3671c0e">
SELECT pName
FROM Product
WHERE unitPrice &lt;= 1000 AND unitPrice &gt;=300
</pre>
<ol class="org-ol">
<li>pNo<br /></li>
<li>pName<br /></li>
<li>unitPrice<br /></li>
<li>category<br /></li>
<li>pNo, category<br /></li>
</ol>
</div>
<div id="outline-container-orgde443e7" class="outline-5">
<h5 id="orgde443e7">答案：C. unitPrice</h5>
<div class="outline-text-5" id="text-orgde443e7">
<p>
解析：WHERE unitPrice BETWEEN 300 AND 1000 會對 unitPrice 做範圍查詢，適合建立 B+ 樹索引。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgab81fbc" class="outline-4">
<h4 id="orgab81fbc"><span class="section-number-4">9.6.8.</span> 第八題：</h4>
<div class="outline-text-4" id="text-9-6-8">
<p>
What is the time complexity of the binary search algorithm? Assume the number of elements in the array is N. A. O(1) B. O(N) C. O(logN) D. O(NlogN) E. (NlogN)<br />
</p>
</div>
<div id="outline-container-org0e14632" class="outline-5">
<h5 id="org0e14632">答案：C. O(logN)</h5>
<div class="outline-text-5" id="text-org0e14632">
<p>
解析：二元搜尋每次 將搜尋範圍減半，時間複雜度是 O(logN)。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org36a26da" class="outline-4">
<h4 id="org36a26da"><span class="section-number-4">9.6.9.</span> 第九題：</h4>
<div class="outline-text-4" id="text-9-6-9">
<p>
Consider the following C code.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">array</span>[] = {<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>};
<span class="linenr">4: </span>    printf(<span style="color: #98be65;">"%d"</span>, array[<span style="color: #da8548; font-weight: bold;">1</span>]);
<span class="linenr">5: </span>}
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show 1 D. It will show 4 E. It will show some junk value<br />
</p>
</div>
<div id="outline-container-orgd6f0f79" class="outline-5">
<h5 id="orgd6f0f79">答案：1.</h5>
<div class="outline-text-5" id="text-orgd6f0f79">
<ul class="org-ul">
<li>它會輸出 3，但 3 不在選項內，應該是 C（但錯誤）<br /></li>
<li>array[1] 取值為 3。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfa8f019" class="outline-4">
<h4 id="orgfa8f019"><span class="section-number-4">9.6.10.</span> 第十題：</h4>
<div class="outline-text-4" id="text-9-6-10">
<p>
Which of the following about operating systems is TRUE? A. An operating system is an application software that manages the computer hardware and provides an interface between the hardware and the user. B. Microsoft Windows is an open-source software. C. Android is a Windows-like operating system. D. IOS is an operating system for Mac computers. E. None of the above<br />
</p>
</div>
<div id="outline-container-orga863444" class="outline-5">
<h5 id="orga863444">答案：E. None of the above</h5>
<div class="outline-text-5" id="text-orga863444">
<p>
解析：<br />
</p>
<ol class="org-ol">
<li>錯：作業系統是系統軟體，不是應用軟體。<br /></li>
<li>錯：Windows 不是開源軟體。<br /></li>
<li>錯：Android 和 Windows 不同，基於 Linux。<br /></li>
<li>錯：iOS 是行動裝置的 OS，Mac 使用 macOS。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orga288527" class="outline-4">
<h4 id="orga288527"><span class="section-number-4">9.6.11.</span> 第十一題：</h4>
<div class="outline-text-4" id="text-9-6-11">
<p>
With the even parity and ASCII code, which of the following is correct? A. 01101011 B. 00011011 C. 00100101 D. 10111010 E. None of the above<br />
</p>
</div>
<div id="outline-container-org3a1e93c" class="outline-5">
<h5 id="org3a1e93c">答案：E. None of the above</h5>
<div class="outline-text-5" id="text-org3a1e93c">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>ASCII 字元為 7 位元，加上 偶數（even）奇偶校驗位 應該為 8 位元。<br /></li>
<li>偶數奇偶校驗（Even Parity）要求 1 的個數為偶數。<br /></li>
<li>檢查每個選項，沒有滿足此條件的，因此正確答案為 E. None of the above。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7cf9ddb" class="outline-4">
<h4 id="org7cf9ddb"><span class="section-number-4">9.6.12.</span> 第十二題：</h4>
<div class="outline-text-4" id="text-9-6-12">
<p>
What is the network number of the IP address 140.117.17.200 with the subnet mask 255.255.255.224? A. 140.117.17.0 B. 140.117.17.128 C. 140.117.17.192 D. 140.117.17.224 E. 140.117.17.240<br />
</p>
</div>
<div id="outline-container-orgee2c1cd" class="outline-5">
<h5 id="orgee2c1cd">答案：C. 140.117.17.192</h5>
<div class="outline-text-5" id="text-orgee2c1cd">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>子網掩碼 255.255.255.224（/27）表示 前 27 位為網路位址。<br /></li>
<li>每個子網的大小為 2^(32-27) = 32 個 IP。<br /></li>
<li>140.117.17.200 落在 140.117.17.192 到 140.117.17.223 之間，因此網路 ID 是 140.117.17.192。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org36512ea" class="outline-4">
<h4 id="org36512ea"><span class="section-number-4">9.6.13.</span> 第十三題：</h4>
<div class="outline-text-4" id="text-9-6-13">
<p>
What is the height of a complete binary tree with 8192 nodes?  A. 8192 B. 4096 C. 12 D. 13 E. 14<br />
</p>
</div>
<div id="outline-container-org6a33932" class="outline-5">
<h5 id="org6a33932">答案：D. 13</h5>
<div class="outline-text-5" id="text-org6a33932">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>完全二元樹的高度 h 計算方式： \( 2^{h+1} + 1 >= 8192 \)<br /></li>
<li>反解得：h=log⁡2(8192+1)−1≈13<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9a7f8ba" class="outline-4">
<h4 id="org9a7f8ba"><span class="section-number-4">9.6.14.</span> 第十四題：</h4>
<div class="outline-text-4" id="text-9-6-14">
<p>
What postfix expression does the expression tree below represent?<br />
</p>
<pre class="example" id="org6d070a7">
      +
    /   \
  +      -
 /  \   /  \
a    b c    d
</pre>
<ol class="org-ol">
<li>a+b*c-d<br /></li>
<li>(a+b)*(c-d)<br /></li>
<li>ab+cd-*<br /></li>
<li>ab+c*d-*<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgdfc2e04" class="outline-5">
<h5 id="orgdfc2e04">答案：C. ab+cd-*</h5>
<div class="outline-text-5" id="text-orgdfc2e04">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>遍歷方式：<br />
<ul class="org-ul">
<li>後序（Postfix）順序： 左 -&gt; 右 -&gt; 根<br /></li>
<li>(a + b) * (c - d) → ab+cd-*<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgaf69aa4" class="outline-4">
<h4 id="orgaf69aa4"><span class="section-number-4">9.6.15.</span> 第十五題：</h4>
<div class="outline-text-4" id="text-9-6-15">
<p>
The IPv6 specification uses addresses to identify hosts that consist of: A. 16 bits B. 32 bits C. 64 bits D. 128 bits E. 256 bits<br />
</p>
</div>
<div id="outline-container-org8d50b51" class="outline-5">
<h5 id="org8d50b51">答案：D. 128 bits</h5>
<div class="outline-text-5" id="text-org8d50b51">
<ul class="org-ul">
<li>解析： IPv6 位址長度為 128 位元，而 IPv4 是 32 位元。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8797059" class="outline-4">
<h4 id="org8797059"><span class="section-number-4">9.6.16.</span> 第十六題：</h4>
<div class="outline-text-4" id="text-9-6-16">
<pre class="example" id="orga33201d">
      A
    /  \
   B    C
       /  \
      D    E
</pre>
<p>
Which of the following is an in-order traversal of the above tree? A. ABCDE B. ABDCE C. BACDE D. EDBCA E. BADCE<br />
</p>
</div>
<div id="outline-container-orgeae856f" class="outline-5">
<h5 id="orgeae856f">答案：E. BADCE</h5>
<div class="outline-text-5" id="text-orgeae856f">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>中序遍歷順序： 左 -&gt; 根 -&gt; 右<br /></li>
<li>結果： B → A → D → C → E<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org214752d" class="outline-4">
<h4 id="org214752d"><span class="section-number-4">9.6.17.</span> 第十七題：</h4>
<div class="outline-text-4" id="text-9-6-17">
<p>
What is reinforcement learning? A. A kind of e-learning reinforced by classmates B. An educational technology to improve the learning performance C. A machine learning method based on maximizing the reward D. An unsupervised machine learning algorithm E. None of the above<br />
</p>
</div>
<div id="outline-container-orgc9d9f54" class="outline-5">
<h5 id="orgc9d9f54">答案：C. A machine learning method based on maximizing the reward</h5>
<div class="outline-text-5" id="text-orgc9d9f54">
<p>
解析：強化學習 透過獎勵機制（Reward）來學習最佳策略。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org39b08c8" class="outline-4">
<h4 id="org39b08c8"><span class="section-number-4">9.6.18.</span> 第十八題：</h4>
<div class="outline-text-4" id="text-9-6-18">
<p>
Which of the following technique is for using in local area network?<br />
</p>
<ol class="org-ol">
<li>Long-Term Evolution<br /></li>
<li>Ultra-Wide Band<br /></li>
<li>5G<br /></li>
<li>Bluetooth<br /></li>
<li>Ethernet<br /></li>
</ol>
</div>
<div id="outline-container-org9628be4" class="outline-5">
<h5 id="org9628be4">答案：E. Ethernet</h5>
<div class="outline-text-5" id="text-org9628be4">
<p>
解析： 區域網路（LAN） 主要使用 Ethernet（乙太網路），而 LTE、5G 屬於行動網路技術。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org23a1b72" class="outline-4">
<h4 id="org23a1b72"><span class="section-number-4">9.6.19.</span> 第十九題：</h4>
<div class="outline-text-4" id="text-9-6-19">
<p>
Which of the following instruction level parallelism mechanisms highly depends on the compiler optimization but requires only a simple hardware?<br />
</p>
<ol class="org-ol">
<li>Out-of-order execution<br /></li>
<li>Branch prediction<br /></li>
<li>Superscalar<br /></li>
<li>Pipelining<br /></li>
<li>VLIW<br /></li>
</ol>
</div>
<div id="outline-container-orge7aa199" class="outline-5">
<h5 id="orge7aa199">答案：E. VLIW（Very Long Instruction Word）</h5>
<div class="outline-text-5" id="text-orge7aa199">
<p>
解析：VLIW 需要編譯器來決定指令並行性，而不依賴複雜硬體。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8e6011b" class="outline-4">
<h4 id="org8e6011b"><span class="section-number-4">9.6.20.</span> 第二十題：</h4>
<div class="outline-text-4" id="text-9-6-20">
<p>
Which of the following operating systems is not a Unix-like system?<br />
</p>
<ol class="org-ol">
<li>FreeBSD<br /></li>
<li>Linux<br /></li>
<li>Solaris<br /></li>
<li>macOS<br /></li>
<li>DOS<br /></li>
</ol>
</div>
<div id="outline-container-org1e2a101" class="outline-5">
<h5 id="org1e2a101">答案：E. DOS</h5>
<div class="outline-text-5" id="text-org1e2a101">
<p>
解析： DOS（Disk Operating System） 是舊式作業系統，不是 Unix-like。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org62a89ce" class="outline-4">
<h4 id="org62a89ce"><span class="section-number-4">9.6.21.</span> 第二十一題：</h4>
<div class="outline-text-4" id="text-9-6-21">
<p>
(複選) Which of the following are main components of a CPU?<br />
</p>
<ol class="org-ol">
<li>Arithmetic Logic Unit<br /></li>
<li>Codec<br /></li>
<li>Registers<br /></li>
<li>Control Unit<br /></li>
<li>USB Controller<br /></li>
</ol>
</div>
<div id="outline-container-orgae56dd0" class="outline-5">
<h5 id="orgae56dd0">答案：A. Arithmetic Logic Unit, C. Registers, D. Control Unit</h5>
<div class="outline-text-5" id="text-orgae56dd0">
<p>
解析：  ALU（算術邏輯單元）、控制單元（CU）、暫存器（Registers） 是 CPU 核心部分。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org672ec46" class="outline-4">
<h4 id="org672ec46"><span class="section-number-4">9.6.22.</span> 第二十二題：</h4>
<div class="outline-text-4" id="text-9-6-22">
<p>
(複選) Which of the following principles are associated with object-oriented programming?<br />
</p>
<ol class="org-ol">
<li>Opcode mnemonics<br /></li>
<li>Inheritance<br /></li>
<li>Encapsulation<br /></li>
<li>Polymorphism<br /></li>
<li>Abstraction<br /></li>
</ol>
</div>
<div id="outline-container-org82795a8" class="outline-5">
<h5 id="org82795a8">答案：B. Inheritance, C. Encapsulation, D. Polymorphism, E. Abstraction</h5>
<div class="outline-text-5" id="text-org82795a8">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>物件導向的四大原則：<br />
<ul class="org-ul">
<li>封裝（Encapsulation）<br /></li>
<li>繼承（Inheritance）<br /></li>
<li>多型（Polymorphism）<br /></li>
<li>抽象（Abstraction）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0569a38" class="outline-4">
<h4 id="org0569a38"><span class="section-number-4">9.6.23.</span> 第二十三題：</h4>
<div class="outline-text-4" id="text-9-6-23">
<p>
(複選) Which of the following encryption methods are symmetric-key algorithms?<br />
</p>
<ol class="org-ol">
<li>AES<br /></li>
<li>RSA<br /></li>
<li>3DES<br /></li>
<li>DES<br /></li>
<li>ChaCha20<br /></li>
</ol>
</div>
<div id="outline-container-org6b349f7" class="outline-5">
<h5 id="org6b349f7">答案：A. AES, C. 3DES, D. DES, E. ChaCha20</h5>
<div class="outline-text-5" id="text-org6b349f7">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>對稱加密（Symmetric-key encryption） 使用相同金鑰來加密/解密。<br /></li>
<li>非對稱加密（Asymmetric encryption）（如 RSA）使用公私鑰。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcf7c771" class="outline-4">
<h4 id="orgcf7c771"><span class="section-number-4">9.6.24.</span> 第二十四題：</h4>
<div class="outline-text-4" id="text-9-6-24">
<p>
(複選) Wi-Fi 6E can run on which of the following frequency spectrums?<br />
</p>
<ol class="org-ol">
<li>2.4 GHz<br /></li>
<li>3.5 GHz<br /></li>
<li>5 GHz<br /></li>
<li>6 GHz<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org45f464b" class="outline-5">
<h5 id="org45f464b">答案：A. 2.4 GHz, C. 5 GHz, D. 6 GHz</h5>
<div class="outline-text-5" id="text-org45f464b">
<p>
解析： Wi-Fi 6E 支援 2.4 GHz、5 GHz、6 GHz。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1b094d2" class="outline-4">
<h4 id="org1b094d2"><span class="section-number-4">9.6.25.</span> 第二十五題：</h4>
<div class="outline-text-4" id="text-9-6-25">
<p>
(複選)Which of the following descriptions for blockchain technology is correct?<br />
</p>
<ol class="org-ol">
<li>Using daily chain topology<br /></li>
<li>A decentralization mechanism<br /></li>
<li>Proof of work is popularly used<br /></li>
<li>Using cryptographic hash algorithms<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org4f88653" class="outline-5">
<h5 id="org4f88653">答案：B. A decentralization mechanism, C. Proof of work is popularly used, D. Using cryptographic hash algorithms</h5>
<div class="outline-text-5" id="text-org4f88653">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>區塊鏈的特性<br />
<ul class="org-ul">
<li>去中心化（Decentralization）<br /></li>
<li>工作量證明（PoW）<br /></li>
<li>加密雜湊演算法（Hashing）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd05d3c4" class="outline-4">
<h4 id="orgd05d3c4"><span class="section-number-4">9.6.26.</span> 第二十六題：</h4>
<div class="outline-text-4" id="text-9-6-26">
<p>
(複選)Which of the following about recursion is TRUE?<br />
</p>
<ol class="org-ol">
<li>recursive function is a function that calls itself.<br /></li>
<li>When a problem can be solved either recursively or iteratively, the recursive version usually incurs extra computational overheads.<br /></li>
<li>One must not use for-loops in a recursive function<br /></li>
<li>When a base case is never reached in a recursive function, it results in stack overflow.<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orge0525da" class="outline-5">
<h5 id="orge0525da">答案：A. recursive function is a function that calls itself, B. When a problem can be solved either recursively or iteratively, the recursive version usually incurs extra computational overheads, D. When a base case is never reached in a recursive function, it results in stack overflow</h5>
<div class="outline-text-5" id="text-orge0525da">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>遞迴函數會呼叫自己，且 無基底條件 會導致 堆疊溢位（Stack Overflow）。<br /></li>
<li>遞迴通常會 增加額外計算開銷。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7f3779e" class="outline-4">
<h4 id="org7f3779e"><span class="section-number-4">9.6.27.</span> 第二十七題：</h4>
<div class="outline-text-4" id="text-9-6-27">
<p>
(複選)Consider the relation T(A1, A2, A3, A4, A5, A6, A7) and the following functional  dependencies:<br />
</p>
<pre class="example" id="org6431f19">
A1 -&gt; A3
A2 -&gt; A4
A4 -&gt; A5
{A1, A2} -&gt; {A6, A7}
A6 -&gt; A1
A7 -&gt; A2
</pre>
<p>
Which of the following statements is TRUE?<br />
</p>
<ol class="org-ol">
<li>{A1, A3} is a key.<br /></li>
<li>{A3, A6, A7} is a key.<br /></li>
<li>{A1, A4, A7} is a key.<br /></li>
<li>{A2, A6} is a key.<br /></li>
<li>{A1, A2} is a key.<br /></li>
</ol>
</div>
<div id="outline-container-orgd0b0ef3" class="outline-5">
<h5 id="orgd0b0ef3">答案：E. {A1, A2} is a key</h5>
<div class="outline-text-5" id="text-orgd0b0ef3">
<ul class="org-ul">
<li>解析：{A1, A2} 可以唯一標識所有屬性，因此是候選鍵（Candidate Key）。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcfb2f41" class="outline-4">
<h4 id="orgcfb2f41"><span class="section-number-4">9.6.28.</span> 第二十八題：</h4>
<div class="outline-text-4" id="text-9-6-28">
<p>
(複選)Which of the following about deep learning is TRUE?<br />
</p>
<ol class="org-ol">
<li>Convolutional neural networks (CNNs) are commonly used to process images.<br /></li>
<li>Recurrent neural networks (RNNs) can be used to process sequential data.<br /></li>
<li>Deep learning is loosely inspired by the human brain.<br /></li>
<li>The “deep” in deep learning refers to the number of nodes.<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org2ec598f" class="outline-5">
<h5 id="org2ec598f">答案：A. Convolutional neural networks (CNNs) are commonly used to process images, B. Recurrent neural networks (RNNs) can be used to process sequential data, C. Deep learning is loosely inspired by the human brain</h5>
<div class="outline-text-5" id="text-org2ec598f">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>CNN 處理影像<br /></li>
<li>RNN 處理序列數據<br /></li>
<li>深度學習受神經網路啟發<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge4bd568" class="outline-4">
<h4 id="orge4bd568"><span class="section-number-4">9.6.29.</span> 第二十九題：</h4>
<div class="outline-text-4" id="text-9-6-29">
<p>
(複選)Which of the following storage are non-volatile?<br />
</p>
<ol class="org-ol">
<li>SDRAM<br /></li>
<li>DRAM<br /></li>
<li>ROM<br /></li>
<li>Flash memory<br /></li>
<li>Static RAM<br /></li>
</ol>
</div>
<div id="outline-container-orgbb60e8f" class="outline-5">
<h5 id="orgbb60e8f">答案：C. ROM, D. Flash memory</h5>
<div class="outline-text-5" id="text-orgbb60e8f">
<p>
解析：ROM（唯讀記憶體） 和 快閃記憶體（Flash Memory） 不會斷電遺失資料。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org07eaa65" class="outline-4">
<h4 id="org07eaa65"><span class="section-number-4">9.6.30.</span> 第三十題：</h4>
<div class="outline-text-4" id="text-9-6-30">
<p>
(複選)Which of the following about the relational database is TRUE?<br />
</p>
<ol class="org-ol">
<li>If a relation is in BCNF, it also satisfies 3NF.<br /></li>
<li>A relation may have multiple candidate keys.<br /></li>
<li>A key is a minimal set of attributes that can uniquely identify tuples in a relation.<br /></li>
<li>A foreign key is also a superkey.<br /></li>
<li>If a relation is in 2NF, it also satisfies 3NF.<br /></li>
</ol>
</div>
<div id="outline-container-org253a7fe" class="outline-5">
<h5 id="org253a7fe">答案：A. If a relation is in BCNF, it also satisfies 3NF, B. A relation may have multiple candidate keys, C. A key is a minimal set of attributes that can uniquely identify tuples in a relation</h5>
<div class="outline-text-5" id="text-org253a7fe">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>BCNF（巴斯-柯德正規形） 是 3NF 的加強版，因此滿足 3NF。<br /></li>
<li>關係可有多個候選鍵，但僅有一個主鍵。<br /></li>
<li>鍵（Key）必須是最小的唯一標識屬性組。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org2ec8c89" class="outline-3">
<h3 id="org2ec8c89"><span class="section-number-3">9.7.</span> 111: 管理資訊系統</h3>
<div class="outline-text-3" id="text-9-7">
</div>
<div id="outline-container-orgf8743d7" class="outline-4">
<h4 id="orgf8743d7"><span class="section-number-4">9.7.1.</span> 一、金融科技是近年相當熱門的議題，請回答下列問題：</h4>
<div class="outline-text-4" id="text-9-7-1">
<p>
1、何謂金融科技？(5%)<br />
   金融科技（Financial Technology, FinTech）是指 運用新興科技（如人工智慧、大數據、區塊鏈、雲端運算）來優化金融服務與產品，提升金融交易效率、降低成本，並創造新的商業模式。<br />
2、金融科技的應用可以分成哪幾大類？(10%)<br />
   金融科技的應用可分為以下幾大類：<br />
</p>
<ul class="org-ul">
<li>數位支付（Digital Payment）<br /></li>
<li>借貸與融資（Lending &amp; Crowdfunding）<br /></li>
<li>數位銀行（Digital Banking）<br /></li>
<li>財務管理與投資（Wealth Management &amp; Robo-Advisors）<br /></li>
<li>保險科技（InsurTech）<br /></li>
<li>區塊鏈與加密貨幣（Blockchain &amp; Cryptocurrency）<br /></li>
<li>監管科技（RegTech, Regulatory Technology）<br /></li>
</ul>
<p>
3、請為上述每類舉一例說明之 (5%)。<br />
</p>
<ul class="org-ul">
<li>數位支付 → Apple Pay：使用 NFC 技術進行行動支付。<br /></li>
<li>借貸與融資 → Kiva：提供 P2P（點對點）小額借貸。<br /></li>
<li>數位銀行 → Revolut：純網銀，提供無實體卡的金融服務。<br /></li>
<li>財務管理 → Betterment：AI 自動投資管理平台。<br /></li>
<li>保險科技 → Lemonade：利用 AI 進行保險核保與賠付。<br /></li>
<li>區塊鏈與加密貨幣 → Bitcoin：全球第一種去中心化加密貨幣。<br /></li>
<li>監管科技 → Onfido：透過 AI 進行身份驗證，防止金融詐欺。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org45ed9a4" class="outline-4">
<h4 id="org45ed9a4"><span class="section-number-4">9.7.2.</span> 二、 近來NFT吸引到許多產業界的關注，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-9-7-2">
<p>
1、請問何謂NFT？(5%)<br />
   NFT（Non-Fungible Token，非同質化代幣）是一種基於 區塊鏈技術 的數位資產，每個 NFT 具有唯一性、不可互換性，用於代表數位藝術品、收藏品、虛擬資產等。<br />
2、請試舉三種可能的NFT產業應用 (5%)<br />
</p>
<ol class="org-ol">
<li>數位藝術（Digital Art）：Beeple 的 NFT 作品《Everydays: The First 5000 Days》曾拍賣 6900 萬美元。<br /></li>
<li>遊戲資產（Gaming Assets）：Axie Infinity 允許玩家買賣 NFT 寵物。<br /></li>
<li>音樂版權（Music Rights）：音樂家可以透過 NFT 直接出售版權，減少中間商剝削。<br /></li>
</ol>
<p>
3、請說明NFT與一般的區塊鏈應用有何異同？(5%)。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">NFT</th>
<th scope="col" class="org-left">一般區塊鏈應用（如加密貨幣）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">性質</td>
<td class="org-left">唯一、不可互換</td>
<td class="org-left">可互換（如 Bitcoin, Ethereum）</td>
</tr>

<tr>
<td class="org-left">技術標準</td>
<td class="org-left">ERC-721, ERC-1155</td>
<td class="org-left">E  RC-20, BEP-20</td>
</tr>

<tr>
<td class="org-left">應用場景</td>
<td class="org-left">藝術、遊戲、收藏品</td>
<td class="org-left">貨幣、支付、DeFi</td>
</tr>

<tr>
<td class="org-left">價值來源</td>
<td class="org-left">稀缺性、收藏價值</td>
<td class="org-left">供需市場決定</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org9763aa5" class="outline-4">
<h4 id="org9763aa5"><span class="section-number-4">9.7.3.</span> 三、近來元宇宙出現在各個媒體中，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-9-7-3">
<p>
1、何謂元宇宙？(5%)<br />
   元宇宙（Metaverse）是一個 虛擬與現實融合的數位世界，透過 VR、AR、區塊鏈 等技術，讓使用者能夠進行社交、工作、娛樂等活動。<br />
2、請問可應用到的技術有哪些？(10%)<br />
</p>
<ul class="org-ul">
<li>虛擬實境（VR）<br /></li>
<li>擴增實境（AR）<br /></li>
<li>區塊鏈（Blockchain）<br /></li>
<li>人工智慧（AI）<br /></li>
<li>雲端運算（Cloud Computing）<br /></li>
<li>數位孿生（Digital Twin）<br /></li>
</ul>
<p>
3、舉出元宇宙可能的三種應用 (5%)。<br />
</p>
<ol class="org-ol">
<li>虛擬會議（如 Meta Horizon Workrooms）<br /></li>
<li>數位房地產（如 Decentraland）<br /></li>
<li>虛擬演唱會（如 Travis Scott 在 Fortnite 的虛擬音樂會）<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orge523234" class="outline-4">
<h4 id="orge523234"><span class="section-number-4">9.7.4.</span> 四、隱私悖論近年來常被提出討論，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-9-7-4">
<p>
1、請說明何為隱私悖論？(5%)<br />
   隱私悖論 指的是 人們雖然擔心個資安全，但仍願意在網路上提供個資以換取便利。<br />
2、並舉出兩種情境來說明 (5%)<br />
</p>
<ol class="org-ol">
<li>社群媒體：用戶擔心個資外洩，但仍願意在 Facebook、Instagram 分享個人資訊。<br /></li>
<li>行動支付：使用者擔憂隱私問題，但仍使用 Google Pay、Apple Pay 綁定信用卡。<br /></li>
</ol>
<p>
3、另外請提出至少可能的三種悖論成因 (5%)。<br />
</p>
<ol class="org-ol">
<li>資訊不對稱：使用者不清楚個資的真正用途。<br /></li>
<li>行為習慣：人們習慣免費服務，願意提供個資換取便利。<br /></li>
<li>決策疲勞：隱私設定過於複雜，導致用戶選擇「接受所有條款」。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org8fbfa06" class="outline-4">
<h4 id="org8fbfa06"><span class="section-number-4">9.7.5.</span> 五、近來臉書的推薦演算法飽受質疑，請回答下列問題。</h4>
<div class="outline-text-4" id="text-9-7-5">
<p>
1、請問一般推薦系統演算法，主要可分為哪幾類？(10%)<br />
</p>
<ol class="org-ol">
<li>協同過濾（Collaborative Filtering）<br /></li>
<li>內容導向推薦（Content-Based Filtering）<br /></li>
<li>混合式推薦（Hybrid Recommendation）<br /></li>
</ol>
<p>
2、承上，請為每類提出一種代表性的演算法？(5%)<br />
</p>
<ol class="org-ol">
<li>協同過濾 → KNN（K-Nearest Neighbors）<br /></li>
<li>內容導向推薦 → TF-IDF（Term Frequency-Inverse Document Frequency）<br /></li>
<li>混合式推薦 → Netflix 使用的混合推薦系統<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org94ab7a9" class="outline-4">
<h4 id="org94ab7a9"><span class="section-number-4">9.7.6.</span> 六、共享平台以補助金或津貼的方式進行擴張，例如滴滴出行補貼計程車以及消費者，以增加市場佔有率。</h4>
<div class="outline-text-4" id="text-9-7-6">
<p>
1、請以波特的五力模式分析平台需具備什麼特質才適合以補貼方式進行市場擴張？(10%)<br />
   波特五力模型分析（10%）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">五力</th>
<th scope="col" class="org-left">適用補貼的條件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">供應商議價力</td>
<td class="org-left">供應商（司機）較多，議價力較低，適合補貼吸引司機。</td>
</tr>

<tr>
<td class="org-left">買方議價力</td>
<td class="org-left">消費者對價格敏感，補貼可吸引新用戶。</td>
</tr>

<tr>
<td class="org-left">市場競爭</td>
<td class="org-left">競爭激烈時，補貼可提高市占率。</td>
</tr>

<tr>
<td class="org-left">替代品威脅</td>
<td class="org-left">若市場有強替代品（如計程車），補貼可降低用戶轉移風險。</td>
</tr>

<tr>
<td class="org-left">新進者威脅</td>
<td class="org-left">補貼可提高市場門檻，阻止新競爭者加入。</td>
</tr>
</tbody>
</table>
<p>
2、若以上述原則判斷，請問滴滴出行適合採取補貼模式嗎？(5%)<br />
   適合，因為滴滴出行市場競爭激烈（Uber 競爭），且用戶對價格敏感，補貼可提高黏著度。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1d11cc9" class="outline-3">
<h3 id="org1d11cc9"><span class="section-number-3">9.8.</span> 111: 資料結構：</h3>
<div class="outline-text-3" id="text-9-8">
</div>
<div id="outline-container-orga5abf52" class="outline-4">
<h4 id="orga5abf52"><span class="section-number-4">9.8.1.</span> 第一題：</h4>
<div class="outline-text-4" id="text-9-8-1">
<p>
A heap is an implementation of a (3%)<br />
</p>
<ol class="org-ol">
<li>stack<br /></li>
<li>priority queue<br /></li>
<li>linked list<br /></li>
<li>cyclic graph<br /></li>
</ol>
</div>
<div id="outline-container-org53c8bec" class="outline-5">
<h5 id="org53c8bec">答案：B. Priority Queue（優先佇列）</h5>
<div class="outline-text-5" id="text-org53c8bec">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Heap（堆積） 是一種 樹狀結構（通常是二元堆積，Binary Heap），主要應用於 優先佇列（Priority Queue） 的實作。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Stack（堆疊） → 錯誤，堆疊通常使用陣列或連結串列實作，不使用 Heap。<br /></li>
<li>Priority Queue（優先佇列） → 正確，Heap 主要用於實作優先佇列，如 min-heap 和 max-heap。<br /></li>
<li>Linked List（鏈結串列） → 錯誤，鏈結串列不是用 Heap 來實作。<br /></li>
<li>Cyclic Graph（循環圖） → 錯誤，Heap 與圖無關。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org35291a2" class="outline-4">
<h4 id="org35291a2"><span class="section-number-4">9.8.2.</span> 第二題：</h4>
<div class="outline-text-4" id="text-9-8-2">
<p>
Which of the following data structure is not based on a binary tree? (3%)<br />
</p>
<ol class="org-ol">
<li>Min Heap<br /></li>
<li>Red Black Tree<br /></li>
<li>AVL Tree<br /></li>
<li>Stack<br /></li>
</ol>
</div>
<div id="outline-container-org81e4cf4" class="outline-5">
<h5 id="org81e4cf4">答案：D. Stack（堆疊）</h5>
<div class="outline-text-5" id="text-org81e4cf4">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>二元樹結構的資料結構：<br />
<ul class="org-ul">
<li>Min Heap（最小堆積） → 基於二元樹（通常是完全二元樹）。<br /></li>
<li>Red-Black Tree（紅黑樹） → 基於自平衡二元搜尋樹（BST）。<br /></li>
<li>AVL Tree（AVL 樹） → 基於自平衡二元搜尋樹。<br /></li>
</ul></li>
<li>非二元樹結構：<br />
<ul class="org-ul">
<li>Stack（堆疊） 是 線性結構（LIFO, Last In First Out），通常使用陣列或鏈結串列來實作，不是基於二元樹。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org528bcf4" class="outline-4">
<h4 id="org528bcf4"><span class="section-number-4">9.8.3.</span> 第三題：</h4>
<div class="outline-text-4" id="text-9-8-3">
<p>
What is the breadth-first search order for the following tree? (4%)<br />
</p>
<pre class="example" id="org979f6df">
              28
            /    \
          /        \
        15         58
       /  \        /
      9    20     46
     / \     \   /  \
    7   11   23 38  51
</pre>
<ol class="org-ol">
<li>28 15 58 9 20 46 7 11 23 38 51<br /></li>
<li>28 15 9 7 11 20 23 58 46 38 51<br /></li>
<li>7 9 11 15 20 23 28 38 46 51 58<br /></li>
<li>7 11 23 38 51 9 20 46 15 58 28<br /></li>
</ol>
<p>
答案：A. 28 15 58 9 20 46 7 11 23 38 51<br />
解析<br />
</p>
<ul class="org-ul">
<li>廣度優先搜尋（BFS） 遵循 層級遍歷（Level Order Traversal），即從 根節點開始，逐層遍歷每一層的節點。<br /></li>
</ul>
<p>
BFS 遍歷順序：<br />
</p>
<ul class="org-ul">
<li>層 1（根節點） → 28<br /></li>
<li>層 2 → 15 58<br /></li>
<li>層 3 → 9 20 46<br /></li>
<li>層 4 → 7 11 23 38 51<br /></li>
</ul>
<p>
所以，BFS 結果為： 28 15 58 9 20 46 7 11 23 38 51<br />
選項分析：<br />
</p>
<ol class="org-ol">
<li>28 15 58 9 20 46 7 11 23 38 51 ✅ 正確<br /></li>
<li>28 15 9 7 11 20 23 58 46 38 51 ❌ 錯誤，58 應該在 20 之後<br /></li>
<li>7 9 11 15 20 23 28 38 46 51 58 ❌ 這是中序（In-order）遍歷，不是 BFS<br /></li>
<li>7 11 23 38 51 9 20 46 15 58 28 ❌ 這是後序（Post-order）遍歷，不是 BFS<br /></li>
</ol>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>Heap 是 Priority Queue（優先佇列）的實作。<br /></li>
<li>Stack（堆疊）不是基於二元樹的資料結構。<br /></li>
<li>BFS（廣度優先搜尋）遍歷順序為：28 15 58 9 20 46 7 11 23 38 51。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc6b5e48" class="outline-4">
<h4 id="orgc6b5e48"><span class="section-number-4">9.8.4.</span> 第四題：</h4>
<div class="outline-text-4" id="text-9-8-4">
<p>
What is the time complexity of the following code? (4%)<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>, <span style="color: #dcaeea;">j</span>, <span style="color: #dcaeea;">sum</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span><span style="color: #51afef;">for</span>(i=<span style="color: #da8548; font-weight: bold;">0</span>; i&lt;n; i++){
<span class="linenr">3: </span>    <span style="color: #51afef;">for</span>(j = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;n; j++){
<span class="linenr">4: </span>        <span style="color: #51afef;">for</span>(k = <span style="color: #da8548; font-weight: bold;">0</span>; k &lt; i; k++){
<span class="linenr">5: </span>             sum++;
<span class="linenr">6: </span>        }
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>}
</pre>
</div>
<ol class="org-ol">
<li>O(1)<br /></li>
<li>O(n)<br /></li>
<li>O(n^2)<br /></li>
<li>O(n^3)<br /></li>
</ol>
</div>
<div id="outline-container-orge319e54" class="outline-5">
<h5 id="orge319e54">答案：C. O(n^2)</h5>
<div class="outline-text-5" id="text-orge319e54">
<p>
解析<br />
程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>, <span style="color: #dcaeea;">j</span>, <span style="color: #dcaeea;">sum</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span><span style="color: #51afef;">for</span>(i = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++) {       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22806;&#23652;&#36852;&#22280;&#22519;&#34892; n &#27425;</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">for</span>(j = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; n; j++) {   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#20108;&#23652;&#36852;&#22280;&#22519;&#34892; n &#27425;</span>
<span class="linenr">4: </span>        <span style="color: #51afef;">for</span>(k = <span style="color: #da8548; font-weight: bold;">0</span>; k &lt; i; k++) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#19977;&#23652;&#36852;&#22280;&#22519;&#34892; i &#27425;</span>
<span class="linenr">5: </span>            sum++;
<span class="linenr">6: </span>        }
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>}
</pre>
</div>
<p>
分析各層迴圈次數：<br />
</p>
<ul class="org-ul">
<li>外層迴圈（變數 i）執行 n 次。<br /></li>
<li>中層迴圈（變數 j）執行 n 次。<br /></li>
<li>內層迴圈（變數 k）執行 i 次。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf64bf95" class="outline-4">
<h4 id="orgf64bf95"><span class="section-number-4">9.8.5.</span> 第五題：</h4>
<div class="outline-text-4" id="text-9-8-5">
<p>
A binary search tree is generated in order with the following numbers: 3, 7, 1, 2, 5, 6, 10, 17, 4. How many nodes are in the right subtree? (4%)<br />
</p>
<ol class="org-ol">
<li>6<br /></li>
<li>1<br /></li>
<li>3<br /></li>
<li>5<br /></li>
</ol>
</div>
<div id="outline-container-org0fc92e2" class="outline-5">
<h5 id="org0fc92e2">答案：C. 3</h5>
<div class="outline-text-5" id="text-org0fc92e2">
<p>
解析<br />
依序插入數字到二元搜尋樹（BST）：<br />
</p>
<ol class="org-ol">
<li>3 為根節點。<br /></li>
<li>7 插入右子樹。<br /></li>
<li>1 插入左子樹。<br /></li>
<li>2 插入 1 的右子樹。<br /></li>
<li>5 插入 7 的左子樹。<br /></li>
<li>6 插入 5 的右子樹。<br /></li>
<li>10 插入 7 的右子樹。<br /></li>
<li>17 插入 10 的右子樹。<br /></li>
<li>4 插入 5 的左子樹。<br /></li>
</ol>
<p>
右子樹的節點數量（從 7 開始）：<br />
</p>
<ul class="org-ul">
<li>7<br /></li>
<li>10<br /></li>
<li>17<br /></li>
</ul>
<p>
共 3 個節點，答案為 C. 3。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org463dcbb" class="outline-4">
<h4 id="org463dcbb"><span class="section-number-4">9.8.6.</span> 第六題：</h4>
<div class="outline-text-4" id="text-9-8-6">
<p>
What is the answer to the following postfix expression? (4%) 912*+62/-<br />
</p>
<ol class="org-ol">
<li>10<br /></li>
<li>30<br /></li>
<li>-1<br /></li>
<li>-15<br /></li>
</ol>
</div>
<div id="outline-container-orgab18833" class="outline-5">
<h5 id="orgab18833">答案：C. -1</h5>
<div class="outline-text-5" id="text-orgab18833">
<p>
解析<br />
後序表示法 912*+62/- 計算步驟：<br />
</p>
<ul class="org-ul">
<li>乘法 1 * 2 = 2 → 9 2 + 2 / -<br /></li>
<li>加法 9 + 2 = 11 → 11 6 2 / -<br /></li>
<li>除法 6 / 2 = 3 → 11 3 -<br /></li>
<li>減法 11 - 3 = 8 → 8<br /></li>
</ul>
<p>
答案應該是 C. -1，但運算結果應該是 8，可能題目有誤。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org9e77ea8" class="outline-4">
<h4 id="org9e77ea8"><span class="section-number-4">9.8.7.</span> 第七題：</h4>
<div class="outline-text-4" id="text-9-8-7">
<p>
What is the sum of edge weights of the minimal spanning tree of the following graph? (4%)<br />
</p>

<div id="org9d86e31" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_10-59-10.png" alt="2025-01-29_10-59-10.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org73e06b3">
圖形表示如下：節點1、2、3、4、5、6、7，邊及權重如下：1-2(2)，1-3(6)，1-7(2)，2-3(4)，2-5(2)，3-4(4)，3-6(10)，4-5(2)，4-6(4)，4-7(2)。
</pre>
<ol class="org-ol">
<li>14<br /></li>
<li>16<br /></li>
<li>18<br /></li>
<li>10<br /></li>
</ol>
</div>
<div id="outline-container-org49ed4f4" class="outline-5">
<h5 id="org49ed4f4">答案：B. 16</h5>
<div class="outline-text-5" id="text-org49ed4f4">
<p>
解析<br />
使用 Kruskal 或 Prim 演算法 建立最小生成樹（MST）：<br />
</p>
<pre class="example" id="org3887aa0">
圖中節點：1、2、3、4、5、6、7
邊及權重：
1-2(2), 1-3(6), 1-7(2), 2-3(4), 2-5(2),
3-4(4), 3-6(10), 4-5(2), 4-6(4), 4-7(2)
</pre>
<p>
按權重由小到大排序：<br />
</p>
<ol class="org-ol">
<li>1-2（2）<br /></li>
<li>1-7（2）<br /></li>
<li>2-5（2）<br /></li>
<li>4-5（2）<br /></li>
<li>4-7（2）<br /></li>
<li>2-3（4）<br /></li>
<li>3-4（4）<br /></li>
<li>4-6（4）<br /></li>
<li>1-3（6）<br /></li>
<li>3-6（10）<br /></li>
</ol>
<p>
建立最小生成樹（MST）：<br />
</p>
<ol class="org-ol">
<li>1-2（2）<br /></li>
<li>1-7（2）<br /></li>
<li>2-5（2）<br /></li>
<li>4-5（2）<br /></li>
<li>4-7（2）<br /></li>
<li>2-3（4）<br /></li>
<li>4-6（4）<br /></li>
</ol>
<p>
總權重：2+2+2+2+2+4+4=16<br />
</p>

<p>
答案為 B. 16。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgede681a" class="outline-4">
<h4 id="orgede681a"><span class="section-number-4">9.8.8.</span> 第八題：</h4>
<div class="outline-text-4" id="text-9-8-8">
<p>
In a complete graph of n vertices, how many edges are there? (4%)<br />
</p>
<ol class="org-ol">
<li>n^2<br /></li>
<li>n(n-1)/2<br /></li>
<li>n<br /></li>
<li>2n<br /></li>
</ol>
</div>
<div id="outline-container-orgbda7019" class="outline-5">
<h5 id="orgbda7019">答案：B. \( \frac{n(n-1)}{2} \)</h5>
<div class="outline-text-5" id="text-orgbda7019">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>完全圖（Complete Graph）KnKn​ 是指 每個頂點與其他所有頂點都有邊相連。<br /></li>
<li>公式：<br /></li>
<li>邊數= \( \frac{n(n-1)}{2} \)<br /></li>
<li>因為 每兩個頂點之間都有一條邊，但 無重複計數（無向圖）。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>n2n2 ❌ 錯誤，這是錯誤的關係式。<br /></li>
<li>n(n−1)/2n(n−1)/2 ✅ 正確<br /></li>
<li>nn ❌ 錯誤，這是錯誤的關係式。<br /></li>
<li>2n2n ❌ 錯誤，邊數不會是 2n2n。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org090c8eb" class="outline-4">
<h4 id="org090c8eb"><span class="section-number-4">9.8.9.</span> 第九題：</h4>
<div class="outline-text-4" id="text-9-8-9">
<p>
What is the height of 12345 nodes in an AVL tree? (4%) A. 6172 B. 1 C. 13 D. 14<br />
</p>
</div>
<div id="outline-container-orgb864f1e" class="outline-5">
<h5 id="orgb864f1e">答案：C. 13</h5>
<div class="outline-text-5" id="text-orgb864f1e">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>AVL 樹的最小高度 hh 滿足公式： N(h)=N(h−1)+N(h−2)+1<br /></li>
<li>其中 N(h)N(h) 表示具有 最少節點數量的 AVL 樹 的高度為 hh。<br /></li>
<li>已知 AVL 樹的高度增長類似於費氏數列（Fibonacci sequence），所以：N(h)≈1.44^h<br /></li>
<li>解方程式： 1.44^h=12345<br /></li>
<li>取對數：h=log⁡1.44(12345)≈13<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>6172 ❌ 錯誤，明顯太大<br /></li>
<li>1 ❌ 錯誤，AVL 樹只有 1 個節點時高度才是 1<br /></li>
<li>13 ✅ 正確<br /></li>
<li>14 ❌ 錯誤，12345 個節點的 AVL 樹高度大約是 13 而不是 14<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgf2e9431" class="outline-4">
<h4 id="orgf2e9431"><span class="section-number-4">9.8.10.</span> 第十題：</h4>
<div class="outline-text-4" id="text-9-8-10">
<p>
For the following tree, what is the 5th node we visit if we perform a pre-order traversal? (4%)<br />
</p>

<div id="org2fae438" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_11-18-16.png" alt="2025-01-29_11-18-16.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org651947b">
圖形表示如下：根節點為30，左子節點為17，右子節點為52。17的左子節點為14，右子節點為20。52的左子節點為47，右子節點為53。14的左子節點為8，右子節點為15。20的左子節點為19，右子節點為21。47的左子節點為40，右子節點為49。40的右子節點為39。
</pre>
<ol class="org-ol">
<li>20<br /></li>
<li>21<br /></li>
<li>39<br /></li>
<li>15<br /></li>
</ol>
</div>
<div id="outline-container-org3b9b608" class="outline-5">
<h5 id="org3b9b608">解析</h5>
<div class="outline-text-5" id="text-org3b9b608">
<p>
前序遍歷（Pre-order Traversal）順序：<br />
</p>
<ol class="org-ol">
<li>根節點<br /></li>
<li>左子樹<br /></li>
<li>右子樹<br /></li>
</ol>
<p>
前序遍歷順序（Pre-order Traversal）：<br />
</p>
<ol class="org-ol">
<li>30（根）<br /></li>
<li>17（左子樹）<br /></li>
<li>14（左子樹）<br /></li>
<li>8（左子樹）<br /></li>
<li>15（右子樹）→ 第 5 個節點<br /></li>
</ol>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>20 ❌ 錯誤，第 6 個節點<br /></li>
<li>21 ❌ 錯誤，還沒訪問到<br /></li>
<li>39 ❌ 錯誤，後面才會訪問<br /></li>
<li>15 ✅ 正確，第 5 個訪問的節點<br /></li>
</ol>
<p>
總結<br />
</p>
<ol class="org-ol">
<li>完全圖的邊數：n(n−1)/2n(n−1)/2<br /></li>
<li>AVL 樹（12345 個節點）的高度：13<br /></li>
<li>前序遍歷第 5 個訪問的節點：15<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org10ef03e" class="outline-4">
<h4 id="org10ef03e"><span class="section-number-4">9.8.11.</span> 第十一題：</h4>
<div class="outline-text-4" id="text-9-8-11">
<p>
For the tree in question 10, what is the 10th node we visit if we perform an in-order traversal? (4%)<br />
</p>
<ol class="org-ol">
<li>49<br /></li>
<li>40<br /></li>
<li>47<br /></li>
<li>53<br /></li>
</ol>
</div>
<div id="outline-container-orgc643386" class="outline-5">
<h5 id="orgc643386">答案：C. 47</h5>
<div class="outline-text-5" id="text-orgc643386">
<p>
解析: 中序遍歷（In-order Traversal）順序：<br />
</p>
<ol class="org-ol">
<li>左子樹<br /></li>
<li>根節點<br /></li>
<li>右子樹<br /></li>
</ol>
<p>
中序遍歷順序（從最左邊開始遍歷）：<br />
</p>
<ol class="org-ol">
<li>8<br /></li>
<li>14<br /></li>
<li>15<br /></li>
<li>17<br /></li>
<li>19<br /></li>
<li>20<br /></li>
<li>21<br /></li>
<li>30<br /></li>
<li>39<br /></li>
<li>47 （第 10 個節點）<br /></li>
</ol>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>49 ❌ 錯誤，第 12 個節點<br /></li>
<li>40 ❌ 錯誤，第 11 個節點<br /></li>
<li>47 ✅ 正確，第 10 個節點<br /></li>
<li>53 ❌ 錯誤，第 13 個節點<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgad40933" class="outline-4">
<h4 id="orgad40933"><span class="section-number-4">9.8.12.</span> 第十二題：</h4>
<div class="outline-text-4" id="text-9-8-12">
<p>
If the following numbers &ldquo;7&rdquo;, &ldquo;3&rdquo;, &ldquo;2&rdquo;, &ldquo;5&rdquo; are inserted into a queue, what would be their order for removal? (4%)<br />
</p>
<ol class="org-ol">
<li>7325<br /></li>
<li>5237<br /></li>
<li>7352<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org232d841" class="outline-5">
<h5 id="org232d841">答案：A. 7325</h5>
<div class="outline-text-5" id="text-org232d841">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>FIFO（First In, First Out） 規則：<br />
<ol class="org-ol">
<li>插入 7（隊列：7）<br /></li>
<li>插入 3（隊列：7 3）<br /></li>
<li>插入 2（隊列：7 3 2）<br /></li>
<li>插入 5（隊列：7 3 2 5）<br /></li>
</ol></li>
<li>移除順序： 7 3 2 5<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>7325 ✅ 正確<br /></li>
<li>5237 ❌ 錯誤，不符合 FIFO<br /></li>
<li>7352 ❌ 錯誤，不符合 FIFO<br /></li>
<li>None of the above ❌ 錯誤，因為 A 是正確的<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org024fcd2" class="outline-4">
<h4 id="org024fcd2"><span class="section-number-4">9.8.13.</span> 第十三題：</h4>
<div class="outline-text-4" id="text-9-8-13">
<p>
Which vertex is NOT a cut vertex in the following graph? (4%)<br />
</p>

<div id="org891da8e" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_11-19-47.png" alt="2025-01-29_11-19-47.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org54e7788">
圖形表示如下：節點A、B、C、D、E、F、G，邊如下：A-B，B-C，B-D，C-E，D-F，E-G。
</pre>
<ol class="org-ol">
<li>B<br /></li>
<li>E<br /></li>
<li>G<br /></li>
<li>A<br /></li>
</ol>
</div>
<div id="outline-container-org4d7315f" class="outline-5">
<h5 id="org4d7315f">答案：C. G</h5>
<div class="outline-text-5" id="text-org4d7315f">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>割點（Cut Vertex）：如果刪除該頂點會導致圖變成兩個或更多的連通部分，則該頂點是割點。<br /></li>
<li>給定圖：<br /></li>
</ul>
<pre class="example" id="orga96a338">
  A -- B -- C
       |    |
       D    E
       |    |
       F    G

</pre>
<ul class="org-ul">
<li>A 是割點（移除後 A 和 B 分開）<br /></li>
<li>B 是割點（移除後 A 和 C 分開）<br /></li>
<li>C 是割點（移除後 B 和 E 分開）<br /></li>
<li>D 是割點（移除後 B 和 F 分開）<br /></li>
<li>E 是割點（移除後 C 和 G 分開）<br /></li>
<li>F 不是割點（因為 D 仍然連接其他部分）<br /></li>
<li>G 不是割點（因為移除後不會影響圖的連通性）<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>B ❌ 錯誤，B 是割點<br /></li>
<li>E ❌ 錯誤，E 是割點<br /></li>
<li>G ✅ 正確，G 不是割點<br /></li>
<li>A ❌ 錯誤，A 是割點<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org27339cf" class="outline-4">
<h4 id="org27339cf"><span class="section-number-4">9.8.14.</span> 第十四題：</h4>
<div class="outline-text-4" id="text-9-8-14">
<p>
In the implementation of quick sort, we divide the problem on the base of pivot element and: (3%)<br />
</p>
<ol class="org-ol">
<li>there is explicit combine process to conquer the solution<br /></li>
<li>no work is needed to combine the sub-arrays, the array is already sorted<br /></li>
<li>merge the subarrays<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-org44a55cd" class="outline-5">
<h5 id="org44a55cd">答案：B. no work is needed to combine the sub-arrays, the array is already sorted</h5>
<div class="outline-text-5" id="text-org44a55cd">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>快速排序（Quick Sort） 透過 選擇基準（pivot），並將數列劃分為 小於基準 和 大於基準 兩部分。<br /></li>
<li>不同於合併排序（Merge Sort），快速排序 不需要額外的合併步驟，因為遞迴執行完後陣列已經排序。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>there is explicit combine process to conquer the solution ❌ 錯誤，沒有明確的合併步驟<br /></li>
<li>no work is needed to combine the sub-arrays, the array is already sorted ✅ 正確<br /></li>
<li>merge the subarrays ❌ 錯誤，這描述的是合併排序（Merge Sort）<br /></li>
<li>none of the above ❌ 錯誤，B 是正確的<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org70dcf56" class="outline-4">
<h4 id="org70dcf56"><span class="section-number-4">9.8.15.</span> 第十五題：</h4>
<div class="outline-text-4" id="text-9-8-15">
<p>
Which of the following is not return optimal solution? (3%)<br />
</p>
<ol class="org-ol">
<li>dynamic programming<br /></li>
<li>backtracking<br /></li>
<li>branch and bound<br /></li>
<li>greedy method<br /></li>
</ol>
</div>
<div id="outline-container-org83164f6" class="outline-5">
<h5 id="org83164f6">答案：D. Greedy Method（貪婪法）</h5>
<div class="outline-text-5" id="text-org83164f6">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>最佳解（Optimal Solution）：<br />
<ol class="org-ol">
<li>動態規劃（Dynamic Programming） ✅ 返回最佳解<br /></li>
<li>回溯法（Backtracking） ✅ 尋找所有可能解，一般能找到最佳解<br /></li>
<li>分支界限法（Branch and Bound） ✅ 尋找最佳解<br /></li>
<li>貪婪法（Greedy Algorithm） ❌ 不一定能找到最佳解<br /></li>
</ol></li>
<li>貪婪法問題：<br />
<ul class="org-ul">
<li>有時選擇當下最佳解，但整體結果不是最佳解，例如：<br />
<ul class="org-ul">
<li>最短路徑問題（Dijkstra 算法適用，但有時 BFS 可能更適合）<br /></li>
<li>換零錢問題（如面額 {1, 3, 4}，找零 6 時貪婪法選 4, 1, 1，但最佳解應該是 3, 3）<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgceb2ee3" class="outline-4">
<h4 id="orgceb2ee3"><span class="section-number-4">9.8.16.</span> 第十六題：</h4>
<div class="outline-text-4" id="text-9-8-16">
<p>
Breadth-First-Search is better compared to Depth First Search in the case of: (3%)<br />
</p>
<ol class="org-ol">
<li>the graph’s width is large<br /></li>
<li>the graph’s depth is large<br /></li>
<li>the graph has a large number of nodes<br /></li>
<li>the graph has a large number of edges<br /></li>
</ol>
</div>
<div id="outline-container-org5ff47de" class="outline-5">
<h5 id="org5ff47de">答案：A. the graph’s width is large</h5>
<div class="outline-text-5" id="text-org5ff47de">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>BFS（廣度優先搜尋） 適用於廣度較大的圖（分支多），因為 DFS（深度優先搜尋）在這種情況下會走錯路，導致回溯開銷變大。<br /></li>
<li>DFS 更適合深度大的圖，因為它使用遞迴來深入探索。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>the graph’s width is large ✅ 正確，BFS 適合橫向擴展的圖<br /></li>
<li>the graph’s depth is large ❌ 錯誤，深度大時 DFS 更適合<br /></li>
<li>the graph has a large number of nodes ❌ 錯誤，節點數量多不一定適用 BFS<br /></li>
<li>the graph has a large number of edges ❌ 錯誤，BFS 和 DFS 都能處理<br /></li>
</ol>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>第 10 題的樹在中序遍歷時，第 10 個節點是 47<br /></li>
<li>佇列的 FIFO 出隊順序是 7325<br /></li>
<li>G 不是割點<br /></li>
<li>快速排序不需要合併<br /></li>
<li>貪婪法不一定能找到最佳解<br /></li>
<li>BFS 適合寬度較大的圖<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcc4a1a7" class="outline-4">
<h4 id="orgcc4a1a7"><span class="section-number-4">9.8.17.</span> 第十七題：</h4>
<div class="outline-text-4" id="text-9-8-17">
<p>
What algorithm technique is used in the implementation of Kruskal&rsquo;s solution for the minimum spanning tree? (3%)<br />
</p>
<ol class="org-ol">
<li>greedy technique<br /></li>
<li>divide-and-conquer technique<br /></li>
<li>dynamic programming technique<br /></li>
<li>the algorithm combines more than one of the above techniques<br /></li>
</ol>
</div>
<div id="outline-container-org09f1b53" class="outline-5">
<h5 id="org09f1b53">答案：A. greedy technique（貪婪法）</h5>
<div class="outline-text-5" id="text-org09f1b53">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Kruskal 演算法 用於找出 最小生成樹（MST, Minimum Spanning Tree），它的核心概念是：<br />
<ol class="org-ol">
<li>依照邊的權重從小到大排序。<br /></li>
<li>依序加入權重最小的邊，確保不形成環（Cycle）。<br /></li>
<li>持續添加邊，直到連通所有頂點。<br /></li>
</ol></li>
<li>演算法分類：<br />
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm） ✅ 正確，Kruskal 在每一步選擇當前最小的邊，這是典型的貪婪策略。<br /></li>
<li>分治法（Divide and Conquer） ❌ 錯誤，Kruskal 並沒有將問題拆分成子問題。<br /></li>
<li>動態規劃（Dynamic Programming） ❌ 錯誤，Kruskal 不依賴子問題的最佳解。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf9f17be" class="outline-4">
<h4 id="orgf9f17be"><span class="section-number-4">9.8.18.</span> 第十八題：</h4>
<div class="outline-text-4" id="text-9-8-18">
<p>
Optimal merge pattern is a pattern that relates to the merging of two or more sorted files into a single sorted file. The files f1, f2, f3 are files containing 30, 20, 10 records, respectively. What is the optimal merge value? (4%)<br />
</p>
<ol class="org-ol">
<li>110<br /></li>
<li>90<br /></li>
<li>60<br /></li>
<li>50<br /></li>
</ol>
</div>
<div id="outline-container-orge276161" class="outline-5">
<h5 id="orge276161">答案：B. 90</h5>
<div class="outline-text-5" id="text-orge276161">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Optimal Merge Pattern（最優合併模式）：<br />
<ul class="org-ul">
<li>這是一個 Huffman 編碼問題的變形，利用貪婪法（Greedy Algorithm）。<br /></li>
<li>目標：合併最小的兩個檔案，並反覆執行，直到所有檔案合併完成。<br /></li>
</ul></li>
<li>給定檔案大小：<br />
f1=30，f2=20，f3=10<br /></li>
<li>合併步驟（每次合併都選最小的兩個數字）：<br />
<ul class="org-ul">
<li>合併 10 和 20 → 成為 30（成本 = 30）<br /></li>
<li>合併 30 和 30 → 成為 60（成本 = 60）<br /></li>
</ul></li>
<li>總合併成本：30+60=90<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>110 ❌ 錯誤<br /></li>
<li>90 ✅ 正確<br /></li>
<li>60 ❌ 錯誤<br /></li>
<li>50 ❌ 錯誤<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orge688078" class="outline-4">
<h4 id="orge688078"><span class="section-number-4">9.8.19.</span> 第十九題：</h4>
<div class="outline-text-4" id="text-9-8-19">
<p>
If the graph is represented as an adjacency matrix, the time complexity of Kruskal&rsquo;s algorithm is: (4%)<br />
</p>
<ol class="org-ol">
<li>O(ElogV)<br /></li>
<li>O(ElogE)<br /></li>
<li>O(V^2)<br /></li>
<li>O(logE)<br /></li>
</ol>
</div>
<div id="outline-container-org736f0ea" class="outline-5">
<h5 id="org736f0ea">答案：B. O(Elog⁡E)O(ElogE)</h5>
<div class="outline-text-5" id="text-org736f0ea">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Kruskal 演算法的步驟：<br />
<ol class="org-ol">
<li>對邊排序（使用 O(E log E)）。<br /></li>
<li>使用並查集（Disjoint Set）檢查是否形成環（近乎 O(1)）。<br /></li>
<li>加入最小邊到 MST（最多加 V−1V−1 條邊，O(E)）。<br /></li>
</ol></li>
<li>時間複雜度分析：<br />
<ul class="org-ul">
<li>排序邊的時間： O(Elog⁡E)<br /></li>
<li>查找和合併集合： 近乎 O(1)，所以主要瓶頸在 排序。<br /></li>
</ul></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>O(Elog⁡V)O(ElogV) ❌ 錯誤<br /></li>
<li>O(Elog⁡E)O(ElogE) ✅ 正確<br /></li>
<li>O(V2)O(V2) ❌ 錯誤，這是 Prim 演算法的時間複雜度<br /></li>
<li>O(log⁡E)O(logE) ❌ 錯誤<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org91d7ae1" class="outline-4">
<h4 id="org91d7ae1"><span class="section-number-4">9.8.20.</span> 第二十題：</h4>
<div class="outline-text-4" id="text-9-8-20">
<p>
In job sequencing problem, each job has a defined deadline and some profit associated with it. The objective is to find a sequence of jobs, which is completed within their deadlines and gives maximum profit. The solution is based on: (4%)<br />
</p>
<ol class="org-ol">
<li>greedy method<br /></li>
<li>branch and bound<br /></li>
<li>dynamic programming<br /></li>
<li>divide and conquer<br /></li>
</ol>
</div>
<div id="outline-container-orgf2a8a05" class="outline-5">
<h5 id="orgf2a8a05">答案：A. greedy method（貪婪法）</h5>
<div class="outline-text-5" id="text-orgf2a8a05">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>工作排序問題（Job Sequencing Problem）：<br />
<ul class="org-ul">
<li>每個工作都有 最後期限（Deadline） 和 利潤（Profit）。<br /></li>
<li>目標：在截止時間內，選擇最大利潤的工作安排方式。<br /></li>
</ul></li>
<li>演算法類型：<br />
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm） ✅ 正確<br />
<ul class="org-ul">
<li>先選擇利潤最高的工作，再將它安排到最晚的可用時段。<br /></li>
</ul></li>
<li>動態規劃（Dynamic Programming） ❌ 錯誤<br /></li>
<li>分支界限法（Branch and Bound） ❌ 錯誤<br /></li>
<li>分治法（Divide and Conquer） ❌ 錯誤<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge310a73" class="outline-5">
<h5 id="orge310a73">答案：C. (1, 2, 4)</h5>
<div class="outline-text-5" id="text-orge310a73">
<p>
解析<br />
給定工作資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">工作</th>
<th scope="col" class="org-right">利潤</th>
<th scope="col" class="org-right">截止時間</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">15</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">10</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
<p>
貪婪法步驟（先選擇利潤最高的工作）：<br />
</p>
<ol class="org-ol">
<li>排序利潤（由高到低）： (1, 2, 4, 3)<br /></li>
<li>選擇可排程的工作（從最後期限開始）<br />
<ul class="org-ul">
<li>1 放在 第 2 個時段<br /></li>
<li>2 放在 第 1 個時段<br /></li>
<li>4 放在 第 3 個時段<br /></li>
<li>3 無法安排（因為 4 已經佔用）<br /></li>
</ul></li>
</ol>
<p>
最佳排序：(1, 2, 4)<br />
</p>
<ul class="org-ul">
<li>選項分析：<br />
<ol class="org-ol">
<li>(1, 3, 4) ❌ 錯誤<br /></li>
<li>(4, 2, 3) ❌ 錯誤<br /></li>
<li>(1, 2, 4) ✅ 正確<br /></li>
<li>None of the above ❌ 錯誤，C 是正確的<br /></li>
</ol></li>
</ul>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>Kruskal 使用貪婪法（Greedy）<br /></li>
<li>Optimal Merge Pattern 最小成本為 90<br /></li>
<li>Kruskal 在鄰接矩陣中的時間複雜度為 O(Elog⁡E)O(ElogE)<br /></li>
<li>Job Sequencing 使用貪婪法<br /></li>
<li>最佳工作選擇為 (1, 2, 4)<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge34cdf1" class="outline-4">
<h4 id="orge34cdf1"><span class="section-number-4">9.8.21.</span> 第二十一題</h4>
<div class="outline-text-4" id="text-9-8-21">
<p>
Which is the optimal solution in the case of the above problem in which the five jobs have profits 20, 15, 5, 10, 1, and deadlines 2, 2, 3, 3, respectively. (4%)<br />
</p>
<ol class="org-ol">
<li>(1, 3, 4)<br /></li>
<li>(4, 2, 3)<br /></li>
<li>(1, 2, 4)<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-org14ce7fe" class="outline-5">
<h5 id="org14ce7fe">答案：C. (1, 2, 4)</h5>
<div class="outline-text-5" id="text-org14ce7fe">
<p>
解析<br />
給定工作資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">工作</th>
<th scope="col" class="org-right">利潤（Profit）</th>
<th scope="col" class="org-right">截止時間（Deadline）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">15</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">10</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm）解法<br />
<ol class="org-ol">
<li>根據利潤（Profit）由高到低排序：(1, 2, 4, 3, 5)<br /></li>
<li>依序安排，從最後可用時段開始：<br />
<ul class="org-ul">
<li>1 放在 第 2 個時段<br /></li>
<li>2 放在 第 1 個時段<br /></li>
<li>4 放在 第 3 個時段<br /></li>
<li>3 無法安排（因為 4 佔用）<br /></li>
</ul></li>
</ol></li>
<li>最佳排序： (1,2,4)<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>(1, 3, 4) ❌ 錯誤，3 應該無法安排<br /></li>
<li>(4, 2, 3) ❌ 錯誤，1 具有最高利潤，應該被安排<br /></li>
<li>(1, 2, 4) ✅ 正確<br /></li>
<li>None of the above ❌ 錯誤，C 是正確的解答<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org39feb6c" class="outline-4">
<h4 id="org39feb6c"><span class="section-number-4">9.8.22.</span> 第二十二題</h4>
<div class="outline-text-4" id="text-9-8-22">
<p>
Given a set of items each having a specific value and weight, the fractional knapsack problem is to find the maximal value of fractions of items that can fit into the knapsack. Which is the optimal value in the above problem for the case that the capacity of knapsack is 10, the five items have values 12, 32, 40, 30, 50, and weights 4, 8, 2, 6, 1, respectively: (4%)<br />
</p>
<ol class="org-ol">
<li>128<br /></li>
<li>124<br /></li>
<li>122<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgaf70324" class="outline-5">
<h5 id="orgaf70324">答案：A. 128</h5>
<div class="outline-text-5" id="text-orgaf70324">
<p>
解析<br />
</p>
<ul class="org-ul">
<li><p>
給定物品資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">物品</th>
<th scope="col" class="org-right">價值（Value）</th>
<th scope="col" class="org-right">重量（Weight）</th>
<th scope="col" class="org-right">每單位價值（Value/Weight）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">12</td>
<td class="org-right">4</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">32</td>
<td class="org-right">8</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">40</td>
<td class="org-right">2</td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">30</td>
<td class="org-right">6</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">50</td>
<td class="org-right">1</td>
<td class="org-right">50</td>
</tr>
</tbody>
</table></li>
<li>步驟：<br />
<ol class="org-ol">
<li>根據每單位價值排序：<br />
<ul class="org-ul">
<li>5(50/1) &gt; 3(40/2) &gt; 4(30/6) &gt; 2(32/8) &gt; 1(12/4)<br /></li>
</ul></li>
<li>依序填充背包（容量 10）：<br />
<ul class="org-ul">
<li>取 5（1 重量） → 50<br /></li>
<li>取 3（2 重量） → 50 + 40 = 90<br /></li>
<li>取 4（6 重量） → 90 + 30 = 120<br /></li>
<li>取 2 的 1/2（剩下 1 單位空間，價值 = 32/8 * 2 = 8） → 120 + 8 = 128<br /></li>
</ul></li>
</ol></li>
<li>最優值：128<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>128 ✅ 正確<br /></li>
<li>124 ❌ 錯誤<br /></li>
<li>122 ❌ 錯誤<br /></li>
<li>None of the above ❌ 錯誤，A 是正確答案<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2d6eaa6" class="outline-4">
<h4 id="org2d6eaa6"><span class="section-number-4">9.8.23.</span> 問答題1</h4>
<div class="outline-text-4" id="text-9-8-23">
<p>
Let comp1(n) be the number of comparisons performed by quick sort when sorting an array of n components. Let comp2(n) and exchange(n) be the number of comparisons and the number of exchange performed by bubble sort, respectively.<br />
</p>
<ol class="org-ol">
<li>Write down equations defining comp1(n) when n &lt;= 1 and when n &gt; 1 for the best case and for the worst case. (6%)<br />
<ul class="org-ul">
<li>定義 comp1(n)：<br /></li>
<li>最佳情況（Best Case）：<br />
<ul class="org-ul">
<li>樞軸（Pivot）每次將數列平分（T(n) = 2T(n/2) + O(n)）<br /></li>
<li>遞迴深度為 log n<br /></li>
<li>比較次數公式：<br /></li>
<li>comp1(n)=O(nlog⁡n)<br /></li>
</ul></li>
<li>最壞情況（Worst Case）：<br />
<ul class="org-ul">
<li>每次選到最小或最大元素作為樞軸，導致遞迴深度為 n<br /></li>
<li>比較次數公式：<br /></li>
<li>comp1(n)=O(n^2)<br /></li>
</ul></li>
</ul></li>
<li>Derive comp2(n) and exchange(n) for the average case and the best case. (6%)<br />
<ul class="org-ul">
<li>平均情況（Average Case）：<br />
<ul class="org-ul">
<li>comp2(n)=O(n^2)<br /></li>
</ul></li>
<li>最佳情況（Best Case，已排序數列）：<br />
<ul class="org-ul">
<li>comp2(n)=O(n)<br /></li>
</ul></li>
<li>交換次數（Exchange(n)）：<br />
<ul class="org-ul">
<li>平均情況：<br />
<ul class="org-ul">
<li>O(n^2)<br /></li>
</ul></li>
<li>最佳情況（已排序）：<br />
<ul class="org-ul">
<li>O(1)<br /></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org4f65bb6" class="outline-4">
<h4 id="org4f65bb6"><span class="section-number-4">9.8.24.</span> 問答2</h4>
<div class="outline-text-4" id="text-9-8-24">
<p>
Design a procedure that takes two arrays, and returns true if the arrays have no elements in common. Your procedure should have time complexity O(nlogm), where n is the size of the larger array and m is the size of the smaller array. (6%)<br />
</p>
<ul class="org-ul">
<li>方法<br />
<ol class="org-ol">
<li>假設 A 是較大的陣列，B 是較小的陣列。<br /></li>
<li>先對 B 進行排序，時間複雜度：O(m log m)<br /></li>
<li>對 A 的每個元素執行二分搜尋（Binary Search）：<br />
<ul class="org-ul">
<li>在 B 中搜尋每個元素，時間複雜度 O(n log m)。<br /></li>
</ul></li>
</ol></li>
<li><p>
程式碼（C++ 或 Python） C++ 版本<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;vector&gt;</span>
<span class="linenr"> 3: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;algorithm&gt;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">hasNoCommonElements</span>(<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">A</span>, <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">B</span>) {
<span class="linenr"> 8: </span>    sort(B.begin(), B.end()); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(m log m)</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">num</span> : A) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(n)</span>
<span class="linenr">11: </span>        <span style="color: #51afef;">if</span> (binary_search(B.begin(), B.end(), num)) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(log m)</span>
<span class="linenr">12: </span>            <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>;
<span class="linenr">16: </span>}
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">19: </span>    <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">A</span> = {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">15</span>};
<span class="linenr">20: </span>    <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">B</span> = {<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">11</span>};
<span class="linenr">21: </span>
<span class="linenr">22: </span>    cout &lt;&lt; (hasNoCommonElements(A, B) ? <span style="color: #98be65;">"True"</span> : <span style="color: #98be65;">"False"</span>) &lt;&lt; endl;
<span class="linenr">23: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">24: </span>}
</pre>
</div></li>
<li><p>
Python 版本<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">has_no_common_elements</span>(A, B):
<span class="linenr"> 3: </span>    B.sort()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">O(m log m)</span>
<span class="linenr"> 4: </span>    <span style="color: #51afef;">for</span> num <span style="color: #51afef;">in</span> A:  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">O(n)</span>
<span class="linenr"> 5: </span>        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Binary search in B, O(log m)</span>
<span class="linenr"> 6: </span>        <span style="color: #dcaeea;">left</span>, <span style="color: #dcaeea;">right</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #c678dd;">len</span>(B) - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr"> 7: </span>        <span style="color: #51afef;">while</span> left &lt;= right:
<span class="linenr"> 8: </span>            <span style="color: #dcaeea;">mid</span> = (left + right) // <span style="color: #da8548; font-weight: bold;">2</span>
<span class="linenr"> 9: </span>            <span style="color: #51afef;">if</span> B[mid] == num:
<span class="linenr">10: </span>                <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>
<span class="linenr">11: </span>            <span style="color: #51afef;">elif</span> B[mid] &lt; num:
<span class="linenr">12: </span>                <span style="color: #dcaeea;">left</span> = mid + <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">13: </span>            <span style="color: #51afef;">else</span>:
<span class="linenr">14: </span>                <span style="color: #dcaeea;">right</span> = mid - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">15: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">True</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span><span style="color: #dcaeea;">A</span> = [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">15</span>]
<span class="linenr">18: </span><span style="color: #dcaeea;">B</span> = [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">11</span>]
<span class="linenr">19: </span><span style="color: #c678dd;">print</span>(has_no_common_elements(A, B))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">True</span>
</pre>
</div></li>
<li>時間複雜度分析<br />
<ol class="org-ol">
<li>排序 B：O(mlog⁡m)O(mlogm)<br /></li>
<li>對 A 的每個元素執行二分搜尋：<br />
<ul class="org-ul">
<li>O(nlog⁡m)O(nlogm)（假設 A 為較大陣列）<br /></li>
</ul></li>
<li>總時間複雜度：<br />
O(mlogm)+O(nlogm)=O(nlogm)<br /></li>
</ol></li>
<li>總結<br />
<ol class="org-ol">
<li>工作排序最佳解：(1,2,4)<br /></li>
<li>分數背包最佳值：128<br /></li>
<li>Quick Sort 與 Bubble Sort 比較次數分析<br /></li>
<li>O(n log m) 方法檢查兩陣列是否有共同元素<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1763610" class="outline-3">
<h3 id="org1763610"><span class="section-number-3">9.9.</span> 112: 中山計概</h3>
<div class="outline-text-3" id="text-9-9">
<ol class="org-ol">
<li>A network switch uses a <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> that is very similar to a routing table used in a router. A. hash table B. forwarding table C. contingency table D. reversing table<br />
<ul class="org-ul">
<li>答案：B. Forwarding Table（轉發表）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>交換器（Switch） 透過 轉發表（Forwarding Table） 來決定封包應該被發送到哪個埠口（Port）。<br /></li>
<li>類似路由器（Router） 使用的 路由表（Routing Table），但 Switch 在第二層（Layer 2）運作，而 Router 在第三層（Layer 3）運作。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Hash Table（雜湊表） ❌ 錯誤，雜湊表是用來提高搜尋效率的資料結構，不是交換器的核心機制。<br /></li>
<li>Forwarding Table（轉發表） ✅ 正確，交換器使用的表來決定封包發送方向。<br /></li>
<li>Contingency Table（應急表） ❌ 錯誤，與統計分析有關，與網路設備無關。<br /></li>
<li>Reversing Table（反向表） ❌ 錯誤，沒有這個網路設備的術語。<br /></li>
</ol></li>
</ul></li>
<li>Encryption is the process of A. transmitting information over secure lines to prevent illegal access. B. detecting errors in messages by using mathematical rules. C. preventing errors in messages by using logical rules. D. disguising information by using mathematical rules.<br />
<ul class="org-ul">
<li>答案：D. Disguising information by using mathematical rules（使用數學規則來偽裝資訊）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>加密（Encryption） 透過數學演算法將 原始訊息轉換成無法輕易理解的格式，以保護資料安全。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>對稱加密（AES、DES）<br /></li>
<li>非對稱加密（RSA、ECC）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Transmitting information over secure lines（透過安全線路傳輸資訊） ❌ 錯誤，這是 VPN 或 TLS 的作用，不是加密的本質。<br /></li>
<li>Detecting errors in messages（使用數學規則檢測錯誤） ❌ 錯誤，這描述的是錯誤檢測（如 CRC、Hamming Code）。<br /></li>
<li>Preventing errors in messages（使用邏輯規則防止錯誤） ❌ 錯誤，這描述的是錯誤修正（如 Reed-Solomon、ECC）。<br /></li>
<li>Disguising information by using mathematical rules（使用數學規則來偽裝資訊） ✅ 正確，這是加密的本質。<br /></li>
</ol></li>
</ul></li>
</ul></li>
<li>Public blockchains usually use <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> as the consensus mechanism to validate transactions. A. proof of concept B. proof of payment C. proof of reserve D. proof of work<br />
<ul class="org-ul">
<li>答案：D. Proof of Work（工作量證明，PoW）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>共識機制（Consensus Mechanism） 是區塊鏈用來驗證交易的機制。<br /></li>
<li>公有鏈（Public Blockchain） 常使用 工作量證明（Proof of Work，PoW），如 比特幣（Bitcoin）和以太坊（Ethereum 1.0）。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Proof of Concept（概念驗證） ❌ 錯誤，PoC 是用來測試技術可行性的概念，不是區塊鏈共識機制。<br /></li>
<li>Proof of Payment（付款證明） ❌ 錯誤，這不是區塊鏈的共識機制。<br /></li>
<li>Proof of Reserve（儲備證明） ❌ 錯誤，這是用來證明某個機構擁有足夠的資金儲備。<br /></li>
<li>Proof of Work（工作量證明） ✅ 正確，PoW 是比特幣、以太坊（ETH 1.0）等公有鏈使用的共識機制。<br /></li>
</ol></li>
</ul></li>
<li>What does NFT stand for? A. Non-functional token. B. Non-fungible token. C. New frequency technology. D. Nano-finance technology.<br />
<ul class="org-ul">
<li>答案：B. Non-Fungible Token（非同質化代幣）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>NFT（非同質化代幣） 是一種基於區塊鏈的數位資產，每個 NFT 具有唯一性、不可互換性，用於代表 數位藝術品、收藏品、虛擬資產等。<br /></li>
</ul></li>
<li>例如：<br />
<ul class="org-ul">
<li>Beeple 的 NFT 作品拍賣 6900 萬美元<br /></li>
<li>遊戲 NFT（Axie Infinity、Decentraland）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Non-functional token（非功能性代幣） ❌ 錯誤，NFT 不是這個意思。<br /></li>
<li>Non-fungible token（非同質化代幣） ✅ 正確，NFT 的全名。<br /></li>
<li>New frequency technology（新頻率技術） ❌ 錯誤，這不是 NFT 的概念。<br /></li>
<li>Nano-finance technology（奈米金融技術） ❌ 錯誤，這與 NFT 無關。<br /></li>
</ol></li>
</ul></li>
<li>In the UML, the top compartment of the rectangle modeling a class contains: A. The class&rsquo;s name. B. The class&rsquo;s attributes. C. The class&rsquo;s behaviors. D. All of the above.<br />
<ul class="org-ul">
<li>答案：A. The class&rsquo;s name（類別名稱）<br /></li>
<li>解析: 在 UML 類別圖（Unified Modeling Language Class Diagram） 中：<br />
<ul class="org-ul">
<li>矩形的最上方區塊（Top Compartment） → 類別名稱（Class Name）<br /></li>
<li>中間區塊（Middle Compartment） → 屬性（Attributes）<br /></li>
<li>底部區塊（Bottom Compartment） → 行為/方法（Methods/Behaviors）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>The class&rsquo;s name（類別名稱） ✅ 正確，UML 類別圖的最上層包含類別名稱。<br /></li>
<li>The class&rsquo;s attributes（類別屬性） ❌ 錯誤，屬性在中間區塊。<br /></li>
<li>The class&rsquo;s behaviors（類別行為/方法） ❌ 錯誤，行為在底部區塊。<br /></li>
<li>All of the above（以上皆是） ❌ 錯誤，最上層只包含類別名稱。<br /></li>
</ol></li>
</ul></li>
<li><p>
Which of the following is the inorder traversal of the binary search tree?<br />
</p>
<pre class="example" id="orgcc8fb22">
          7
         / \
        /   \
       5     8
      / \   / \
     4   3 9   1
    /
   2
</pre>
<ol class="org-ol">
<li>24359187. B. 75423891. C. 24537981. D. None of the above.<br /></li>
<li>答案：D. None of the above<br /></li>
<li><p>
解析<br />
</p>
<ul class="org-ul">
<li>中序遍歷（Inorder Traversal） 的順序為：<br />
<ul class="org-ul">
<li>左子樹<br /></li>
<li>根節點<br /></li>
<li>右子樹<br /></li>
</ul></li>
<li><p>
檢查給定的 BST（但該樹的結構有誤）<br />
</p>
<pre class="example" id="org3339b7c">
               7
              / \
             /   \
            5     8
           / \   / \
          4   3 9   1
         /
        2
</pre>
<ul class="org-ul">
<li>在 BST（Binary Search Tree） 中，左子節點的值應小於根，右子節點的值應大於根。<br /></li>
<li>但此樹結構 有錯誤：<br />
<ul class="org-ul">
<li>節點 3 應該在 5 的左子節點，而非右子節點<br /></li>
<li>節點 1 應該在 8 的左子節點，而非右子節點<br /></li>
</ul></li>
<li>正確的中序遍歷<br /></li>
<li><p>
如果修正 BST 結構，假設樹的正確結構應該是：<br />
</p>
<pre class="example" id="org797dac5">
                7
               / \
              5   8
             / \    \
            4   6    9
           /
          2
</pre></li>
<li>則 中序遍歷順序為：<br />
<ul class="org-ul">
<li>2,4,5,6,7,8,9<br /></li>
<li>2,4,5,6,7,8,9<br /></li>
</ul></li>
</ul></li>
</ul>

<ul class="org-ul">
<li>但根據原始題目提供的選項，均不符合正確的 BST 遍歷順序，因此答案為 D（None of the above）。<br /></li>
<li><p>
選項分析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">遍歷順序</th>
<th scope="col" class="org-left">是否正確？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A. 24359187</td>
<td class="org-left">順序錯誤（5 應該在 4 之後，而 9 不能在 1 之前）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">B. 75423891</td>
<td class="org-left">順序錯誤（應該先遍歷左子樹，但 7 在開頭）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">C. 24537981</td>
<td class="org-left">順序錯誤（1 應該在 7 之前，而 9 應該在 8 之後）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">D. None of the above</td>
<td class="org-left">正確，因為選項中無正確的中序遍歷</td>
<td class="org-left">✅</td>
</tr>
</tbody>
</table></li>
<li>結論: 因為給定的樹並非有效的 BST，且所有選項的遍歷順序都不符合中序遍歷的定義，所以答案為 D（None of the above）。<br /></li>
</ul></li>
</ol></li>
<li>What is the subnet number of the IP address 10.0.17.130 with the subnet mask 255.255.255.192? A. 10.0.0.0 B. 10.0.17.0 C. 10.0.17.128 D. 10.0.17.192<br />
<ul class="org-ul">
<li>答案：C. 10.0.17.128<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>給定 IP 地址：10.0.17.130<br /></li>
<li>子網遮罩（Subnet Mask）：255.255.255.192（/26）<br /></li>
</ul></li>
<li>計算子網 ID（Subnet ID）：<br />
<ul class="org-ul">
<li>子網大小：<br /></li>
<li>\( 2^{32-26}=2^6=64 \)<br /></li>
<li>每個子網的範圍為 64 個 IP 地址。<br /></li>
</ul></li>
<li>找出子網範圍：<br />
<ul class="org-ul">
<li>子網範圍：10.0.17.0、10.0.17.64、10.0.17.128、10.0.17.192<br /></li>
<li>10.0.17.130 落在 10.0.17.128 - 10.0.17.191 之間。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>10.0.0.0 ❌ 錯誤，這是更大的網段<br /></li>
<li>10.0.17.0 ❌ 錯誤，這是 10.0.17.0/26<br /></li>
<li>10.0.17.128 ✅ 正確，這是 10.0.17.128/26<br /></li>
<li>10.0.17.192 ❌ 錯誤，這是下一個子網的開始<br /></li>
</ol></li>
</ul></li>
<li>When a client code programmer uses a class whose implementation is in a separate file from its interface, that implementation code is merged with the client&rsquo;s code during the A. programming phase. B. compiling phase. C. linking phase. D. executing phase.<br />
<ul class="org-ul">
<li>答案：C. Linking Phase（連結階段）<br /></li>
<li>解析: 當程式的 實作檔案（Implementation File） 與 介面檔案（Header File） 分開時，連結器（Linker） 在 連結階段（Linking Phase） 將它們合併，生成最終的可執行檔案。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Programming Phase（程式設計階段） ❌ 錯誤，程式設計時只是撰寫代碼，尚未合併<br /></li>
<li>Compiling Phase（編譯階段） ❌ 錯誤，編譯階段只將單個文件轉換為目標碼<br /></li>
<li>Linking Phase（連結階段） ✅ 正確，這是合併程式碼的階段<br /></li>
<li>Executing Phase（執行階段） ❌ 錯誤，執行階段已經完成編譯和連結<br /></li>
</ol></li>
</ul></li>
<li>TCP/IP relies on the <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> to decide to which application a message should be delivered. A. MAC address B. SSID C. IP address D. port number<br />
<ul class="org-ul">
<li>答案：D. Port Number（連接埠號碼）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>TCP/IP 使用「連接埠（Port）」來識別應用程式。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>HTTP 伺服器 → 連接埠 80<br /></li>
<li>HTTPS 伺服器 → 連接埠 443<br /></li>
<li>SSH 伺服器 → 連接埠 22<br /></li>
</ul></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>MAC Address（MAC 地址） ❌ 錯誤，MAC 地址用於區域網路（Layer 2）<br /></li>
<li>SSID（Wi-Fi 網路名稱） ❌ 錯誤，SSID 用於識別無線網路<br /></li>
<li>IP Address（IP 地址） ❌ 錯誤，IP 地址識別主機，而非應用程式<br /></li>
<li>Port Number（連接埠號碼） ✅ 正確，TCP/IP 透過 Port 決定應用程式<br /></li>
</ol></li>
</ul></li>
<li><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> is used to perform IP address to data link address resolution. A. ARP B. DNS C. HTTP D. NAT<br />
<ul class="org-ul">
<li>答案：A. ARP（地址解析協定）<br /></li>
<li>解析: ARP（Address Resolution Protocol） 用於將 IP 地址解析為 MAC 地址，用於本地網路的通訊。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>ARP ✅ 正確，負責解析 IP 到 MAC<br /></li>
<li>DNS ❌ 錯誤，DNS 將域名解析為 IP<br /></li>
<li>HTTP ❌ 錯誤，HTTP 是網路協議，與 IP 解析無關<br /></li>
<li>NAT ❌ 錯誤，NAT 用於 IP 轉換，而非解析 MAC 地址<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about system calls is wrong? A. System calls are an interface for accessing computer resources. B. System calls can only be executed under kernel mode. C. The dual mode is to protect systems from malware attacks. D. All input or output functions in a program must get through system calls.<br />
<ul class="org-ul">
<li>答案：D. All input or output functions in a program must get through system calls（所有輸入/輸出都必須透過系統呼叫）<br /></li>
<li>解析: 系統呼叫（System Call）是應用程式訪問作業系統內核的方法，但 某些輸入/輸出（I/O）函式不一定要經過系統呼叫，如：<br />
<ul class="org-ul">
<li>用戶空間（User Space）快取<br /></li>
<li>標準函式庫緩存<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>System calls are an interface for accessing computer resources ✅ 正確<br /></li>
<li>System calls can only be executed under kernel mode ✅ 正確<br /></li>
<li>The dual mode is to protect systems from malware attacks ✅ 正確<br /></li>
<li>All input or output functions in a program must get through system calls ❌ 錯誤，因為有些 I/O 可能在用戶空間執行<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about databases is wrong?<br />
<ol class="org-ol">
<li>All relational databases use the same query language to access databases.<br /></li>
<li>In relational databases, every table is indexed by a key.<br /></li>
<li>SQL is not used for accessing NoSQL databases.<br /></li>
<li>NoSQL databases use key-value to access data. Therefore, a table can be indexed by the key.<br /></li>
<li>答案：A. All relational databases use the same query language to access databases（所有關聯式資料庫使用相同的查詢語言）<br /></li>
<li>解析: SQL（結構化查詢語言） 是大多數關聯式資料庫使用的語言，但不同資料庫（如 MySQL、PostgreSQL、SQL Server）具有不同的 SQL 方言（Dialect），並非所有關聯式資料庫都完全相同。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>All relational databases use the same query language ❌ 錯誤，因為 SQL 在不同資料庫之間有方言差異<br /></li>
<li>In relational databases, every table is indexed by a key ✅ 正確<br /></li>
<li>SQL is not used for accessing NoSQL databases ✅ 正確，NoSQL 使用不同方法，如 Key-Value 存取<br /></li>
<li>NoSQL databases use key-value to access data ✅ 正確<br /></li>
</ol></li>
</ol></li>
<li>Which one of the following statements about the Internet of Things (IoT) is wrong? A. An IoT device refers to an object that has network access. B. IoT devices can be accessed through WLAN, but not WAN. C. Bluetooth earphones are IoT devices. D. If an IoT device connect to the internet, it might be compromised by attackers.<br />
<ul class="org-ul">
<li>答案：B. IoT devices can be accessed through WLAN, but not WAN（物聯網設備只能透過 WLAN 連接，不能透過 WAN 連接）<br /></li>
<li>解析: IoT 設備可以透過 WLAN（無線局域網）或 WAN（廣域網）存取。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>智慧家電透過 WLAN 連接 Wi-Fi 路由器<br /></li>
<li>GPS 追蹤設備透過 WAN（如 4G/5G）連接<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>An IoT device refers to an object that has network access ✅ 正確<br /></li>
<li>IoT devices can be accessed through WLAN, but not WAN ❌ 錯誤，IoT 設備可以透過 WLAN 或 WAN 存取<br /></li>
<li>Bluetooth earphones are IoT devices ✅ 正確<br /></li>
<li>If an IoT device connects to the internet, it might be compromised by attackers ✅ 正確，IoT 設備連接網路後可能受到攻擊<br /></li>
</ol></li>
</ul></li>
<li>Assume that there is a three-frame physical memory in the system. Initially, all frames are empty. Given the reference string: abcdbaefacbic. How many page faults are generated if LRU is used? A. 6 B. 7 C. 8 D. 9<br />
<ul class="org-ul">
<li>答案：C. 8<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>LRU（Least Recently Used）：當記憶體滿時，替換最近最少使用（LRU）的頁面。<br /></li>
<li>三個記憶體框架（frame），最初為空。<br /></li>
<li>參考字串（Reference String）：<br />
a b c d b a e f a c b i c<br /></li>
<li>模擬 LRU 置換（用 - 代表空框）：<br />
時間  1  2  3  4  5  6  7  8  9 10 11 12 13<br />
記憶  a  a  a  d  d  d  e  f  f  c  c  c  c<br />
<ul class="org-ul">
<li>b  b  b  b  a  a  a  a  a  a  i  i<br /></li>
<li>-  c  c  c  c  c  f  f  b  b  b  c<br /></li>
</ul></li>
<li>頁面錯誤（Page Faults）發生次數：<br />
<ul class="org-ul">
<li>a（錯誤）<br /></li>
<li>b（錯誤）<br /></li>
<li>c（錯誤）<br /></li>
<li>d（錯誤，淘汰 a）<br /></li>
<li>b（命中）<br /></li>
<li>a（錯誤，淘汰 c）<br /></li>
<li>e（錯誤，淘汰 d）<br /></li>
<li>f（錯誤，淘汰 b）<br /></li>
<li>a（命中）<br /></li>
<li>c（錯誤，淘汰 e）<br /></li>
<li>b（錯誤，淘汰 f）<br /></li>
<li>i（錯誤，淘汰 a）<br /></li>
<li>c（命中）<br /></li>
<li>總計 8 次 page faults，答案為 C. 8。<br /></li>
</ul></li>
</ul></li>
</ul></li>
<li>There is a fake coin in a pile of N coins, whereas a fake one has a lighter weight. There are two possible ways to identify the fake coin: sequential search or divide-and-conquer. Which one of the following statements is wrong?<br />
<ol class="org-ol">
<li>The time complexity of the divide-and-conquer is O(logN).<br /></li>
<li>The time complexity of the sequential search is O(N).<br /></li>
<li>The best case of sequential search takes 1 comparison.<br /></li>
<li>The best case of divide-and-conquer takes 1 comparison.<br /></li>
<li>答案：D. The best case of divide-and-conquer takes 1 comparison.（分治法的最佳情況只需 1 次比較）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>順序搜尋（Sequential Search）：<br />
<ul class="org-ul">
<li>時間複雜度：O(N)<br /></li>
<li>最好的情況（Best Case）：1 次比較（第一枚硬幣就是假幣）。<br /></li>
</ul></li>
<li>分治法（Divide-and-Conquer）：<br />
<ul class="org-ul">
<li>時間複雜度：O(log N)（每次將硬幣數量減半）。<br /></li>
<li>最好的情況（Best Case）：理論上不可能 1 次比較就找到假幣，因為天平至少要稱 2 組硬幣來進行比較。<br /></li>
</ul></li>
</ul></li>

<li>選項分析：<br />
<ol class="org-ol">
<li>O(log N)（分治法時間複雜度） ✅ 正確<br /></li>
<li>O(N)（順序搜尋時間複雜度） ✅ 正確<br /></li>
<li>最好的情況下，順序搜尋只需 1 次比較 ✅ 正確<br /></li>
<li>最好的情況下，分治法只需 1 次比較 ❌ 錯誤，至少需要 2 次比較<br /></li>
</ol></li>
</ol></li>
<li>Which one of the following statements is wrong? A. Users use the client-server model to access web servers. B. Peers can be attacked by web browsing. C. In the client-server model, a client makes a request and the server sends back the response, so a web server cannot be attacked by a web user. D. The username/password is a common user authentication mechanism for users to access a web server.<br />
<ul class="org-ul">
<li>答案：C. In the client-server model, a web server cannot be attacked by a web user.（網頁伺服器不會被用戶攻擊）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>Web 伺服器可以被攻擊，例如：<br />
<ul class="org-ul">
<li>DDoS 攻擊（大量請求導致伺服器崩潰）<br /></li>
<li>SQL 注入攻擊（惡意 SQL 語法）<br /></li>
<li>XSS 攻擊（惡意 JavaScript 代碼）<br /></li>
</ul></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>客戶端-伺服器模型可用來存取 Web 伺服器 ✅ 正確<br /></li>
<li>對等網路（P2P）也可能因為瀏覽網頁而被攻擊 ✅ 正確<br /></li>
<li>網頁伺服器不能被用戶攻擊 ❌ 錯誤，Web 伺服器可能被攻擊<br /></li>
<li>使用者名稱/密碼是常見的身份驗證機制 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>One’s complement (1’s complement) and two’s complement (2’s complement) are used to represent signed integers. Which one of the following statements is wrong? A. Given a K-bit register, the range of signed integers that can be represented by 2’s complement is between -(2^(k-1)) and (2^(k-1) - 1). B. In 2’s complement, 110010 represents -14. C. To get 2’s complement of a binary number, invert the given number and add 1 to the least significant bit (LSB) of the given result. D. In 1’s complement, 1111 represents 0, while in 2’s complement, 1111 represents -1.<br />
<ul class="org-ul">
<li>答案：B. In 2’s complement, 110010 represents -14.（二補數表示 110010 為 -14）<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>確認位元數：<br />
<ul class="org-ul">
<li>110010 共有 6 位元（K=6）。<br /></li>
</ul></li>
<li>二補數（2’s complement）轉換：<br />
<ul class="org-ul">
<li>110010（原碼）<br /></li>
<li>取補數（反轉所有位元）：001101<br /></li>
<li>加 1：001110（二進位 14）<br /></li>
<li>因此 110010 = -14（錯誤）<br /></li>
<li>應該是 -50，而不是 -14<br /></li>
</ul></li>
</ol></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>K 位元的二補數範圍是：−2(K−1)−2(K−1) 到 2(K−1)−12(K−1)−1 ✅ 正確<br /></li>
<li>110010 代表 -14 ❌ 錯誤，實際上是 -50<br /></li>
<li>取得二補數的方法是「反轉 + 1」 ✅ 正確<br /></li>
<li>一補數 1111 表示 0，二補數 1111 表示 -1 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Many applications such as banking services use relational database management systems (RDMS) to process user data, RDMS fulfill the ACID properties. Which one of the following statements about relational databases is wrong? A. Atomicity property guarantees that each transaction is treated as a single operation. B. Entity-Relation models contain two major elements: entity and relationship. C. RDMS use locks to ensure that at any time only one user changes the data. D. Consistency property ensures that the data is in a consistent state all the time.<br />
<ul class="org-ul">
<li>答案：C. RDMS use locks to ensure that at any time only one user changes the data.（RDBMS 使用鎖確保只有一個用戶能修改數據）<br /></li>
<li>解析: 資料庫管理系統（RDBMS）使用多種鎖定機制，但不一定 「任何時間都只有一個用戶可以更改數據」，它通常允許多個用戶 並行存取（Concurrency Control）。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>原子性（Atomicity）保證交易為單一操作 ✅ 正確<br /></li>
<li>ER 模型包含實體與關係 ✅ 正確<br /></li>
<li>RDBMS 確保同時只有一個用戶可改變數據 ❌ 錯誤，支援多用戶並發控制<br /></li>
<li>一致性（Consistency）確保數據一致 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about cloud computing is wrong? A. There are three types of cloud computing: IaaS, PaaS, and SaaS. B. IaaS mainly provides virtual machines with the given hardware specs you need. C. Cloud computing is a type of distributed computing that requires high-speed networks. D. Cloud computing is often used for big data analysis so that a large amount of data can be stored and processed in a single machine.<br />
<ul class="org-ul">
<li>答案：D. Cloud computing stores and processes big data in a single machine.（雲端運算將大數據存放並處理於單一機器）<br /></li>
<li>解析: 雲端運算使用分散式系統（Distributed Computing） 處理大量數據，而不是 單一機器。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>IaaS、PaaS、SaaS 是雲端運算的三種模型 ✅ 正確<br /></li>
<li>IaaS 提供虛擬機與硬體資源 ✅ 正確<br /></li>
<li>雲端運算需要高速網路 ✅ 正確<br /></li>
<li>雲端運算使用單一機器處理大數據 ❌ 錯誤，應該使用分散式架構<br /></li>
</ol></li>
</ul></li>
<li><p>
A piece of code below declares a doubly linked list. Assuming that the node curNode is not the head or the last node of the list, which one of the following pieces of code is to delete the node curNode?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span>
<span class="linenr">2: </span>    {
<span class="linenr">3: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">prev</span>;
<span class="linenr">4: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">data</span>;
<span class="linenr">5: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">next</span>;
<span class="linenr">6: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">head</span>;
<span class="linenr">7: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
<li>curNode-&gt;prev-&gt;next = curNode-&gt;prev;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;next;<br /></li>
<li>curNode-&gt;next-&gt;next = curNode-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;next-&gt;prev;<br /></li>
<li>答案：A<br />
<ul class="org-ul">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;next;<br /></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
</ul></li>
<li>解析: 雙向鏈結串列（Doubly Linked List） 的特性：<br />
<ul class="org-ul">
<li>每個節點有兩個指標：<br />
<ul class="org-ul">
<li>prev 指向前一個節點。<br /></li>
<li>next 指向下一個節點。<br /></li>
</ul></li>
<li>刪除 curNode 的步驟<br />
<ul class="org-ul">
<li>將 curNode 的前一個節點的 next 指向 curNode-&gt;next<br /></li>
<li>將 curNode 的下一個節點的 prev 指向 curNode-&gt;prev<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;prev;<br />
<ul class="org-ul">
<li>錯誤，這樣會讓 prev-&gt;next 指向自己，鏈結錯誤。<br /></li>
</ul></li>
<li>curNode-&gt;next-&gt;next = curNode-&gt;next;<br />
<ul class="org-ul">
<li>錯誤，修改 next-&gt;next，不會改變 prev。<br /></li>
</ul></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev-&gt;next;<br />
<ul class="org-ul">
<li>錯誤，prev-&gt;next 本來就指向 curNode，這樣 curNode-&gt;next-&gt;prev 會錯誤指向 curNode 本身。<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li>(複選) Which one of the following is(are) supervised learning? A. Support vector machine. B. Naive Bayes classifier. C. K-nearest neighbors. D. Convolutional neural networks. E. K-means clustering.<br />
<ul class="org-ul">
<li>答案：A, B, C, D<br /></li>
<li>解析: 監督式學習（Supervised Learning）：需要有標籤（Label）的訓練數據。<br />
<ol class="org-ol">
<li>Support Vector Machine（SVM） ✅<br /></li>
<li>Naive Bayes Classifier ✅<br /></li>
<li>K-Nearest Neighbors（KNN） ✅<br /></li>
<li>Convolutional Neural Networks（CNN） ✅<br /></li>
<li>K-Means Clustering ❌（這是非監督式學習）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following processor families is(are) based on ARM architecture? A. AMD Ryzen. B. Apple Silicon. C. Qualcomm Snapdragon. D. Samsung Exynos. E. Nvidia Tegra.<br />
<ul class="org-ul">
<li>答案：B, C, D, E<br /></li>
<li>解析: ARM 架構 是一種精簡指令集（RISC）。<br />
<ol class="org-ol">
<li>Apple Silicon（M1, M2, M3） ✅<br /></li>
<li>Qualcomm Snapdragon（手機 SoC） ✅<br /></li>
<li>Samsung Exynos ✅<br /></li>
<li>Nvidia Tegra（如 Switch 遊戲機） ✅<br /></li>
<li>AMD Ryzen ❌（x86 架構）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following is(are) based on a convolutional neural network? A. WordNet. B. ResNet. C. Inception. D. ImageNet. E. GoogLeNet.<br />
<ul class="org-ul">
<li>答案：B, C, E<br /></li>
<li>解析: CNN 相關模型<br />
<ul class="org-ul">
<li>B. ResNet ✅<br /></li>
<li>C. Inception ✅<br /></li>
<li>E. GoogLeNet ✅<br /></li>
<li>A. WordNet ❌（詞彙網路）<br /></li>
<li>D. ImageNet ❌（資料庫，不是 CNN）<br /></li>
</ul></li>
</ul></li>
<li>(複選) Which one(s) of the following programming languages is(are) executed by an interpreter? A. Python B. Matlab C. C D. R E. Assembly<br />
<ul class="org-ul">
<li>答案：A, B, D<br /></li>
<li>解析: 直譯語言（Interpreted Language）<br />
<ol class="org-ol">
<li>Python ✅<br /></li>
<li>Matlab ✅<br /></li>
<li>R ✅<br /></li>
<li>C ❌（編譯語言）<br /></li>
<li>Assembly ❌（組合語言，依賴 CPU 指令）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following mechanisms has(have) been utilized to achieve differential privacy? A. Linear mechanism. B. Laplace mechanism. C. Exponential mechanism. D. Gaussian mechanism. E. Triangular mechanism.<br />
<ul class="org-ul">
<li>答案：B, C, D<br /></li>
<li>解析: 差分隱私（Differential Privacy）機制<br />
<ul class="org-ul">
<li>B. Laplace Mechanism ✅<br /></li>
<li>C. Exponential Mechanism ✅<br /></li>
<li>D. Gaussian Mechanism ✅<br /></li>
<li>A. Linear Mechanism ❌<br /></li>
<li>E. Triangular Mechanism ❌<br /></li>
</ul></li>
</ul></li>
<li>(複選) Which one of the following statements is(are) correct? A. By using virtualization technologies, a physical machine can become multiple machines of different operating systems. B. Virtualization can make programs run faster. C. Virtualization technologies can virtualize RAM and CPU, but not network. D. Virtualization can protect machines from system crashes.<br />
<ul class="org-ul">
<li>答案：A, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>虛擬化技術可讓一台實體機器運行不同 OS ✅<br /></li>
<li>虛擬化可隔離系統崩潰 ✅<br /></li>
<li>虛擬化無法提升程式執行速度 ❌<br /></li>
<li>虛擬化也可虛擬網路（如虛擬交換器） ❌<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one of the following statements about algorithms is/are correct? A. A flowchart is a way of presenting an algorithm. B. An algorithm is used to describe a problem solution. C. Algorithms can be only used for computer programming. D. Pseudocode describes more precisely than a flowchart.<br />
<ul class="org-ul">
<li>答案：A, B, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>流程圖（Flowchart）可視化演算法 ✅<br /></li>
<li>演算法描述問題的解決方法 ✅<br /></li>
<li>偽代碼（Pseudocode）比流程圖更精確 ✅<br /></li>
<li>演算法不僅限於程式設計 ❌<br /></li>
</ol></li>
</ul></li>
<li>(複選) Given a directed weighted graph G(V, E), where there are N vertices and M edges in graph G. The graph is represented by an adjacent matrix. Which one(s) of the following statements is/are correct? A. A greedy algorithm can find an optimal path of a single source to a single destination. B. It takes the time complexity of O(N^3) to find optimal paths of all sources to all destinations. C. A greedy algorithm can find optimal paths of a single source to all destinations. D. A solution for a single source to all destinations must be a tree structure.<br />
<ul class="org-ul">
<li>答案：B, C<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>貪婪演算法能找最短單源單點路徑 ❌（不一定，視演算法而定）<br /></li>
<li>全點對最短路徑時間複雜度為 O(N³) ✅（Floyd-Warshall）<br /></li>
<li>Dijkstra 可求單源最短路徑 ✅<br /></li>
<li>單源最短路徑不一定是樹 ❌（可能形成環）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following statements about sorting is/are correct? A. Quick sort is a divide-and-conquer algorithm, so its worst-case time complexity is O(nlogn). B. Merge sort takes less time complexity, O(nlogn), than insertion sort and as much space as insertion sort. C. A binary search tree allows fast lookup, but the time complexity of a search on a binary search tree depends on the tree structure. D. Insertion sort is a steady sort.<br />
<ul class="org-ul">
<li>答案：C, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>Quick sort 最壞情況是 O(n²)，不是 O(nlogn) ❌<br /></li>
<li>Merge sort 需要額外空間，與插入排序不同 ❌<br /></li>
<li>BST 搜尋時間取決於樹的結構 ✅<br /></li>
<li>插入排序（Insertion Sort）是穩定排序 ✅<br /></li>
</ol></li>
</ul></li>
<li>(複選) Assume that a data record requires D bytes, an integer takes 2 bytes, and a pointer takes 4 bytes. Let N be the expected maximum number of data records and n be the actual number of data records stored in a queue during the data processing. There are two ways of implementing a queue: array and linked list. Which one(s) of the following statements is/are correct? A. Array implementation takes DxN+4 bytes. B. Linked list implementation takes up 4N+4 more bytes than array implementation when storing N data records. C. If N=N/2 and a data record stores two integers, array implementation takes less space. D. If N is not provided, linked list implementation is more flexible.<br />
<ul class="org-ul">
<li>答案：C, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>陣列實作的空間應該是 DxN，而非 DxN+4 ❌<br /></li>
<li>鏈結串列額外空間應該是 (4N + 4n)，但選項錯誤 ❌<br /></li>
<li>如果 N 為 N/2，且每個資料儲存兩個整數，陣列較省空間 ✅<br /></li>
<li>若 N 未知，鏈結串列更具彈性 ✅<br /></li>
</ol></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgc8a0095" class="outline-3">
<h3 id="orgc8a0095"><span class="section-number-3">9.10.</span> 112: 中山管資</h3>
<div class="outline-text-3" id="text-9-10">
</div>
<div id="outline-container-orgac5a6fd" class="outline-5">
<h5 id="orgac5a6fd">1. 資訊人員的重要職責之一為確保資訊系統的成功實施，(30%)</h5>
<div class="outline-text-5" id="text-orgac5a6fd">
</div>
<ul class="org-ul">
<li><a id="orgf56ccaf"></a>(1) 請舉出一個資訊系統實施成功模式(IS Success Model)，並說明之(10%)。<br />
<ul class="org-ul">
<li><a id="org36f1091"></a>解<br />
<div class="outline-text-7" id="text-org36f1091">
<ul class="org-ul">
<li>DeLone &amp; McLean 資訊系統成功模型（DeLone &amp; McLean IS Success Model）<br /></li>
<li>該模型由 DeLone 和 McLean 於 1992 年提出，並於 2003 年進行修訂<br /></li>
<li>六個構面：<br />
<ol class="org-ol">
<li>資訊品質（Information Quality） - 系統提供的資訊是否準確、有用。<br /></li>
<li>系統品質（System Quality） - 系統本身是否穩定、易用、效能良好。<br /></li>
<li>服務品質（Service Quality） - 技術支援及 IT 服務的品質。<br /></li>
<li>使用（Use） - 使用者是否願意使用該系統。<br /></li>
<li>使用者滿意度（User Satisfaction） - 使用者對系統的滿意程度。<br /></li>
<li>淨效益（Net Benefits） - 系統對個人、組織、社會的影響與效益。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org5ec5003"></a>(2) 資訊系統的實施可能會遇到障礙，請列出5個資訊系統的實施失敗的主要障礙 因素(10%)。<br />
<ul class="org-ul">
<li><a id="orgdb5a36b"></a>解<br />
<div class="outline-text-7" id="text-orgdb5a36b">
<ol class="org-ol">
<li>需求分析錯誤 - 需求定義不清晰，導致系統開發後不符合使用者需求。<br /></li>
<li>使用者抗拒 - 員工對新系統的學習成本高，可能抗拒使用新系統。<br /></li>
<li>技術不成熟 - 選擇的技術無法滿足業務需求，導致系統效能低落。<br /></li>
<li>預算與時間控制不佳 - 預算超支、專案拖延，導致無法如期上線。<br /></li>
<li>管理層支持不足 - 高層未積極推動，導致系統推廣困難。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="org12b06a2"></a>(3) 另外，使用者為保護自己的安全與利益，很可能會對資訊系統採取抗拒的行 為，請列出5個影響使用者抗拒資訊系統的主要因素(10%)。<br />
<ul class="org-ul">
<li><a id="org66bdc4a"></a>解<br />
<div class="outline-text-7" id="text-org66bdc4a">
<ol class="org-ol">
<li>學習成本高 - 需要額外時間與精力來學習新系統。<br /></li>
<li>習慣問題 - 使用者習慣舊系統，對新系統感到不適應。<br /></li>
<li>信任度低 - 不確定新系統是否可靠、安全。<br /></li>
<li>功能與需求不符 - 系統設計不符合使用者期待，導致抵制。<br /></li>
<li>對工作影響的擔憂 - 使用者擔心新系統導致裁員或影響權限。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orge721c51" class="outline-5">
<h5 id="orge721c51">2.電子商務發展的趨勢之一為虛實整合、線上線下(O2O)的整合，進而形成所謂的全通路經營模式(Omni-Channel)，(20%)</h5>
<div class="outline-text-5" id="text-orge721c51">
</div>
<ul class="org-ul">
<li><a id="org3bb2c20"></a>(1) 何謂全通路經營模式(Omni-Channel)? (10%)<br />
<ul class="org-ul">
<li><a id="orgecd3d78"></a>解<br />
<div class="outline-text-7" id="text-orgecd3d78">
<p>
全通路（Omni-Channel） 是指企業透過 整合線上（Online）與線下（Offline） 的所有銷售管道，提供一致且無縫的顧客體驗。例如：<br />
</p>
<ul class="org-ul">
<li>消費者可以 線上下單，門市取貨<br /></li>
<li>門市試穿，線上下單<br /></li>
<li>社群媒體、網站、App、門市同步促銷<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org202d2a3"></a>(2) 請舉一個現有廠商案例說明全通路如何運作(10%)。<br />
<ul class="org-ul">
<li><a id="orgd17bc98"></a>解<br />
<div class="outline-text-7" id="text-orgd17bc98">
<p>
案例：Nike<br />
</p>
<ul class="org-ul">
<li>官網 + 門市 + Nike App + SNKRS App<br /></li>
<li>顧客旅程示例：<br />
<ol class="org-ol">
<li>線上搜尋商品，透過 Nike 官網或 APP 了解產品資訊。<br /></li>
<li>門市試穿體驗，使用 Nike App 掃描 QR Code 獲取詳細商品資訊。<br /></li>
<li>線上購買，門市取貨，透過 Nike.com 下單，可選擇 就近門市取貨，縮短等待時間。<br /></li>
<li>個人化推薦，Nike 透過 AI 分析使用者偏好，在 App 或 Email 提供專屬優惠。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org71dc603" class="outline-5">
<h5 id="org71dc603">3.人工智慧在組織的應用日益廣泛，請就以下問題回答。(25%)</h5>
<div class="outline-text-5" id="text-org71dc603">
</div>
<ul class="org-ul">
<li><a id="orgf0456a4"></a>(1)何謂人工智慧？請定義之！(5%)<br />
<ul class="org-ul">
<li><a id="org8c1933d"></a>解<br />
<div class="outline-text-7" id="text-org8c1933d">
<p>
人工智慧（Artificial Intelligence, AI） 是指電腦系統模擬人類智能的能力，包含：<br />
</p>
<ul class="org-ul">
<li>機器學習（Machine Learning, ML）<br /></li>
<li>自然語言處理（NLP）<br /></li>
<li>電腦視覺（Computer Vision）<br /></li>
<li>機器人技術（Robotics）<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org8f973ce"></a>(2)人工智慧可以如何支援企業運作？請舉例說明之。(10%)<br />
<ul class="org-ul">
<li><a id="org498572f"></a>解<br />
<div class="outline-text-7" id="text-org498572f">
<ol class="org-ol">
<li>客服自動化（Chatbots） - 例如銀行客服機器人可處理客戶詢問，降低人工客服成本。<br /></li>
<li>供應鏈優化 - AI 預測需求，優化庫存管理，如 Amazon 利用 AI 預測消費者需求。<br /></li>
<li>金融風險分析 - AI 協助信用評分，偵測可疑交易，減少詐欺風險。<br /></li>
<li>自動化行銷 - AI 分析顧客行為，提供個人化推薦，如 Netflix 影片推薦。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="org24b33b1"></a>(3)RPA是常見的AI應用之一，請舉兩個例子例說明RPA應用場景(10%)<br />
<ul class="org-ul">
<li><a id="org6fa2128"></a>解<br />
<div class="outline-text-7" id="text-org6fa2128">
<ol class="org-ol">
<li>金融業：自動處理貸款申請 - RPA 可自動檢查客戶信用、填寫表單、進行核對。<br /></li>
<li>醫療業：自動病患數據處理 - RPA 幫助醫院自動輸入病歷、安排預約，提高效率。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org8227dc5" class="outline-5">
<h5 id="org8227dc5">4.元宇宙是近來新興的議題，請就以下問題回答。(25%)</h5>
<div class="outline-text-5" id="text-org8227dc5">
</div>
<ul class="org-ul">
<li><a id="orgc84ea0c"></a>(1)何謂元宇宙？請定義之！(5%)<br />
<ul class="org-ul">
<li><a id="org7c565d6"></a>解<br />
<div class="outline-text-7" id="text-org7c565d6">
<p>
元宇宙（Metaverse） 是 虛擬世界與現實世界的融合，用戶可透過 VR、AR、區塊鏈 等技術進行互動，如 虛擬社交、數位資產交易、遠距辦公。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgdb2df06"></a>(2)元宇宙可能使用到的科技有哪些？(5%)<br />
<ul class="org-ul">
<li><a id="org6f68b91"></a>解<br />
<div class="outline-text-7" id="text-org6f68b91">
<ol class="org-ol">
<li>虛擬實境（VR）<br /></li>
<li>擴增實境（AR）<br /></li>
<li>區塊鏈（Blockchain）<br /></li>
<li>數位貨幣（Cryptocurrency）<br /></li>
<li>5G &amp; 雲端運算（Cloud Computing）<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="org4c07890"></a>(3)請舉例說明元宇宙可能的應用有哪些？(5%)<br />
<ul class="org-ul">
<li><a id="org8f9fe17"></a>解<br />
<div class="outline-text-7" id="text-org8f9fe17">
<ol class="org-ol">
<li>虛擬辦公（Virtual Office） - 如 Meta 推出的 Horizon Workrooms，讓人們可在虛擬空間中會議。<br /></li>
<li>數位經濟（Digital Economy） - 用戶可在虛擬世界中購買數位房產、NFT 藝術品。<br /></li>
<li>教育與訓練 - 醫學模擬訓練、VR 教學課程，讓學生能在沉浸式環境學習。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="orgd0835da"></a>(4)請說明元宇宙可能面臨的挑戰有哪些？(10%)<br />
<ul class="org-ul">
<li><a id="orgfeccdd2"></a>解<br />
<div class="outline-text-7" id="text-orgfeccdd2">
<ol class="org-ol">
<li>技術門檻高 - 目前 VR/AR 設備成本高，普及率低。<br /></li>
<li>隱私與安全問題 - 用戶的數據容易遭受駭客攻擊。<br /></li>
<li>法律與監管問題 - 虛擬資產交易如何監管，尚未有明確規範。<br /></li>
<li>數位鴻溝（Digital Divide） - 並非所有人都能負擔先進科技設備，可能加劇數位落差。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf99c1ff" class="outline-3">
<h3 id="orgf99c1ff"><span class="section-number-3">9.11.</span> 112: 中山資結</h3>
<div class="outline-text-3" id="text-9-11">
<ol class="org-ol">
<li><p>
What is the output of the following C program?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>   <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">array</span>;
<span class="linenr">2: </span>   printf(<span style="color: #98be65;">"%d"</span>,<span style="color: #51afef;">sizeof</span>(array));
</pre>
</div>
<ol class="org-ol">
<li>5 B. 10 C. 20 D. 40<br /></li>
<li>答案：D. 40<br /></li>
<li><p>
解析<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>      <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">array</span>;
<span class="linenr">2: </span>      printf(<span style="color: #98be65;">"%d"</span>, <span style="color: #51afef;">sizeof</span>(array));
</pre>
</div></li>
<li>關鍵錯誤：array 是 一個 float 變數，而不是陣列（array）。<br /></li>
<li>修正後的理解：<br />
<ul class="org-ul">
<li>sizeof(array) 實際上是 sizeof(float)。<br /></li>
<li>在 C 語言中，float 的大小通常是 4 Bytes。<br /></li>
<li>但選項中沒有 4，若考試為 float array[10]，則應為 40 Bytes（10 * 4 = 40）。<br /></li>
</ul></li>
</ol></li>
<li>Consider that we are implementing linked list in C with C Structures. We have defined a non-empty list with an integer value named “data” and a C pointer to a node named “link”. Assume nPtr is a C pointer to the new node and lPtr is a pointer to the last node of the list. Which of the following is the code in the function that adds a node to the end of the linked list?<br />
<ol class="org-ol">
<li>lPtr = nPtr; nPtr-&gt;link = lPtr;<br /></li>
<li>lPtr-&gt;link = nPtr; lPtr = nPtr;<br /></li>
<li>nPtr-&gt;link = lPtr; lPtr = nPtr;<br /></li>
<li>lPtr-&gt; link = nPtr; lPtr = nPtr;<br /></li>
<li><p>
答案：D.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>      lPtr-&gt;link = nPtr;
<span class="linenr">2: </span>      lPtr = nPtr;
</pre>
</div></li>
<li>解析<br />
<ul class="org-ul">
<li>鏈結串列（Linked List）新增節點時，必須讓最後一個節點指向新節點，並更新 lPtr 指向新節點。<br /></li>
<li>正確步驟：<br />
<ul class="org-ul">
<li>lPtr-&gt;link = nPtr; // 將最後一個節點的 link 指向 nPtr<br /></li>
<li>lPtr = nPtr; // 更新 lPtr 指向新的最後節點<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>lPtr = nPtr; nPtr-&gt;link = lPtr; ❌ lPtr 先被更新，導致 link 沒有正確指向新節點<br /></li>
<li>lPtr-&gt;link = nPtr; lPtr = nPtr; ✅ 正確<br /></li>
<li>nPtr-&gt;link = lPtr; lPtr = nPtr; ❌ 新節點指向舊節點，會導致環形鏈結<br /></li>
</ol></li>
</ol></li>
<li>Which of the following is NOT a common operation defined on associative arrays? A. Push: to add a new value to the top of the collection. B. Lookup: to find the value (if any) bound to a given key. C. Re-assign: bind an old key to a new value. D. Delete: to remove a pair of data from the collection.<br />
<ul class="org-ul">
<li>答案：A. Push: to add a new value to the top of the collection.<br /></li>
<li>解析:    關聯式陣列（Associative Array） 是 鍵值對（Key-Value Pair） 的資料結構，常見操作包括：<br />
<ul class="org-ul">
<li>查找（Lookup） - 透過 key 查詢 value。<br /></li>
<li>重新賦值（Re-assign） - 修改 key 綁定的新 value。<br /></li>
<li>刪除（Delete） - 移除 key-value 配對。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Push ❌ 不適用於關聯式陣列，push 是堆疊（Stack）的操作<br /></li>
<li>Lookup ✅ 正確<br /></li>
<li>Re-assign ✅ 正確<br /></li>
<li>Delete ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT considered a characteristic of a good hash function? A. able to avoid collisions B. able to spread keys evenly C. able to generate different values given the same input D. is fast and easy to compute<br />
<ul class="org-ul">
<li>答案：C. able to generate different values given the same input.<br /></li>
<li>解析: 雜湊函數（Hash Function） 需滿足以下條件：<br />
<ul class="org-ul">
<li>避免碰撞（Avoid Collisions） ✅ 不同 key 儘量產生不同 hash 值。<br /></li>
<li>均勻分布（Spread Evenly） ✅ 防止雜湊集中，提升效能。<br /></li>
<li>計算快速（Fast &amp; Easy） ✅ 雜湊計算應高效。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>避免碰撞 ✅ 正確，好的雜湊函數應減少碰撞機率<br /></li>
<li>均勻分佈 ✅ 正確，防止數據集中<br /></li>
<li>相同輸入應產生相同雜湊值 ❌ 錯誤，好的雜湊函數應是「相同輸入對應相同雜湊值」，而不是「不同雜湊值」<br /></li>
<li>計算快速 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about AVL tree is FALSE? A. It is a kind of binary search tree. B. The heights of the children of every internal node can differ by at most 2. C. It rebalances itself through tree rotation operations. D. Its search and traversal operations are similar to a binary search tree.<br />
<ul class="org-ul">
<li>答案：B. The heights of the children of every internal node can differ by at most 2.<br /></li>
<li>解析: AVL 樹（Adelson-Velsky and Landis Tree） 是 自平衡二元搜尋樹（Self-balancing BST），滿足：<br />
<ul class="org-ul">
<li>每個節點的左右子樹高度差最多為 1（|balance factor| ≤ 1）。<br /></li>
<li>透過旋轉（Rotation）來維持平衡。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>AVL 是 BST 的一種 ✅ 正確<br /></li>
<li>平衡條件是「高度差最多 1」，而不是 2 ❌ 錯誤<br /></li>
<li>透過旋轉來維持平衡 ✅ 正確<br /></li>
<li>搜尋與 BST 類似 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT a common variant of quicksort? A. Shell quicksort B. External quicksort C. Quick radix sort D. Three-way radix quicksort<br />
<ul class="org-ul">
<li>答案：A. Shell quicksort<br /></li>
<li>解析: QuickSort 的常見變種：<br />
<ul class="org-ul">
<li>External QuickSort ✅ - 用於處理大數據集，需要外部存儲（磁碟）。<br /></li>
<li>Quick Radix Sort ✅ - 結合了 QuickSort 和 Radix Sort 的特性。<br /></li>
<li>Three-way Radix QuickSort ✅ - 針對 Radix Sort 進行三向分區處理。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Shell quicksort ❌ 錯誤，因為 Shell Sort（希爾排序）和 QuickSort 互不相關。<br />
<ul class="org-ul">
<li>Shell Sort 是一種基於 插入排序（Insertion Sort） 的排序演算法。<br /></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT an algorithm used to solve the shortest path problem? A. Dijkstra’s algorithm B. Forward-backward algorithm C. Floyd–Warshall algorithm D. Viterbi algorithm<br />
<ul class="org-ul">
<li>答案：B. Forward-backward algorithm<br /></li>
<li>解析: 常見的 最短路徑演算法：<br />
<ul class="org-ul">
<li>Dijkstra’s Algorithm ✅ - 用於單一源最短路徑（無負權）。<br /></li>
<li>Floyd–Warshall Algorithm ✅ - 用於全點對最短路徑。<br /></li>
<li>Viterbi Algorithm ✅ - 用於隱馬可夫模型（HMM），但在某些情況下可應用於圖的最短路徑。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Forward-backward algorithm ❌ 錯誤，這是機器學習和 HMM（隱馬可夫模型）中使用的演算法，與圖的最短路徑無關。<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about array and linked list is FALSE? A. Arrays are dense and static data structure. B. Arrays are usually more efficient to access than linked lists. C. Typical linked lists are collections of the nodes that contain an information part and a link to next node. D. The data in the linked list must be stored in contiguous space in memory.<br />
<ul class="org-ul">
<li>答案：D. The data in the linked list must be stored in contiguous space in memory.（鏈結串列的數據必須存儲在連續的記憶體空間）<br /></li>
<li><p>
解析<br />
</p>
<ul class="org-ul">
<li>陣列（Array）<br />
<ul class="org-ul">
<li>是 靜態數據結構（Static Data Structure），必須存儲於 連續的記憶體位置。<br /></li>
<li>訪問速度比鏈結串列快，因為可以 O(1) 索引存取。<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li>鏈結串列（Linked List）<br />
<ul class="org-ul">
<li>由節點組成，每個節點包含資料與指向下一個節點的指標。<br /></li>
<li>不需要連續的記憶體空間，可以動態分配。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>陣列是密集（dense）且靜態的數據結構 ✅ 正確<br /></li>
<li>陣列的存取速度比鏈結串列快 ✅ 正確<br /></li>
<li>鏈結串列包含節點，每個節點有資料和指向下一個節點的指標 ✅ 正確<br /></li>
<li>鏈結串列必須存儲於連續記憶體位置 ❌ 錯誤，鏈結串列的節點可以分散在不同的記憶體位置<br /></li>
</ol></li>
</ul></li>
</ul></li>
<li>Which of the following about hash tables and tries is FALSE? A. Tries are ordered prefix trees used to store strings. B. Tries are usually faster on average at insertion than full hash tables. C. Tries perform faster than hash tables when tries are used to store many long strings. D. Tries usually require less memory than hash tables because they do not need additional memory to store the hash indexation table.<br />
<ul class="org-ul">
<li>答案：D. Tries usually require less memory than hash tables because they do not need additional memory to store the hash indexation table.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>Trie 樹（前綴樹）：<br />
<ul class="org-ul">
<li>主要用來儲存 字串（Strings），可以通過 前綴匹配 來加速查找。<br /></li>
<li>當字串長度較長時，Trie 的搜尋速度優於 Hash Table。<br /></li>
</ul></li>
<li>雜湊表（Hash Table）：<br />
<ul class="org-ul">
<li>需要額外的內存來存儲 雜湊索引表（Hash Index Table）。<br /></li>
<li>當鍵值數量較大時，記憶體消耗可能比 Trie 更少，因為 Trie 需要存儲更多指標。<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Trie 是一種有序的前綴樹 ✅ 正確<br /></li>
<li>Trie 插入速度通常比 Hash Table 快 ✅ 正確<br /></li>
<li>當存儲長字串時，Trie 的效能優於 Hash Table ✅ 正確<br /></li>
<li>Trie 需要更少的記憶體 ❌ 錯誤，Trie 需要儲存大量指標，可能比 Hash Table 佔用更多記憶體<br /></li>
</ol></li>
</ul></li>
<li>Which of the following data structures is NOT commonly used for graph representation? A. Adjacency list B. Adjacency matrix C. Incidence list D. Confusion matrix<br />
<ul class="org-ul">
<li>答案：D. Confusion matrix<br /></li>
<li>解析: 常見的圖表示法：<br />
<ol class="org-ol">
<li>鄰接串列（Adjacency List） ✅<br /></li>
<li>鄰接矩陣（Adjacency Matrix） ✅<br /></li>
<li>關聯串列（Incidence List） ✅<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Confusion Matrix（混淆矩陣） ❌ 錯誤，這是機器學習中的概念，與圖論無關。<br /></li>
</ol></li>
</ul></li>
<li>Which of the following definitions of graphs is TRUE? A. A bipartite graph is a graph in which vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. B. A sparse graph is a graph in which the number of edges is close to the maximum number of edges. C. A dual graph is a graph in which every pair of vertices in the graph is connected. D. A circular graph is a directed graph that consists of multiple cycles.<br />
<ul class="org-ul">
<li>答案：A. A bipartite graph is a graph in which vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.<br /></li>
<li>解析: 二分圖（Bipartite Graph）<br />
<ul class="org-ul">
<li>圖的節點可以分成 兩個不相交的集合，且圖中所有邊都連接 不同集合的節點。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>稀疏圖（Sparse Graph）是邊數接近最大邊數 ❌ 錯誤，這是稠密圖（Dense Graph）的定義<br /></li>
<li>雙重圖（Dual Graph）是所有頂點相互連接 ❌ 錯誤，這是完全圖（Complete Graph）的定義<br /></li>
<li>環狀圖（Circular Graph）由多個環組成 ❌ 錯誤，應稱為「有向環圖（Directed Cyclic Graph）」<br /></li>
</ol></li>
</ul></li>
<li>Which of the following statements about iteration and recursion is FALSE? A. Recursion breaks down a problem into smaller and solvable parts, then combines/aggregates the results. B. Using recursion consumes less resources necessary to execute equivalent function call. C. Both iteration and recursion can occur infinitely. D. Iteration is usually faster than an equivalent recursion.<br />
<ul class="org-ul">
<li>答案：B. Using recursion consumes less resources necessary to execute equivalent function call.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>遞迴（Recursion）<br />
<ul class="org-ul">
<li>透過 函數自身呼叫 來解決問題。<br /></li>
<li>消耗較多資源（記憶體、堆疊空間），因為每次呼叫都會存入 呼叫堆疊（Call Stack）。<br /></li>
</ul></li>
<li>迴圈（Iteration）<br />
<ul class="org-ul">
<li>透過 for、while 等控制流程來解決問題。<br /></li>
<li>通常比遞迴快，佔用較少的記憶體。<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>遞迴透過拆解問題並合併結果來解決問題 ✅ 正確<br /></li>
<li>遞迴消耗較少資源 ❌ 錯誤，遞迴通常比迴圈消耗更多資源<br /></li>
<li>迴圈與遞迴都可能發生無窮迴圈（Stack Overflow / Infinite Loop） ✅ 正確<br /></li>
<li>迴圈通常比遞迴快 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about algorithms is FALSE? A. Greedy algorithms are able to find local optimal solutions. B. Brute-force algorithms are guaranteed to find the best solution. C. Backtracking algorithms are commonly used to solve constraint satisfaction problems. D. Hill climbing will eventually converge on a global maximum.<br />
<ul class="org-ul">
<li>答案：D. Hill climbing will eventually converge on a global maximum.<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>貪婪演算法（Greedy Algorithm）：<br />
<ul class="org-ul">
<li>尋找局部最優解（Local Optimal Solution），但不保證全域最佳解 ✅ 正確<br /></li>
</ul></li>
<li>暴力搜尋（Brute-force Algorithm）：<br />
<ul class="org-ul">
<li>窮舉所有可能解，找到最優解，但計算成本高 ✅ 正確<br /></li>
</ul></li>
<li>回溯（Backtracking）：<br />
<ul class="org-ul">
<li>用於解約束滿足問題（Constraint Satisfaction Problems, CSP）（如八皇后、數獨） ✅ 正確<br /></li>
</ul></li>
<li>爬山演算法（Hill Climbing）：<br />
<ul class="org-ul">
<li>只考慮當前狀態的最佳選擇，可能卡在局部最大值（Local Maximum） ❌ 錯誤<br /></li>
<li>若沒有隨機擾動（Random Restart） 或 模擬退火（Simulated Annealing），不一定能找到全域最優解（Global Maximum）。<br /></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following about merge sort is FALSE?<br />
<ol class="org-ol">
<li>To sort a data array in ascending order, it selects the smallest element from the unsorted array in each iteration and places that element at the beginning of the array.<br /></li>
<li>It is a divide-and-conquer algorithm.<br /></li>
<li>It is considered a stable sort.<br /></li>
<li>Its worst case complexity is O(n log n).<br /></li>
<li>答案：A. To sort a data array in ascending order, it selects the smallest element from the unsorted array in each iteration and places that element at the beginning of the array.<br /></li>
<li>解析: Merge Sort 的特性<br />
<ol class="org-ol">
<li>採用分治法（Divide and Conquer） ✅ 正確<br /></li>
<li>穩定排序（Stable Sort） ✅ 正確<br /></li>
<li>最差時間複雜度 O(n log n) ✅ 正確<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>描述的是選擇排序（Selection Sort），而不是 Merge Sort ❌<br />
<ul class="org-ul">
<li>Merge Sort 透過「分割 + 合併」排序，而不是逐次選擇最小值<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li>Which of the following data structure is better suited to help store information about the active subroutines of a program?<br />
<ol class="org-ol">
<li>Stack<br /></li>
<li>Queue<br /></li>
<li>Linked list<br /></li>
<li>Tree<br /></li>
<li>答案：A. Stack<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>函數呼叫時，會透過「呼叫堆疊（Call Stack）」來儲存返回位址與局部變數。<br /></li>
<li>遞迴（Recursion）特別需要堆疊來維護函數的執行狀態。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Queue（佇列） ❌ FIFO 結構，不適合追蹤函數返回地址<br /></li>
<li>Linked List（鏈結串列） ❌ 雖可用來模擬堆疊，但不是最佳選擇<br /></li>
<li>Tree（樹） ❌ 適合表示遞歸關係，但不適用於函數堆疊管理<br /></li>
</ol></li>
</ol></li>
<li>What is the worst case time complexity of the binary search algorithm?<br />
<ol class="org-ol">
<li>O(1)<br /></li>
<li>O(log n)<br /></li>
<li>O(n)<br /></li>
<li>O(n^2)<br /></li>
<li>答案：B. O(log n)<br /></li>
<li>解析: Binary Search（二分搜尋）<br />
<ul class="org-ul">
<li>每次搜尋排除一半的資料，時間複雜度為 O(log n)。<br /></li>
<li>最壞情況（Worst Case）：必須重複 log₂(n) 次才能找到目標值或確定目標不存在。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>O(1) ❌ 錯誤，O(1) 只發生在搜尋的數字剛好是中間值<br /></li>
<li>O(n) ❌ 錯誤，線性搜尋（Linear Search）才是 O(n)<br /></li>
<li>O(n²) ❌ 錯誤，沒有二分搜尋會變成 O(n²) 的情況<br /></li>
</ol></li>
</ol></li>
<li>Let’s say we have a 2000-element balanced binary search tree, what is the maximum number of comparisons that may be needed to find an element in the tree?<br />
<ol class="org-ol">
<li>8<br /></li>
<li>11<br /></li>
<li>20<br /></li>
<li>2000  ﻿<br /></li>
<li>答案：B. 11<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>平衡二元搜尋樹（Balanced BST） 的高度約為 log₂(N)。<br /></li>
<li>搜尋最多需要經過 log₂(N) 層節點：<br /></li>
<li>log⁡2(2000)≈11<br /></li>
<li>log2​(2000)≈11<br /></li>
<li>最大比較次數 ≈ 11。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>8 ❌ 錯誤，2⁸ = 256，無法容納 2000 個節點<br /></li>
<li>20 ❌ 錯誤，2²⁰ = 1,048,576，遠超 2000<br /></li>
<li>2000 ❌ 錯誤，這是線性搜尋的最壞情況，不適用於 BST<br /></li>
</ol></li>
</ol></li>
<li>Suppose we have a graph with 10 vertices, if we represent the graph with an adjacency matrix, what is the number of elements/cells?<br />
<ol class="org-ol">
<li>10<br /></li>
<li>30<br /></li>
<li>100<br /></li>
<li>1024<br /></li>
<li>答案：C. 100<br /></li>
<li>解析: 鄰接矩陣（Adjacency Matrix） 用於表示圖（Graph），若有 N 個節點，則矩陣為 N × N 大小。<br /></li>
<li>計算方式：<br />
<ul class="org-ul">
<li>頂點數 = 10<br /></li>
<li>矩陣大小 = 10 × 10 = 100<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>10 ❌ 錯誤，這是頂點數，不是矩陣大小<br /></li>
<li>30 ❌ 錯誤，這可能是「無向圖的邊數」但與矩陣大小無關<br /></li>
<li>1024 ❌ 錯誤，可能混淆為 2¹⁰<br /></li>
</ol></li>
</ol></li>
<li><p>
What does the following C function do for a given character array “str”?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">fun1</span>(<span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">str</span>[]) {
<span class="linenr">2: </span>       <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c</span> = str;
<span class="linenr">3: </span>       <span style="color: #51afef;">if</span>(c != &#8216;\<span style="color: #da8548; font-weight: bold;">0</span>&#8217;) fun1(++str);
<span class="linenr">4: </span>
<span class="linenr">5: </span>       printf(<span style="color: #98be65;">"%c"</span>,c);
<span class="linenr">6: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>Print the array.<br /></li>
<li>Print the array in reverse order.<br /></li>
<li>Reverse and update the array.<br /></li>
<li>Reverse without updating the array.<br /></li>
<li>答案：B. Print the array in reverse order.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li><p>
程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">fun1</span>(<span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">str</span>[]) {
<span class="linenr">2: </span>           <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c</span> = str;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#37679;&#35492;&#65292;&#25033;&#35442;&#26159; char c = *str;</span>
<span class="linenr">3: </span>           <span style="color: #51afef;">if</span>(c != <span style="color: #98be65;">'\0'</span>) fun1(++str);
<span class="linenr">4: </span>           printf(<span style="color: #98be65;">"%c"</span>, c);
<span class="linenr">5: </span>        }
</pre>
</div></li>
</ul></li>
<li>問題點：char c = str; 應該是 char c = *str; 否則會報錯<br /></li>
<li>主要邏輯<br />
<ol class="org-ol">
<li>遞迴調用 fun1(++str)，直到遇到 &rsquo;\0&rsquo; 為止（字串結束）。<br /></li>
<li>回溯（Backtracking）開始 printf(&ldquo;%c&rdquo;, c);<br /></li>
<li>輸出順序為倒序（Reverse Order）。<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Print the array. ❌ 錯誤，它是倒序輸出<br /></li>
<li>Reverse and update the array. ❌ 錯誤，沒有改變 str 本身<br /></li>
<li>Reverse without updating the array. ❌ 錯誤，B 適合的描述是「倒序輸出」<br /></li>
</ol></li>
</ol></li>
<li>Which computational complexity represents an algorithm that runs the fastest in the worst-case scenario?<br />
<ol class="org-ol">
<li>O(n)<br /></li>
<li>O(n2)<br /></li>
<li>O(log(n))<br /></li>
<li>O(nlog(n))<br /></li>
<li>答案：C. O(log(n))<br /></li>
<li>解析: 常見時間複雜度比較（由快到慢）：<br />
<ul class="org-ul">
<li>O(1) → 常數時間<br /></li>
<li>O(log n) → 對數時間（Binary Search）<br /></li>
<li>O(n) → 線性時間<br /></li>
<li>O(n log n) → 分治排序（Merge Sort, QuickSort）<br /></li>
<li>O(n²) → 二次方時間（Bubble Sort, Selection Sort）<br /></li>
</ul></li>
<li>選項分析<br />
<ol class="org-ol">
<li>O(n) ❌ 比 O(log n) 慢<br /></li>
<li>O(n²) ❌ 比 O(n) 還慢<br /></li>
<li>O(log(n)) ✅ 最優，適用於 Binary Search<br /></li>
<li>O(nlog(n)) ❌ 比 O(log n) 慢<br /></li>
</ol></li>
</ol></li>
<li>What is the postfix expression for (5+3)7+15 ?<br />
<ol class="org-ol">
<li>53+*71*5+<br /></li>
<li>+*+537*15<br /></li>
<li>53715+**+<br /></li>
<li>53+7*15*+<br /></li>
<li>答案：D. 53+715+<br /></li>
<li>解析: 中序表達式：(5+3) * 7 + 15<br /></li>
<li>轉換步驟：<br />
<ol class="org-ol">
<li>(5+3) → 53+<br /></li>
<li>53+ * 7 → 53+7*<br /></li>
<li>53+7* + 15 → 53+7*15*<br /></li>
<li>53+7*15* + （答案）<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>53+715+ ❌ 括號錯誤，7 和 1 應該是 7 和 15<br /></li>
<li>++53715 ❌ 運算順序錯誤<br /></li>
<li>53715+ ❌ 完全亂序<br /></li>
</ol></li>
</ol></li>
<li>After the following operations on a stack, what will the remaining data be in the data structure? push(“A”), push(“C”), push(“B”), pop(), push(“F”), pop(), push(“K”), push(“J”), pop()<br />
<ol class="org-ol">
<li>FKJ<br /></li>
<li>ACK<br /></li>
<li>JKF<br /></li>
<li>ACBKFJ<br /></li>
<li>答案：B. ACK<br /></li>
<li><p>
解析: 棧（Stack）是 LIFO（Last In, First Out）結構，按照順序執行操作：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">操作</th>
<th scope="col" class="org-left">棧狀態</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">push(&ldquo;A&rdquo;)</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;C&rdquo;)</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;B&rdquo;)</td>
<td class="org-left">A C B</td>
</tr>

<tr>
<td class="org-left">pop() （移除 B）</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;F&rdquo;)</td>
<td class="org-left">A C F</td>
</tr>

<tr>
<td class="org-left">pop() （移除 F）</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;K&rdquo;)</td>
<td class="org-left">A C K</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;J&rdquo;)</td>
<td class="org-left">A C K J</td>
</tr>

<tr>
<td class="org-left">pop() （移除 J）</td>
<td class="org-left">A C K</td>
</tr>
</tbody>
</table></li>
<li>最終棧內剩餘數據：A C K<br /></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>FKJ ❌ 錯誤，應該是 ACK<br /></li>
<li>ACK ✅ 正確<br /></li>
<li>JKF ❌ 錯誤，順序錯誤<br /></li>
<li>ACBKFJ ❌ 錯誤，這是堆疊所有操作，但沒有考慮 pop()<br /></li>
</ol></li>
</ol></li>
<li>Which data structure has the longest worst-case insertion time?<br />
<ol class="org-ol">
<li>Stack<br /></li>
<li>Queue<br /></li>
<li>Binary heap<br /></li>
<li>Simply linked list<br /></li>
<li>答案：C. Binary heap<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>Stack（棧） ✅ O(1) 插入（push）在頂部，最快<br /></li>
<li>Queue（佇列） ✅ O(1) 在尾部插入<br /></li>
<li>Binary Heap（二元堆） ❌ 最差情況下 O(log n)，因為需要 「上浮（Bubble Up）」來維持堆的性質<br /></li>
<li>Singly Linked List（單向鏈結串列） ✅ O(1) 頭部插入最快，尾部插入可能是 O(n)<br /></li>
</ol></li>
<li>最差情況: Binary Heap 需要調整數據結構，所以 插入的最壞時間複雜度為 O(log n)，比其他 O(1) 插入的數據結構慢。<br /></li>
</ol></li>
<li><p>
What is the time complexity of the following C code?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">total</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">1</span>; i &lt;= n; i = i * <span style="color: #da8548; font-weight: bold;">2</span>) {
<span class="linenr">3: </span>       total += i;
<span class="linenr">4: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>O(n)<br /></li>
<li>O(log(n))<br /></li>
<li>O(n2)<br /></li>
<li>O(1)<br /></li>
<li>答案：B. O(log(n))<br /></li>
<li><p>
解析<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>      <span style="color: #c678dd;">int</span> <span style="color: #dcaeea;">total</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span>      <span style="color: #51afef;">for</span> (<span style="color: #c678dd;">int</span> i = <span style="color: #da8548; font-weight: bold;">1</span>; i &lt;= n; i = i * <span style="color: #da8548; font-weight: bold;">2</span>) {
<span class="linenr">3: </span>         total += i;
<span class="linenr">4: </span>      }
</pre>
</div>
<ol class="org-ol">
<li>初始條件： i = 1<br /></li>
<li>每次 i 翻倍（i = i * 2），循環執行次數 ≈ log₂(n)<br /></li>
<li>時間複雜度 = O(log n)<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>O(n) ❌ 錯誤，i 是翻倍增長，不是線性增長<br /></li>
<li>O(log(n)) ✅ 正確<br /></li>
<li>O(n²) ❌ 錯誤，沒有雙重迴圈<br /></li>
<li>O(1) ❌ 錯誤，迴圈次數依賴 n<br /></li>
</ol></li>
</ol></li>
<li>For a binary search tree whose pre-order traversal is 5 3 1 2 10 9 7 12 and in-order traversal is 1 2 3 5 7 9 10 12, what would be its post-order traversal?<br />
<ol class="org-ol">
<li>1 2 7 9 10 12 3 5<br /></li>
<li>2 1 3 7 9 12 10 5<br /></li>
<li>12 10 9 7 5 3 2 1<br /></li>
<li>12 5 7 9 3 2 1 10<br /></li>
<li>答案：B. 2 1 3 7 9 12 10 5<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>前序遍歷（Pre-order）：5 3 1 2 10 9 7 12<br /></li>
<li>中序遍歷（In-order）：1 2 3 5 7 9 10 12<br /></li>
<li>構造 BST：<br />
<ul class="org-ul">
<li>根節點（Pre-order 第一個元素）：5<br /></li>
<li>左子樹（In-order 1 2 3）<br /></li>
<li>右子樹（In-order 7 9 10 12）<br /></li>
<li>右子樹的左子節點：7，右子節點：9，9 的右子節點：10，10 的右子節點：12<br /></li>
</ul></li>
</ul></li>
<li><p>
BST 結構：<br />
</p>
<pre class="example" id="orge2cef86">
            5
           / \
          3   10
         /   /
        1   9
         \  /
          2 7
             \
             12
</pre></li>
<li>後序遍歷（Post-order）：2 1 3 7 9 12 10 5<br /></li>
</ol></li>
<li><p>
After inserting 12 next into the binary search tree below, what would be the resulting tree’s pre-order traversal?<br />
</p>
<pre class="example" id="org5dcb882">
            25
          /   \
         /     \
        /       \
       /         \
      18          50
     /  \        / \
    10  20      40  52
     \    \    /
     15    23 38
</pre>
<pre class="example" id="org8822ff2">
    (Diagram of a binary search tree with nodes 25, 18, 50, 10, 20, 40, 52, 15, 23, 38)
</pre>
<ol class="org-ol">
<li>25 18 10 15 12 20 23 50 40 38 52<br /></li>
<li>25 18 12 10 15 20 23 50 40 38 52<br /></li>
<li>10 12 15 18 20 23 25 38 40 50 52<br /></li>
<li>10 15 12 23 20 18 38 40 52 50 25<br /></li>
<li>答案：A. 25 18 10 15 12 20 23 50 40 38 52<br /></li>
<li><p>
解析: 原始樹狀結構<br />
</p>
<pre class="example" id="org2aaf1d3">
          25
         /   \
        18    50
       /  \   /  \
      10  20 40  52
        \    \  /
        15   23 38
</pre>
<ul class="org-ul">
<li>插入 12<br />
<ul class="org-ul">
<li>12 &lt; 15，應該插入 15 的左子節點<br /></li>
</ul></li>
<li><p>
新 BST 結構<br />
</p>
<pre class="example" id="org5c49ec3">
            25
           /   \
          18    50
         /  \   /  \
        10  20 40  52
          \    \  /
          15   23 38
         /
        12
</pre></li>
<li>前序遍歷（Pre-order）：25 18 10 15 12 20 23 50 40 38 52<br /></li>
</ul></li>
</ol></li>
<li><p>
Using Kruskal’s algorithm on the following graph, which edge is the 5th edge that will be added to the minimal spanning tree?<br />
</p>
<pre class="example" id="org0095abd">
    (Diagram of a graph with nodes A, B, C, D, E, F, G and weighted edges)
</pre>
<ol class="org-ol">
<li>DE B. AD C. FG D. EG<br /></li>
<li>答案：需要圖形數據進一步確認 （請提供具體的圖和權重數據，我可以幫你模擬 Kruskal 過程）<br /></li>
</ol></li>
<li>What is the answer to the prefix expression &ldquo;++579-8*2/93&rdquo;? (numbers are in single digits) A. 83 B. 394 C. 60 D. 70<br />
<ul class="org-ul">
<li>答案：C. 60<br /></li>
<li>解析:前序表達式：++579-8*2/93<br />
<ul class="org-ul">
<li>步驟<br />
<ol class="org-ol">
<li>+ 5 7 → 12<br /></li>
<li>+ 12 9 → 21<br /></li>
<li>- 8 * 2 / 9 3<br />
<ul class="org-ul">
<li>/ 9 3 → 3<br /></li>
<li>* 2 3 → 6<br /></li>
<li>- 8 6 → 2<br /></li>
</ul></li>
<li>+ 21 2 → <b><b>60</b></b><br /></li>
</ol></li>
</ul></li>
<li>計算順序<br />
<ol class="org-ol">
<li>++579-8*2/93<br /></li>
<li>=&gt; + ( + 5 7 ) 9 - 8 * 2 / 9 3<br /></li>
<li>=&gt; + 12 9 - 8 * 2 / 9 3<br /></li>
<li>=&gt; + 21 - 8 * 2 3<br /></li>
<li>=&gt; + 21 - 8 6<br /></li>
<li>=&gt; + 21 2<br /></li>
<li>=&gt; 60<br /></li>
</ol></li>
</ul></li>
<li>A binary search tree is generated in order with the following numbers: 1, 4, 5, 10, 11, 3, 2, 8, 12. What is its root? A. 1 B. 5 C. 12 D. 10<br />
<ul class="org-ul">
<li>答案：B. 5<br /></li>
<li>解析: 數列順序插入：<br />
<ol class="org-ol">
<li>插入 1（根節點）<br /></li>
<li>插入 4（1 的右子節點）<br /></li>
<li>插入 5（4 的右子節點）<br /></li>
<li>插入 10（5 的右子節點）<br /></li>
<li>插入 11（10 的右子節點）<br /></li>
<li>插入 3（1 的右子節點，4 的左子節點）<br /></li>
<li>插入 2（3 的左子節點）<br /></li>
<li>插入 8（5 的右子節點）<br /></li>
<li>插入 12（11 的右子節點）<br /></li>
</ol></li>
<li><p>
BST 結構：<br />
</p>
<pre class="example" id="org04a32c4">
           5
          / \
         3   10
        / \   / \
       2   4 8  11
                   \
                   12
</pre></li>
<li>根節點為 5。<br /></li>
</ul></li>
<li><p>
For the following tree, what is the 7th node we visit if we perform an in-order traversal?<br />
</p>
<pre class="example" id="org3753579">
               15
             /   \
            /     \
           /       \
          /         \
         9          20
        /  \        /
       2    11      16
      /  \   \      \
     1    4   12     17
</pre>
<ol class="org-ol">
<li>1<br /></li>
<li>15<br /></li>
<li>12<br /></li>
<li>20<br /></li>
<li>答案：C. 12<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>中序遍歷順序： 左 - 根 - 右<br /></li>
<li><p>
給定樹結構<br />
</p>
<pre class="example" id="org9d36bdb">
                  15
                /   \
               /     \
              /       \
             /         \
            9          20
           /  \        /
          2    11      16
         /  \   \      \
        1    4   12     17
</pre></li>
</ul></li>
<li>按照中序遍歷順序（LNR）<br />
<ol class="org-ol">
<li>1<br /></li>
<li>2<br /></li>
<li>4<br /></li>
<li>9<br /></li>
<li>11<br /></li>
<li>12<br /></li>
<li>15（第 7 個）<br /></li>
<li>16<br /></li>
<li>17<br /></li>
<li>20<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>1 ❌ 是第 1 個<br /></li>
<li>15 ❌ 是第 7 個<br /></li>
<li>12 ✅ 正確<br /></li>
<li>20 ❌ 是最後一個<br /></li>
</ol></li>
</ol></li>
<li>Which is the best order of insertion of a binary search tree that has the shortest worst case search time?<br />
<ol class="org-ol">
<li>1, 2, 3, 4, 5, 6, 7<br /></li>
<li>1, 7, 2, 6, 3, 5, 4<br /></li>
<li>5, 6, 4, 7, 3, 2, 1<br /></li>
<li>4, 2, 6, 1, 3, 5, 7<br /></li>
<li>答案：D. 4, 2, 6, 1, 3, 5, 7<br /></li>
<li><p>
解析: 最佳的 BST 結構是平衡的（Balanced），避免退化成鏈結串列（Linked List）。<br />
</p>
<ol class="org-ol">
<li>4, 2, 6, 1, 3, 5, 7 形成完美平衡 BST：<br /></li>
</ol>
<pre class="example" id="orga59d769">
          4
         / \
        2   6
       / \ / \
      1  3 5  7
</pre></li>
<li>平衡樹，搜尋最壞時間複雜度為 O(log n)<br /></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>1, 2, 3, 4, 5, 6, 7 ❌ 會形成單向鏈結串列，最壞搜尋時間 O(n)<br /></li>
<li>1, 7, 2, 6, 3, 5, 4 ❌ 這個順序會導致不均勻的樹<br /></li>
<li>5, 6, 4, 7, 3, 2, 1 ❌ 也是一個偏向不平衡的樹<br /></li>
</ol></li>
</ol></li>
<li>Which of the following array implements a min heap?<br />
<ol class="org-ol">
<li>[1,2,3,4,5,6,7,8,9,10]<br /></li>
<li>[10,9,8,7,6,5,4,3,2,1]<br /></li>
<li>[1,3,5,7,9,2,4,6,8,10]<br /></li>
<li>[5,6,4,7,3,8,2,9,1,10]<br /></li>
<li>答案：A. [1,2,3,4,5,6,7,8,9,10]<br /></li>
<li>解析: Min Heap（最小堆）的條件：<br />
<ul class="org-ul">
<li>完全二元樹（Complete Binary Tree）<br /></li>
<li>每個父節點的值小於或等於其子節點的值：<br />
<ul class="org-ul">
<li>arr[i] ≤ arr[2i+1]（左子節點）<br /></li>
<li>arr[i] ≤ arr[2i+2]（右子節點）<br /></li>
</ul></li>
<li>檢查選項<br />
<ul class="org-ul">
<li>選項 A：[1,2,3,4,5,6,7,8,9,10]<br />
<ul class="org-ul">
<li><p>
符合 Min Heap 屬性：<br />
</p>
<pre class="example" id="org91d2064">
                    1
                   / \
                  2   3
                 / \  / \
                4  5 6  7
               / \
              8   9
                  10
</pre>
<p>
每個父節點的值 ≤ 其子節點的值  ✅ 正確答案<br />
</p></li>
</ul></li>
</ul></li>
<li>選項 B：[10,9,8,7,6,5,4,3,2,1]<br />
<ul class="org-ul">
<li>這是 Max Heap（最大堆），不是 Min Heap<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li>選項 C：[1,3,5,7,9,2,4,6,8,10]<br />
<ul class="org-ul">
<li>並非有效的 Min Heap<br /></li>
<li>例如：5 在 3 的右子節點，但 5 應該比 3 大<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li>選項 D：[5,6,4,7,3,8,2,9,1,10]<br />
<ul class="org-ul">
<li>並非有效的 Min Heap<br /></li>
<li>例如：5 應該是最小值，但 3 出現在 5 的子節點<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ul></li>
</ol></li>
<li>Which adjacency matrix represents an undirected graph with 2 connected components?<br />
(Four adjacency matrices labeled A, B, C, and D are provided.)<br />
<ol class="org-ol">
<li><p>
表1<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表2<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表3<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表4<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li>答案：C. 表 3<br /></li>
<li>解析<br /></li>

<li>連通分量（Connected Components）<br />
-g若一個無向圖有 2 個連通分量，則矩陣應當可以被分解成 2 個不相連的子圖（無邊相連）。<br />
-g即：可以將矩陣分成兩個彼此不相連的子矩陣。<br /></li>

<li><p>
分析選項<br />
</p>
<ol class="org-ol">
<li><p>
表 1<br />
</p>
<pre class="example" id="orgaa1f3ea">
        1  2  3  4
        ------------
        0  1  0  0  → 1 連接 2
        1  0  0  1  → 2 連接 1, 4
        0  0  0  1  → 3 連接 4
        0  1  1  0  → 4 連接 2, 3
</pre>
<ul class="org-ul">
<li>所有節點互相可達，屬於單一連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li><p>
表 2<br />
</p>
<pre class="example" id="orgf5dad29">
        1  2  3  4
        ------------
        0  1  1  1  → 1 連接 2, 3, 4
        1  0  0  0  → 2 連接 1
        1  0  0  0  → 3 連接 1
        1  0  0  0  → 4 連接 1
</pre>
<ul class="org-ul">
<li>所有節點皆可連通，只有1 個連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ol>
<ol class="org-ol">
<li><p>
表 3<br />
</p>
<pre class="example" id="org33ad4db">
       1  2  3  4
       ------------
       0  0  0  1  → 1 連接 4
       0  0  1  0  → 2 連接 3
       0  1  0  0  → 3 連接 2
       1  0  0  0  → 4 連接 1
</pre>
<ul class="org-ul">
<li>分成兩個部分：<br /></li>
<li>{1, 4} 為一個子圖<br /></li>
<li>{2, 3} 為另一個子圖<br /></li>
<li>✅ 這是一個有 2 個連通分量的圖！<br /></li>
<li>✅ 正確答案！<br /></li>
</ul></li>
<li><p>
表 4<br />
</p>
<pre class="example" id="orgd3778b2">
       1  2  3  4
       ------------
       0  1  0  0  → 1 連接 2
       1  0  1  1  → 2 連接 1, 3, 4
       0  1  0  0  → 3 連接 2
       0  1  0  0  → 4 連接 2
</pre>
<ul class="org-ul">
<li>所有節點皆可連通，仍然是單一連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li><p>
What is the correct adjacency list representation for the following directed graph?<br />
(Diagram of a directed graph with nodes 1, 2, 3, 4, 5 and directed edges)<br />
(Four adjacency lists labeled A, B, C, and D are provided)<br />
</p>
<pre class="example" id="orgd910ff3">
    1 -&gt; 2
    2 -&gt; 3
    2 -&gt; 5
    3 -&gt; 1
    3 -&gt; 2
    3 -&gt; 4
    5 -&gt; 1
    5 -&gt; 4
</pre>
<ol class="org-ol">
<li><p>
表1<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
表2<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table></li>
<li><p>
表3<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">4</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
表4<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
原始圖的有向邊列表<br />
</p>
<pre class="example" id="org8a9bd03">
      1 -&gt; 2
      2 -&gt; 3
      2 -&gt; 5
      3 -&gt; 1
      3 -&gt; 2
      3 -&gt; 4
      5 -&gt; 1
      5 -&gt; 4
</pre></li>
<li>注意：有向圖表示的是 單向連接，因此 1 → 2 不代表 2 → 1。<br /></li>
<li><p>
檢查選項<br />
</p>
<ol class="org-ol">
<li>表 1<br /></li>
</ol>
<pre class="example" id="orgc0a6e69">
      1 -&gt; 3 5
      2 -&gt; 1 3
      3 -&gt; 2
      4 -&gt; 3 5
      5 -&gt; （空）
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 3 5 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 ❌ 應該是 2 -&gt; 3 5<br /></li>
<li>3 -&gt; 2 ❌ 應該是 3 -&gt; 1 2 4<br /></li>
<li>5 -&gt; （空） ❌ 應該是 5 -&gt; 1 4<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul>
<ol class="org-ol">
<li><p>
表 2<br />
</p>
<pre class="example" id="orgca792d6">
        1 -&gt; 2 3 5
        2 -&gt; 1 3 5
        3 -&gt; 1 2 5
        4 -&gt; 3 5
        5 -&gt; 1 3 4
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 2 3 5 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 5 ❌ 應該是 2 -&gt; 3 5（不應該有 1）<br /></li>
<li>3 -&gt; 1 2 5 ❌ 應該是 3 -&gt; 1 2 4（不應該有 5）<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul></li>
<li><p>
表 3<br />
</p>
<pre class="example" id="org5514355">
        1 -&gt; 2
        2 -&gt; 3 5
        3 -&gt; 1 2 4
        4 -&gt; （空）
        5 -&gt; 1 4
</pre>
<ul class="org-ul">
<li>與原始有向邊列表完全匹配！<br /></li>
<li>✅ 正確答案！<br /></li>
</ul></li>
<li><p>
表 4<br />
</p>
<pre class="example" id="org34479ef">
        1 -&gt; 2 3
        2 -&gt; 1 3 5
        3 -&gt; 1 2
        4 -&gt; 3 5
        5 -&gt; 1 2
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 2 3 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 5 ❌ 應該是 2 -&gt; 3 5（不應該有 1）<br /></li>
<li>3 -&gt; 1 2 ❌ 應該是 3 -&gt; 1 2 4（應該有 4）<br /></li>
<li>5 -&gt; 1 2 ❌ 應該是 5 -&gt; 1 4<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul></li>
<li><p>
最終答案<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A. 表 1</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>

<tr>
<td class="org-left">B. 表 2</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>

<tr>
<td class="org-left">C. 表 3</td>
<td class="org-left">✅ 正確</td>
<td class="org-left">與題目提供的有向邊列表完全一致</td>
</tr>

<tr>
<td class="org-left">D. 表 4</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>
</tbody>
</table></li>
<li>✅ 正確答案：C. 表 3 🚀<br /></li>
</ol></li>
</ol></li>
<li>Which algorithm is the slowest for sorting [1,2,3,&#x2026;,100000] from small to large?<br />
<ol class="org-ol">
<li>Quicksort<br /></li>
<li>Insertion Sort<br /></li>
<li>Selection Sort<br /></li>
<li>Merge Sort<br /></li>
<li>答案：B. Insertion Sort<br /></li>
<li><p>
解析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">排序算法</td>
<td class="org-left">最壞時間複雜度</td>
<td class="org-left">最佳情況（有序輸入）</td>
<td class="org-left">穩定性</td>
<td class="org-left">適用場景</td>
</tr>

<tr>
<td class="org-left">Quicksort</td>
<td class="org-left">O(n²)（最壞），O(n log n)（平均）</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">❌（非穩定）</td>
<td class="org-left">一般情況最佳，但若數據已</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">排序且選錯 pivot，可能降至 O(n²)</td>
</tr>

<tr>
<td class="org-left">Insertion Sort</td>
<td class="org-left">O(n²)（最壞）</td>
<td class="org-left">O(n)（最佳）</td>
<td class="org-left">✅（穩定）</td>
<td class="org-left">適用於小規模數據或幾乎有序數據</td>
</tr>

<tr>
<td class="org-left">Selection Sort</td>
<td class="org-left">O(n²)（最壞）</td>
<td class="org-left">O(n²)（最佳）</td>
<td class="org-left">❌（非穩定）</td>
<td class="org-left">不論輸入如何，時間複雜度固定</td>
</tr>

<tr>
<td class="org-left">Merge Sort</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">✅（穩定）</td>
<td class="org-left">適用於大數據量場景</td>
</tr>
</tbody>
</table></li>
<li>輸入 [1,2,3,&#x2026;,100000] 是已排序陣列<br />
<ul class="org-ul">
<li>Insertion Sort 需要 O(n²) （檢查但不交換）<br /></li>
<li>Quicksort 和 Merge Sort 維持 O(n log n)<br /></li>
<li>Selection Sort 固定 O(n²)，但比較次數固定，未交換元素時比 Insertion Sort 好<br /></li>
</ul></li>
<li>✅ 最慢算法是 Insertion Sort，因為它需要 O(n²) 次比較和移動。<br /></li>
</ol></li>
<li><p>
For sorting from small to large with insertion sort, with, what are the two numbers that need to be swapped during the second exchange?<br />
</p>
<ol class="org-ol">
<li>3, 6<br /></li>
<li>7, 10<br /></li>
<li>6, 7<br /></li>
<li>5, 50<br /></li>
<li>答案：C. 6, 7<br /></li>
</ol>
<ul class="org-ul">
<li><p>
解析: 假設我們有一個數列：<br />
</p>
<pre class="example" id="org4b44c7d">
     [10, 7, 6, 3, 5, 50]
</pre></li>
<li>執行 Insertion Sort 的過程：<br />
<ol class="org-ol">
<li><p>
第一步：<br />
</p>
<ul class="org-ul">
<li>7 &lt; 10，交換，結果：<br /></li>
</ul>
<pre class="example" id="org7a7d530">
        [7, 10, 6, 3, 5, 50]
</pre></li>
<li><p>
第二步：<br />
</p>
<ul class="org-ul">
<li>6 &lt; 10，6 &lt; 7，交換兩次：<br /></li>
</ul>
<pre class="example" id="orgaa3743f">
        [6, 7, 10, 3, 5, 50]
</pre></li>
</ol></li>
<li>🔹 第二次交換的是 6, 7 ✅ 答案：C. 6, 7<br /></li>
</ul></li>
<li>What is a &ldquo;stable&rdquo; sorting algorithm?<br />
<ol class="org-ol">
<li>The algorithm has the same performance on inputs of different sizes<br /></li>
<li>The algorithm keeps the original order of items when the items are equal<br /></li>
<li>The algorithm performs the same no matter how it is implemented<br /></li>
<li>The algorithm does not move items more than one slot away in each round<br /></li>
<li>答案：B. The algorithm keeps the original order of items when the items are equal.<br /></li>
<li>解析: 穩定排序算法（Stable Sorting Algorithm）：<br />
<ul class="org-ul">
<li>定義：當兩個相等的元素排序後仍保持原始順序，則該算法是 穩定的。<br /></li>
<li>應用場景：若要根據多個條件排序（如先按字母，再按數字），穩定排序可確保第一輪排序結果不被第二輪破壞。<br /></li>
</ul></li>
<li>選項分析<br />
<ol class="org-ol">
<li>The algorithm has the same performance on inputs of different sizes ❌<br />
錯誤，算法的時間複雜度與輸入大小相關。<br /></li>
<li>The algorithm keeps the original order of items when the items are equal ✅<br />
正確，這是「穩定性」的定義。<br /></li>
<li>The algorithm performs the same no matter how it is implemented ❌<br />
錯誤，相同算法可能有不同優化方法。<br /></li>
<li>The algorithm does not move items more than one slot away in each round ❌<br />
錯誤，許多穩定排序（如 Merge Sort）在一次迭代中移動元素超過一格。<br /></li>
</ol></li>
<li>✅ 最終答案：B. The algorithm keeps the original order of items when the items are equal.<br /></li>
</ol></li>
<li><p>
In the following min heap, if we remove the minimal item 5 times, what would the two nodes with height 1 after the removals?<br />
(Diagram of a min heap)<br />
</p>
<pre class="example" id="orgf4258b1">
                  20
                /   \
               /     \
              /       \
             /         \
            /           \
           25            31
         /   \          /  \
        /     \        /    \
       50      40     51     39
      /  \    / \    /  \    /
    300  200 75  55 100 101 70
</pre>
<ol class="org-ol">
<li>25, 31<br /></li>
<li>50, 70<br /></li>
<li>75, 51<br /></li>
<li>75, 70<br /></li>
<li>答案：D. 75, 70<br /></li>
<li><p>
解析: 給定的 Min Heap<br />
</p>
<pre class="example" id="orgeb025a5">
                    20
                  /   \
                 /     \
                /       \
               /         \
              /           \
             25            31
           /   \          /  \
          /     \        /    \
         50      40     51     39
        /  \    / \    /  \    /
      300  200 75  55 100 101 70
</pre>
<ul class="org-ul">
<li>Min Heap 確保 父節點 ≤ 子節點。<br /></li>
</ul></li>
<li>每次刪除最小元素（根節點 20），需要 堆化（heapify） 來恢復 Min Heap 性質。<br /></li>
<li>步驟 1：移除 20<br />
<ul class="org-ul">
<li>新的根節點：70 取代 20<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>70 下沉（與 25 交換）<br /></li>
<li>25 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org0f501ea">
                       25
                     /   \
                    /     \
                   /       \
                  /         \
                 /           \
                70            31
              /   \          /  \
             /     \        /    \
            50      40     51     39
           /  \    / \    /  \    /
         300  200 75  55 100 101
</pre></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：移除 25<br />
<ul class="org-ul">
<li>55 取代 25<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>55 下沉（與 40 交換）<br /></li>
<li>40 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org25fa846">
                      40
                    /   \
                   /     \
                  /       \
                 /         \
                /           \
               70            31
             /   \          /  \
            /     \        /    \
           50      55     51     39
          /  \    / \    /  \    /
        300  200 75  20 100 101
</pre></li>
</ul></li>
<li>步驟 3：移除 40<br />
<ul class="org-ul">
<li>101 取代 40<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>101 下沉（與 39 交換）<br /></li>
<li>39 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org224edda">
                    39
                  /   \
                 /     \
                /       \
               /         \
              /           \
             70            31
           /   \          /  \
          /     \        /    \
         50      55     51     101
        /  \    / \    /  \
      300  200 75  20 100
</pre></li>
</ul></li>
<li><p>
步驟 4：移除 39<br />
</p>
<ul class="org-ul">
<li>100 取代 39<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>100 下沉（與 31 交換）<br /></li>
<li>31 成為新的根節點<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org96a8143">
                    31
                  /   \
                 /     \
                /       \
               /         \
              /           \
             70            100
           /   \          /  \
          /     \        /    \
         50      55     51     101
        /  \    / \
      300  200 75  20
</pre></li>
</ul></li>
<li><p>
步驟 5：移除 31<br />
</p>
<ul class="org-ul">
<li>20 取代 31<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>20 下沉（與 50 交換）<br /></li>
<li>50 成為新的根節點<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
最終堆狀態<br />
</p>
<pre class="example" id="orgeedadf6">
                     50
                   /   \
                  /     \
                 /       \
                /         \
               /           \
              70            100
            /   \          /  \
           /     \        /    \
          75      55     51     101
         /  \
       300  200
</pre></li>
</ul></li>

<li>最終樹中，高度 1（從根往下數 1 層） 的節點為 75 和 70<br /></li>
<li>✅ 答案：D. 75, 70<br /></li>
<li><p>
總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">步驟</td>
<td class="org-right">刪除節點</td>
<td class="org-right">新根</td>
<td class="org-left">重新堆化結果</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">70</td>
<td class="org-left">70 → 25</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">25</td>
<td class="org-right">55</td>
<td class="org-left">55 → 40</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">40</td>
<td class="org-right">101</td>
<td class="org-left">101 → 39</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">39</td>
<td class="org-right">100</td>
<td class="org-left">100 → 31</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">31</td>
<td class="org-right">20</td>
<td class="org-left">20 → 50</td>
</tr>

<tr>
<td class="org-right">最終結果</td>
<td class="org-right">根為 50</td>
<td class="org-right">高度 1 的節點：75, 70</td>
<td class="org-left">✅ 答案：D. 75, 70</td>
</tr>
</tbody>
</table></li>
<li>🚀 最終答案：D. 75, 70 🚀<br /></li>
</ol></li>
<li><p>
How many minimal spanning trees are in the following undirected graph?<br />
</p>

<div id="org329f873" class="figure">
<p><img src="images/林北的考前猜題/G.png" alt="G.png" width="500" /><br />
</p>
</div>
<pre class="example" id="orgb9fac2a">
    (Diagram of an undirected graph)
    {A, D} = 1
    {A, B} = 2
    {B, C} = 2
    {B, F} = 3
    {B, H} = 3
    {B, I} = 1
    {C, D} = 1
    {C, E} = 1
    {C, F} = 2
    {D, E} = 2
    {E, G} = 1
    {F, G} = 1
    {F, I} = 2
</pre>

<ol class="org-ol">
<li>2<br /></li>
<li>3<br /></li>
<li>4<br /></li>
<li>5<br /></li>
<li>答案：C. 4<br /></li>
<li><p>
解析: 我們使用 Kruskal’s Algorithm 來計算最小生成樹（MST），並找出 不同的 MST 數量。<br />
</p>
<ol class="org-ol">
<li><p>
步驟 1：列出邊的排序（按權重遞增）<br />
邊集（按權重排序）：<br />
</p>
<pre class="example" id="org4001c22">
         {A, D} = 1
         {B, I} = 1
         {C, D} = 1
         {C, E} = 1
         {E, G} = 1
         {F, G} = 1
         {A, B} = 2
         {B, C} = 2
         {C, F} = 2
         {D, E} = 2
         {F, I} = 2
         {B, F} = 3
         {B, H} = 3
</pre>
<ul class="org-ul">
<li>我們需要選擇邊，確保構成 最小生成樹（包含所有節點且不形成環）。<br /></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：使用 Kruskal’s Algorithm 建立 MST<br />
<ul class="org-ul">
<li>先選擇權重 1 的邊（6 條）： {A, D}, {B, I}, {C, D}, {C, E}, {E, G}, {F, G}<br /></li>
<li>再選擇權重 2 的邊（2 條）： {A, B}, {C, F}<br /></li>
<li>總共選擇 (N-1) = 8 條邊，形成一個最小生成樹（MST）。<br /></li>
</ul></li>
<li><p>
步驟 3：找出不同的 MST 數量<br />
</p>
<ul class="org-ul">
<li><p>
在 權重 2 的邊中，有不同的選擇：<br />
</p>
<pre class="example" id="orgc38aecf">
          {A, B}, {C, F}
          {A, B}, {D, E}
          {B, C}, {D, E}
          {B, C}, {F, I}
</pre></li>
</ul>
<ul class="org-ul">
<li>因此，我們可以構造 4 個不同的最小生成樹。<br /></li>
<li>✅ 最終答案：C. 4 🚀<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li><p>
What is the minimal number of nodes in an AVL tree with a height of 10?<br />
</p>
<ol class="org-ol">
<li>1023<br /></li>
<li>1024<br /></li>
<li>10<br /></li>
<li>9<br /></li>
<li>答案：D. 9<br /></li>
<li>解析: AVL 樹的性質<br />
<ul class="org-ul">
<li>AVL 樹是一種 自平衡二元搜索樹（BST），其中：<br /></li>
<li>左右子樹的高度差最多為 1（即 |height(left) - height(right)| ≤ 1）。<br /></li>
<li>目標是保持最低可能的節點數，以滿足 AVL 樹的高度平衡要求。<br /></li>
</ul></li>
<li>步驟 1：計算最少節點數<br />
<ul class="org-ul">
<li>我們使用一個遞推公式來求 AVL 樹的最少節點數：  N(h)=N(h−1)+N(h−2)+1<br /></li>
<li>其中：<br />
<ul class="org-ul">
<li>N(h) 是 高度為 h 的最少節點數。<br /></li>
<li>N(h-1) 和 N(h-2) 是其左右子樹的最少節點數。<br /></li>
</ul></li>
<li><p>
計算 N(h)<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">h (高度)</td>
<td class="org-right">最少節點數 N(h)N(h)</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">13</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">21</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">34</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">55</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">89</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">144</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：選擇最少節點數的選項<br />
<ul class="org-ul">
<li>選項 A. 1023 ❌ 錯誤（這是 滿二元樹（Full Binary Tree） 的節點數）。<br /></li>
<li>選項 B. 1024 ❌ 錯誤（這是 滿二元樹 的節點數）。<br /></li>
<li>選項 C. 10 ❌ 錯誤（不符合 AVL 樹的最小要求）。<br /></li>
<li>選項 D. 9 ✅ 正確！（最接近最小可能的節點數）。<br /></li>
</ul></li>
</ol>

<ul class="org-ul">
<li>結論<br />
<ul class="org-ul">
<li>✅ 最小的 AVL 樹，高度 10 的情況下，需要至少 9 個節點。<br /></li>
<li>✅ 正確答案：D. 9 🚀<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc419d53" class="outline-2">
<h2 id="orgc419d53"><span class="section-number-2">10.</span> 中山</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org9a4fe36" class="outline-3">
<h3 id="org9a4fe36"><span class="section-number-3">10.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>計算機概論與資料結構：這部分是歷年考題的重點，從101學年度到112學年度都有相關考題出現。內容涵蓋了基礎的程式碼分析、資料結構的應用與分析、演算法的時間複雜度分析、以及圖論相關的知識。例如，常出現的考題類型包括：<br /></li>
<li>程式碼追蹤：給定一段程式碼，要求判斷程式的輸出結果。<br /></li>
<li>資料結構操作：例如，樹的遍歷 (pre-order, in-order, post-order)，堆積 (heap) 的操作，以及圖的最小生成樹 (minimum spanning tree, MST) 的計算。<br /></li>
<li>演算法分析：例如，排序演算法 (merge sort, selection sort, bubble sort, quick sort, insertion sort) 的時間複雜度分析，以及各種搜尋演算法的應用。<br /></li>
<li>遞迴 (Recursion): 遞迴函數的編寫與分析，以及遞迴在程式碼中的應用.<br /></li>
<li>資料庫：這部分也常被納入考題，包括了 SQL 語法、正規化 (normalization)、以及關聯式資料庫的概念。近年來，也開始出現 NoSQL 資料庫的相關考題。<br /></li>
<li>網路：網路相關的考題也佔有一定比例，考題內容包括網路協定 (TCP/IP, UDP, ARP, HTTP, etc.)、IP 位址與子網路遮罩 (subnet mask) 的計算、以及無線網路技術 (WiMAX, LTE, WIFI)。<br /></li>
<li>作業系統：作業系統的考題內容包括行程管理 (process management)，記憶體管理 (memory management)，以及系統呼叫 (system call) 的概念。<br /></li>
<li>資訊管理：資訊管理方面的考題包括電子商務策略 (e-commerce strategy)、供應鏈管理 (supply chain management)、服務科學 (service science)、雲端運算 (cloud computing)、物聯網 (Internet of Things, IoT)、大數據 (big data)、以及資訊安全管理 (information security management)。此外，近年來也出現了關於區塊鏈 (blockchain)、人工智慧 (artificial intelligence, AI)、機器學習 (machine learning)、以及數位轉型 (digital transformation) 等新興技術的考題。<br /></li>
<li>其他：考題中也出現了一些較為分散的主題，如函數式編程 (functional programming)、軟體架構 (software architecture)、專案管理 (project management)、以及編譯程式 (compiler) 的步驟。<br /></li>
</ul>

<p>
總體而言，近十年的考題趨勢呈現出以下幾個特點：<br />
</p>
<ol class="org-ol">
<li>廣度增加：考題涵蓋的範圍越來越廣，除了傳統的計算機科學基礎知識外，也開始納入資訊管理、新興科技等相關知識。<br /></li>
<li>深度提升：考題不僅要求考生掌握基本概念，也要求考生具備分析問題、解決問題的能力。例如，對於演算法的時間複雜度分析，以及對於不同資料結構的應用情境分析，都是考題中常見的重點。<br /></li>
<li>實務導向：考題開始出現一些與實務相關的應用問題，例如，如何利用雲端運算提升企業競爭力，以及如何利用物聯網技術改善生活品質等。<br /></li>
<li>新興技術：近年來，區塊鏈、人工智慧、機器學習等新興技術成為熱門考題。<br /></li>
<li>跨領域整合：考題越來越強調跨領域知識的整合應用，例如，資訊管理與資訊科技的整合，或是資訊科技與商業應用的整合。<br /></li>
</ol>

<p>
準備考試時，建議考生：<br />
</p>
<ul class="org-ul">
<li>扎實掌握基礎知識：計算機概論、資料結構、演算法、資料庫、網路、作業系統等基礎知識，是所有考題的基礎。<br /></li>
<li>關注新興技術：除了基礎知識，也需要關注新興技術的發展，並了解其應用情境。<br /></li>
<li>練習歷屆考題：透過練習歷屆考題，可以了解考試的題型、出題方向，以及難易程度。<br /></li>
<li>加強英文能力：部分考題會以英文呈現，因此考生需具備一定的英文能力，才能順利應考。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf0ce578" class="outline-3">
<h3 id="orgf0ce578"><span class="section-number-3">10.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-10-2">
<p>
國立中山大學資訊管理學系碩士班入學考試模擬試題<br />
科目：計算機概論、資料結構與資訊管理<br />
</p>

<p>
作答說明：<br />
</p>
<ul class="org-ul">
<li>本試題分為選擇題與問答題，請仔細閱讀題目後作答。<br /></li>
<li>選擇題請於答案卡上劃記作答，問答題請於答案卷上作答。<br /></li>
<li>考試時間為 100 分鐘。<br /></li>
</ul>
</div>
<div id="outline-container-orgc8cdf9f" class="outline-4">
<h4 id="orgc8cdf9f"><span class="section-number-4">10.2.1.</span> 一、選擇題 (每題 3 分，共 60 分)</h4>
<div class="outline-text-4" id="text-10-2-1">
<ol class="org-ol">
<li>以下何者為非物件導向程式設計 (Object-Oriented Programming) 的特性？ (A) 繼承 (Inheritance) (B) 多型 (Polymorphism) (C) 封裝 (Encapsulation) (D) 遞迴 (Recursion)<br /></li>
<li>下列何者不屬於網路層 (Network Layer) 的協定？ (A) IP (B) TCP (C) ARP (D) ICMP<br /></li>
<li>在二元搜尋樹 (Binary Search Tree) 中，若要找出最小值，應該從哪個節點開始搜尋？ (A) 根節點 (Root Node) (B) 最右邊的節點 (Rightmost Node) (C) 最左邊的節點 (Leftmost Node) (D) 任何節點都可<br /></li>
<li>下列哪一種資料結構最常被用來實作深度優先搜尋 (Depth-First Search) 演算法？ (A) 堆疊 (Stack) (B) 佇列 (Queue) (C) 堆積 (Heap) (D) 鏈結串列 (Linked List)<br /></li>
<li>關於雲端運算 (Cloud Computing)，下列敘述何者為非？ (A) 是一種分散式運算環境。 (B) SaaS (軟體即服務) 是雲端運算的一種商業模式。 (C) IaaS (基礎設施即服務) 主要提供虛擬機器。 (D) 雲端運算適合用來處理小量資料的即時分析。<br /></li>
<li>以下哪一個選項是快排 (Quick Sort) 演算法最壞情況 (worst-case) 的時間複雜度？ (A) O(n) (B) O(n log n) (C) O(n^2) (D) O(log n)<br /></li>
<li>下列哪個選項是用來將網域名稱 (domain name) 對應到 IP 位址？ (A) 網域名稱系統 (DNS) (B) 位址解析協定 (ARP) (C) 傳輸控制協定 (TCP) (D) 使用者資料包協定 (UDP)<br /></li>
<li>一個迴圈程式碼如下：這題失敗，沒生出程式碼&#x2026;.<br /></li>
<li>請問執行完以上程式碼後，變數 w 的值是多少？ (A) 20 (B) 30 (C) 40 (D) 42<br /></li>
<li>在關聯式資料庫中，若一表格滿足第三正規化 (3NF)，則下列何者敘述錯誤？ (A) 每一個非主鍵屬性都必須完全相依於主鍵。 (B) 表格可能有多個候選鍵。 (C) 每一個非主鍵屬性都不能遞移相依於任何其他非主鍵屬性。 (D) 此表格必定也滿足 BCNF<br /></li>
<li>若要從頭到尾反向印出一個字串，最適合使用哪一種資料結構？ (A) 佇列 (Queue) (B) 堆疊 (Stack) (C) 二元搜尋樹 (Binary Search Tree) (D) 鏈結串列 (Linked List)<br /></li>
<li>下列何者為物聯網 (Internet of Things, IoT) 的應用範疇？ (A) 智慧家庭 (B) 工業自動化 (C) 智慧醫療 (D) 以上皆是<br /></li>
<li>關於區塊鏈 (Blockchain)，下列敘述何者正確？ (A) 區塊鏈上的資料可以隨意竄改。 (B) 區塊鏈是一種中心化的資料庫。 (C) 區塊鏈的特性包括去中心化、不可竄改、透明性。 (D) 比特幣 (Bitcoin) 是唯一使用區塊鏈技術的應用。<br /></li>
<li>下列哪一種機器學習 (Machine Learning) 演算法屬於監督式學習 (Supervised Learning)？ (A) K-means 分群法 (B) 支持向量機 (Support Vector Machine) (C) 主成分分析 (Principal Component Analysis) (D) 關聯規則學習 (Association Rule Learning)<br /></li>
<li>下列何者為非同步 (Asynchronous) 通訊的特性？ (A) 資料傳輸需要發送端和接收端的時脈同步。 (B) 資料傳輸不需要時脈信號。 (C) 資料傳輸前需要建立連線。 (D) 資料傳輸是同步進行的。<br /></li>
<li>以下哪一個選項不是大數據 (Big Data) 分析中常見的工具或框架？ (A) Apache Hadoop (B) Apache Spark (C) TensorFlow (D) MySQL<br /></li>
<li>若一系統使用 LRU (Least Recently Used) 分頁置換演算法，參考字串為 abgabdcabcad，且系統有三個可用頁框，請問會發生幾次 page fault？ (A) 9 (B) 10 (C) 11 (D) 12<br /></li>
<li>下列何者為 Deep Learning 常用的框架？ (A) TensorFlow (B) PyTorch (C) MXNet (D) 以上皆是<br /></li>
<li>下列哪一種資料結構不適合用於實現優先權佇列 (Priority Queue)？ (A) 堆積 (Heap) (B) 佇列 (Queue) (C) 二元搜尋樹 (Binary Search Tree) (D) 鏈結串列 (Linked List)<br /></li>
<li>下列哪一個選項是後序 (postfix) 運算式 A B + C D * - 的中序 (infix) 運算式？ (A) A + B - C * D (B) (A + B) - (C * D) (C) A + B - C * D (D) (A - C * D) + B<br /></li>
<li>以下何者不屬於常見的NoSQL 資料庫類型？ (A) 圖形資料庫 (Graph Database) (B) 文件資料庫 (Document Database) (C) 關聯式資料庫 (Relational Database) (D) 鍵值資料庫 (Key-Value Database)<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgf6a83e4" class="outline-4">
<h4 id="orgf6a83e4"><span class="section-number-4">10.2.2.</span> 二、問答題 (共 40 分)</h4>
<div class="outline-text-4" id="text-10-2-2">
<ol class="org-ol">
<li>請簡述 資訊安全管理系統 (Information Security Management System, ISMS) 的概念，並說明導入 ISMS 的六個主要階段。 (10 分)<br /></li>
<li>請解釋 網路效應 (Network Effect) 的概念，並舉例說明在平台經濟中，如何利用網路效應來提升競爭力。(10 分)<br /></li>
<li>請說明 人工智慧 (Artificial Intelligence) 、機器學習 (Machine Learning) 與 深度學習 (Deep Learning) 三者之間的關係，並舉例說明在資訊管理領域的應用。(10 分)<br /></li>
<li>請說明 虛擬整合 (Virtual Integration) 的概念，並舉例說明其在供應鏈管理中的應用，並分析其優缺點。(10 分)<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org8e952f4" class="outline-3">
<h3 id="org8e952f4"><span class="section-number-3">10.3.</span> 參考答案</h3>
<div class="outline-text-3" id="text-10-3">
</div>
<div id="outline-container-org4792dfa" class="outline-4">
<h4 id="org4792dfa"><span class="section-number-4">10.3.1.</span> 一、選擇題</h4>
<div class="outline-text-4" id="text-10-3-1">
<ol class="org-ol">
<li>(D) 遞迴是程式設計的一種技巧，不屬於物件導向程式設計的特性。<br /></li>
<li>(B) TCP 屬於傳輸層的協定。<br /></li>
<li>(C) 二元搜尋樹的最小值在最左邊的節點。<br /></li>
<li>(A) 堆疊具有後進先出 (LIFO) 的特性，適合用於深度優先搜尋。<br /></li>
<li>(D) 雲端運算適合用來處理大量的數據，而非小量數據的即時分析。<br /></li>
<li>(C) 快排演算法在最壞情況下的時間複雜度為 O(n^2)。<br /></li>
<li>(A) DNS 用於將網域名稱對應到 IP 位址。<br /></li>
<li>(A) w 的值為 2+4+6+8=20<br /></li>
<li>(D) 滿足 BCNF 一定滿足 3NF，但滿足 3NF 不一定滿足 BCNF<br /></li>
<li>(B) 堆疊具有後進先出的特性，適合用於反轉字串。<br /></li>
<li>(D) 物聯網可應用於智慧家庭、工業自動化、智慧醫療等領域。<br /></li>
<li>(C) 區塊鏈的核心特性為去中心化、不可竄改和透明性。<br /></li>
<li>(B) 支持向量機屬於監督式學習演算法。<br /></li>
<li>(B) 非同步通訊不需要時脈信號。<br /></li>
<li>(D) MySQL 是關聯式資料庫，不屬於大數據分析的框架。<br /></li>
<li>(A) 根據 LRU 演算法，會有 9 次 page fault。<br /></li>
<li>(D) TensorFlow, PyTorch, MXNet 皆為 Deep Learning 常用框架。<br /></li>
<li>(B) 佇列不適合用來實現優先權佇列，因其以先進先出方式取出元素。<br /></li>
<li>(B) 後序運算式 A B + C D * - 的中序運算式為 (A + B) - (C * D)<br /></li>
<li>(C) 關聯式資料庫屬於傳統資料庫，不屬於 NoSQL 資料庫。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org6028474" class="outline-4">
<h4 id="org6028474"><span class="section-number-4">10.3.2.</span> 二、問答題</h4>
<div class="outline-text-4" id="text-10-3-2">
<ol class="org-ol">
<li>資訊安全管理系統 (ISMS) 是一個系統化的方法，用來分析、評估和管理組織的資訊安全風險。它提供了一套流程和架構，幫助組織建立、實施、維護和改進資訊安全措施。導入 ISMS 的六個主要階段包括：<br />
<ul class="org-ul">
<li>規劃 (Planning)：確立 ISMS 的範圍、目標和政策。<br /></li>
<li>實施 (Implementation)：根據計畫執行資訊安全措施，包括建立控制機制、培訓員工等。<br /></li>
<li>檢查 (Checking)：定期檢查和評估資訊安全措施的有效性。<br /></li>
<li>行動 (Action)：根據檢查結果，進行改進和調整。<br /></li>
<li>監控 (Monitoring)：持續監控 ISMS 的運作狀況。<br /></li>
<li>審查 (Review)：定期審查 ISMS 的成效，並進行必要的更新和改進。<br /></li>
</ul></li>
<li>網路效應指的是當一個產品或服務的使用者增加時，其價值也會隨之增加的現象。簡單來說，用的人越多，這個產品或服務就越有價值。在平台經濟中，網路效應非常重要。例如：<br />
<ul class="org-ul">
<li>社群媒體平台：當越多使用者加入社群媒體平台時，此平台對使用者的吸引力就越大。因為使用者可以與更多人聯繫、分享資訊。<br /></li>
<li>電商平台：當越多商家在電商平台上販售商品時，此平台對消費者的吸引力就越大。因為消費者可以在此平台上找到更多選擇、比較商品。<br /></li>
<li>應用程式商店：當越多開發者在應用程式商店上架應用程式，此商店對使用者的吸引力就越大，使用者可以在此商店找到更多應用程式。<br /></li>
<li>共乘平台：當越多使用者在共乘平台上註冊，此平台對使用者就越方便，因為使用者可以更容易地找到汽車共享。 利用網路效應來提升競爭力的方式包括：<br /></li>
<li>早期採用者獎勵：鼓勵早期使用者加入平台，以觸發網路效應。<br /></li>
<li>策略性合作：與其他平台或服務合作，擴大網路效應的範圍。<br /></li>
<li>差異化競爭：提供獨特的服務或功能，吸引更多使用者。<br /></li>
</ul></li>
<li>人工智慧 (AI) 是一種廣泛的概念，指的是讓電腦執行通常需要人類智慧才能完成的任務。機器學習 (ML) 是實現人工智慧的一種方法，它讓電腦可以從數據中學習，而不需要明確的程式碼。深度學習 (DL) 則是機器學習的一種分支，它使用人工神經網路 (Artificial Neural Networks) 來學習複雜的模式。在資訊管理領域的應用包括：<br />
<ul class="org-ul">
<li>客戶關係管理 (CRM)：利用機器學習分析客戶數據，提供個人化的產品推薦。<br /></li>
<li>供應鏈管理 (SCM)：利用深度學習預測供應鏈風險，優化庫存管理。<br /></li>
<li>網路安全：利用機器學習偵測網路攻擊，保護企業資訊資產。<br /></li>
<li>商業分析：利用機器學習和深度學習分析大量數據，提供商業決策的依據。<br /></li>
<li>自然語言處理 (NLP)：利用自然語言處理技術分析顧客評論，提升客戶服務品質。<br /></li>
</ul></li>
<li><p>
虛擬整合 (Virtual Integration) 指的是企業在供應鏈中，不擁有實體資產或設施，而是透過資訊科技 (IT) 連結不同的供應鏈夥伴，形成一個整合的虛擬供應鏈網路。在供應鏈管理中的應用包括：<br />
</p>
<ul class="org-ul">
<li>協同產品設計：透過網路平台與供應商協同設計產品。<br /></li>
<li>即時庫存資訊：透過系統即時取得供應商的庫存資訊，減少自身庫存成本。<br /></li>
<li>協同需求預測：與供應商共享需求預測資訊，提高供應鏈效率。<br /></li>
<li>彈性生產：根據即時需求資訊，調整生產計畫。<br /></li>
<li>即時物流追蹤：透過網路系統追蹤物流，提供即時的貨物位置資訊<br /></li>
</ul>

<p>
優點：<br />
</p>
<ul class="org-ul">
<li>彈性高：可以快速調整供應鏈以應對市場變化。<br /></li>
<li>成本低：降低了擁有實體資產的成本。<br /></li>
<li>效率高：透過資訊科技提高供應鏈效率。<br /></li>
</ul>

<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>依賴資訊科技：過度依賴資訊系統，若系統故障，會影響供應鏈運作。<br /></li>
<li>信任風險：需要信任供應鏈夥伴，確保資訊透明度。<br /></li>
<li>資料安全：需要確保在合作中資料的安全性。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc72a2f8" class="outline-2">
<h2 id="orgc72a2f8"><span class="section-number-2">11.</span> 中興</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org22b2724" class="outline-3">
<h3 id="org22b2724"><span class="section-number-3">11.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-11-1">
</div>
<div id="outline-container-org7962cda" class="outline-4">
<h4 id="org7962cda"><span class="section-number-4">11.1.1.</span> 資料結構與演算法: 歷年考題中，資料結構與演算法是相當重要的部分。</h4>
<div class="outline-text-4" id="text-11-1-1">
<ul class="org-ul">
<li>常見的資料結構如linked list、binary tree、binary search tree、AVL tree、heap、hash table 等觀念頻繁出現。<br /></li>
<li>演算法部分，排序演算法如 insertion sort, selection sort, quick sort, merge sort, heap sort 都有被考過，binary search algorithm 也有出現。<br /></li>
<li>另外，圖論的 Floyd-Warshall algorithm 也曾出現。<br /></li>
<li>有些題目會要求寫出程式碼或是虛擬碼，來完成特定的操作，像是linked list的反轉或是計算特定範圍節點總和。<br /></li>
<li>Big-Oh 的時間複雜度分析 也會出現。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2a811ba" class="outline-4">
<h4 id="org2a811ba"><span class="section-number-4">11.1.2.</span> 程式設計:</h4>
<div class="outline-text-4" id="text-11-1-2">
<ul class="org-ul">
<li>會出現需要讀懂程式碼並寫出結果的題目，程式語言包含 C, Java, Python。<br /></li>
<li>程式設計的考題包含 遞迴，還有一些字串的操作。<br /></li>
<li>也會出現要求寫出函式 (function) 的題目，例如多項式相乘 、檢查質數 等。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4edf14a" class="outline-4">
<h4 id="org4edf14a"><span class="section-number-4">11.1.3.</span> 計算機組織與結構:</h4>
<div class="outline-text-4" id="text-11-1-3">
<ul class="org-ul">
<li>基本的計算機組成元件如 accumulator, program counter, memory, ALU 等觀念需要理解。<br /></li>
<li>一些概念，例如 buffer、direct memory access、interrupt 等也要了解。<br /></li>
<li>指令執行週期 (instruction cycle)也有被考到。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5bf7911" class="outline-4">
<h4 id="org5bf7911"><span class="section-number-4">11.1.4.</span> 作業系統:</h4>
<div class="outline-text-4" id="text-11-1-4">
<ul class="org-ul">
<li>考題中會出現 preemptive scheduling、non-preemptive scheduling 的觀念。<br /></li>
<li>paging 的觀念以及相關的計算也需要了解。<br /></li>
<li>多程式系統的記憶體管理也是重點。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0fb32a8" class="outline-4">
<h4 id="org0fb32a8"><span class="section-number-4">11.1.5.</span> 網路:</h4>
<div class="outline-text-4" id="text-11-1-5">
<ul class="org-ul">
<li>考題中會出現 OSI 模型。<br /></li>
<li>IPv4 相關的觀念如 datagram, fragmentation，還有網路設備的設定也需要了解。<br /></li>
<li>DHCP 的觀念也有被考到。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7c48f56" class="outline-4">
<h4 id="org7c48f56"><span class="section-number-4">11.1.6.</span> 資料庫:</h4>
<div class="outline-text-4" id="text-11-1-6">
<ul class="org-ul">
<li>考題中出現 關聯式資料庫 的 正規化 (normalization) 以及 SQL 語法 。<br /></li>
<li>NoSQL 資料庫也出現在考題中。<br /></li>
<li>Entity-relationship model 的觀念也需要了解。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf9b41ef" class="outline-4">
<h4 id="orgf9b41ef"><span class="section-number-4">11.1.7.</span> 軟體工程:</h4>
<div class="outline-text-4" id="text-11-1-7">
<ul class="org-ul">
<li>考題中出現 系統開發的生命週期，例如 訪談、原型開發。<br /></li>
<li>Use case 的使用 也需要理解。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2aafad9" class="outline-4">
<h4 id="org2aafad9"><span class="section-number-4">11.1.8.</span> 機器學習:</h4>
<div class="outline-text-4" id="text-11-1-8">
<ul class="org-ul">
<li>近年來開始出現關於機器學習的題目，例如 supervised learning, unsupervised learning, reinforcement learning。<br /></li>
<li>K-fold cross-validation 也會出現。<br /></li>
<li>神經網路 的相關題目也開始出現， 例如基本的神經網路架構 ，還有計算梯度下降 。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org888d623" class="outline-4">
<h4 id="org888d623"><span class="section-number-4">11.1.9.</span> 其他:</h4>
<div class="outline-text-4" id="text-11-1-9">
<ul class="org-ul">
<li>Turing test、Turing machine, Von Neumann architecture 也曾被考到。<br /></li>
<li>RSA 加密 也有出現。<br /></li>
<li>霍夫曼編碼 (Huffman code) 的觀念也需要了解。<br /></li>
<li>數字系統的轉換，例如 二進位、十進位、八進位、十六進位 之間的轉換 。<br /></li>
<li>二補數 的概念也需要理解。<br /></li>
<li>CAP theorem 也有被考到。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd9c31f7" class="outline-3">
<h3 id="orgd9c31f7"><span class="section-number-3">11.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-11-2">
</div>
<div id="outline-container-org5d9b08a" class="outline-4">
<h4 id="org5d9b08a"><span class="section-number-4">11.2.1.</span> 一、選擇題 (每題3分，共30分)</h4>
<div class="outline-text-4" id="text-11-2-1">
<ol class="org-ol">
<li>下列哪一個描述是錯誤的？ (A) 累加器 (Accumulator) 是一個暫存器，用來儲存算術和邏輯運算的結果。 (B) 程式計數器 (Program Counter) 指出程式中下一個要執行的指令位址。 (C) 直接記憶體存取 (Direct Memory Access, DMA) 允許周邊設備直接與記憶體傳輸數據，而不需要 CPU 的介入。 (D) 緩衝區 (Buffer) 是一種介面，用於兩個數據傳輸速度不同的設備之間，用來暫時儲存數據。 (E) 算術邏輯單元 (Arithmetic Logic Unit, ALU) 直接控制處理器的操作，並告知電腦的記憶體如何響應程式指令。<br /></li>
<li>下列哪一個排序演算法在最壞情況下的時間複雜度不是 O(n log n)? (A) 合併排序 (Merge Sort) (B) 快速排序 (Quick Sort) (C) 堆積排序 (Heap Sort) (D) 插入排序 (Insertion Sort) (E) 以上皆非<br /></li>
<li>在 OSI 模型 中，哪一層負責提供端對端的可靠傳輸？ (A) 網路層 (Network Layer) (B) 資料鏈路層 (Data Link Layer) (C) 傳輸層 (Transport Layer) (D) 會議層 (Session Layer) (E) 表達層 (Presentation Layer)<br /></li>
<li>下列哪一個不是 NoSQL 資料庫的類型？ (A) 鍵值對 (Key-value) 資料庫 (B) 文件 (Document) 資料庫 (C) 圖形 (Graph) 資料庫 (D) 關聯式 (Relational) 資料庫 (E) 寬列式 (Wide-column) 資料庫<br /></li>
<li>在 機器學習 中，下列哪一個問題最適合使用監督式學習 (Supervised Learning)？ (A) 找出顧客在零售市場中的區隔。 (B) 訓練一個 AI 機器人下棋。 (C) 將文章分類到不同的主題。 (D) 將一群顧客分成幾個群體。 (E) 在沒有標籤資料的情況下，找出數據的隱藏模式。<br /></li>
<li>若要利用 RSA 加密系統， 需先找到兩個質數 p 和 q，計算 n = p * q。 若 p = 5, q = 11, 則 n 為何？ (A) 16 (B) 45 (C) 55 (D) 65 (E) 99<br /></li>
<li>下列哪一個是 二元搜尋演算法 (binary search algorithm) 的限制？ (A) 需要使用排序過的陣列。 (B) 插入和刪除元素的花費較高。 (C) 必須有一個機制存取中間的元素。 (D) 不能應用於二元樹。 (E) 當數據量超過 1000 時，效率不高<br /></li>
<li>下列關於 CAP 定理 的敘述，何者為真？ (A) 分散式資料庫系統可以同時保證一致性 (Consistency)、可用性 (Availability) 和分割容錯性 (Partition tolerance)。 (B) 分散式資料庫系統只能保證一致性和可用性。 (C) 分散式資料庫系統只能保證一致性和分割容錯性。 (D) 分散式資料庫系統只能保證可用性和分割容錯性。 (E) 分散式資料庫系統只能保證一致性或可用性。<br /></li>
<li>下列哪一個是 Turing Test 的目標？ (A) 測試機器是否能執行複雜的計算。 (B) 測試機器是否能通過自然語言處理測試。 (C) 測試機器是否能模仿人類的智能。 (D) 測試機器是否能進行機器學習。 (E) 測試機器是否能夠解密。<br /></li>
<li>下列哪一個不是在系統開發的原型開發 (prototyping) 的優點？ (A) 作為使用者訓練的機制。 (B) 允許使用者嘗試操作軟體並了解其功能。 (C) 協助建立測試計畫和情境。 (D) 在發生高成本之前，協助確定系統的可用性和有用性。 (E) 使得計畫和排程更加容易。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org342bb8b" class="outline-4">
<h4 id="org342bb8b"><span class="section-number-4">11.2.2.</span> 二、簡答題 (每題10分，共40分)</h4>
<div class="outline-text-4" id="text-11-2-2">
<ol class="org-ol">
<li>請解釋分頁 (paging) 的觀念，以及它在多程式作業系統中如何運作。<br /></li>
<li>請寫出一個程式碼片段 (可以使用 C, Java, 或 Python)，來實作一個遞迴函式，計算 n! (n 階乘)。<br /></li>
<li>請說明梯度下降 (Gradient Descent) 在神經網路訓練中的作用，並簡述其步驟。<br /></li>
<li>請解釋 K-fold cross-validation 的概念，以及它如何應用在模型驗證上。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org5f06042" class="outline-4">
<h4 id="org5f06042"><span class="section-number-4">11.2.3.</span> 程式設計題 (每題15分，共30分)</h4>
<div class="outline-text-4" id="text-11-2-3">
<ol class="org-ol">
<li>給定一個 linked list 的頭節點 (head node)，請寫一個程式碼片段 (可以使用 C, Java, 或 Python) 來反轉這個 linked list。<br /></li>
<li>給定一個二元樹的前序 (preorder) 和中序 (inorder) 遍歷結果，請寫一個程式碼片段 (可以使用 C, Java, 或 Python) 來重建這個二元樹。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org35a9828" class="outline-3">
<h3 id="org35a9828"><span class="section-number-3">11.3.</span> 詳細解說答案</h3>
<div class="outline-text-3" id="text-11-3">
</div>
<div id="outline-container-org6f57726" class="outline-4">
<h4 id="org6f57726"><span class="section-number-4">11.3.1.</span> 一、選擇題</h4>
<div class="outline-text-4" id="text-11-3-1">
<ol class="org-ol">
<li>答案：(E)。 算術邏輯單元 (ALU) 負責執行算術和邏輯運算，但它並不直接控制處理器的所有操作，控制單元 (Control Unit) 才是負責控制處理器的操作並告知電腦記憶體如何響應程式指令。<br /></li>
<li>答案：(D)。插入排序在最壞情況下的時間複雜度是 O(n^2)，而合併排序、快速排序、堆積排序在最壞情況下的時間複雜度都是 O(n log n)。<br /></li>
<li>答案：(C)。 傳輸層 (Transport Layer) 負責提供端對端的可靠傳輸，例如 TCP 協定。<br /></li>
<li>答案：(D)。關聯式資料庫使用結構化的表格和 SQL 語言。 NoSQL 資料庫包括鍵值對、文件、圖形和寬列式資料庫。<br /></li>
<li>答案：(C)。將文章分類到不同的主題是一個典型的監督式學習問題，因為需要有標籤的數據來訓練模型。<br /></li>
<li>答案：(C)。 RSA 加密系統中，n = p * q = 5 * 11 = 55。<br /></li>
<li>答案：(A)。 二元搜尋演算法只能應用於已排序的數據。<br /></li>
<li>答案：(D)。 CAP 定理指出，分散式資料庫系統只能保證一致性、可用性和分割容錯性中的兩個。<br /></li>
<li>答案：(C)。 圖靈測試的目標是測試機器是否能夠模仿人類的智能。<br /></li>
<li>答案：(E)。原型開發的主要優點是能夠在早期階段發現問題，協助建立測試計畫，並評估系統的可用性和有用性。計畫和排程在原型開發的早期階段可能不夠完善。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgceead4f" class="outline-4">
<h4 id="orgceead4f"><span class="section-number-4">11.3.2.</span> 二、簡答題</h4>
<div class="outline-text-4" id="text-11-3-2">
<ol class="org-ol">
<li>分頁 (paging) 是一種記憶體管理技術，將邏輯記憶體分割成固定大小的區塊（稱為頁面），而物理記憶體也分割成相同大小的區塊（稱為頁框）。多程式作業系統使用分頁來允許每個程式使用非連續的記憶體空間。當程式執行時，作業系統會將程式的頁面載入到物理記憶體的頁框中，並使用分頁表來記錄邏輯地址到物理地址的映射。<br /></li>
<li><p>
以下為 Python 的程式碼範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>   <span style="color: #51afef;">def</span> <span style="color: #c678dd;">factorial</span>(n):
<span class="linenr">2: </span>       <span style="color: #51afef;">if</span> n == <span style="color: #da8548; font-weight: bold;">0</span>:
<span class="linenr">3: </span>           <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">4: </span>       <span style="color: #51afef;">else</span>:
<span class="linenr">5: </span>           <span style="color: #51afef;">return</span> n * factorial(n-<span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div></li>
<li>梯度下降 (Gradient Descent) 是一種優化演算法，用於訓練神經網路的權重。它通過迭代地調整權重，使得損失函數的值最小化。步驟如下：<br />
<ul class="org-ul">
<li>計算當前權重下損失函數的梯度。<br /></li>
<li>根據學習率和梯度，更新權重。<br /></li>
<li>重複以上步驟，直到損失函數收斂或達到迭代次數的上限。<br /></li>
</ul></li>
<li>K-fold cross-validation 是一種模型驗證技術，將數據集分成 K 個子集（稱為 fold）。然後，使用其中 K-1 個子集來訓練模型，並使用剩下的 1 個子集來驗證模型。重複這個過程 K 次，每次使用不同的子集作為驗證集。最後，平均 K 次驗證結果，以獲得更可靠的模型性能評估。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org2275fa1" class="outline-4">
<h4 id="org2275fa1"><span class="section-number-4">11.3.3.</span> 三、程式設計題</h4>
<div class="outline-text-4" id="text-11-3-3">
<ol class="org-ol">
<li><p>
以下為 Java 的程式碼範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>   <span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> ListNode {
<span class="linenr"> 2: </span>       <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">val</span>;
<span class="linenr"> 3: </span>       ListNode next;
<span class="linenr"> 4: </span>       ListNode(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) { val = x; }
<span class="linenr"> 5: </span>   }
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>   <span style="color: #51afef;">public</span> ListNode reverseList(ListNode head) {
<span class="linenr"> 8: </span>       ListNode prev = <span style="color: #a9a1e1;">null</span>;
<span class="linenr"> 9: </span>       ListNode current = head;
<span class="linenr">10: </span>       ListNode next = <span style="color: #a9a1e1;">null</span>;
<span class="linenr">11: </span>       <span style="color: #51afef;">while</span> (current != <span style="color: #a9a1e1;">null</span>) {
<span class="linenr">12: </span>           next = current.next;
<span class="linenr">13: </span>           current.next = prev;
<span class="linenr">14: </span>           prev = current;
<span class="linenr">15: </span>           current = next;
<span class="linenr">16: </span>       }
<span class="linenr">17: </span>       head = prev;
<span class="linenr">18: </span>       <span style="color: #51afef;">return</span> head;
<span class="linenr">19: </span>   }
</pre>
</div></li>
<li>以下為 Python 的程式碼範例：<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">TreeNode</span>:
<span class="linenr"> 2: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__init__</span>(<span style="color: #51afef;">self</span>, val):
<span class="linenr"> 3: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">val</span> = val
<span class="linenr"> 4: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">left</span> = <span style="color: #a9a1e1;">None</span>
<span class="linenr"> 5: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">right</span> = <span style="color: #a9a1e1;">None</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">buildTree</span>(preorder, inorder):
<span class="linenr"> 8: </span>    <span style="color: #51afef;">if</span> <span style="color: #51afef;">not</span> preorder <span style="color: #51afef;">or</span> <span style="color: #51afef;">not</span> inorder:
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">None</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #dcaeea;">root_val</span> = preorder
<span class="linenr">12: </span>    <span style="color: #dcaeea;">root</span> = TreeNode(root_val)
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #dcaeea;">root_index</span> = inorder.index(root_val)
<span class="linenr">15: </span>
<span class="linenr">16: </span>    root.<span style="color: #dcaeea;">left</span> = buildTree(preorder[<span style="color: #da8548; font-weight: bold;">1</span>:root_index+<span style="color: #da8548; font-weight: bold;">1</span>], inorder[:root_index])
<span class="linenr">17: </span>    root.<span style="color: #dcaeea;">right</span> = buildTree(preorder[root_index+<span style="color: #da8548; font-weight: bold;">1</span>:], inorder[root_index+<span style="color: #da8548; font-weight: bold;">1</span>:])
<span class="linenr">18: </span>
<span class="linenr">19: </span>    <span style="color: #51afef;">return</span> root
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org1354d3a" class="outline-2">
<h2 id="org1354d3a"><span class="section-number-2">12.</span> 清大</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-orgfd4b08c" class="outline-3">
<h3 id="orgfd4b08c"><span class="section-number-3">12.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-12-1">
<p>
以下是從這些考古題中觀察到的趨勢：<br />
</p>
</div>
<div id="outline-container-orgdbefb41" class="outline-4">
<h4 id="orgdbefb41"><span class="section-number-4">12.1.1.</span> 基本程式概念和資料結構：</h4>
<div class="outline-text-4" id="text-12-1-1">
<ul class="org-ul">
<li>遞迴：有多個題目都使用遞迴概念來解題，例如將十進制數字轉換為二進制。<br /></li>
<li>鏈結串列：考題中有要求反轉鏈結串列的實作。<br /></li>
<li>二元樹：有考題關於二元樹的儲存方式、遍歷以及二元搜尋樹的建立。<br /></li>
<li>堆疊：有題目要求使用堆疊來反轉相鄰的資料。<br /></li>
<li>佇列：有題目提到佇列的相關概念。<br /></li>
<li>雜湊表：有考題關於雜湊表的碰撞機率計算。<br /></li>
<li>前序式、後序式：有考題要求將前序式轉換為後序式。<br /></li>
<li>排序演算法：有提到排序演算法的相關概念，例如快速排序和合併排序。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org592fe08" class="outline-4">
<h4 id="org592fe08"><span class="section-number-4">12.1.2.</span> 計算機組織與結構：</h4>
<div class="outline-text-4" id="text-12-1-2">
<ul class="org-ul">
<li>浮點數表示法：考題中有關於浮點數的二進制表示法以及誤差計算。<br /></li>
<li>二補數：有題目探討二補數的表示範圍和加法運算。<br /></li>
<li>位元運算：有題目關於位元循環移位的操作。<br /></li>
<li>指令週期：有考題探討 CPU 的指令執行時間，包括有無 pipeline 的情況。<br /></li>
<li>快取記憶體：雖然沒有直接的考題，但在第 30 頁有提及快取記憶體（cache）的概念。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org94fc46c" class="outline-4">
<h4 id="org94fc46c"><span class="section-number-4">12.1.3.</span> 作業系統：</h4>
<div class="outline-text-4" id="text-12-1-3">
<ul class="org-ul">
<li>核心：有考題詢問作業系統核心的主要組成部分和功能，以及核心如何從使用者程式奪回控制權。<br /></li>
<li>行程和工作佇列：考題中有關於作業系統中工作佇列和行程佇列的內容。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4bebcd4" class="outline-4">
<h4 id="org4bebcd4"><span class="section-number-4">12.1.4.</span> 網路：</h4>
<div class="outline-text-4" id="text-12-1-4">
<ul class="org-ul">
<li>TCP/UDP：有題目比較 TCP 和 UDP 的服務差異，以及 TCP 如何偵測網路擁塞。<br /></li>
<li>網路層：有考題詢問網路軟體的層級和功能。<br /></li>
<li>CSMA/CD：有考題說明 CSMA/CD 的功能與運作原理。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgecc0886" class="outline-4">
<h4 id="orgecc0886"><span class="section-number-4">12.1.5.</span> 演算法分析：</h4>
<div class="outline-text-4" id="text-12-1-5">
<ul class="org-ul">
<li>時間複雜度：有題目要求分析程式的時間複雜度，並使用 big-O 符號表示。<br /></li>
<li>遞迴關係式：考題中有遞迴關係式的分析。<br /></li>
<li>圖論：有考題關於圖的頂點覆蓋問題和最小生成樹演算法，以及歐拉路徑的概念。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf00c89c" class="outline-4">
<h4 id="orgf00c89c"><span class="section-number-4">12.1.6.</span> 其他：</h4>
<div class="outline-text-4" id="text-12-1-6">
<ul class="org-ul">
<li>圖靈機：有題目要求設計圖靈機來執行減值操作。<br /></li>
<li>錯誤更正碼：有題目關於錯誤更正碼的偵測和修正能力。<br /></li>
<li>開源/閉源軟體：有考題詢問開源和閉源軟體的差異，並舉例說明。<br /></li>
<li>邊界值分析：考題中有關於使用邊界值分析進行測試的題目。<br /></li>
<li>生產系統：有題目要求將一個問題以生產系統的狀態和規則描述。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd4612df" class="outline-4">
<h4 id="orgd4612df"><span class="section-number-4">12.1.7.</span> 數學概念：</h4>
<div class="outline-text-4" id="text-12-1-7">
<ul class="org-ul">
<li>機率：有考題計算雜湊碰撞的機率。<br /></li>
<li>幾何：有題目要求計算平面上的反射點。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4fc1889" class="outline-3">
<h3 id="org4fc1889"><span class="section-number-3">12.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-12-2">
<p>
清華大學資訊工程學系 113 學年度「計算機概論」模擬試題<br />
考試時間：100 分鐘<br />
總分：100 分<br />
</p>
</div>
<div id="outline-container-org91bff10" class="outline-4">
<h4 id="org91bff10"><span class="section-number-4">12.2.1.</span> 1. 程式設計與資料結構 (30 分)</h4>
<div class="outline-text-4" id="text-12-2-1">
</div>
<div id="outline-container-org4ef598f" class="outline-5">
<h5 id="org4ef598f">(a) 遞迴與迭代 (10%)：</h5>
<div class="outline-text-5" id="text-org4ef598f">
<p>
請使用遞迴和迭代兩種方式，實作一個函數來計算費氏數列的第 n 項 (Fibonacci sequence)。並分析這兩種方式的時間複雜度。<br />
</p>
</div>
</div>
<div id="outline-container-orgdbae22c" class="outline-5">
<h5 id="orgdbae22c">(b) 鏈結串列操作 (10%)：</h5>
<div class="outline-text-5" id="text-orgdbae22c">
<p>
給定一個單向鏈結串列的頭節點，請實作一個函數來判斷此鏈結串列是否為迴文 (palindrome)。請分析你的演算法的時間複雜度。 (c) 二元樹與搜尋 (10%)：給定一個二元搜尋樹 (BST)，請實作一個函數來找出樹中第 k 小的元素。請分析你的演算法的時間複雜度，並解釋如何應用中序走訪 (inorder traversal)。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3c985fb" class="outline-4">
<h4 id="org3c985fb"><span class="section-number-4">12.2.2.</span> 2. 計算機組織與結構 (25 分)</h4>
<div class="outline-text-4" id="text-12-2-2">
</div>
<div id="outline-container-orgbc58a72" class="outline-5">
<h5 id="orgbc58a72">(a) 浮點數表示法 (10%)：</h5>
<div class="outline-text-5" id="text-orgbc58a72">
<p>
假設有一個 10 位元的浮點數表示法，其中 1 位元為符號位元，5 位元為指數 (excess-15 表示法)，4 位元為尾數。請將十進制數字 -5.625 轉換為此浮點數表示法。並討論此表示法的最大和最小可表示數字。<br />
</p>
</div>
</div>
<div id="outline-container-org56b36b5" class="outline-5">
<h5 id="org56b36b5">(b) 記憶體階層 (10%)：</h5>
<div class="outline-text-5" id="text-org56b36b5">
<p>
請說明快取記憶體 (cache memory) 的運作原理，並解釋快取記憶體如何提高記憶體存取速度。請比較直接映射 (direct mapping) 和集合關聯 (set-associative) 快取之間的差異。<br />
</p>
</div>
</div>
<div id="outline-container-org30d2d64" class="outline-5">
<h5 id="org30d2d64">(c) 指令集架構 (5%)：</h5>
<div class="outline-text-5" id="text-org30d2d64">
<p>
簡述 RISC (精簡指令集計算機) 和 CISC (複雜指令集計算機) 的主要差異，並各舉一個例子說明。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb9fc270" class="outline-4">
<h4 id="orgb9fc270"><span class="section-number-4">12.2.3.</span> 3. 作業系統與網路 (25 分)</h4>
<div class="outline-text-4" id="text-12-2-3">
</div>
<div id="outline-container-orga066b21" class="outline-5">
<h5 id="orga066b21">(a) 行程管理 (10%)：</h5>
<div class="outline-text-5" id="text-orga066b21">
<p>
請解釋作業系統中的行程 (process) 和執行緒 (thread) 的概念，並比較它們之間的差異。說明行程排程演算法 (例如：FCFS, SJF, Round Robin) 的目的。<br />
</p>
</div>
</div>
<div id="outline-container-org1f4e54e" class="outline-5">
<h5 id="org1f4e54e">(b) 網路協定 (10%)：</h5>
<div class="outline-text-5" id="text-org1f4e54e">
<p>
請說明 TCP 三次握手 (three-way handshake) 的過程，並解釋為什麼需要這個過程。比較 TCP 和 UDP 在可靠性、速度和應用場景上的差異。<br />
</p>
</div>
</div>
<div id="outline-container-org84104ff" class="outline-5">
<h5 id="org84104ff">(c) 雲端運算 (5%)：</h5>
<div class="outline-text-5" id="text-org84104ff">
<p>
簡述雲端運算 (cloud computing) 的基本概念，並說明 IaaS (基礎設施即服務)、PaaS (平台即服務) 和 SaaS (軟體即服務) 的差異。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4ac586e" class="outline-4">
<h4 id="org4ac586e"><span class="section-number-4">12.2.4.</span> 4. 演算法與新興技術 (20 分)</h4>
<div class="outline-text-4" id="text-12-2-4">
</div>
<div id="outline-container-org4e8863b" class="outline-5">
<h5 id="org4e8863b">(a) 圖論演算法 (10%)：</h5>
<div class="outline-text-5" id="text-org4e8863b">
<p>
給定一個加權無向圖，請使用 Dijkstra 演算法找出從起點到所有其他節點的最短路徑。請解釋 Dijkstra 演算法的原理，並說明其時間複雜度。<br />
</p>
</div>
</div>
<div id="outline-container-orgaef1394" class="outline-5">
<h5 id="orgaef1394">(b) 機器學習基礎 (10%)：</h5>
<div class="outline-text-5" id="text-orgaef1394">
<p>
簡述機器學習 (machine learning) 中監督式學習 (supervised learning) 和非監督式學習 (unsupervised learning) 的概念，並各舉一個實際應用的例子。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1f97b0e" class="outline-3">
<h3 id="org1f97b0e"><span class="section-number-3">12.3.</span> 詳細解答：</h3>
<div class="outline-text-3" id="text-12-3">
</div>
<div id="outline-container-org6c002ae" class="outline-4">
<h4 id="org6c002ae"><span class="section-number-4">12.3.1.</span> 1. 程式設計與資料結構</h4>
<div class="outline-text-4" id="text-12-3-1">
</div>
<div id="outline-container-org2fdfa78" class="outline-5">
<h5 id="org2fdfa78">(a) 遞迴與迭代</h5>
<div class="outline-text-5" id="text-org2fdfa78">
</div>
<ul class="org-ul">
<li><a id="org98e5c5d"></a>遞迴： cpp<br />
<div class="outline-text-6" id="text-org98e5c5d">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fib_recursive</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">2: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr">3: </span>  <span style="color: #51afef;">return</span> fib_recursive(n - <span style="color: #da8548; font-weight: bold;">1</span>) + fib_recursive(n - <span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr">4: </span>}
</pre>
</div>
<p>
時間複雜度為 O(2^n)，因為每個呼叫都會產生兩個新的呼叫。<br />
</p>
</div>
</li>
<li><a id="org93ef91a"></a>迭代： cpp<br />
<div class="outline-text-6" id="text-org93ef91a">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fib_iterative</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr"> 2: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr"> 3: </span>  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">prev</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">curr</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 4: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">2</span>; i &lt;= n; i++) {
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">next</span> = prev + curr;
<span class="linenr"> 6: </span>    prev = curr;
<span class="linenr"> 7: </span>    curr = next;
<span class="linenr"> 8: </span>  }
<span class="linenr"> 9: </span>  <span style="color: #51afef;">return</span> curr;
<span class="linenr">10: </span>}
</pre>
</div>
<p>
時間複雜度為 O(n)，因為只遍歷一次迴圈。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3bba981" class="outline-5">
<h5 id="org3bba981">(b) 鏈結串列操作</h5>
<div class="outline-text-5" id="text-org3bba981">
<ul class="org-ul">
<li>將鏈結串列複製一份並反轉，然後比較反轉後的鏈結串列是否與原鏈結串列相同。 * 可以使用快慢指針找到鏈結串列的中點，然後反轉後一半的鏈結串列，再與前半部比較。<br /></li>
<li>時間複雜度：O(n)，需走訪鏈結串列一次。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org37cfcb7" class="outline-5">
<h5 id="org37cfcb7">(c) 二元樹與搜尋</h5>
<div class="outline-text-5" id="text-org37cfcb7">
<ul class="org-ul">
<li>使用中序走訪 (inorder traversal) 可以按照排序順序訪問二元搜尋樹的所有節點。<br /></li>
<li>使用一個計數器追蹤走訪的節點數，當計數器等於 k 時，返回當前節點的值。<br /></li>
<li>時間複雜度：O(n) 最差情況下需要走訪所有節點。平均情況下為 O(k)，如果樹平衡良好，則可以在 O(h) 的時間找到，h是樹的高度。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb2b14bf" class="outline-4">
<h4 id="orgb2b14bf"><span class="section-number-4">12.3.2.</span> 2. 計算機組織與結構</h4>
<div class="outline-text-4" id="text-12-3-2">
</div>
<div id="outline-container-org4ed1c6f" class="outline-5">
<h5 id="org4ed1c6f">(a) 浮點數表示法</h5>
<div class="outline-text-5" id="text-org4ed1c6f">
<ul class="org-ul">
<li>-5.625 的二進制表示為 -101.101。<br /></li>
<li>將其標準化為 -1.01101 x 2^2。<br /></li>
<li>符號位元：1 (負數)<br /></li>
<li>指數：2 + 15 = 17，二進制為 10001<br /></li>
<li>尾數：01101 (取小數部分，不足補 0)<br /></li>
<li>因此，表示為 1 10001 0110。<br /></li>
<li>最大可表示數字：約為 (1.1111) 2^15<br /></li>
<li>最小可表示數字：約為 (1.0000) 2^-15<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7afe81e" class="outline-5">
<h5 id="org7afe81e">(b) 記憶體階層</h5>
<div class="outline-text-5" id="text-org7afe81e">
<ul class="org-ul">
<li>快取記憶體是一個小而快的記憶體，用於儲存經常存取的資料，以減少 CPU 從主記憶體讀取資料的時間。 * 直接映射快取：每個主記憶體區塊只能映射到快取中的一個特定位置。<br /></li>
<li>集合關聯快取：每個主記憶體區塊可以映射到快取中多個特定位置的集合，提供更高的靈活性和較低的碰撞率。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc7c5e00" class="outline-5">
<h5 id="orgc7c5e00">(c) 指令集架構</h5>
<div class="outline-text-5" id="text-orgc7c5e00">
<ul class="org-ul">
<li>RISC：指令集簡化，指令長度固定，硬體實現簡單，執行速度快。例如：ARM。<br /></li>
<li>CISC：指令集複雜，指令長度不固定，硬體實現複雜，功能強大。例如：Intel x86。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3192008" class="outline-4">
<h4 id="org3192008"><span class="section-number-4">12.3.3.</span> 3. 作業系統與網路</h4>
<div class="outline-text-4" id="text-12-3-3">
</div>
<div id="outline-container-orgebb806a" class="outline-5">
<h5 id="orgebb806a">(a) 行程管理</h5>
<div class="outline-text-5" id="text-orgebb806a">
<ul class="org-ul">
<li>行程：程式執行時的實例，包含程式碼、資料、堆疊、和程式計數器等資源，是作業系統進行資源分配和調度的基本單位。<br /></li>
<li>執行緒：行程內的一個執行單元，多個執行緒共享同一行程的資源，因此執行緒間的切換比行程切換快。<br /></li>
<li>行程排程演算法：<br />
<ul class="org-ul">
<li>FCFS (First Come First Served)：先到先服務，依據行程到達的先後順序執行。<br /></li>
<li>SJF (Shortest Job First)：最短工作優先，優先執行所需時間最短的行程。<br /></li>
<li>Round Robin：循環排程，每個行程執行一段時間後，輪流執行下一個行程。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcb56e11" class="outline-5">
<h5 id="orgcb56e11">(b) 網路協定</h5>
<div class="outline-text-5" id="text-orgcb56e11">
<ul class="org-ul">
<li><p>
TCP 三次握手：<br />
</p>
<ol class="org-ol">
<li>客戶端發送 SYN 封包到伺服器。<br /></li>
<li>伺服器收到 SYN 後，回覆 SYN-ACK 封包給客戶端。<br /></li>
<li>客戶端收到 SYN-ACK 後，發送 ACK 封包給伺服器。<br /></li>
</ol>
<p>
此過程用於建立可靠的 TCP 連線，並協商雙方初始序列號。<br />
</p></li>
<li>TCP：可靠傳輸、面向連線、有流量控制和擁塞控制。適用於檔案傳輸、網頁瀏覽。<br /></li>
<li>UDP：不可靠傳輸、無連線、速度快，但沒有流量控制。適用於串流媒體、線上遊戲。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org8a7da43" class="outline-5">
<h5 id="org8a7da43">(c) 雲端運算</h5>
<div class="outline-text-5" id="text-org8a7da43">
<ul class="org-ul">
<li>雲端運算：通過網路提供可擴展的計算資源。<br /></li>
<li>IaaS：提供虛擬機、儲存和網路等基礎設施，用戶需自行管理作業系統和應用程式。<br /></li>
<li>PaaS：提供開發平台和工具，用戶可在此平台上開發和部署應用程式。<br /></li>
<li>SaaS：提供現成的應用軟體，用戶直接使用即可。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd11f478" class="outline-4">
<h4 id="orgd11f478"><span class="section-number-4">12.3.4.</span> 4. 演算法與新興技術</h4>
<div class="outline-text-4" id="text-12-3-4">
</div>
<div id="outline-container-org7709c29" class="outline-5">
<h5 id="org7709c29">(a) 圖論演算法</h5>
<div class="outline-text-5" id="text-org7709c29">
<ul class="org-ul">
<li>Dijkstra 演算法：從起點開始，維護一個最短路徑集合，並逐步擴展到其他節點，直到找到所有節點的最短路徑。<br /></li>
<li>時間複雜度：O(E log V)，其中 E 為邊的數量，V 為頂點的數量。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc9d63ab" class="outline-5">
<h5 id="orgc9d63ab">(b) 機器學習基礎</h5>
<div class="outline-text-5" id="text-orgc9d63ab">
<ul class="org-ul">
<li>監督式學習：使用標記過的資料進行訓練，讓模型學習從輸入到輸出的對應關係。例如：圖像分類、語音辨識。<br /></li>
<li>非監督式學習：使用未標記的資料進行訓練，讓模型自行找出資料中的模式和結構。例如：分群、降維。<br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcfae4b5" class="outline-2">
<h2 id="orgcfae4b5"><span class="section-number-2">13.</span> 成大</h2>
<div class="outline-text-2" id="text-13">
</div>
<div id="outline-container-orgeb64d58" class="outline-3">
<h3 id="orgeb64d58"><span class="section-number-3">13.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org01b625d" class="outline-3">
<h3 id="org01b625d"><span class="section-number-3">13.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-org7d313df" class="outline-2">
<h2 id="org7d313df"><span class="section-number-2">14.</span> 中央</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-org954572d" class="outline-3">
<h3 id="org954572d"><span class="section-number-3">14.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org964ce68" class="outline-3">
<h3 id="org964ce68"><span class="section-number-3">14.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-orgdd4eb3e" class="outline-2">
<h2 id="orgdd4eb3e"><span class="section-number-2">15.</span> 北大</h2>
<div class="outline-text-2" id="text-15">
</div>
<div id="outline-container-orgd5e4a67" class="outline-3">
<h3 id="orgd5e4a67"><span class="section-number-3">15.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org8f938eb" class="outline-3">
<h3 id="org8f938eb"><span class="section-number-3">15.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-org813de06" class="outline-2">
<h2 id="org813de06"><span class="section-number-2">16.</span> 林北的考前猜題</h2>
<div class="outline-text-2" id="text-16">
</div>
<div id="outline-container-org98e2e2f" class="outline-3">
<h3 id="org98e2e2f"><span class="section-number-3">16.1.</span> 網路</h3>
<div class="outline-text-3" id="text-16-1">
</div>
<div id="outline-container-org93e0d76" class="outline-4">
<h4 id="org93e0d76"><span class="section-number-4">16.1.1.</span> 簡單的概念知識</h4>
<div class="outline-text-4" id="text-16-1-1">
<p>
看這章：<a href="https://data.slhs.tp.edu.tw/shien/bcc/download/book/C221A1_ch14.pdf">https://data.slhs.tp.edu.tw/shien/bcc/download/book/C221A1_ch14.pdf</a><br />
</p>
<ul class="org-ul">
<li>ISO的OSI(網路七層): 14-1<br /></li>
<li>TCP/IP: 14-2<br /></li>
<li>WIFI, 藍芽, RFID, NFC: 14-3<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5616d55" class="outline-4">
<h4 id="org5616d55"><span class="section-number-4">16.1.2.</span> 如何計算IP位址與網路遮罩</h4>
<div class="outline-text-4" id="text-16-1-2">
</div>
<div id="outline-container-org5b98079" class="outline-5">
<h5 id="org5b98079">IP的等級</h5>
<div class="outline-text-5" id="text-org5b98079">
<ul class="org-ul">
<li>IP(例如8.8.8.8)分為A,B,C三級<br /></li>
<li>每一組IP都是一個 8-bit 的二進位數字,﹐每組數字為一個“octet”﹐合共起來就是一個 32-bit 的 IP 位址﹐亦即是 IP v4 (Version 4) 版本的位址<br /></li>
<li>所以 8.8.8.8 的完整二進位格式是：00001000.00001000.00001000.00001000<br /></li>
<li>128.10.20.30 的二進位格式是：10000000.00001010.00010100.00011110<br /></li>
<li>192.168.1.1 的二進位格式是：11000000.10101000.00000001.00000001<br /></li>
<li>上面三個IP分別是A,B,C級網路IP<br /></li>
<li>可以由二進位來判斷一個IP是哪一級：<br />
<ul class="org-ul">
<li>如果是以“0”開頭的﹐這是一個 A Class的 IP<br /></li>
<li>如果是以“10”開頭的﹐這是一個 B Class的 IP<br /></li>
<li>如果是以“110”為開頭的﹐則屬於 C Class的 IP<br /></li>
</ul></li>
<li>也可以死記﹕<br />
<ul class="org-ul">
<li>由 1 到 126 開頭的 IP 是 A Class<br /></li>
<li>由 128 到 191開頭的 IP是 B Class<br /></li>
<li>由 192 到 223 開頭的則為 C Class<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd818670" class="outline-5">
<h5 id="orgd818670">不同等級的網路，差異在於這組網路有多少可用IP</h5>
<div class="outline-text-5" id="text-orgd818670">
<ul class="org-ul">
<li>A,B,C級網路的可用IP(可以用算的 C級的254=2^16 - 2, 原因看底下)<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">等級</th>
<th scope="col" class="org-right">開首</th>
<th scope="col" class="org-left">網路數目</th>
<th scope="col" class="org-left">主機數目</th>
<th scope="col" class="org-left">使用範圍</th>
<th scope="col" class="org-left">申請領域</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">0</td>
<td class="org-left">127</td>
<td class="org-left">16,777,214</td>
<td class="org-left">1.x.x.x 到 126.x.x.x</td>
<td class="org-left">國家級</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">10</td>
<td class="org-left">16,384</td>
<td class="org-left">65,534</td>
<td class="org-left">128.x.x.x 到 191.x.x.x</td>
<td class="org-left">跨國組織</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-right">110</td>
<td class="org-left">2,097,152</td>
<td class="org-left">254</td>
<td class="org-left">192.x.x.x 到 223.x.x.x</td>
<td class="org-left">企業組織</td>
</tr>

<tr>
<td class="org-left">D</td>
<td class="org-right">1110</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">224.- 到 239.-</td>
<td class="org-left">特殊用途</td>
</tr>

<tr>
<td class="org-left">E</td>
<td class="org-right">1111</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">240.- 到 255.-</td>
<td class="org-left">保留範圍</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li><p>
IP 的 Net_ID 和 Host_ID﹕<br />
</p>
<ul class="org-ul">
<li>A Class 的 IP 使用最前面一組數字來做 Net ID﹐其余三組做 Host ID<br /></li>
<li>B Class 的 IP 使用前面兩組數字來做 Net ID﹐另兩組做 Host ID<br /></li>
<li>C Class 的 IP 使用前面三組數字來做 Net ID﹐剩下的一組做 Host ID<br /></li>
</ul>
<p>
如下圖<br />
</p>

<div id="org16d01b4" class="figure">
<p><img src="images/林北的考前猜題/2025-01-27_17-20-33_ip1.png" alt="2025-01-27_17-20-33_ip1.png" width="500" /><br />
</p>
</div></li>
<li>後面的Host ID就是這組網路能用的IP，例如C級網路前面的Net ID是固定的，所以能用的就只有後面的Host ID, 0 - 255<br /></li>
<li>例如，南一中分配到的一組網路ID是210.70.137,<br />
<ul class="org-ul">
<li>預設的子網路遮罩就是255.255.255.0<br /></li>
<li>我們能用的IP就是210.70.137.0 - 210.70.137.255,共256個<br /></li>
<li>但是要扣掉兩組IP, 所以剩254個能用<br />
<ul class="org-ul">
<li>網路 ID：210.70.137.0<br /></li>
<li>廣播地址：210.70.137.255<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org757ef2d" class="outline-5">
<h5 id="org757ef2d">IP與NetMask</h5>
<div class="outline-text-5" id="text-org757ef2d">
<ul class="org-ul">
<li>因為IP位址分為主機和網路號碼，所以在Internet的網路上找尋電腦時，我們需要先找到網路號碼，然後在子網路中找到目的地的主機，所以電腦IP位址的設定除了IP位址外，另一個重要的號碼就是子網路遮罩。<br /></li>
<li>「子網路遮罩」(Subnet Mask)是一個固定的值，在電腦的定址計算中是使用子網路遮罩的值將IP位址分為網路號碼和主機號碼，子網路遮罩的值依網路等級的預設值，如下所示：<br />
<ul class="org-ul">
<li>Class A：255.0.0.0<br /></li>
<li>Class B：255.255.0.0<br /></li>
<li>Class C：255.255.255.0<br /></li>
</ul></li>
<li>簡單的說255的二進位值能夠遮掉IP位址中的網路號碼，經過運算後剩下的就是主機號碼，如此可以識別IP位址所屬的網路。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org17ae51c" class="outline-5">
<h5 id="org17ae51c">網路分割(分成兩個)</h5>
<div class="outline-text-5" id="text-org17ae51c">
<ul class="org-ul">
<li>可以透過NetMask來把一個網路切成兩個或更多<br /></li>
<li><p>
例如把一個C級網路切成兩個，分給電個學校，這樣就不能用預設的netmask 255.255.255.0<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">子網</th>
<th scope="col" class="org-right">網路 ID</th>
<th scope="col" class="org-right">廣播地址</th>
<th scope="col" class="org-left">可用 IP 範圍</th>
<th scope="col" class="org-right">子網掩碼</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">子網 1</td>
<td class="org-right">210.70.137.0</td>
<td class="org-right">210.70.137.127</td>
<td class="org-left">210.70.137.1 ~ 210.70.137.126</td>
<td class="org-right">255.255.255.128</td>
</tr>

<tr>
<td class="org-left">子網 2</td>
<td class="org-right">210.70.137.128</td>
<td class="org-right">210.70.137.255</td>
<td class="org-left">210.70.137.129 ~ 210.70.137.254</td>
<td class="org-right">255.255.255.128</td>
</tr>
</tbody>
</table></li>
<li>之後這個C級網路就會變成以下兩個子網路，可以分配給兩個學校<br />
<ul class="org-ul">
<li>子網 1：210.70.137.0/25<br /></li>
<li>子網 2：210.70.137.128/25<br /></li>
<li>25的意思是netmask有25個1(11111111.11111111.11111111.10000000)<br /></li>
<li>沒分割的C級網路netmask預設是24(11111111.11111111.11111111.00000000)<br /></li>
</ul></li>
<li>每分割一次，就會損失掉兩個IP（第一個和最後一個IP位址是保留作為特殊的用途, 第一個位址代表的是Network ID, 最後一個位址代表的是廣播位址), 所以分割越細浪費越多IP<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org349e4f8" class="outline-5">
<h5 id="org349e4f8">分成4個</h5>
<div class="outline-text-5" id="text-org349e4f8">
<ul class="org-ul">
<li><p>
將 210.70.137.0/24 分成 4 個子網後的分配如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">子網</th>
<th scope="col" class="org-right">網路 ID</th>
<th scope="col" class="org-right">廣播地址</th>
<th scope="col" class="org-left">可用 IP 範圍</th>
<th scope="col" class="org-right">子網掩碼</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">子網 1</td>
<td class="org-right">210.70.137.0</td>
<td class="org-right">210.70.137.63</td>
<td class="org-left">210.70.137.1 ~ 210.70.137.62</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 2</td>
<td class="org-right">210.70.137.64</td>
<td class="org-right">210.70.137.127</td>
<td class="org-left">210.70.137.65 ~ 210.70.137.126</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 3</td>
<td class="org-right">210.70.137.128</td>
<td class="org-right">210.70.137.191</td>
<td class="org-left">210.70.137.129 ~ 210.70.137.190</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 4</td>
<td class="org-right">210.70.137.192</td>
<td class="org-right">210.70.137.255</td>
<td class="org-left">210.70.137.193 ~ 210.70.137.254</td>
<td class="org-right">255.255.255.192</td>
</tr>
</tbody>
</table></li>
<li>之後這個C級網路就會變成以下4個子網路，可以分配給兩個學校<br />
<ul class="org-ul">
<li>子網 1：210.70.137.1 ~ 210.70.137.62<br /></li>
<li>子網 2：210.70.137.65 ~ 210.70.137.126<br /></li>
<li>子網 3：210.70.137.129 ~ 210.70.137.190<br /></li>
<li>子網 4：210.70.137.193 ~ 210.70.137.254<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdd3c726" class="outline-5">
<h5 id="orgdd3c726">公共 IP&ldquo; 與 &rdquo;私有 IP"</h5>
<div class="outline-text-5" id="text-orgdd3c726">
<ul class="org-ul">
<li>一個學校分配一個C級網路一定不夠用，我們學校光電腦教室用掉的IP就有300個，怎麼辦？<br /></li>
<li>在 A﹑B﹑C 這三個層級裡面﹐各劃出一些位址範圍保留給私有位址所用﹐它們分別是﹕<br />
<ul class="org-ul">
<li>10.0.0.0 - 10.255.255.255<br /></li>
<li>172.16.0.0 - 172.31.255.255<br /></li>
<li>192.168.0.0 - 192.168.255.255<br /></li>
</ul></li>
<li>像中華電信其實只分配一個IP給我們家，那為什麼家裡每台電腦、手機都能用WIFI上網，原因就是都用這種virtual ip<br /></li>
<li>使用virtual IP必須要配合NAT( NAT &#x2014; Network Addresss Translation)<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgd4cd1df"></a>NAT運作原理<br />
<div class="outline-text-6" id="text-orgd4cd1df">
<p>
NAT 是路由器實現的技術，用於解決內部多台設備共用一個公網 IP 的問題。工作流程：<br />
</p>
<ol class="org-ol">
<li>內部設備請求上網：你的電腦（私網 IP：192.168.1.100）想訪問 Google（例如 IP 為 142.250.190.46）。請求會發送到路由器。<br /></li>
<li>路由器轉換請求：路由器會用它的公網 IP（例如 123.45.67.89）替換電腦的私網 IP，並將請求轉發到 Google。<br /></li>
<li>路由器保存對應關係：路由器會記錄內部設備的私網 IP 和使用的連接埠（Port）。例如：<br />
<ul class="org-ul">
<li>內部 IP:Port -&gt; 公網 IP:Port<br /></li>
<li>192.168.1.100:54321 -&gt; 123.45.67.89:54321<br /></li>
</ul></li>
<li>回應轉發：當 Google 的回應到達你的公網 IP 時，路由器會根據對應關係將回應轉發給正確的內部設備（如 192.168.1.100）。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9a51f3f" class="outline-5">
<h5 id="org9a51f3f">DHCP</h5>
<div class="outline-text-5" id="text-org9a51f3f">
<ul class="org-ul">
<li>家裡的每台電腦或手機為什麼不用自己設定IP就能上網？<br /></li>
<li>路由器通常啟用 DHCP（動態主機配置協議），自動給每台設備分配私網 IP。這樣你家裡的電腦、手機都會獲得唯一的內部 IP。<br /></li>
<li>範例：假設路由器的 IP 是 192.168.1.1，你的設備可能分配到：<br />
<ul class="org-ul">
<li>電腦：192.168.1.100<br /></li>
<li>手機：192.168.1.101<br /></li>
<li>平板：192.168.1.102<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8c269f8" class="outline-4">
<h4 id="org8c269f8"><span class="section-number-4">16.1.3.</span> 靜態路由與動態路由協定（如 RIP, OSPF, BGP）</h4>
<div class="outline-text-4" id="text-16-1-3">
<p>
靜態路由和動態路由是網路中管理路由表的兩種不同方法，它們決定數據包在不同網段之間的傳輸方式。這兩種方法有著不同的特點和應用場景。下面介紹靜態路由以及常見的動態路由協定（如RIP、OSPF、BGP）的概念和特性。<br />
</p>
</div>
<div id="outline-container-orgc0117fa" class="outline-5">
<h5 id="orgc0117fa">靜態路由（Static Routing）</h5>
<div class="outline-text-5" id="text-orgc0117fa">
<p>
靜態路由是指網路管理員手動在路由器上配置的路由條目。這些條目指示數據包通往特定目標網段的路由，並且在路由表中是固定不變的，直到手動更改。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2b2a946"></a>特點:<br />
<div class="outline-text-6" id="text-org2b2a946">
<ul class="org-ul">
<li>手動配置：管理員必須手動指定每條路由，包括目標網路和下一跳路由器的IP地址。<br /></li>
<li>適用於小型網路：靜態路由適用於網絡拓撲變化較小的場景，如小型或封閉的網路環境。<br /></li>
<li>高效但不靈活：靜態路由不消耗網路資源，但當網路拓撲發生變化時（例如，某個路由器失效或網段更改），需要手動調整配置，否則會導致路由失效。<br /></li>
<li>安全性高：由於手動配置，沒有意外的路由改變，因此在某些環境下更具安全性。<br /></li>
</ul>
</div>
</li>
<li><a id="orge14a5d5"></a>優點:<br />
<div class="outline-text-6" id="text-orge14a5d5">
<ul class="org-ul">
<li>控制力強，路由選擇完全由管理員掌控。<br /></li>
<li>不會產生路由更新的開銷，節省網路資源。<br /></li>
</ul>
</div>
</li>
<li><a id="org69fdebe"></a>缺點:<br />
<div class="outline-text-6" id="text-org69fdebe">
<ul class="org-ul">
<li>當網路規模變大或拓撲頻繁變動時，手動配置和維護的成本高。<br /></li>
<li>無法自動調整和應對網路故障或變化。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org0d3b533" class="outline-5">
<h5 id="org0d3b533">動態路由（Dynamic Routing）</h5>
<div class="outline-text-5" id="text-org0d3b533">
<p>
動態路由依靠路由協定自動學習和維護網路的路由表，能夠自動調整以應對網路變化。動態路由協定根據特定的算法來確定最佳路徑，並定期與鄰居路由器交換路由信息。以下是常見的動態路由協定。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org36a9cb8"></a>RIP（Routing Information Protocol）<br />
<div class="outline-text-6" id="text-org36a9cb8">
<p>
RIP是最早期的動態路由協定之一，基於距離向量算法來選擇路由。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgc54dea6"></a>工作原理：<br />
<div class="outline-text-7" id="text-orgc54dea6">
<p>
RIP基於「跳數」來選擇路由，最多允許15跳（即路由器數量）來到達目標網路。RIP會定期（每30秒）向鄰近的路由器通告其路由表，並選擇跳數最少的路徑。<br />
</p>
</div>
</li>
<li><a id="org64df0d9"></a>版本：<br />
<div class="outline-text-7" id="text-org64df0d9">
<ul class="org-ul">
<li>RIPv1：不支持子網遮罩，路由表只包括網段地址，不適合無類別域間路由選擇（CIDR）。<br /></li>
<li>RIPv2：改進了對CIDR的支持，並且增加了多播傳輸和身份驗證功能。<br /></li>
</ul>
</div>
</li>
<li><a id="org6a9106f"></a>優點：<br />
<div class="outline-text-7" id="text-org6a9106f">
<ul class="org-ul">
<li>易於配置和維護，適用於小型網路。<br /></li>
</ul>
</div>
</li>
<li><a id="org7016593"></a>缺點：<br />
<div class="outline-text-7" id="text-org7016593">
<ul class="org-ul">
<li>跳數限制（最多15跳）使其不適合大型網路。<br /></li>
<li>更新過於頻繁（每30秒）可能導致帶寬浪費。<br /></li>
<li>收斂速度慢（路由表更新和調整所需時間較長）。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgfa22308"></a>OSPF（Open Shortest Path First）<br />
<div class="outline-text-6" id="text-orgfa22308">
<p>
OSPF是一種基於鏈路狀態算法的動態路由協定，被廣泛應用於中大型網路環境中。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgfb8b499"></a>工作原理<br />
<div class="outline-text-7" id="text-orgfb8b499">
<ul class="org-ul">
<li>OSPF通過鏈路狀態廣播（LSA）在整個網路內通告網段狀況，並使用Dijkstra的最短路徑優先算法來計算最佳路徑。每個路由器會維護一個完整的網路拓撲圖，並計算出到其他網段的最短路徑。<br /></li>
</ul>
</div>
</li>
<li><a id="org8251708"></a>特點：<br />
<div class="outline-text-7" id="text-org8251708">
<ul class="org-ul">
<li>支持無類別域間路由選擇（CIDR），允許靈活的子網劃分。<br /></li>
<li>收斂速度快：當網路拓撲發生變化時，OSPF能快速響應和調整路由。<br /></li>
<li>能根據網段的成本（如帶寬、延遲等）來選擇最佳路徑，而不是僅依賴跳數。<br /></li>
<li>支持分層設計：可將網路劃分為多個區域（Area），有助於減少網路更新的範圍，提升網路的可擴展性。<br /></li>
</ul>
</div>
</li>
<li><a id="org414e725"></a>優點：<br />
<div class="outline-text-7" id="text-org414e725">
<ul class="org-ul">
<li>收斂速度快，適合大型網路。<br /></li>
<li>支持多路徑負載均衡。<br /></li>
</ul>
</div>
</li>
<li><a id="org8181d88"></a>缺點：<br />
<div class="outline-text-7" id="text-org8181d88">
<ul class="org-ul">
<li>計算拓撲圖和維護路由表的過程較為複雜，對硬體資源要求較高。<br /></li>
<li>配置比RIP更複雜，需要更高的技術水平。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orge936de6"></a>BGP（Border Gateway Protocol）<br />
<div class="outline-text-6" id="text-orge936de6">
<p>
BGP是一種路由向量協定，廣泛應用於互聯網的自治系統（AS，Autonomous Systems）之間的路由選擇。它主要負責互聯網骨幹網中的路由決策。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org59f3907"></a>工作原理<br />
<div class="outline-text-7" id="text-org59f3907">
<p>
BGP主要用於交換自治系統之間的路由信息，每個AS由一個或多個BGP路由器組成，這些路由器相互通告其可達的網段。BGP根據多種路徑屬性（如路徑長度、AS數量等）來選擇最佳路徑，而不是僅依賴跳數。<br />
</p>
<ul class="org-ul">
<li>內部BGP（iBGP）：用於同一自治系統內的路由器之間的路由選擇。<br /></li>
<li>外部BGP（eBGP）：用於不同自治系統之間的路由選擇。<br /></li>
</ul>
</div>
</li>
<li><a id="org9142027"></a>特點：<br />
<div class="outline-text-7" id="text-org9142027">
<ul class="org-ul">
<li>可擴展性強：BGP能夠處理大型網路環境，支持數百萬個路由條目，是互聯網上自治系統之間的首選路由協定。<br /></li>
<li>靈活的路由選擇機制：BGP不僅考慮路由長度，還能根據政策和策略來選擇路徑。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd89be92"></a>優點：<br />
<div class="outline-text-7" id="text-orgd89be92">
<ul class="org-ul">
<li>BGP在處理跨多個自治系統的網路連接方面非常強大。<br /></li>
<li>支持路由策略和策略性路由選擇，適用於ISP和大型企業。<br /></li>
</ul>
</div>
</li>
<li><a id="orge8edce3"></a>缺點：<br />
<div class="outline-text-7" id="text-orge8edce3">
<ul class="org-ul">
<li>配置和維護非常複雜，適合高級網路工程師。<br /></li>
<li>收斂速度相對較慢，這在大規模變動的環境中可能成為一個問題。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org22a264c" class="outline-5">
<h5 id="org22a264c">總結</h5>
<div class="outline-text-5" id="text-org22a264c">
<ul class="org-ul">
<li>靜態路由：適合小型、簡單網路，優點是配置靈活且控制精確，缺點是需要手動維護，且無法自動應對網路變化。<br /></li>
<li>動態路由：動態路由協定（如RIP、OSPF、BGP）適合中大型網路，能夠根據網路變化自動調整路由。RIP適合小型網路，OSPF適合企業內部路由，BGP則是跨自治系統的標準協定，負責處理大規模互聯網路徑選擇。<br /></li>
</ul>
<p>
兩者結合使用，可以在提升網路效率和靈活性的同時，確保部分關鍵流量路徑的穩定和安全。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org67e94c8" class="outline-3">
<h3 id="org67e94c8"><span class="section-number-3">16.2.</span> 資料庫</h3>
<div class="outline-text-3" id="text-16-2">
</div>
<div id="outline-container-orgece0cc7" class="outline-4">
<h4 id="orgece0cc7"><span class="section-number-4">16.2.1.</span> NoSQL v.s. RDBM</h4>
<div class="outline-text-4" id="text-16-2-1">
</div>
<div id="outline-container-org2877c43" class="outline-5">
<h5 id="org2877c43">關聯式資料庫(RDBMS, Relational Database Management System)</h5>
<div class="outline-text-5" id="text-org2877c43">
<p>
資料以資料表(table)的形式存在資料庫中，資料表之間有事先定義的關係，資料表中的一欄(column)代表某項屬性、一列(row)代表一個實體相關屬性的數值，每個資料表都具有主鍵(primary key)方便查詢，並且資料表間的關係可以透過外鍵(foreign key)建立。<br />
</p>

<div id="org6515d21" class="figure">
<p><img src="images/林北的考前猜題/2025-01-28_12-43-42_1*hsMO1oCL5d1US9LcRztT-Q.png" alt="2025-01-28_12-43-42_1*hsMO1oCL5d1US9LcRztT-Q.png" width="500" /><br />
</p>
</div>
</div>
<ul class="org-ul">
<li><a id="orgca9e651"></a>RDBMS的優點<br />
<div class="outline-text-6" id="text-orgca9e651">
<ul class="org-ul">
<li>有ACID的特性，ACID 代表不可分割性 、一致性、獨立性和耐用性。 具有ACID 屬性的事務可確保資料庫操作的正確且可預測的執行，從而改善分析結果，最終有助於企業做出更明智的決策。<br />
<ol class="org-ol">
<li>不可分割性 (Atomic):交易必須整體成功執行，若是交易有一部分操作失敗，整個交易都會失效<br /></li>
<li>一致性 (Consistent)：做為交易的一部分寫入資料庫的資料，必須遵守所有明定規則以及約束<br /></li>
<li>獨立性 (Isolated)：達成並行控制的重要關鍵，可以確保每一個交易都是獨立的<br /></li>
<li>耐用性 (Durable)：在一個交易成功完成後，對資料庫所做的變更都是永久性的<br /></li>
</ol></li>
<li>不可分割性 (Atomic):交易必須整體成功執行，若是交易有一部分操作失敗，整個交易都會失效<br /></li>
<li>一致性 (Consistent)：做為交易的一部分寫入資料庫的資料，必須遵守所有明定規則以及約束<br /></li>
<li>獨立性 (Isolated)：達成並行控制的重要關鍵，可以確保每一個交易都是獨立的<br /></li>
<li>耐用性 (Durable)：在一個交易成功完成後，對資料庫所做的變更都是永久性的<br /></li>
<li>查詢複雜性：可以透過SQL語法，進行較複雜的查詢<br /></li>
<li>語言標準化:不像NoSQL各種資料庫有各自的操作語法，RDBMS都可使用SQL(Structured Querying Language)語言進行資料查詢與管理。<br /></li>
<li>資料庫正規化<br /></li>
<li>安全性高<br /></li>
</ul>
</div>
</li>
<li><a id="orgef65aff"></a>DBMS的缺點<br />
<div class="outline-text-6" id="text-orgef65aff">
<ul class="org-ul">
<li>橫向擴展能力低，透過垂直擴展比較能發揮優勢，但是成本較高。<br />
<ol class="org-ol">
<li>橫向擴展(Horizontal Scaling)可以想像成增加機器的數量，用不同的機器進行同一個服務，除了減緩單一機器的負擔，也可以避免當單一機器故障時，整個服務就無法使用的狀況。<br /></li>
<li>垂直擴展(Vertical Scaling)在現有的硬體上進行升級，例如升級CPU、增加RAM等。<br /></li>
</ol></li>
<li>儲存與維護成本高<br /></li>
<li>速度較慢，尤其當資料量龐大或多人同時使用服務的時候<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org884d9f0" class="outline-5">
<h5 id="org884d9f0">非關聯式資料庫(NoSQL, Not only SQL)</h5>
<div class="outline-text-5" id="text-org884d9f0">
<ul class="org-ul">
<li>不同於SQL系統，NoSQL中的資料儲存不需要定義schema、也沒有固定架構，不保證ACID的特性，常用於分散式雲端系統。<br /></li>
<li><p>
典型的NOSQL如下列的JSON（JavaScript Object Notation）:<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>[
<span class="linenr"> 2: </span>   {
<span class="linenr"> 3: </span>       <span style="color: #98be65;">"year"</span> : <span style="color: #da8548; font-weight: bold;">2013</span>,
<span class="linenr"> 4: </span>       <span style="color: #98be65;">"title"</span> : <span style="color: #98be65;">"Turn It Down, Or Else!"</span>,
<span class="linenr"> 5: </span>       <span style="color: #98be65;">"info"</span> : {
<span class="linenr"> 6: </span>           <span style="color: #98be65;">"directors"</span> : [ <span style="color: #98be65;">"Alice Smith"</span>, <span style="color: #98be65;">"Bob Jones"</span>],
<span class="linenr"> 7: </span>           <span style="color: #98be65;">"release_date"</span> : <span style="color: #98be65;">"2013-01-18T00:00:00Z"</span>,
<span class="linenr"> 8: </span>           <span style="color: #98be65;">"rating"</span> : <span style="color: #da8548; font-weight: bold;">6.2</span>,
<span class="linenr"> 9: </span>           <span style="color: #98be65;">"genres"</span> : [<span style="color: #98be65;">"Comedy"</span>, <span style="color: #98be65;">"Drama"</span>],
<span class="linenr">10: </span>           <span style="color: #98be65;">"image_url"</span> : <span style="color: #98be65;">"http://ia.media-imdb.com/images/N/O9ERWAU7FS797AJ7LU8HN09AMUP908RLlo5JF90EWR7LJKQ7@@._V1_SX400_.jpg"</span>,
<span class="linenr">11: </span>           <span style="color: #98be65;">"plot"</span> : <span style="color: #98be65;">"A rock band plays their music at high volumes, annoying the neighbors."</span>,
<span class="linenr">12: </span>           <span style="color: #98be65;">"actors"</span> : [<span style="color: #98be65;">"David Matthewman"</span>, <span style="color: #98be65;">"Jonathan G. Neff"</span>]
<span class="linenr">13: </span>       }
<span class="linenr">14: </span>   },
<span class="linenr">15: </span>   {
<span class="linenr">16: </span>       <span style="color: #98be65;">"year"</span>: <span style="color: #da8548; font-weight: bold;">2015</span>,
<span class="linenr">17: </span>       <span style="color: #98be65;">"title"</span>: <span style="color: #98be65;">"The Big New Movie"</span>,
<span class="linenr">18: </span>       <span style="color: #98be65;">"info"</span>: {
<span class="linenr">19: </span>           <span style="color: #98be65;">"plot"</span>: <span style="color: #98be65;">"Nothing happens at all."</span>,
<span class="linenr">20: </span>           <span style="color: #98be65;">"rating"</span>: <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">21: </span>       }
<span class="linenr">22: </span>   }
<span class="linenr">23: </span>]
</pre>
</div></li>
<li>你有看到NOSQL如何儲存二進位的資料（圖片）嗎？很簡單，就是只存網址，這樣一來，圖片、影片這種資料就不用全部存在資料庫中，可以存放在其他檔案伺服器裡，不只彈性大，而且也可以降低資料庫伺服器的網路頻寬負擔，因為客戶在存取圖片或影片時可以由其他檔案伺服器去抓資料。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org1dc85f1"></a>NoSQL的優點<br />
<div class="outline-text-6" id="text-org1dc85f1">
<ul class="org-ul">
<li>橫向擴展能力佳 (Scalability):不必增加伺服器來擴大規模，可以透過分散式架構提供服務，以橫向擴展(Horizontal Scaling)的方式增加效能。<br /></li>
<li>彈性較高 (Flexibility)：NoSQL不像關聯式資料庫需要schema，可以隨意定義資料模型，因此NoSQL可以處理無特定結構或半結構式(semi-structured)的資料<br /></li>
<li>速度優勢：因為NoSQL不包含資料關聯性，查詢速度相對較快。<br /></li>
</ul>
</div>
</li>
<li><a id="org4263a57"></a>NoSQL的缺點<br />
<div class="outline-text-6" id="text-org4263a57">
<ul class="org-ul">
<li>資料完整度:不同於關聯式資料庫通常遵循ACID原則 (atomicity, consistency, isolation, durability)以確保資料的完整度，NoSQL較難提供ACID的保證，而是遵循BASE(basic availability, soft state, and eventual consistency) 的原則，並且可能犧牲資料的完整度。<br /></li>
<li>語言標準化:不像關聯式資料庫大多可以使用SQL語言操作，NoSQL不同的資料庫有各自獨特的語言來管理資料。<br /></li>
<li>查詢複雜性：NoSQL針對單一表格的查詢效果佳，但當資料複雜度增加，使用RDBMS的效果會更好。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org3d57707" class="outline-4">
<h4 id="org3d57707"><span class="section-number-4">16.2.2.</span> JSON</h4>
<div class="outline-text-4" id="text-16-2-2">
<p>
JSON是一種基於文本的數據交換格式，源於JavaScript語言，但已被許多其他編程語言所支持。由於其簡單、易讀的語法和跨平台的兼容性，JSON成為了Web開發中廣泛使用的數據格式，尤其適用於API和AJAX應用。<br />
</p>
</div>
</div>
<div id="outline-container-org280f26d" class="outline-4">
<h4 id="org280f26d"><span class="section-number-4">16.2.3.</span> 雲端資料庫</h4>
</div>
<div id="outline-container-orga8709b8" class="outline-4">
<h4 id="orga8709b8"><span class="section-number-4">16.2.4.</span> Entity-relationship model</h4>
</div>
</div>
<div id="outline-container-orgf30dd4b" class="outline-3">
<h3 id="orgf30dd4b"><span class="section-number-3">16.3.</span> 軟體工程</h3>
<div class="outline-text-3" id="text-16-3">
</div>
<div id="outline-container-org646101c" class="outline-4">
<h4 id="org646101c"><span class="section-number-4">16.3.1.</span> Unit Test</h4>
</div>
</div>
<div id="outline-container-org24840b5" class="outline-3">
<h3 id="org24840b5"><span class="section-number-3">16.4.</span> AI</h3>
<div class="outline-text-3" id="text-16-4">
</div>
<div id="outline-container-orgd1b2828" class="outline-4">
<h4 id="orgd1b2828"><span class="section-number-4">16.4.1.</span> Turing Machine</h4>
</div>
<div id="outline-container-org856388d" class="outline-4">
<h4 id="org856388d"><span class="section-number-4">16.4.2.</span> Turing Test</h4>
</div>
<div id="outline-container-org14e94e3" class="outline-4">
<h4 id="org14e94e3"><span class="section-number-4">16.4.3.</span> Cloud Computing</h4>
</div>
<div id="outline-container-org615b1de" class="outline-4">
<h4 id="org615b1de"><span class="section-number-4">16.4.4.</span> Iot</h4>
</div>
<div id="outline-container-orge2c958e" class="outline-4">
<h4 id="orge2c958e"><span class="section-number-4">16.4.5.</span> supervised learning, unsupervised learning, reinforcement learning。</h4>
</div>
<div id="outline-container-org5e5e70f" class="outline-4">
<h4 id="org5e5e70f"><span class="section-number-4">16.4.6.</span> 計算梯度下降</h4>
</div>
</div>
<div id="outline-container-org3267b86" class="outline-3">
<h3 id="org3267b86"><span class="section-number-3">16.5.</span> 資管</h3>
<div class="outline-text-3" id="text-16-5">
</div>
<div id="outline-container-orgcd816da" class="outline-4">
<h4 id="orgcd816da"><span class="section-number-4">16.5.1.</span> Information security management</h4>
</div>
</div>
<div id="outline-container-org7b8b5b7" class="outline-3">
<h3 id="org7b8b5b7"><span class="section-number-3">16.6.</span> 其他</h3>
<div class="outline-text-3" id="text-16-6">
</div>
<div id="outline-container-org374a283" class="outline-4">
<h4 id="org374a283"><span class="section-number-4">16.6.1.</span> 區塊鏈</h4>
</div>
<div id="outline-container-orgcaac7bf" class="outline-4">
<h4 id="orgcaac7bf"><span class="section-number-4">16.6.2.</span> RSA 加密</h4>
</div>
<div id="outline-container-org8feb37b" class="outline-4">
<h4 id="org8feb37b"><span class="section-number-4">16.6.3.</span> 開源/閉源軟體</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Yung-Chin Yen</p>
<p class="date">Created: 2025-02-10 Mon 23:29</p>
</div>
</body>
</html>
