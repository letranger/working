<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-01-29 Wed 00:59 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>James Exam</title>
<meta name="author" content="Yung-Chin Yen" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/muse.css" />
<script src="../css/copy_code.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">James Exam</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgdf3d162">1. 中山近三年考題及詳解</a></li>
<li><a href="#orgd503f1c">2. 中山</a></li>
<li><a href="#orgdc612d7">3. 中興</a></li>
<li><a href="#orgcc13b9a">4. 清大</a></li>
<li><a href="#org9cd3f92">5. 成大</a></li>
<li><a href="#org1ff9937">6. 中央</a></li>
<li><a href="#org53b088e">7. 北大</a></li>
<li><a href="#org33e9a81">8. 林北的考前猜題</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgdf3d162" class="outline-2">
<h2 id="orgdf3d162"><span class="section-number-2">1.</span> 中山近三年考題及詳解</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org1ca0bf1" class="outline-3">
<h3 id="org1ca0bf1"><span class="section-number-3">1.1.</span> 110 - 國立中山大學 110 學年度 碩士暨碩士專班招生考試試題</h3>
<div class="outline-text-3" id="text-1-1">
<p>
科目名稱：管理資訊系統 【資管系碩士班甲組】 題號：442003<br />
※本科目依簡章規定「不可以」使用計算機 (問答申論題) 共 1 頁 第 1 頁<br />
</p>
</div>
<div id="outline-container-org984cddd" class="outline-4">
<h4 id="org984cddd"><span class="section-number-4">1.1.1.</span> 1. 人工智慧(Artificial Intelligence)是近年來相當受到注目的資訊發展，而其中的發展理論可以分為兩大學派，分別為法則學派(Rule-based Approach)與機器學習學派(Machine Learning Approach)。</h4>
<div class="outline-text-4" id="text-1-1-1">
</div>
<div id="outline-container-org41b1855" class="outline-5">
<h5 id="org41b1855">(1)機器學習學派有四種不同類型，分別為非監督式學習(Unsupervised)、半監督式學習(Semi-supervised)、監督式學習(Supervised)與增強式學習(Reinforcements Learning)，試說明這四種不同類型，並舉例說明之。<code>[12%]</code></h5>
<div class="outline-text-5" id="text-org41b1855">
</div>
<ul class="org-ul">
<li><a id="org25d536b"></a>解答<br />
<div class="outline-text-6" id="text-org25d536b">
<ol class="org-ol">
<li>非監督式學習 (Unsupervised Learning): 此類學習的特點是沒有標籤的數據，模型需要自行從數據中找出模式或結構。例如：分群算法 (clustering) 可以將數據分為不同的組別，但事先並不知道這些組別的意義。<br /></li>
<li>半監督式學習 (Semi-supervised Learning): 此類學習使用部分標籤的數據來訓練模型。它介於監督式學習和非監督式學之間，利用少量標籤數據來輔助訓練，提高模型的泛化能力。<br /></li>
<li>監督式學習 (Supervised Learning): 此類學習使用標籤數據來訓練模型，讓模型學習輸入和輸出之間的關係。例如：分類 (classification) 和迴歸 (regression) 問題都屬於監督式學習的範疇。<br /></li>
<li>增強式學習 (Reinforcement Learning): 此類學習通過與環境互動，根據獎勵或懲罰來學習最佳策略。模型會嘗試不同的行動，並根據結果調整策略，以最大化累積獎勵。例如：訓練機器人行走、玩遊戲等。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org7084ecf" class="outline-5">
<h5 id="org7084ecf">(2)機器學習學派與法則學派兩者的特性與區別在哪？ 兩者與傳統的統計學方法差別又在哪？ <code>[13%]</code></h5>
<div class="outline-text-5" id="text-org7084ecf">
</div>
<ul class="org-ul">
<li><a id="org27f389e"></a>解<br />
<div class="outline-text-6" id="text-org27f389e">
<ul class="org-ul">
<li>法則學派 (Rule-based Approach):<br />
<ul class="org-ul">
<li>特性： 依賴人為事先定義好的規則來解決問題。專家需要將領域知識編寫成明確的規則，然後讓系統根據這些規則進行推理和決策。<br /></li>
<li>優點： 容易理解和解釋，適用於規則明確且不複雜的問題。<br /></li>
<li>缺點： 需要大量人工編寫規則，難以處理複雜和不確定的情況。<br /></li>
</ul></li>
<li>機器學習學派 (Machine Learning Approach):<br />
<ul class="org-ul">
<li>特性： 通過從數據中學習來解決問題。模型會自動找出數據中的模式，並根據這些模式進行預測和決策，不需要事先編寫規則。<br /></li>
<li>優點： 能夠處理複雜和不確定的情況，能夠從大量數據中學習，並隨著數據增加不斷提升性能。<br /></li>
<li>缺點： 模型難以解釋，需要大量的訓練數據。<br /></li>
</ul></li>
<li>與傳統統計學方法的差別：<br />
<ul class="org-ul">
<li>傳統統計學： 注重數據分析和假設檢驗，目標是理解數據背後的規律。<br /></li>
<li>機器學習： 注重預測和決策，目標是從數據中建立模型並進行應用。機器學習更多的是從數據中學習模型，統計學則更關注對數據的分析。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org26d36b0" class="outline-4">
<h4 id="org26d36b0"><span class="section-number-4">1.1.2.</span> 2.</h4>
<div class="outline-text-4" id="text-1-1-2">
</div>
<div id="outline-container-org6f600fd" class="outline-5">
<h5 id="org6f600fd">(1)新興技術區塊鏈(Blockchain)在現今產業應用越來越多，請問區塊鏈是什麼？ 有哪些特性呢？ <code>[10%]</code></h5>
<div class="outline-text-5" id="text-org6f600fd">
</div>
<ul class="org-ul">
<li><a id="org7f80d18"></a>解<br />
<div class="outline-text-6" id="text-org7f80d18">
<ul class="org-ul">
<li>定義： 區塊鏈是一種分散式帳本技術，以區塊為單位記錄交易信息，並將這些區塊按時間順序連接成鏈。每個區塊都包含前一個區塊的哈希值，形成一個不可篡改的鏈條.<br /></li>
<li>特性：<br /></li>
<li>去中心化： 沒有單一的控制者，數據由網絡中的多個節點共同維護。<br /></li>
<li>不可篡改： 區塊鏈的數據一旦記錄就難以更改，因為任何修改都會導致後續區塊的哈希值改變。<br /></li>
<li>透明度： 區塊鏈上的交易記錄是公開的，任何人都可以查看。<br /></li>
<li>安全性： 使用密碼學技術來確保數據的安全性和完整性。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9e5f808" class="outline-5">
<h5 id="org9e5f808">(2)區塊鏈除了比特幣(Bitcoin)、以太幣(Ether)等數位貨幣外，就你所知，還有哪些產業應用？試舉例說明這些應用。而這些區塊鏈應用，原來是想解決產業什麼樣的問題呢？為什麼會需要使用到區塊鏈技術呢？如果靠其他方法或是其他資訊技術，有沒有辦法解決相同的問題呢？ <code>[15%]</code></h5>
<div class="outline-text-5" id="text-org9e5f808">
</div>
<ul class="org-ul">
<li><a id="org3ccb5f8"></a>解<br />
<div class="outline-text-6" id="text-org3ccb5f8">
<ul class="org-ul">
<li>產業應用： 除了比特幣 (Bitcoin) 和以太幣 (Ether) 等數位貨幣之外，區塊鏈還被應用於許多其他領域，例如：<br />
<ol class="org-ol">
<li>供應鏈管理： 追蹤商品從生產到消費的整個過程，確保商品的真實性和品質。<br /></li>
<li>數位身份驗證： 建立安全可靠的數位身份系統，保護用戶的隱私。<br /></li>
<li>智能合約： 自動執行合約條款，提高交易的效率和透明度。<br /></li>
<li>版權保護： 追蹤數位內容的版權，防止盜版。<br /></li>
<li>醫療健康： 安全地管理病患數據，方便醫療機構共享信息。<br /></li>
</ol></li>
<li>解決問題：<br />
<ol class="org-ol">
<li>信任問題： 區塊鏈透過分散式帳本和密碼學技術建立信任機制，解決傳統中心化系統的信任問題。<br /></li>
<li>資訊不透明： 區塊鏈的透明特性可以增加資訊的公開性，讓交易記錄可追溯。<br /></li>
<li>效率低下： 區塊鏈的智能合約可以自動執行交易，提高效率。<br /></li>
<li>其他解決方案： 某些情境中，可能可以使用其他方法或是資訊科技來解決產業問題。像是傳統的資料庫系統，可以用來管理數據，或是透過數位簽章來確保數位內容的真偽。但是區塊鏈的去中心化、不可篡改等特性，在需要高度信任的場景下，有其獨特的優勢。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org1c7ebba" class="outline-4">
<h4 id="org1c7ebba"><span class="section-number-4">1.1.3.</span> 3. 目前全球市值最高的前七大公司例如Facebook, Amazon, Google 大都是所謂的「平台經營模式」，請問，何謂平台經營模式？ 其與傳統經營模式相比有何特色？ 其在經營上與傳統模式相比，又有哪些優勢？ <code>[25%]</code></h4>
<div class="outline-text-4" id="text-1-1-3">
</div>
<div id="outline-container-orgaa3a912" class="outline-5">
<h5 id="orgaa3a912">解</h5>
<div class="outline-text-5" id="text-orgaa3a912">
<ul class="org-ul">
<li>平台經營模式的定義：<br />
<ul class="org-ul">
<li>平台經營模式指的是一種以建立平台為核心的商業模式，它不直接提供產品或服務，而是提供一個連接不同用戶群體的場所，讓他們能夠互動、交易或共享資源。<br /></li>
<li>平台通常會利用網絡效應，讓更多用戶的加入使得平台的價值不斷增加。<br /></li>
<li>典型的平台包括像是：Amazon, Facebook, Google 等等。<br /></li>
</ul></li>
<li>平台經營模式與傳統經營模式的特色比較：<br />
<ul class="org-ul">
<li>傳統經營模式：<br />
<ul class="org-ul">
<li>特性： 專注於生產和銷售產品或服務，企業通常直接與客戶互動。<br /></li>
<li>組織結構： 偏向垂直整合，強調內部效率和控制。<br /></li>
<li>收入來源： 主要來自銷售產品或服務。<br /></li>
</ul></li>
<li>平台經營模式：<br />
<ul class="org-ul">
<li>特性： 專注於建立和維護平台，並連接不同的用戶群體。<br /></li>
<li>組織結構： 偏向水平分工，強調協作和網絡效應。<br /></li>
<li>收入來源： 多元化，可能來自廣告、佣金、會員費等。<br /></li>
</ul></li>
<li>平台經營模式的優勢：<br />
<ul class="org-ul">
<li>網絡效應： 用戶越多，平台價值越高，形成正向循環。<br /></li>
<li>規模經濟： 平台可以服務大量用戶，降低單位成本。<br /></li>
<li>多元化收入來源： 平台可以從多個方面獲取收入，降低風險。<br /></li>
<li>創新： 平台可以促進創新，讓第三方開發者在其上開發應用和服務。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org52dabd1" class="outline-4">
<h4 id="org52dabd1"><span class="section-number-4">1.1.4.</span> 4.資訊安全目前一直是所有組織最關心與擔憂的議題，一個組織要能夠有效率的資訊安全管理，必須要由組織的許多面向與層次(例如政策、組織、人員、制度、科技等)同時來建立，請問，如果你是一個資安顧問，你會如何建立一個完整的資訊安全管理架構，來嚇阻、預防與偵測資安的威脅？ (提示：ISO 27001) <code>[25%]</code></h4>
<div class="outline-text-4" id="text-1-1-4">
</div>
<div id="outline-container-org1ff1bab" class="outline-5">
<h5 id="org1ff1bab">解</h5>
<div class="outline-text-5" id="text-org1ff1bab">
<p>
建立資訊安全管理架構：<br />
</p>
<ul class="org-ul">
<li>全面性： 資訊安全需要考量組織的許多面向與層次，不能只專注在單一技術或措施。<br /></li>
<li>政策： 制定明確的資訊安全政策，規範員工的行為，並確保與法規要求一致。<br /></li>
<li>組織： 建立資訊安全組織，明確人員的責任和權限。<br /></li>
<li>人員： 對員工進行資訊安全培訓，提高安全意識。<br /></li>
<li>制度： 建立完善的資訊安全管理制度，例如：風險評估、存取控制、事件回應等。<br /></li>
<li>科技： 導入必要的資訊安全技術，例如：防火牆、入侵偵測系統、資料加密等。<br /></li>
<li>符合 ISO 27001 標準： 參考 ISO 27001 標準，建立符合國際標準的資訊安全管理系統。<br /></li>
<li>嚇阻、預防、偵測： 建立完善的資訊安全管理架構來達到這三個目的。<br />
<ul class="org-ul">
<li>嚇阻： 建立嚴格的規範與制度，讓潛在的攻擊者知難而退。<br /></li>
<li>預防： 採取主動的防禦措施，降低資安事件發生的可能性。<br /></li>
<li>偵測： 建立監控機制，及早發現資安威脅。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org127ffa3" class="outline-3">
<h3 id="org127ffa3"><span class="section-number-3">1.2.</span> 110: 國立中山大學 110 學年度 碩士暨碩士專班招生考試試題</h3>
<div class="outline-text-3" id="text-1-2">
<p>
科目名稱：資料結構 【資管系碩士班乙組】 題號：442002 ※本科目依簡章規定「不可以」使用計算機(問答申論題) 共 2 頁 第 1 頁<br />
</p>
</div>
<div id="outline-container-orga55ba78" class="outline-4">
<h4 id="orga55ba78"><span class="section-number-4">1.2.1.</span> 1. AVL tree operations. (16%; 4% for each)</h4>
<div class="outline-text-4" id="text-1-2-1">
</div>
<div id="outline-container-org0065d1d" class="outline-5">
<h5 id="org0065d1d">(A) Please draw the result of inserting the keys 6, 5, 3, 9, 10 into an empty AVL tree.</h5>
<div class="outline-text-5" id="text-org0065d1d">
</div>
<ul class="org-ul">
<li><a id="org1bb6486"></a>解: 插入鍵值 6, 5, 3, 9, 10<br />
<div class="outline-text-6" id="text-org1bb6486">
<ol class="org-ol">
<li><p>
插入 6：建立一個只有根節點的樹：<br />
</p>
<pre class="example" id="orgd28669d">
  6
</pre></li>
<li><p>
插入 5：插入左子樹，平衡性仍然維持：<br />
</p>
<pre class="example" id="org9a8db1b">
  6
 /
5
</pre></li>
<li><p>
插入 3：插入 5 的左子樹後導致失衡，執行右旋：<br />
</p>
<pre class="example" id="orgc55b8a7">
    5
   / \
  3   6
</pre></li>
<li><p>
插入 9：插入 6 的右子樹：<br />
</p>
<pre class="example" id="org0d0c0fc">
    5
   / \
  3   6
       \
        9
</pre></li>
<li><p>
插入 10：插入 9 的右子樹後導致失衡，執行左旋：<br />
</p>
<pre class="example" id="orgb8fb54f">
    5
   / \
  3   9
     / \
    6  10
</pre></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org058f8c1" class="outline-5">
<h5 id="org058f8c1">(B) Please draw the result after inserting the keys 7, 8, 11 into the AVL tree from (A).</h5>
<div class="outline-text-5" id="text-org058f8c1">
</div>
<ul class="org-ul">
<li><a id="orgd278c7f"></a>解: 插入鍵值 7, 8, 11<br />
<div class="outline-text-6" id="text-orgd278c7f">
<ol class="org-ol">
<li><p>
插入 7：插入 6 的右子樹：<br />
</p>
<pre class="example" id="orgc6a714a">
    5
   / \
  3   9
     / \
    6  10
     \
      7
</pre></li>
<li><p>
插入 8：插入 7 的右子樹後導致失衡，對 6 節點執行左旋：<br />
</p>
<pre class="example" id="org24e151b">
    5
   / \
  3   9
     / \
    7  10
   / \
  6   8
</pre></li>
<li><p>
插入 11：插入 10 的右子樹後無需調整：<br />
</p>
<pre class="example" id="orge18c4b5">
        5
       / \
      3   9
         / \
        7  10
       / \    \
      6   8    11
</pre></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org853a851" class="outline-5">
<h5 id="org853a851">(C) Please draw the result after removing the key 6 from the AVL tree from (B).</h5>
<div class="outline-text-5" id="text-org853a851">
</div>
<ul class="org-ul">
<li><a id="orgefca898"></a>解:刪除鍵值 6<br />
<div class="outline-text-6" id="text-orgefca898">
<p>
移除葉節點 6，不影響平衡性：<br />
</p>
<pre class="example" id="org41e4802">
    5
   / \
  3   9
     / \
    7  10
     \    \
      8    11
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2084bb6" class="outline-5">
<h5 id="org2084bb6">(D) Please draw the result after removing the key 11 from the AVL tree from (C).</h5>
<div class="outline-text-5" id="text-org2084bb6">
</div>
<ul class="org-ul">
<li><a id="org10594e1"></a>解: 刪除鍵值 11<br />
<div class="outline-text-6" id="text-org10594e1">
<p>
移除葉節點 11，不影響平衡性：<br />
</p>
<pre class="example" id="orgace34ed">
    5
   / \
  3   9
     / \
    7  10
     \
      8
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6dd58e3" class="outline-4">
<h4 id="org6dd58e3"><span class="section-number-4">1.2.2.</span> 2. (10%; 5% for each)</h4>
<div class="outline-text-4" id="text-1-2-2">
</div>
<div id="outline-container-orgae40780" class="outline-5">
<h5 id="orgae40780">(A) What is the minimum number of nodes in an AVL tree to achieve the height = 9?</h5>
<div class="outline-text-5" id="text-orgae40780">
</div>
<ul class="org-ul">
<li><a id="org867f69b"></a>解<br />
<div class="outline-text-6" id="text-org867f69b">
<p>
高度 h=9h=9，最小節點數公式為： N(h)=1+N(h−1)+N(h−2)N(h)=1+N(h−1)+N(h−2) 初始條件：<br />
N(0)=1,N(1)=2<br />
N(0)=1,N(1)=2<br />
</p>

<p>
逐步計算：<br />
N(2)=1+2+1=4,N(3)=1+4+2=7<br />
N(2)=1+2+1=4,N(3)=1+4+2=7<br />
</p>

<p>
&#x2026;<br />
N(9)=1+N(8)+N(7)=1+88+56=145<br />
N(9)=1+N(8)+N(7)=1+88+56=145<br />
</p>

<p>
答案：145<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbe717cb" class="outline-5">
<h5 id="orgbe717cb">(B) What is the maximum number of nodes in an AVL tree with height = 8? Note that the height is 1 for a tree with only one node.</h5>
<div class="outline-text-5" id="text-orgbe717cb">
</div>
<ul class="org-ul">
<li><a id="org888ed32"></a>解:<br />
<div class="outline-text-6" id="text-org888ed32">
<p>
高度為 8 的 AVL Tree 最大節點數<br />
</p>

<p>
高度 h=8h=8，滿二叉樹節點數為：<br />
N=2^(h+1)−1=29−1=511<br />
</p>

<p>
答案：511<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6ce3ed4" class="outline-4">
<h4 id="org6ce3ed4"><span class="section-number-4">1.2.3.</span> 3.(4%)</h4>
<div class="outline-text-4" id="text-1-2-3">
</div>
<div id="outline-container-org55ec9e4" class="outline-5">
<h5 id="org55ec9e4">(A) Dijkstra&rsquo;s algorithm will fail in what kind of situation? (4%)</h5>
<div class="outline-text-5" id="text-org55ec9e4">
</div>
<ul class="org-ul">
<li><a id="org9b32c9e"></a>解:Dijkstra 演算法失效情況<br />
<div class="outline-text-6" id="text-org9b32c9e">
<p>
Dijkstra 演算法在圖中存在 負邊權重 時失效。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org29355d8" class="outline-5">
<h5 id="org29355d8">(B) Floyd-Warshall algorithm will fail in what kind of situation? (6%)</h5>
<div class="outline-text-5" id="text-org29355d8">
</div>
<ul class="org-ul">
<li><a id="org99f39f3"></a>解:Floyd-Warshall 演算法失效情況<br />
<div class="outline-text-6" id="text-org99f39f3">
<p>
Floyd-Warshall 在圖中存在 負權重環 (Negative Weight Cycle) 時無法計算正確結果。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf101c6b" class="outline-5">
<h5 id="orgf101c6b">(C) Complete the following pseudo code of Floyd-Warshall algorithm.</h5>
<div class="outline-text-5" id="text-orgf101c6b">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>let dist be a |V| x |V| array of minimum distances initialized to &#8734;
<span class="linenr">2: </span><span style="color: #51afef;">for</span> each vertex v
<span class="linenr">3: </span>    dist[v][v] &#8592; <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">4: </span><span style="color: #51afef;">for</span> each edge (u,v)
<span class="linenr">5: </span>    dist[u][v] &#8592; weight(u,v)
<span class="linenr">6: </span>    <span style="color: #51afef;">for</span> k from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">7: </span>        <span style="color: #51afef;">for</span> i from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">8: </span>            <span style="color: #51afef;">for</span> j from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">9: </span>                <span style="color: #51afef;">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org32cac49"></a>解: Floyd-Warshall 演算法的偽代碼補全<br />
<div class="outline-text-6" id="text-org32cac49">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:
<span class="linenr">2: </span>    dist[i][j] = dist[i][k] + dist[k][j]
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org68b4751" class="outline-4">
<h4 id="org68b4751"><span class="section-number-4">1.2.4.</span> 4. (10%) Given the frequencies of characters shown in the following table, please encode these characters to binary codes using Huffman coding.</h4>
<div class="outline-text-4" id="text-1-2-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">A</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">C</th>
<th scope="col" class="org-right">D</th>
<th scope="col" class="org-right">E</th>
<th scope="col" class="org-right">F</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">45</td>
<td class="org-right">13</td>
<td class="org-right">12</td>
<td class="org-right">16</td>
<td class="org-right">9</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org28073d2" class="outline-5">
<h5 id="org28073d2">解</h5>
<div class="outline-text-5" id="text-org28073d2">
</div>
<ul class="org-ul">
<li><a id="orge70bd8b"></a>步驟：<br />
<div class="outline-text-6" id="text-orge70bd8b">
<ol class="org-ol">
<li>合併最低頻率：F(5)+E(9)=14F(5)+E(9)=14<br /></li>
<li>合併結果與 C：C(12)+14=26C(12)+14=26<br /></li>
<li>合併 B 與 D：B(13)+D(16)=29B(13)+D(16)=29<br /></li>
<li>合併 AA 與 2626：A(45)+26=71A(45)+26=71<br /></li>
<li>合併 2929 與 7171：29+71=10029+71=100<br /></li>
</ol>
</div>
</li>
<li><a id="org15aa5e0"></a>編碼結果如下：<br />
<div class="outline-text-6" id="text-org15aa5e0">
<ul class="org-ul">
<li>A: 0<br /></li>
<li>B: 101<br /></li>
<li>C: 1001<br /></li>
<li>D: 11<br /></li>
<li>E: 10001<br /></li>
<li>F: 10000<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbf3b284" class="outline-3">
<h3 id="orgbf3b284"><span class="section-number-3">1.3.</span> 110: 國立中山大學 110 學年度 碩士暨碩士專班招生考試試題</h3>
<div class="outline-text-3" id="text-1-3">
<p>
科目名稱：資料結構 【資管系碩士班乙組】 題號：442002 ※本科目依簡章規定「不可以」使用計算機(問答申論題) 共 2 頁 第 2 頁<br />
</p>
</div>
<div id="outline-container-orgbe145e7" class="outline-4">
<h4 id="orgbe145e7"><span class="section-number-4">1.3.1.</span> 5.(24%)</h4>
<div class="outline-text-4" id="text-1-3-1">
</div>
<div id="outline-container-org26ad921" class="outline-5">
<h5 id="org26ad921">(A) Write a procedure to reverse an array of integers.</h5>
<div class="outline-text-5" id="text-org26ad921">
</div>
<ul class="org-ul">
<li><a id="orgb62c52c"></a>解: 反轉整數陣列<br />
<div class="outline-text-6" id="text-orgb62c52c">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">reverse_array</span>(arr):
<span class="linenr">2: </span>    left, right = <span style="color: #da8548; font-weight: bold;">0</span>, len(arr) - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">while</span> left &lt; right:
<span class="linenr">4: </span>        arr[left], arr[right] = arr[right], arr[left]
<span class="linenr">5: </span>        left += <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">6: </span>        right -= <span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org75f5717" class="outline-5">
<h5 id="org75f5717">(B) Analyze the time complexity (runtime formula) of your answer in (A)?</h5>
<div class="outline-text-5" id="text-org75f5717">
<p>
時間複雜度：O(n)<br />
</p>
</div>
</div>
<div id="outline-container-org4871386" class="outline-5">
<h5 id="org4871386">(C) Write a procedure to calculate n! for a given integer n and analyze the time complexity of your procedure?</h5>
<div class="outline-text-5" id="text-org4871386">
</div>
<ul class="org-ul">
<li><a id="orge654858"></a>解: 計算 n!<br />
<div class="outline-text-6" id="text-orge654858">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">factorial</span>(n):
<span class="linenr">2: </span>    <span style="color: #51afef;">if</span> n == <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #51afef;">or</span> n == <span style="color: #da8548; font-weight: bold;">1</span>:
<span class="linenr">3: </span>        <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">4: </span>    <span style="color: #51afef;">return</span> n * factorial(n - <span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div>
<p>
時間複雜度：O(n)<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org05bce55" class="outline-5">
<h5 id="org05bce55">(D) How many disk moves are needed in the recursive procedure for solving the n-disk Hanoi tower problem? Prove your answer.</h5>
<div class="outline-text-5" id="text-org05bce55">
</div>
<ul class="org-ul">
<li><a id="org7864c67"></a>解: 河內塔問題移動次數<br />
<div class="outline-text-6" id="text-org7864c67">
<p>
公式為：<br />
\[ T(n)=2^n−1 \]<br />
</p>

<p>
證明：遞迴式 T(n)=2T(n−1)+1T(n)=2T(n−1)+1 解為 \(2^n−1\)。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd0d67b6" class="outline-4">
<h4 id="orgd0d67b6"><span class="section-number-4">1.3.2.</span> 6. (26%) For a graph G = (V, E), V = {1, 2, 3, 4, 5, 6, 7}, E = {(1, 2), (2, 3), (3, 4), (1, 5), (2, 5), (1, 6), (1, 7), (5, 4), (6, 7)}, and the cost for above edges are {11, 5, 12, 18, 20, 6, 11, 14, 23}, respectively.</h4>
<div class="outline-text-4" id="text-1-3-2">
</div>
<div id="outline-container-org9a699de" class="outline-5">
<h5 id="org9a699de">(A) Use Prim’s algorithm to find the minimum spanning tree of G and give the cost.</h5>
<div class="outline-text-5" id="text-org9a699de">
</div>
<ul class="org-ul">
<li><a id="org9e2fc23"></a>解:Prim 演算法找最小生成樹<br />
<div class="outline-text-6" id="text-org9e2fc23">
<ul class="org-ul">
<li>起點：節點 1<br /></li>
<li>選邊順序：(1,2)→(2,3)→(3,4)→(1,5)→(1,6)→(1,7)<br /></li>
<li>總成本：11+5+12+18+6+11=63<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org62fff49" class="outline-5">
<h5 id="org62fff49">(B) How to detect a cycle in the above algorithm?</h5>
<div class="outline-text-5" id="text-org62fff49">
</div>
<ul class="org-ul">
<li><a id="org98ed0a4"></a>解: 如何檢測環<br />
<div class="outline-text-6" id="text-org98ed0a4">
<ul class="org-ul">
<li>在加入邊時，使用 並查集 (Union-Find) 判斷兩端點是否已連通。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1274b6b" class="outline-5">
<h5 id="org1274b6b">(C) Starting from node 1, use Depth First Search (DFS) and Breadth First Search (BFS) to determine the minimum spanning tree of graph G.</h5>
<div class="outline-text-5" id="text-org1274b6b">
</div>
<ul class="org-ul">
<li><a id="org96524cd"></a>解: DFS 與 BFS 的最小生成樹<br />
<div class="outline-text-6" id="text-org96524cd">
<ul class="org-ul">
<li>DFS 和 BFS 找出的生成樹不一定是最小生成樹，因為這兩者不考慮邊的權重。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb5b266d" class="outline-5">
<h5 id="orgb5b266d">(D) Can DFS or BFS guarantee to find the optimal solution? Why?</h5>
<div class="outline-text-5" id="text-orgb5b266d">
</div>
<ul class="org-ul">
<li><a id="org22b537a"></a>解<br />
<div class="outline-text-6" id="text-org22b537a">
<ul class="org-ul">
<li>不能，因為最優解取決於邊權重，而 DFS 和 BFS 並未考慮此條件。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org12ab319" class="outline-5">
<h5 id="org12ab319">(E) Write a procedure to find (list) all connected components of a graph.</h5>
<div class="outline-text-5" id="text-org12ab319">
</div>
<ul class="org-ul">
<li><a id="orgeb3ba34"></a>解:<br />
<div class="outline-text-6" id="text-orgeb3ba34">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">connected_components</span>(graph):
<span class="linenr"> 2: </span>    visited = set()
<span class="linenr"> 3: </span>    components = []
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    def dfs(node, component):
<span class="linenr"> 6: </span>        visited.add(node)
<span class="linenr"> 7: </span>        component.append(node)
<span class="linenr"> 8: </span>        <span style="color: #51afef;">for</span> neighbor in graph[node]:
<span class="linenr"> 9: </span>            <span style="color: #51afef;">if</span> neighbor <span style="color: #51afef;">not</span> in visited:
<span class="linenr">10: </span>                dfs(neighbor, component)
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #51afef;">for</span> node in graph:
<span class="linenr">13: </span>        <span style="color: #51afef;">if</span> node <span style="color: #51afef;">not</span> in visited:
<span class="linenr">14: </span>            component = []
<span class="linenr">15: </span>            dfs(node, component)
<span class="linenr">16: </span>            components.append(component)
<span class="linenr">17: </span>
<span class="linenr">18: </span>    <span style="color: #51afef;">return</span> components
<span class="linenr">19: </span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5e6223d" class="outline-3">
<h3 id="org5e6223d"><span class="section-number-3">1.4.</span> 110: 國立中山大學 110 學年度 碩士暨碩士專班招生考試試題</h3>
<div class="outline-text-3" id="text-1-4">
<p>
科目名稱：計算機概論 【資管系碩士班甲組、乙組】 題號：442001 ※本科目依簡章規定「不可以」使用計算機(選擇題) 共 8 頁 第 6 頁<br />
</p>
<ol class="org-ol">
<li>In Python 3, which of the following is used to define a block of code (e.g. body of loop)? A. Curly braces B. Indentation C. Semicolon D. Parenthesis<br />
<ul class="org-ul">
<li>解答：B. Indentation<br /></li>
<li>Python 使用 縮排 (Indentation) 來定義代碼塊，例如 for 或 if 的內容，這與其他語言的花括號 ({}) 不同。<br /></li>
</ul></li>
<li>Which of the following is NOT considered the reason for the recent AI boom? A. The global investment of AI B. The accessibility of cheap computation C. The exponential growth of data D. The advances of learning algorithms<br />
<ul class="org-ul">
<li>解答：A. The global investment of AI<br /></li>
<li>雖然 AI 的投資確實在增加，但這並非 AI 爆炸的直接技術性原因，而是技術的普及結果。其他選項 (計算能力、數據增長、演算法進步) 才是 AI 發展的核心推動力。<br /></li>
</ul></li>
<li>Which of the following about split-apply-combine strategy of data analytics is FALSE? A. It can be implemented by SQL B. It should not be used to replace loops C. It can help parallelize computations D. It is widely used in daily data management tasks<br />
<ul class="org-ul">
<li>解答：B. It should not be used to replace loops<br /></li>
<li>解釋：Split-apply-combine 策略常用於數據分析中，用來分割數據，應用函數，並將結果結合。它通常可以替代迴圈，提高計算效率，特別是在使用 pandas 或 SQL 等工具時。<br /></li>
</ul></li>
<li>Which of the following about Deep Neural Network is FALSE? A. The trained models are usually called black-box models B. Compared to traditional machine learning algorithms, it has more hyperparameters to tune C. It takes more time to do manual feature engineering D. It usually requires comparatively more computing resources to train a model<br />
<ul class="org-ul">
<li>解答：C. It takes more time to do manual feature engineering<br /></li>
<li>解釋： 深度神經網路的特點是可以自動提取特徵，因此通常 不需要 花大量時間進行手動特徵工程。<br /></li>
</ul></li>
<li>Which of the following is NOT a common feature of object-oriented programming languages? A. Parallelism B. Polymorphism C. Encapsulation D. Inheritance<br />
<ul class="org-ul">
<li>解答：A. Parallelism<br /></li>
<li>解釋： 物件導向程式語言 (OOP) 的核心特性是 多型 (Polymorphism)、封裝 (Encapsulation) 和 繼承 (Inheritance)。平行運算並非 OOP 的內建特性。<br /></li>
</ul></li>
<li>Which of the following is NOT a common feature of functional programming languages? A. Lazy Evaluation B. Higher-order functions C. Recursion D. Inheritance<br />
<ul class="org-ul">
<li>解答：D. Inheritance<br /></li>
<li>解釋：繼承是物件導向的特性，而 惰性求值 (Lazy Evaluation)、高階函數 (Higher-order functions) 和 遞迴 (Recursion) 是函數式程式設計的核心特性。<br /></li>
</ul></li>
<li>Which of the following about cloud, fog, and edge computing is FALSE? A. Cloud computing is often used to process urgent requests in the local network B. To improve response times, fog computing can be used to process computation-intensive requests C. They help promote decentralized storages and computations D. Amazon Web Services can be considered cloud computing platforms<br />
<ul class="org-ul">
<li>解答：A. Cloud computing is often used to process urgent requests in the local network<br /></li>
<li>解釋：雲端運算通常處理集中式的非即時性計算需求，而本地網絡中的即時請求更適合邊緣運算或霧運算處理。<br /></li>
</ul></li>
<li>Which of the following about data structures is TRUE? A. Arrays are dynamic data structures able to increase their sizes at runtime B. The length of a linked list is usually fixed C. Data elements in a linked list must be stored in adjacent memory space D. Linked lists can be used to implement stacks<br />
<ul class="org-ul">
<li>解答：D. Linked lists can be used to implement stacks<br /></li>
<li>解釋：連結串列 (Linked List) 可以用來實現堆疊 (Stack)，而其他選項皆為錯誤：<br />
<ul class="org-ul">
<li>陣列大小是靜態的，不能在執行期增長 (A 錯)。<br /></li>
<li>連結串列長度不固定 (B 錯)。<br /></li>
<li>連結串列節點不需要儲存在連續的記憶體空間 (C 錯)。<br /></li>
</ul></li>
</ul></li>
<li>Suppose we have a table in the third normal form (3NF) in a relational database. Which of the following statement is FALSE? A. The table is also in the 2NF B. The table may have multiple candidate keys C. Every non-prime attribute is non-transitively dependent on every key of the table D. For each of the functional dependency A-&gt;B that exists, A is the super key of the table<br />
<ul class="org-ul">
<li>解答：D. For each of the functional dependency A-&gt;B that exists, A is the super key of the table<br /></li>
<li>解釋：在 3NF 中，函數依賴的屬性 AA 不一定是超鍵，只要 BB 是主鍵或候選鍵的非傳遞依賴即可。<br /></li>
</ul></li>
<li><p>
Consider the following tables, A and B, in a relational database:<br />
A:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
</tr>
</tbody>
</table>
<p>
B:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table>
<p>
Which of the following SQL statement can be used to concatenate A and B?<br />
</p>
<ul class="org-ul">
<li>A. SELECT * FROM A UNION ALL SELECT * FROM B<br /></li>
<li>B. SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id<br /></li>
<li>C. SELECT * FROM A INNER JOIN B ON A.id = B.id<br /></li>
<li>D. SELECT * FROM A LEFT JOIN B ON A.id = B.id<br /></li>
<li>解: 題目要求的是將兩張表 A 和 B 串接，這裡的 串接 指的是結合兩張表的所有數據，而非進行條件配對。仔細分析每個選項後，可以看出符合要求的正確語句。<br /></li>
<li>選項分析:<br />
<ol class="org-ol">
<li>SELECT * FROM A UNION ALL SELECT * FROM B<br />
<ul class="org-ul">
<li>說明：UNION ALL 是直接將兩張表的數據合併，不會過濾重複的記錄。在這裡，A 和 B 的結合將包含兩張表的所有數據，不需要關聯條件。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table></li>
<li>結論： 符合 串接 (concatenate) 的要求。<br /></li>
</ul></li>
<li>SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明：FULL OUTER JOIN 將返回兩張表中所有記錄，並將 匹配的 id 行合併。對於沒有匹配的記錄，將使用 NULL 填充缺失的列。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">NULL</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table></li>
<li>結論： 這是進行關聯操作，不符合單純串接兩張表的需求。<br /></li>
</ul></li>
<li>SELECT * FROM A INNER JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明：INNER JOIN 只返回 A 和 B 中 id 匹配的記錄。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>
</tbody>
</table></li>
<li>結論： 僅返回兩表中匹配的部分，不符合串接需求。<br /></li>
</ul></li>
<li>SELECT * FROM A LEFT JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明： LEFT JOIN 返回 A 中的所有記錄，並將匹配 B 的行合併；對於 B 中沒有匹配的部分，填充 NULL。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>
</tbody>
</table></li>
<li>結論： 這是進行關聯操作，不符合單純串接兩張表的需求。<br /></li>
</ul></li>
<li>正確解答 答案：A. SELECT * FROM A UNION ALL SELECT * FROM B<br /></li>
<li>補充說明<br />
<ul class="org-ul">
<li>UNION 和 UNION ALL 的區別：<br />
<ul class="org-ul">
<li>UNION 會移除重複的記錄。<br /></li>
<li>UNION ALL 不會移除重複記錄，速度更快，適合需要保留重複值的場合。<br /></li>
</ul></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT considered a kind of NoSQL databases? A. Graph database B. Document database C. Object-relational database D. Key-value database<br /></li>
<li>Which of the following is the postfix expression of math representation A * B / C + D - E? A. A B * C / D + E -<br />
<ol class="org-ol">
<li>A B * C / D + - E<br /></li>
<li>* A B / C + D - E<br /></li>
<li>- / + * A B C D E<br /></li>
</ol></li>
<li><p>
Which of the following is the post-order traversal of the below binary search tree?<br />
</p>
<pre class="example" id="org8626b53">
            45
           /  \
          /    \
         27    55
        /        \
      18          58
        \          \
         19         60
</pre>
<ol class="org-ol">
<li>18 19 27 45 55 58 60<br /></li>
<li>45 27 18 19 55 58 60<br /></li>
<li>19 18 27 55 58 60 45<br /></li>
<li>19 18 27 60 58 55 45<br /></li>
</ol>
<p>
解： 後序遍歷步驟<br />
</p>
<ol class="org-ol">
<li><p>
遍歷左子樹<br />
節點 27 的左子樹為：<br />
</p>
<pre class="example" id="orgd9f8a51">

            27
           /
          18
           \
            19

</pre>
<p>
後序遍歷順序：<br />
</p>
<ul class="org-ul">
<li>遍歷左子樹 18（沒有左子樹，直接看右子樹）。<br /></li>
<li>遍歷右子樹的 19。<br /></li>
<li>訪問根節點 27。<br /></li>
</ul>
<p>
結果：18 → 19 → 27<br />
</p></li>
<li><p>
遍歷右子樹<br />
節點 55 的右子樹為：<br />
</p>
<pre class="example" id="orge932d73">
            55
              \
               58
                 \
                  60
</pre>
<p>
後序遍歷順序：<br />
</p>
<ul class="org-ul">
<li>遍歷左子樹（55 無左子樹，直接看右子樹）。<br /></li>
<li>遍歷右子樹的 58，接著是其右子樹的 60。<br /></li>
<li>訪問根節點 55。<br /></li>
</ul>
<p>
結果：60 → 58 → 55<br />
</p></li>
<li>訪問根節點<br />
最後訪問根節點 45。<br />
後序遍歷結果<br />
將步驟 1、2、3 的結果結合：<br />
18 → 19 → 27 → 60 → 58 → 55 → 45<br /></li>
</ol>
<p>
解答：D. 19 18 27 60 58 55 45<br />
</p></li>
</ol>
</div>
</div>
<div id="outline-container-orgea78dd1" class="outline-3">
<h3 id="orgea78dd1"><span class="section-number-3">1.5.</span> 110: 【資管系碩士班甲組、乙組】</h3>
<div class="outline-text-3" id="text-1-5">
<p>
國立中山大學 110 學年度 碩士暨碩士專班招生考試試題 科目名稱：計算機概論 【資管系碩士班甲組、乙組】 題號：442001 ※本科目依簡章規定「不可以」使用計算機(選擇題) 共 8 頁 第 1 頁<br />
</p>
</div>
<div id="outline-container-org0098c13" class="outline-4">
<h4 id="org0098c13"><span class="section-number-4">1.5.1.</span> 單選題，每題 2.5 分</h4>
<div class="outline-text-4" id="text-1-5-1">
<ol class="org-ol">
<li>Which of the following statements about memory is FALSE? A. Static RAM is an example of volatile memory B. Flash memory is a type of nonvolatile memory that can be erased electronically and rewritten C. Dynamic RAM is faster than static RAM D. Read-only memory (ROM) is a type of nonvolatile memory<br />
<ul class="org-ul">
<li>解答：C. Dynamic RAM is faster than static RAM<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>Static RAM (SRAM) 是揮發性記憶體，比動態 RAM (DRAM) 更快，但成本也更高。<br /></li>
<li>Dynamic RAM (DRAM) 雖然更慢，但每單位存儲空間成本更低，常用於主記憶體。<br /></li>
<li>其他選項正確，因為 Flash 是非揮發性、ROM 是非揮發性記憶體。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following best describes the principle of least privilege? A. Data access restrictions are lifted to ensure data integrity B. Data is encrypted and passwords are used C. Users should not share access details with others D. Users’ access privileges are limited to the lowest level necessary to perform required tasks<br />
<ul class="org-ul">
<li>解答：D. Users’ access privileges are limited to the lowest level necessary to perform required tasks<br /></li>
<li>詳解：<br />
最小權限原則 (Principle of Least Privilege) 是一種安全策略，確保用戶只能存取完成工作所需的最小權限，減少安全風險。<br /></li>
</ul></li>
<li>Which of the following about the binary search algorithm is TRUE? A. It is not possible for a binary search to find the value 2 in the array of B. The maximum number of comparisons required to perform a binary search of a 1000 element array is 9 C. The best-case time complexity of a binary search is O(log N), with N the number of elements in an array D. An iterative implementation of the binary search has a space complexity of O(N), with N the number of elements in an array<br />
解答：B. The maximum number of comparisons required to perform a binary search of a 1000 element array is 9<br />
<ul class="org-ul">
<li>詳解：<br />
<ul class="org-ul">
<li>二分搜尋的時間複雜度為 O(log⁡N)O(logN)。對於 1000 個元素的陣列，最多需要比較 ⌈log⁡21000⌉=10⌈log2​1000⌉=10 次，因此選項 B 是正確的。<br /></li>
<li>最佳情況下（找到目標元素），時間複雜度為 O(1)O(1)，所以選項 C 錯誤。<br /></li>
<li>二分搜尋的迭代實現的空間複雜度是 O(1)O(1)，非 O(N)O(N)。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following about web application development is FALSE? A. CSS allows web designers to change the layout and appearance of the webpage B. HTML stands for hypertext markup language and used hashtags to specify the content of webpages C. JavaScript can be used to display a prompt box that prompts the user to input some text D. JavaScript adds interactivity to webpages<br />
<ul class="org-ul">
<li>解答：B. HTML stands for hypertext markup language and used hashtags to specify the content of webpages<br /></li>
<li>詳解：<br />
HTML 是超文字標記語言，使用標籤 (tags)，而非井號 (hashtags)，來描述網頁內容。<br /></li>
</ul></li>
<li>Which of the following provides remote users with a secure connection to the organization network? A. VPN B. https C. Ethernet D. FTP<br />
<ul class="org-ul">
<li>解答：A. VPN<br /></li>
<li>詳解：<br />
VPN (Virtual Private Network) 提供安全的遠端連線，通常用於保護敏感數據在公共網路上的傳輸。<br /></li>
</ul></li>
<li>Which of the following about deep learning frameworks is FALSE? A. PyTorch uses dynamic computation graphs B. Tensorflow is an open-source deep learning framework developed by Google C. Keras is officially integrated with PyTorch in the latest release of PyTorch D. TensorFlow 2.x supports dynamic computation graphs<br />
<ul class="org-ul">
<li>解答：C. Keras is officially integrated with PyTorch in the latest release of PyTorch<br /></li>
<li>詳解：<br />
Keras 是 TensorFlow 的高階 API，並非與 PyTorch 整合的框架。<br /></li>
</ul></li>
<li>Which of the following about IP addresses and domain names is FALSE? A. A DNS server translates an IP address to its corresponding domain name B. An IPv6 address is 128 bits in length and written as a string of hexadecimal digits C. An IPv4 address is 32 bits and often written in dotted decimal notation D. A domain name is a text-based name of a computer or server that is easier for humans to memorize<br />
<ul class="org-ul">
<li>解答：A. A DNS server translates an IP address to its corresponding domain name<br /></li>
<li>詳解：<br />
DNS (Domain Name System) 的作用是將域名轉換為對應的 IP 位址，而不是將 IP 位址轉換為域名。<br /></li>
</ul></li>
<li>The Hamming distance between two binary strings is defined as the number of bit positions in which two bits are different. Which of the following can be used to find the differences between two binary strings in computing Hamming distance? A. OR B. XOR C. AND D. NOT<br />
<ul class="org-ul">
<li>解答：B. XOR<br /></li>
<li>詳解：<br />
XOR (異或運算) 可以標識兩個二進位串不同的位置，然後統計結果中 1 的數量即可得到漢明距離。<br /></li>
</ul></li>
<li>Which of the following is NOT an advantage of solid-state drives (SSDs) over traditional hard disks? A. Faster transfer rates B. Less power consumption C. Lighter weight D. Lower cost per gigabyte<br />
<ul class="org-ul">
<li>解答：D. Lower cost per gigabyte<br /></li>
<li>詳解：<br />
SSD 的成本較高，特別是在每 GB 的價格上，通常比傳統硬碟 (HDD) 貴。<br /></li>
</ul></li>
<li>Amazon EC2 is an example of <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. A. IaaS B. PaaS C. SaaS D. DaaS<br />
<ul class="org-ul">
<li>解答：A. IaaS (Infrastructure as a Service)<br /></li>
<li>詳解：<br />
Amazon EC2 提供虛擬伺服器實例，讓用戶能建立和管理基礎設施，屬於 IaaS 類型服務。<br /></li>
</ul></li>
<li>Consider an operating system that uses paging for virtual memory management. Assume that there are 4 page frames which are initially empty. Given the page reference string 1, 2, 3, 4, 5, 1, 3, 1, 1, 6, 3, 2, 5, how many page faults occur if the optimal page replacement is used? A. 5 B. 6 C. 8 D. 9<br />
<ul class="org-ul">
<li>解答：C. 8<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>頁面參考字串：1, 2, 3, 4, 5, 1, 3, 1, 1, 6, 3, 2, 5<br /></li>
<li>初始頁框數：4<br /></li>
<li>遵循最佳頁替換策略，每次替換時選擇將來最晚被使用的頁。<br /></li>
<li>具體計算可得到 8 次頁錯誤。<br /></li>
</ul></li>
</ul></li>
<li>Consider the addition of two 8-bit 2’s complement integers. Which of the following is the binary representation of 6 + (-8)? A. 00000010 B. 11111110 C. 11110001 D. 11111110<br />
<ul class="org-ul">
<li>解答：B. 11111110<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>6=000001106=00000110，−8=11111000−8=11111000（以 2 的補碼表示）。<br /></li>
<li>計算 6+(−8)6+(−8)：00000110+11111000=1111111000000110+11111000=11111110。<br /></li>
</ul></li>
</ul></li>
<li>Given two vertices, s and t, in a graph, which of the two traversals, breadth-first search (BFS) and depth-first search (DFS), can be used to determine if there is a path from s to t? A. Only BFS B. Only DFS C. Both BFS and DFS D. Neither BFS nor DFS<br />
<ul class="org-ul">
<li>解答：C. Both BFS and DFS<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>BFS 和 DFS 都可用於判斷是否存在從 ss 到 tt 的路徑。<br /></li>
<li>BFS 適合尋找最短路徑，DFS 適合完整探索。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following about Wi-Fi networks is FALSE? A. Most Wi-Fi is based on the 802.15 standards developed by IEEE B. Wi-Fi accesses the network in conjunction with the TCP/IP standard C. Most devices support multiple Wi-Fi standards D. Wi-Fi is often used to provide hot spots<br />
<ul class="org-ul">
<li>解答：A. Most Wi-Fi is based on the 802.15 standards developed by IEEE<br /></li>
<li>詳解：<br />
Wi-Fi 是基於 IEEE 802.11 標準，而 802.15 是藍牙標準。<br /></li>
</ul></li>
<li>Which of the following about network architectures is TRUE? A. Only one computer can act as a server on the client/server network B. Each device on a peer-to-peer network can share its resources with other devices C. One client computer crashing can affect the other computers on a client/server network D. A computer can act as either a client or a server, but not both, on a peer-to-peer network<br />
<ul class="org-ul">
<li>解答：B. Each device on a peer-to-peer network can share its resources with other devices<br /></li>
<li>詳解：<br />
P2P 網路允許每個設備共享資源，而其他選項的描述均不正確。<br /></li>
</ul></li>
<li>In 2020, Amazon Web Services was hit by an attack that floods the target with massive amounts of data to disrupt normal traffic. What is this attack called? A. Phishing B. Ransomware C. Malware attack D. DDoS<br />
<ul class="org-ul">
<li>解答：D. DDoS<br /></li>
<li>詳解：<br />
DDoS (Distributed Denial-of-Service) 是一種透過大規模數據請求癱瘓伺服器的攻擊方式。<br /></li>
</ul></li>
<li>Which of the following about drones is TRUE? A. The flight of drones cannot operate by an onboard computer or an autopilot B. A drone is an aircraft that operates by a human on board C. A drone is also known as an unmanned aerial vehicle (UAV) D. Drones are for hobbyists and cannot be used to monitor crop growth<br />
<ul class="org-ul">
<li>解答：C. A drone is also known as an unmanned aerial vehicle (UAV)<br /></li>
<li>詳解：<br />
無人機 (Drone) 是無人駕駛航空器 (UAV)，可由自動駕駛或人遠程操作。<br /></li>
</ul></li>
<li>Which of the following is a small, high-speed storage location within a processor that temporarily hold data and instructions? A. ALU B. CU C. register D. RAM<br />
<ul class="org-ul">
<li>解答：C. register<br /></li>
<li>詳解：<br />
寄存器 (register) 是處理器內部的高速存儲位置，用於臨時保存數據和指令。<br /></li>
</ul></li>
<li>Wearable devices, such as smartwatches, can monitor blood pressure and heart rates and send alerts in case of emergency, which is an example of <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. A. big data B. wireless communication C. cloud computing D. internet of things<br />
<ul class="org-ul">
<li>解答：D. internet of things<br /></li>
<li>詳解：<br />
穿戴裝置屬於物聯網 (IoT) 應用的一部分，將感測數據連接至網路進行處理。<br /></li>
</ul></li>
<li>Which of the following about RAID is TRUE? A. RAID 0 writes data to two drives at the same time to duplicate the data B. RAID 1 provides data reliability via redundancy C. Mirroring splits data and instructions across multiple drives in the array D. RAID stands for reliable array of inexpensive disks<br />
<ul class="org-ul">
<li>解答：B. RAID 1 provides data reliability via redundancy<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>RAID 1 透過鏡像技術提供冗餘數據保護。<br /></li>
<li>RAID 0 並未提供數據保護。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following is a last-in fast-out data structure? A. array B. stack C. queue D. tree<br />
<ul class="org-ul">
<li>解答：B. stack<br /></li>
<li>詳解：<br />
堆疊 (stack) 遵循後進先出 (LIFO) 原則，其他選項均不符。<br /></li>
</ul></li>
<li>In C/C++ programming, it requires at least <span class="underline"><span class="underline"><span class="underline">__</span></span></span> byte(s) when an integer number 32768 is stored as characters in computer memory. A. 2 B. 4 C. 5 D. 8<br />
<ul class="org-ul">
<li>解答：C. 5<br /></li>
<li>詳解：<br />
32768 作為字元需轉為 ASCII 表示，包括 3, 2, 7, 6, 8 共 5 個字元。<br /></li>
</ul></li>
<li>Which of the following is NOT a common data format/structure to save and describe network data? A. adjacency matrix B. hash table C. adjacency list D. edge list<br />
<ul class="org-ul">
<li>解答：B. hash table<br /></li>
<li>詳解：<br />
雖然哈希表常用於查詢，但不是保存網路數據的標準結構。<br /></li>
</ul></li>
<li>Consider the below C/C++ statement: int i = 1; const int *iPtr = &amp;i; Which of the following is FALSE? A. iPtr is a variable that stores a memory address B. Statement *iPtr = 10 is invalid C. iPtr is a pointer variable that points to an object of type int D. The data value of the object that iPtr points to can be modified<br />
<ul class="org-ul">
<li>解答：D. The data value of the object that iPtr points to can be modified<br /></li>
<li>詳解：<br />
const int *iPtr 指向的值不可修改。<br /></li>
</ul></li>
<li><p>
Consider the below C/C++ program:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">    #include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span> (){
<span class="linenr">3: </span>      <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">aStr</span>[] = <span style="color: #98be65;">"A string"</span>;
<span class="linenr">4: </span>      <span style="color: #ECBE7B;">void</span> <span style="color: #dcaeea;">pPtr</span> = &amp;aStr;
<span class="linenr">5: </span>      printf(<span style="color: #98be65;">"%s\n"</span>, ((<span style="color: #ECBE7B;">char</span>) aPtr));
<span class="linenr">6: </span>    }
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following statement is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show &ldquo;A string&rdquo; D. It will show &ldquo;A&rdquo;<br />
</p>
<ul class="org-ul">
<li>解答：A. It will show compilation errors<br /></li>
<li>詳解：<br />
void pPtr = &amp;aStr; 是錯誤的，void 不能直接用於指針。<br /></li>
</ul></li>
<li><p>
Consider the below C/C++ program:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">    #include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span>    <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span>{ <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>; <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>; };
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">passXY</span>(<span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span> *<span style="color: #dcaeea;">xy</span>){
<span class="linenr"> 4: </span>      xy -&gt; x = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 5: </span>      xy -&gt; y = <span style="color: #da8548; font-weight: bold;">2</span>;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>(<span style="color: #ECBE7B;">void</span>){
<span class="linenr"> 8: </span>      <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span> <span style="color: #dcaeea;">s</span>;
<span class="linenr"> 9: </span>      s.x = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">10: </span>      s.y = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">11: </span>      passXY(&amp;s);
<span class="linenr">12: </span>      printf(<span style="color: #98be65;">"x = %d, y = %d\n"</span>, s.x, s.y);
<span class="linenr">13: </span>    }
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following statement is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show &ldquo;x = 0, y = 0&rdquo; D. It will show &ldquo;x = 1, y = 2&rdquo;<br />
</p>
<ul class="org-ul">
<li>解答：D. It will show &ldquo;x = 1, y = 2&rdquo;<br /></li>
<li>詳解：<br />
指針 &amp;s 被傳遞，函數 passXY 成功修改了結構的成員值。<br /></li>
</ul></li>
<li>Which of the following about recursion is TRUE? A. We should always replace iterations with recursions if possible B. Recursion usually uses less memory than iteration as the code is more concise and clearer C. Recursion usually has higher algorithm performance D. Any problems that can be solved by recursions can also be solved by iterations<br />
<ul class="org-ul">
<li>解答：D. Any problems that can be solved by recursions can also be solved by iterations<br /></li>
<li>詳解：<br />
任何遞迴問題都可以轉換為迭代解法，雖然代碼可能更冗長。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd503f1c" class="outline-2">
<h2 id="orgd503f1c"><span class="section-number-2">2.</span> 中山</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org4e50255" class="outline-3">
<h3 id="org4e50255"><span class="section-number-3">2.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>計算機概論與資料結構：這部分是歷年考題的重點，從101學年度到112學年度都有相關考題出現。內容涵蓋了基礎的程式碼分析、資料結構的應用與分析、演算法的時間複雜度分析、以及圖論相關的知識。例如，常出現的考題類型包括：<br /></li>
<li>程式碼追蹤：給定一段程式碼，要求判斷程式的輸出結果。<br /></li>
<li>資料結構操作：例如，樹的遍歷 (pre-order, in-order, post-order)，堆積 (heap) 的操作，以及圖的最小生成樹 (minimum spanning tree, MST) 的計算。<br /></li>
<li>演算法分析：例如，排序演算法 (merge sort, selection sort, bubble sort, quick sort, insertion sort) 的時間複雜度分析，以及各種搜尋演算法的應用。<br /></li>
<li>遞迴 (Recursion): 遞迴函數的編寫與分析，以及遞迴在程式碼中的應用.<br /></li>
<li>資料庫：這部分也常被納入考題，包括了 SQL 語法、正規化 (normalization)、以及關聯式資料庫的概念。近年來，也開始出現 NoSQL 資料庫的相關考題。<br /></li>
<li>網路：網路相關的考題也佔有一定比例，考題內容包括網路協定 (TCP/IP, UDP, ARP, HTTP, etc.)、IP 位址與子網路遮罩 (subnet mask) 的計算、以及無線網路技術 (WiMAX, LTE, WIFI)。<br /></li>
<li>作業系統：作業系統的考題內容包括行程管理 (process management)，記憶體管理 (memory management)，以及系統呼叫 (system call) 的概念。<br /></li>
<li>資訊管理：資訊管理方面的考題包括電子商務策略 (e-commerce strategy)、供應鏈管理 (supply chain management)、服務科學 (service science)、雲端運算 (cloud computing)、物聯網 (Internet of Things, IoT)、大數據 (big data)、以及資訊安全管理 (information security management)。此外，近年來也出現了關於區塊鏈 (blockchain)、人工智慧 (artificial intelligence, AI)、機器學習 (machine learning)、以及數位轉型 (digital transformation) 等新興技術的考題。<br /></li>
<li>其他：考題中也出現了一些較為分散的主題，如函數式編程 (functional programming)、軟體架構 (software architecture)、專案管理 (project management)、以及編譯程式 (compiler) 的步驟。<br /></li>
</ul>

<p>
總體而言，近十年的考題趨勢呈現出以下幾個特點：<br />
</p>
<ol class="org-ol">
<li>廣度增加：考題涵蓋的範圍越來越廣，除了傳統的計算機科學基礎知識外，也開始納入資訊管理、新興科技等相關知識。<br /></li>
<li>深度提升：考題不僅要求考生掌握基本概念，也要求考生具備分析問題、解決問題的能力。例如，對於演算法的時間複雜度分析，以及對於不同資料結構的應用情境分析，都是考題中常見的重點。<br /></li>
<li>實務導向：考題開始出現一些與實務相關的應用問題，例如，如何利用雲端運算提升企業競爭力，以及如何利用物聯網技術改善生活品質等。<br /></li>
<li>新興技術：近年來，區塊鏈、人工智慧、機器學習等新興技術成為熱門考題。<br /></li>
<li>跨領域整合：考題越來越強調跨領域知識的整合應用，例如，資訊管理與資訊科技的整合，或是資訊科技與商業應用的整合。<br /></li>
</ol>

<p>
準備考試時，建議考生：<br />
</p>
<ul class="org-ul">
<li>扎實掌握基礎知識：計算機概論、資料結構、演算法、資料庫、網路、作業系統等基礎知識，是所有考題的基礎。<br /></li>
<li>關注新興技術：除了基礎知識，也需要關注新興技術的發展，並了解其應用情境。<br /></li>
<li>練習歷屆考題：透過練習歷屆考題，可以了解考試的題型、出題方向，以及難易程度。<br /></li>
<li>加強英文能力：部分考題會以英文呈現，因此考生需具備一定的英文能力，才能順利應考。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge30e080" class="outline-3">
<h3 id="orge30e080"><span class="section-number-3">2.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-2-2">
<p>
國立中山大學資訊管理學系碩士班入學考試模擬試題<br />
科目：計算機概論、資料結構與資訊管理<br />
</p>

<p>
作答說明：<br />
</p>
<ul class="org-ul">
<li>本試題分為選擇題與問答題，請仔細閱讀題目後作答。<br /></li>
<li>選擇題請於答案卡上劃記作答，問答題請於答案卷上作答。<br /></li>
<li>考試時間為 100 分鐘。<br /></li>
</ul>
</div>
<div id="outline-container-org8bbf3b4" class="outline-4">
<h4 id="org8bbf3b4"><span class="section-number-4">2.2.1.</span> 一、選擇題 (每題 3 分，共 60 分)</h4>
<div class="outline-text-4" id="text-2-2-1">
<ol class="org-ol">
<li>以下何者為非物件導向程式設計 (Object-Oriented Programming) 的特性？ (A) 繼承 (Inheritance) (B) 多型 (Polymorphism) (C) 封裝 (Encapsulation) (D) 遞迴 (Recursion)<br /></li>
<li>下列何者不屬於網路層 (Network Layer) 的協定？ (A) IP (B) TCP (C) ARP (D) ICMP<br /></li>
<li>在二元搜尋樹 (Binary Search Tree) 中，若要找出最小值，應該從哪個節點開始搜尋？ (A) 根節點 (Root Node) (B) 最右邊的節點 (Rightmost Node) (C) 最左邊的節點 (Leftmost Node) (D) 任何節點都可<br /></li>
<li>下列哪一種資料結構最常被用來實作深度優先搜尋 (Depth-First Search) 演算法？ (A) 堆疊 (Stack) (B) 佇列 (Queue) (C) 堆積 (Heap) (D) 鏈結串列 (Linked List)<br /></li>
<li>關於雲端運算 (Cloud Computing)，下列敘述何者為非？ (A) 是一種分散式運算環境。 (B) SaaS (軟體即服務) 是雲端運算的一種商業模式。 (C) IaaS (基礎設施即服務) 主要提供虛擬機器。 (D) 雲端運算適合用來處理小量資料的即時分析。<br /></li>
<li>以下哪一個選項是快排 (Quick Sort) 演算法最壞情況 (worst-case) 的時間複雜度？ (A) O(n) (B) O(n log n) (C) O(n^2) (D) O(log n)<br /></li>
<li>下列哪個選項是用來將網域名稱 (domain name) 對應到 IP 位址？ (A) 網域名稱系統 (DNS) (B) 位址解析協定 (ARP) (C) 傳輸控制協定 (TCP) (D) 使用者資料包協定 (UDP)<br /></li>
<li>一個迴圈程式碼如下：這題失敗，沒生出程式碼&#x2026;.<br /></li>
<li>請問執行完以上程式碼後，變數 w 的值是多少？ (A) 20 (B) 30 (C) 40 (D) 42<br /></li>
<li>在關聯式資料庫中，若一表格滿足第三正規化 (3NF)，則下列何者敘述錯誤？ (A) 每一個非主鍵屬性都必須完全相依於主鍵。 (B) 表格可能有多個候選鍵。 (C) 每一個非主鍵屬性都不能遞移相依於任何其他非主鍵屬性。 (D) 此表格必定也滿足 BCNF<br /></li>
<li>若要從頭到尾反向印出一個字串，最適合使用哪一種資料結構？ (A) 佇列 (Queue) (B) 堆疊 (Stack) (C) 二元搜尋樹 (Binary Search Tree) (D) 鏈結串列 (Linked List)<br /></li>
<li>下列何者為物聯網 (Internet of Things, IoT) 的應用範疇？ (A) 智慧家庭 (B) 工業自動化 (C) 智慧醫療 (D) 以上皆是<br /></li>
<li>關於區塊鏈 (Blockchain)，下列敘述何者正確？ (A) 區塊鏈上的資料可以隨意竄改。 (B) 區塊鏈是一種中心化的資料庫。 (C) 區塊鏈的特性包括去中心化、不可竄改、透明性。 (D) 比特幣 (Bitcoin) 是唯一使用區塊鏈技術的應用。<br /></li>
<li>下列哪一種機器學習 (Machine Learning) 演算法屬於監督式學習 (Supervised Learning)？ (A) K-means 分群法 (B) 支持向量機 (Support Vector Machine) (C) 主成分分析 (Principal Component Analysis) (D) 關聯規則學習 (Association Rule Learning)<br /></li>
<li>下列何者為非同步 (Asynchronous) 通訊的特性？ (A) 資料傳輸需要發送端和接收端的時脈同步。 (B) 資料傳輸不需要時脈信號。 (C) 資料傳輸前需要建立連線。 (D) 資料傳輸是同步進行的。<br /></li>
<li>以下哪一個選項不是大數據 (Big Data) 分析中常見的工具或框架？ (A) Apache Hadoop (B) Apache Spark (C) TensorFlow (D) MySQL<br /></li>
<li>若一系統使用 LRU (Least Recently Used) 分頁置換演算法，參考字串為 abgabdcabcad，且系統有三個可用頁框，請問會發生幾次 page fault？ (A) 9 (B) 10 (C) 11 (D) 12<br /></li>
<li>下列何者為 Deep Learning 常用的框架？ (A) TensorFlow (B) PyTorch (C) MXNet (D) 以上皆是<br /></li>
<li>下列哪一種資料結構不適合用於實現優先權佇列 (Priority Queue)？ (A) 堆積 (Heap) (B) 佇列 (Queue) (C) 二元搜尋樹 (Binary Search Tree) (D) 鏈結串列 (Linked List)<br /></li>
<li>下列哪一個選項是後序 (postfix) 運算式 A B + C D * - 的中序 (infix) 運算式？ (A) A + B - C * D (B) (A + B) - (C * D) (C) A + B - C * D (D) (A - C * D) + B<br /></li>
<li>以下何者不屬於常見的NoSQL 資料庫類型？ (A) 圖形資料庫 (Graph Database) (B) 文件資料庫 (Document Database) (C) 關聯式資料庫 (Relational Database) (D) 鍵值資料庫 (Key-Value Database)<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org6933c01" class="outline-4">
<h4 id="org6933c01"><span class="section-number-4">2.2.2.</span> 二、問答題 (共 40 分)</h4>
<div class="outline-text-4" id="text-2-2-2">
<ol class="org-ol">
<li>請簡述 資訊安全管理系統 (Information Security Management System, ISMS) 的概念，並說明導入 ISMS 的六個主要階段。 (10 分)<br /></li>
<li>請解釋 網路效應 (Network Effect) 的概念，並舉例說明在平台經濟中，如何利用網路效應來提升競爭力。(10 分)<br /></li>
<li>請說明 人工智慧 (Artificial Intelligence) 、機器學習 (Machine Learning) 與 深度學習 (Deep Learning) 三者之間的關係，並舉例說明在資訊管理領域的應用。(10 分)<br /></li>
<li>請說明 虛擬整合 (Virtual Integration) 的概念，並舉例說明其在供應鏈管理中的應用，並分析其優缺點。(10 分)<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgaf6decb" class="outline-3">
<h3 id="orgaf6decb"><span class="section-number-3">2.3.</span> 參考答案</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org1a48914" class="outline-4">
<h4 id="org1a48914"><span class="section-number-4">2.3.1.</span> 一、選擇題</h4>
<div class="outline-text-4" id="text-2-3-1">
<ol class="org-ol">
<li>(D) 遞迴是程式設計的一種技巧，不屬於物件導向程式設計的特性。<br /></li>
<li>(B) TCP 屬於傳輸層的協定。<br /></li>
<li>(C) 二元搜尋樹的最小值在最左邊的節點。<br /></li>
<li>(A) 堆疊具有後進先出 (LIFO) 的特性，適合用於深度優先搜尋。<br /></li>
<li>(D) 雲端運算適合用來處理大量的數據，而非小量數據的即時分析。<br /></li>
<li>(C) 快排演算法在最壞情況下的時間複雜度為 O(n^2)。<br /></li>
<li>(A) DNS 用於將網域名稱對應到 IP 位址。<br /></li>
<li>(A) w 的值為 2+4+6+8=20<br /></li>
<li>(D) 滿足 BCNF 一定滿足 3NF，但滿足 3NF 不一定滿足 BCNF<br /></li>
<li>(B) 堆疊具有後進先出的特性，適合用於反轉字串。<br /></li>
<li>(D) 物聯網可應用於智慧家庭、工業自動化、智慧醫療等領域。<br /></li>
<li>(C) 區塊鏈的核心特性為去中心化、不可竄改和透明性。<br /></li>
<li>(B) 支持向量機屬於監督式學習演算法。<br /></li>
<li>(B) 非同步通訊不需要時脈信號。<br /></li>
<li>(D) MySQL 是關聯式資料庫，不屬於大數據分析的框架。<br /></li>
<li>(A) 根據 LRU 演算法，會有 9 次 page fault。<br /></li>
<li>(D) TensorFlow, PyTorch, MXNet 皆為 Deep Learning 常用框架。<br /></li>
<li>(B) 佇列不適合用來實現優先權佇列，因其以先進先出方式取出元素。<br /></li>
<li>(B) 後序運算式 A B + C D * - 的中序運算式為 (A + B) - (C * D)<br /></li>
<li>(C) 關聯式資料庫屬於傳統資料庫，不屬於 NoSQL 資料庫。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgd3295bf" class="outline-4">
<h4 id="orgd3295bf"><span class="section-number-4">2.3.2.</span> 二、問答題</h4>
<div class="outline-text-4" id="text-2-3-2">
<ol class="org-ol">
<li>資訊安全管理系統 (ISMS) 是一個系統化的方法，用來分析、評估和管理組織的資訊安全風險。它提供了一套流程和架構，幫助組織建立、實施、維護和改進資訊安全措施。導入 ISMS 的六個主要階段包括：<br />
<ul class="org-ul">
<li>規劃 (Planning)：確立 ISMS 的範圍、目標和政策。<br /></li>
<li>實施 (Implementation)：根據計畫執行資訊安全措施，包括建立控制機制、培訓員工等。<br /></li>
<li>檢查 (Checking)：定期檢查和評估資訊安全措施的有效性。<br /></li>
<li>行動 (Action)：根據檢查結果，進行改進和調整。<br /></li>
<li>監控 (Monitoring)：持續監控 ISMS 的運作狀況。<br /></li>
<li>審查 (Review)：定期審查 ISMS 的成效，並進行必要的更新和改進。<br /></li>
</ul></li>
<li>網路效應指的是當一個產品或服務的使用者增加時，其價值也會隨之增加的現象。簡單來說，用的人越多，這個產品或服務就越有價值。在平台經濟中，網路效應非常重要。例如：<br />
<ul class="org-ul">
<li>社群媒體平台：當越多使用者加入社群媒體平台時，此平台對使用者的吸引力就越大。因為使用者可以與更多人聯繫、分享資訊。<br /></li>
<li>電商平台：當越多商家在電商平台上販售商品時，此平台對消費者的吸引力就越大。因為消費者可以在此平台上找到更多選擇、比較商品。<br /></li>
<li>應用程式商店：當越多開發者在應用程式商店上架應用程式，此商店對使用者的吸引力就越大，使用者可以在此商店找到更多應用程式。<br /></li>
<li>共乘平台：當越多使用者在共乘平台上註冊，此平台對使用者就越方便，因為使用者可以更容易地找到汽車共享。 利用網路效應來提升競爭力的方式包括：<br /></li>
<li>早期採用者獎勵：鼓勵早期使用者加入平台，以觸發網路效應。<br /></li>
<li>策略性合作：與其他平台或服務合作，擴大網路效應的範圍。<br /></li>
<li>差異化競爭：提供獨特的服務或功能，吸引更多使用者。<br /></li>
</ul></li>
<li>人工智慧 (AI) 是一種廣泛的概念，指的是讓電腦執行通常需要人類智慧才能完成的任務。機器學習 (ML) 是實現人工智慧的一種方法，它讓電腦可以從數據中學習，而不需要明確的程式碼。深度學習 (DL) 則是機器學習的一種分支，它使用人工神經網路 (Artificial Neural Networks) 來學習複雜的模式。在資訊管理領域的應用包括：<br />
<ul class="org-ul">
<li>客戶關係管理 (CRM)：利用機器學習分析客戶數據，提供個人化的產品推薦。<br /></li>
<li>供應鏈管理 (SCM)：利用深度學習預測供應鏈風險，優化庫存管理。<br /></li>
<li>網路安全：利用機器學習偵測網路攻擊，保護企業資訊資產。<br /></li>
<li>商業分析：利用機器學習和深度學習分析大量數據，提供商業決策的依據。<br /></li>
<li>自然語言處理 (NLP)：利用自然語言處理技術分析顧客評論，提升客戶服務品質。<br /></li>
</ul></li>
<li><p>
虛擬整合 (Virtual Integration) 指的是企業在供應鏈中，不擁有實體資產或設施，而是透過資訊科技 (IT) 連結不同的供應鏈夥伴，形成一個整合的虛擬供應鏈網路。在供應鏈管理中的應用包括：<br />
</p>
<ul class="org-ul">
<li>協同產品設計：透過網路平台與供應商協同設計產品。<br /></li>
<li>即時庫存資訊：透過系統即時取得供應商的庫存資訊，減少自身庫存成本。<br /></li>
<li>協同需求預測：與供應商共享需求預測資訊，提高供應鏈效率。<br /></li>
<li>彈性生產：根據即時需求資訊，調整生產計畫。<br /></li>
<li>即時物流追蹤：透過網路系統追蹤物流，提供即時的貨物位置資訊<br /></li>
</ul>

<p>
優點：<br />
</p>
<ul class="org-ul">
<li>彈性高：可以快速調整供應鏈以應對市場變化。<br /></li>
<li>成本低：降低了擁有實體資產的成本。<br /></li>
<li>效率高：透過資訊科技提高供應鏈效率。<br /></li>
</ul>

<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>依賴資訊科技：過度依賴資訊系統，若系統故障，會影響供應鏈運作。<br /></li>
<li>信任風險：需要信任供應鏈夥伴，確保資訊透明度。<br /></li>
<li>資料安全：需要確保在合作中資料的安全性。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdc612d7" class="outline-2">
<h2 id="orgdc612d7"><span class="section-number-2">3.</span> 中興</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org74b332d" class="outline-3">
<h3 id="org74b332d"><span class="section-number-3">3.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org0ca1f51" class="outline-4">
<h4 id="org0ca1f51"><span class="section-number-4">3.1.1.</span> 資料結構與演算法: 歷年考題中，資料結構與演算法是相當重要的部分。</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>常見的資料結構如linked list、binary tree、binary search tree、AVL tree、heap、hash table 等觀念頻繁出現。<br /></li>
<li>演算法部分，排序演算法如 insertion sort, selection sort, quick sort, merge sort, heap sort 都有被考過，binary search algorithm 也有出現。<br /></li>
<li>另外，圖論的 Floyd-Warshall algorithm 也曾出現。<br /></li>
<li>有些題目會要求寫出程式碼或是虛擬碼，來完成特定的操作，像是linked list的反轉或是計算特定範圍節點總和。<br /></li>
<li>Big-Oh 的時間複雜度分析 也會出現。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org6fa7d3b" class="outline-4">
<h4 id="org6fa7d3b"><span class="section-number-4">3.1.2.</span> 程式設計:</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>會出現需要讀懂程式碼並寫出結果的題目，程式語言包含 C, Java, Python。<br /></li>
<li>程式設計的考題包含 遞迴，還有一些字串的操作。<br /></li>
<li>也會出現要求寫出函式 (function) 的題目，例如多項式相乘 、檢查質數 等。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org773272c" class="outline-4">
<h4 id="org773272c"><span class="section-number-4">3.1.3.</span> 計算機組織與結構:</h4>
<div class="outline-text-4" id="text-3-1-3">
<ul class="org-ul">
<li>基本的計算機組成元件如 accumulator, program counter, memory, ALU 等觀念需要理解。<br /></li>
<li>一些概念，例如 buffer、direct memory access、interrupt 等也要了解。<br /></li>
<li>指令執行週期 (instruction cycle)也有被考到。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2079f4f" class="outline-4">
<h4 id="org2079f4f"><span class="section-number-4">3.1.4.</span> 作業系統:</h4>
<div class="outline-text-4" id="text-3-1-4">
<ul class="org-ul">
<li>考題中會出現 preemptive scheduling、non-preemptive scheduling 的觀念。<br /></li>
<li>paging 的觀念以及相關的計算也需要了解。<br /></li>
<li>多程式系統的記憶體管理也是重點。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org21cc7ce" class="outline-4">
<h4 id="org21cc7ce"><span class="section-number-4">3.1.5.</span> 網路:</h4>
<div class="outline-text-4" id="text-3-1-5">
<ul class="org-ul">
<li>考題中會出現 OSI 模型。<br /></li>
<li>IPv4 相關的觀念如 datagram, fragmentation，還有網路設備的設定也需要了解。<br /></li>
<li>DHCP 的觀念也有被考到。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgab629df" class="outline-4">
<h4 id="orgab629df"><span class="section-number-4">3.1.6.</span> 資料庫:</h4>
<div class="outline-text-4" id="text-3-1-6">
<ul class="org-ul">
<li>考題中出現 關聯式資料庫 的 正規化 (normalization) 以及 SQL 語法 。<br /></li>
<li>NoSQL 資料庫也出現在考題中。<br /></li>
<li>Entity-relationship model 的觀念也需要了解。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge3f41b6" class="outline-4">
<h4 id="orge3f41b6"><span class="section-number-4">3.1.7.</span> 軟體工程:</h4>
<div class="outline-text-4" id="text-3-1-7">
<ul class="org-ul">
<li>考題中出現 系統開發的生命週期，例如 訪談、原型開發。<br /></li>
<li>Use case 的使用 也需要理解。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc59a472" class="outline-4">
<h4 id="orgc59a472"><span class="section-number-4">3.1.8.</span> 機器學習:</h4>
<div class="outline-text-4" id="text-3-1-8">
<ul class="org-ul">
<li>近年來開始出現關於機器學習的題目，例如 supervised learning, unsupervised learning, reinforcement learning。<br /></li>
<li>K-fold cross-validation 也會出現。<br /></li>
<li>神經網路 的相關題目也開始出現， 例如基本的神經網路架構 ，還有計算梯度下降 。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5401464" class="outline-4">
<h4 id="org5401464"><span class="section-number-4">3.1.9.</span> 其他:</h4>
<div class="outline-text-4" id="text-3-1-9">
<ul class="org-ul">
<li>Turing test、Turing machine, Von Neumann architecture 也曾被考到。<br /></li>
<li>RSA 加密 也有出現。<br /></li>
<li>霍夫曼編碼 (Huffman code) 的觀念也需要了解。<br /></li>
<li>數字系統的轉換，例如 二進位、十進位、八進位、十六進位 之間的轉換 。<br /></li>
<li>二補數 的概念也需要理解。<br /></li>
<li>CAP theorem 也有被考到。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0a9dc2e" class="outline-3">
<h3 id="org0a9dc2e"><span class="section-number-3">3.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org9c33c30" class="outline-4">
<h4 id="org9c33c30"><span class="section-number-4">3.2.1.</span> 一、選擇題 (每題3分，共30分)</h4>
<div class="outline-text-4" id="text-3-2-1">
<ol class="org-ol">
<li>下列哪一個描述是錯誤的？ (A) 累加器 (Accumulator) 是一個暫存器，用來儲存算術和邏輯運算的結果。 (B) 程式計數器 (Program Counter) 指出程式中下一個要執行的指令位址。 (C) 直接記憶體存取 (Direct Memory Access, DMA) 允許周邊設備直接與記憶體傳輸數據，而不需要 CPU 的介入。 (D) 緩衝區 (Buffer) 是一種介面，用於兩個數據傳輸速度不同的設備之間，用來暫時儲存數據。 (E) 算術邏輯單元 (Arithmetic Logic Unit, ALU) 直接控制處理器的操作，並告知電腦的記憶體如何響應程式指令。<br /></li>
<li>下列哪一個排序演算法在最壞情況下的時間複雜度不是 O(n log n)? (A) 合併排序 (Merge Sort) (B) 快速排序 (Quick Sort) (C) 堆積排序 (Heap Sort) (D) 插入排序 (Insertion Sort) (E) 以上皆非<br /></li>
<li>在 OSI 模型 中，哪一層負責提供端對端的可靠傳輸？ (A) 網路層 (Network Layer) (B) 資料鏈路層 (Data Link Layer) (C) 傳輸層 (Transport Layer) (D) 會議層 (Session Layer) (E) 表達層 (Presentation Layer)<br /></li>
<li>下列哪一個不是 NoSQL 資料庫的類型？ (A) 鍵值對 (Key-value) 資料庫 (B) 文件 (Document) 資料庫 (C) 圖形 (Graph) 資料庫 (D) 關聯式 (Relational) 資料庫 (E) 寬列式 (Wide-column) 資料庫<br /></li>
<li>在 機器學習 中，下列哪一個問題最適合使用監督式學習 (Supervised Learning)？ (A) 找出顧客在零售市場中的區隔。 (B) 訓練一個 AI 機器人下棋。 (C) 將文章分類到不同的主題。 (D) 將一群顧客分成幾個群體。 (E) 在沒有標籤資料的情況下，找出數據的隱藏模式。<br /></li>
<li>若要利用 RSA 加密系統， 需先找到兩個質數 p 和 q，計算 n = p * q。 若 p = 5, q = 11, 則 n 為何？ (A) 16 (B) 45 (C) 55 (D) 65 (E) 99<br /></li>
<li>下列哪一個是 二元搜尋演算法 (binary search algorithm) 的限制？ (A) 需要使用排序過的陣列。 (B) 插入和刪除元素的花費較高。 (C) 必須有一個機制存取中間的元素。 (D) 不能應用於二元樹。 (E) 當數據量超過 1000 時，效率不高<br /></li>
<li>下列關於 CAP 定理 的敘述，何者為真？ (A) 分散式資料庫系統可以同時保證一致性 (Consistency)、可用性 (Availability) 和分割容錯性 (Partition tolerance)。 (B) 分散式資料庫系統只能保證一致性和可用性。 (C) 分散式資料庫系統只能保證一致性和分割容錯性。 (D) 分散式資料庫系統只能保證可用性和分割容錯性。 (E) 分散式資料庫系統只能保證一致性或可用性。<br /></li>
<li>下列哪一個是 Turing Test 的目標？ (A) 測試機器是否能執行複雜的計算。 (B) 測試機器是否能通過自然語言處理測試。 (C) 測試機器是否能模仿人類的智能。 (D) 測試機器是否能進行機器學習。 (E) 測試機器是否能夠解密。<br /></li>
<li>下列哪一個不是在系統開發的原型開發 (prototyping) 的優點？ (A) 作為使用者訓練的機制。 (B) 允許使用者嘗試操作軟體並了解其功能。 (C) 協助建立測試計畫和情境。 (D) 在發生高成本之前，協助確定系統的可用性和有用性。 (E) 使得計畫和排程更加容易。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orge9e9660" class="outline-4">
<h4 id="orge9e9660"><span class="section-number-4">3.2.2.</span> 二、簡答題 (每題10分，共40分)</h4>
<div class="outline-text-4" id="text-3-2-2">
<ol class="org-ol">
<li>請解釋分頁 (paging) 的觀念，以及它在多程式作業系統中如何運作。<br /></li>
<li>請寫出一個程式碼片段 (可以使用 C, Java, 或 Python)，來實作一個遞迴函式，計算 n! (n 階乘)。<br /></li>
<li>請說明梯度下降 (Gradient Descent) 在神經網路訓練中的作用，並簡述其步驟。<br /></li>
<li>請解釋 K-fold cross-validation 的概念，以及它如何應用在模型驗證上。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgb483fd9" class="outline-4">
<h4 id="orgb483fd9"><span class="section-number-4">3.2.3.</span> 程式設計題 (每題15分，共30分)</h4>
<div class="outline-text-4" id="text-3-2-3">
<ol class="org-ol">
<li>給定一個 linked list 的頭節點 (head node)，請寫一個程式碼片段 (可以使用 C, Java, 或 Python) 來反轉這個 linked list。<br /></li>
<li>給定一個二元樹的前序 (preorder) 和中序 (inorder) 遍歷結果，請寫一個程式碼片段 (可以使用 C, Java, 或 Python) 來重建這個二元樹。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org2d4077b" class="outline-3">
<h3 id="org2d4077b"><span class="section-number-3">3.3.</span> 詳細解說答案</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-orga67de01" class="outline-4">
<h4 id="orga67de01"><span class="section-number-4">3.3.1.</span> 一、選擇題</h4>
<div class="outline-text-4" id="text-3-3-1">
<ol class="org-ol">
<li>答案：(E)。 算術邏輯單元 (ALU) 負責執行算術和邏輯運算，但它並不直接控制處理器的所有操作，控制單元 (Control Unit) 才是負責控制處理器的操作並告知電腦記憶體如何響應程式指令。<br /></li>
<li>答案：(D)。插入排序在最壞情況下的時間複雜度是 O(n^2)，而合併排序、快速排序、堆積排序在最壞情況下的時間複雜度都是 O(n log n)。<br /></li>
<li>答案：(C)。 傳輸層 (Transport Layer) 負責提供端對端的可靠傳輸，例如 TCP 協定。<br /></li>
<li>答案：(D)。關聯式資料庫使用結構化的表格和 SQL 語言。 NoSQL 資料庫包括鍵值對、文件、圖形和寬列式資料庫。<br /></li>
<li>答案：(C)。將文章分類到不同的主題是一個典型的監督式學習問題，因為需要有標籤的數據來訓練模型。<br /></li>
<li>答案：(C)。 RSA 加密系統中，n = p * q = 5 * 11 = 55。<br /></li>
<li>答案：(A)。 二元搜尋演算法只能應用於已排序的數據。<br /></li>
<li>答案：(D)。 CAP 定理指出，分散式資料庫系統只能保證一致性、可用性和分割容錯性中的兩個。<br /></li>
<li>答案：(C)。 圖靈測試的目標是測試機器是否能夠模仿人類的智能。<br /></li>
<li>答案：(E)。原型開發的主要優點是能夠在早期階段發現問題，協助建立測試計畫，並評估系統的可用性和有用性。計畫和排程在原型開發的早期階段可能不夠完善。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgd8e238e" class="outline-4">
<h4 id="orgd8e238e"><span class="section-number-4">3.3.2.</span> 二、簡答題</h4>
<div class="outline-text-4" id="text-3-3-2">
<ol class="org-ol">
<li>分頁 (paging) 是一種記憶體管理技術，將邏輯記憶體分割成固定大小的區塊（稱為頁面），而物理記憶體也分割成相同大小的區塊（稱為頁框）。多程式作業系統使用分頁來允許每個程式使用非連續的記憶體空間。當程式執行時，作業系統會將程式的頁面載入到物理記憶體的頁框中，並使用分頁表來記錄邏輯地址到物理地址的映射。<br /></li>
<li><p>
以下為 Python 的程式碼範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>   <span style="color: #51afef;">def</span> <span style="color: #c678dd;">factorial</span>(n):
<span class="linenr">2: </span>       <span style="color: #51afef;">if</span> n == <span style="color: #da8548; font-weight: bold;">0</span>:
<span class="linenr">3: </span>           <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">4: </span>       <span style="color: #51afef;">else</span>:
<span class="linenr">5: </span>           <span style="color: #51afef;">return</span> n * factorial(n-<span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div></li>
<li>梯度下降 (Gradient Descent) 是一種優化演算法，用於訓練神經網路的權重。它通過迭代地調整權重，使得損失函數的值最小化。步驟如下：<br />
<ul class="org-ul">
<li>計算當前權重下損失函數的梯度。<br /></li>
<li>根據學習率和梯度，更新權重。<br /></li>
<li>重複以上步驟，直到損失函數收斂或達到迭代次數的上限。<br /></li>
</ul></li>
<li>K-fold cross-validation 是一種模型驗證技術，將數據集分成 K 個子集（稱為 fold）。然後，使用其中 K-1 個子集來訓練模型，並使用剩下的 1 個子集來驗證模型。重複這個過程 K 次，每次使用不同的子集作為驗證集。最後，平均 K 次驗證結果，以獲得更可靠的模型性能評估。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgafd22e6" class="outline-4">
<h4 id="orgafd22e6"><span class="section-number-4">3.3.3.</span> 三、程式設計題</h4>
<div class="outline-text-4" id="text-3-3-3">
<ol class="org-ol">
<li><p>
以下為 Java 的程式碼範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>   <span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> ListNode {
<span class="linenr"> 2: </span>       <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">val</span>;
<span class="linenr"> 3: </span>       ListNode next;
<span class="linenr"> 4: </span>       ListNode(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) { val = x; }
<span class="linenr"> 5: </span>   }
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>   <span style="color: #51afef;">public</span> ListNode reverseList(ListNode head) {
<span class="linenr"> 8: </span>       ListNode prev = <span style="color: #a9a1e1;">null</span>;
<span class="linenr"> 9: </span>       ListNode current = head;
<span class="linenr">10: </span>       ListNode next = <span style="color: #a9a1e1;">null</span>;
<span class="linenr">11: </span>       <span style="color: #51afef;">while</span> (current != <span style="color: #a9a1e1;">null</span>) {
<span class="linenr">12: </span>           next = current.next;
<span class="linenr">13: </span>           current.next = prev;
<span class="linenr">14: </span>           prev = current;
<span class="linenr">15: </span>           current = next;
<span class="linenr">16: </span>       }
<span class="linenr">17: </span>       head = prev;
<span class="linenr">18: </span>       <span style="color: #51afef;">return</span> head;
<span class="linenr">19: </span>   }
</pre>
</div></li>
<li>以下為 Python 的程式碼範例：<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">TreeNode</span>:
<span class="linenr"> 2: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__init__</span>(<span style="color: #51afef;">self</span>, val):
<span class="linenr"> 3: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">val</span> = val
<span class="linenr"> 4: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">left</span> = <span style="color: #a9a1e1;">None</span>
<span class="linenr"> 5: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">right</span> = <span style="color: #a9a1e1;">None</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">buildTree</span>(preorder, inorder):
<span class="linenr"> 8: </span>    <span style="color: #51afef;">if</span> <span style="color: #51afef;">not</span> preorder <span style="color: #51afef;">or</span> <span style="color: #51afef;">not</span> inorder:
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">None</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #dcaeea;">root_val</span> = preorder
<span class="linenr">12: </span>    <span style="color: #dcaeea;">root</span> = TreeNode(root_val)
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #dcaeea;">root_index</span> = inorder.index(root_val)
<span class="linenr">15: </span>
<span class="linenr">16: </span>    root.<span style="color: #dcaeea;">left</span> = buildTree(preorder[<span style="color: #da8548; font-weight: bold;">1</span>:root_index+<span style="color: #da8548; font-weight: bold;">1</span>], inorder[:root_index])
<span class="linenr">17: </span>    root.<span style="color: #dcaeea;">right</span> = buildTree(preorder[root_index+<span style="color: #da8548; font-weight: bold;">1</span>:], inorder[root_index+<span style="color: #da8548; font-weight: bold;">1</span>:])
<span class="linenr">18: </span>
<span class="linenr">19: </span>    <span style="color: #51afef;">return</span> root
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcc13b9a" class="outline-2">
<h2 id="orgcc13b9a"><span class="section-number-2">4.</span> 清大</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orge56f5da" class="outline-3">
<h3 id="orge56f5da"><span class="section-number-3">4.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-4-1">
<p>
以下是從這些考古題中觀察到的趨勢：<br />
</p>
</div>
<div id="outline-container-org26c1ead" class="outline-4">
<h4 id="org26c1ead"><span class="section-number-4">4.1.1.</span> 基本程式概念和資料結構：</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>遞迴：有多個題目都使用遞迴概念來解題，例如將十進制數字轉換為二進制。<br /></li>
<li>鏈結串列：考題中有要求反轉鏈結串列的實作。<br /></li>
<li>二元樹：有考題關於二元樹的儲存方式、遍歷以及二元搜尋樹的建立。<br /></li>
<li>堆疊：有題目要求使用堆疊來反轉相鄰的資料。<br /></li>
<li>佇列：有題目提到佇列的相關概念。<br /></li>
<li>雜湊表：有考題關於雜湊表的碰撞機率計算。<br /></li>
<li>前序式、後序式：有考題要求將前序式轉換為後序式。<br /></li>
<li>排序演算法：有提到排序演算法的相關概念，例如快速排序和合併排序。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf918b9e" class="outline-4">
<h4 id="orgf918b9e"><span class="section-number-4">4.1.2.</span> 計算機組織與結構：</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>浮點數表示法：考題中有關於浮點數的二進制表示法以及誤差計算。<br /></li>
<li>二補數：有題目探討二補數的表示範圍和加法運算。<br /></li>
<li>位元運算：有題目關於位元循環移位的操作。<br /></li>
<li>指令週期：有考題探討 CPU 的指令執行時間，包括有無 pipeline 的情況。<br /></li>
<li>快取記憶體：雖然沒有直接的考題，但在第 30 頁有提及快取記憶體（cache）的概念。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3e4422f" class="outline-4">
<h4 id="org3e4422f"><span class="section-number-4">4.1.3.</span> 作業系統：</h4>
<div class="outline-text-4" id="text-4-1-3">
<ul class="org-ul">
<li>核心：有考題詢問作業系統核心的主要組成部分和功能，以及核心如何從使用者程式奪回控制權。<br /></li>
<li>行程和工作佇列：考題中有關於作業系統中工作佇列和行程佇列的內容。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org25ee48f" class="outline-4">
<h4 id="org25ee48f"><span class="section-number-4">4.1.4.</span> 網路：</h4>
<div class="outline-text-4" id="text-4-1-4">
<ul class="org-ul">
<li>TCP/UDP：有題目比較 TCP 和 UDP 的服務差異，以及 TCP 如何偵測網路擁塞。<br /></li>
<li>網路層：有考題詢問網路軟體的層級和功能。<br /></li>
<li>CSMA/CD：有考題說明 CSMA/CD 的功能與運作原理。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge35ed2a" class="outline-4">
<h4 id="orge35ed2a"><span class="section-number-4">4.1.5.</span> 演算法分析：</h4>
<div class="outline-text-4" id="text-4-1-5">
<ul class="org-ul">
<li>時間複雜度：有題目要求分析程式的時間複雜度，並使用 big-O 符號表示。<br /></li>
<li>遞迴關係式：考題中有遞迴關係式的分析。<br /></li>
<li>圖論：有考題關於圖的頂點覆蓋問題和最小生成樹演算法，以及歐拉路徑的概念。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5450f4b" class="outline-4">
<h4 id="org5450f4b"><span class="section-number-4">4.1.6.</span> 其他：</h4>
<div class="outline-text-4" id="text-4-1-6">
<ul class="org-ul">
<li>圖靈機：有題目要求設計圖靈機來執行減值操作。<br /></li>
<li>錯誤更正碼：有題目關於錯誤更正碼的偵測和修正能力。<br /></li>
<li>開源/閉源軟體：有考題詢問開源和閉源軟體的差異，並舉例說明。<br /></li>
<li>邊界值分析：考題中有關於使用邊界值分析進行測試的題目。<br /></li>
<li>生產系統：有題目要求將一個問題以生產系統的狀態和規則描述。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1ba18cd" class="outline-4">
<h4 id="org1ba18cd"><span class="section-number-4">4.1.7.</span> 數學概念：</h4>
<div class="outline-text-4" id="text-4-1-7">
<ul class="org-ul">
<li>機率：有考題計算雜湊碰撞的機率。<br /></li>
<li>幾何：有題目要求計算平面上的反射點。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga399099" class="outline-3">
<h3 id="orga399099"><span class="section-number-3">4.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-4-2">
<p>
清華大學資訊工程學系 113 學年度「計算機概論」模擬試題<br />
考試時間：100 分鐘<br />
總分：100 分<br />
</p>
</div>
<div id="outline-container-orgb49f061" class="outline-4">
<h4 id="orgb49f061"><span class="section-number-4">4.2.1.</span> 1. 程式設計與資料結構 (30 分)</h4>
<div class="outline-text-4" id="text-4-2-1">
</div>
<div id="outline-container-org3477413" class="outline-5">
<h5 id="org3477413">(a) 遞迴與迭代 (10%)：</h5>
<div class="outline-text-5" id="text-org3477413">
<p>
請使用遞迴和迭代兩種方式，實作一個函數來計算費氏數列的第 n 項 (Fibonacci sequence)。並分析這兩種方式的時間複雜度。<br />
</p>
</div>
</div>
<div id="outline-container-org8abc084" class="outline-5">
<h5 id="org8abc084">(b) 鏈結串列操作 (10%)：</h5>
<div class="outline-text-5" id="text-org8abc084">
<p>
給定一個單向鏈結串列的頭節點，請實作一個函數來判斷此鏈結串列是否為迴文 (palindrome)。請分析你的演算法的時間複雜度。 (c) 二元樹與搜尋 (10%)：給定一個二元搜尋樹 (BST)，請實作一個函數來找出樹中第 k 小的元素。請分析你的演算法的時間複雜度，並解釋如何應用中序走訪 (inorder traversal)。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orge044072" class="outline-4">
<h4 id="orge044072"><span class="section-number-4">4.2.2.</span> 2. 計算機組織與結構 (25 分)</h4>
<div class="outline-text-4" id="text-4-2-2">
</div>
<div id="outline-container-org96a32f5" class="outline-5">
<h5 id="org96a32f5">(a) 浮點數表示法 (10%)：</h5>
<div class="outline-text-5" id="text-org96a32f5">
<p>
假設有一個 10 位元的浮點數表示法，其中 1 位元為符號位元，5 位元為指數 (excess-15 表示法)，4 位元為尾數。請將十進制數字 -5.625 轉換為此浮點數表示法。並討論此表示法的最大和最小可表示數字。<br />
</p>
</div>
</div>
<div id="outline-container-org8a38807" class="outline-5">
<h5 id="org8a38807">(b) 記憶體階層 (10%)：</h5>
<div class="outline-text-5" id="text-org8a38807">
<p>
請說明快取記憶體 (cache memory) 的運作原理，並解釋快取記憶體如何提高記憶體存取速度。請比較直接映射 (direct mapping) 和集合關聯 (set-associative) 快取之間的差異。<br />
</p>
</div>
</div>
<div id="outline-container-org9acaec7" class="outline-5">
<h5 id="org9acaec7">(c) 指令集架構 (5%)：</h5>
<div class="outline-text-5" id="text-org9acaec7">
<p>
簡述 RISC (精簡指令集計算機) 和 CISC (複雜指令集計算機) 的主要差異，並各舉一個例子說明。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org589a2d3" class="outline-4">
<h4 id="org589a2d3"><span class="section-number-4">4.2.3.</span> 3. 作業系統與網路 (25 分)</h4>
<div class="outline-text-4" id="text-4-2-3">
</div>
<div id="outline-container-org057857d" class="outline-5">
<h5 id="org057857d">(a) 行程管理 (10%)：</h5>
<div class="outline-text-5" id="text-org057857d">
<p>
請解釋作業系統中的行程 (process) 和執行緒 (thread) 的概念，並比較它們之間的差異。說明行程排程演算法 (例如：FCFS, SJF, Round Robin) 的目的。<br />
</p>
</div>
</div>
<div id="outline-container-orgfdfa358" class="outline-5">
<h5 id="orgfdfa358">(b) 網路協定 (10%)：</h5>
<div class="outline-text-5" id="text-orgfdfa358">
<p>
請說明 TCP 三次握手 (three-way handshake) 的過程，並解釋為什麼需要這個過程。比較 TCP 和 UDP 在可靠性、速度和應用場景上的差異。<br />
</p>
</div>
</div>
<div id="outline-container-org149c73f" class="outline-5">
<h5 id="org149c73f">(c) 雲端運算 (5%)：</h5>
<div class="outline-text-5" id="text-org149c73f">
<p>
簡述雲端運算 (cloud computing) 的基本概念，並說明 IaaS (基礎設施即服務)、PaaS (平台即服務) 和 SaaS (軟體即服務) 的差異。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4abd835" class="outline-4">
<h4 id="org4abd835"><span class="section-number-4">4.2.4.</span> 4. 演算法與新興技術 (20 分)</h4>
<div class="outline-text-4" id="text-4-2-4">
</div>
<div id="outline-container-org614c968" class="outline-5">
<h5 id="org614c968">(a) 圖論演算法 (10%)：</h5>
<div class="outline-text-5" id="text-org614c968">
<p>
給定一個加權無向圖，請使用 Dijkstra 演算法找出從起點到所有其他節點的最短路徑。請解釋 Dijkstra 演算法的原理，並說明其時間複雜度。<br />
</p>
</div>
</div>
<div id="outline-container-org793d2f5" class="outline-5">
<h5 id="org793d2f5">(b) 機器學習基礎 (10%)：</h5>
<div class="outline-text-5" id="text-org793d2f5">
<p>
簡述機器學習 (machine learning) 中監督式學習 (supervised learning) 和非監督式學習 (unsupervised learning) 的概念，並各舉一個實際應用的例子。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org65a9a65" class="outline-3">
<h3 id="org65a9a65"><span class="section-number-3">4.3.</span> 詳細解答：</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-orgb2eda29" class="outline-4">
<h4 id="orgb2eda29"><span class="section-number-4">4.3.1.</span> 1. 程式設計與資料結構</h4>
<div class="outline-text-4" id="text-4-3-1">
</div>
<div id="outline-container-org11125c7" class="outline-5">
<h5 id="org11125c7">(a) 遞迴與迭代</h5>
<div class="outline-text-5" id="text-org11125c7">
</div>
<ul class="org-ul">
<li><a id="orgc370be5"></a>遞迴： cpp<br />
<div class="outline-text-6" id="text-orgc370be5">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fib_recursive</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">2: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr">3: </span>  <span style="color: #51afef;">return</span> fib_recursive(n - <span style="color: #da8548; font-weight: bold;">1</span>) + fib_recursive(n - <span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr">4: </span>}
</pre>
</div>
<p>
時間複雜度為 O(2^n)，因為每個呼叫都會產生兩個新的呼叫。<br />
</p>
</div>
</li>
<li><a id="org44e42e1"></a>迭代： cpp<br />
<div class="outline-text-6" id="text-org44e42e1">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fib_iterative</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr"> 2: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr"> 3: </span>  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">prev</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">curr</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 4: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">2</span>; i &lt;= n; i++) {
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">next</span> = prev + curr;
<span class="linenr"> 6: </span>    prev = curr;
<span class="linenr"> 7: </span>    curr = next;
<span class="linenr"> 8: </span>  }
<span class="linenr"> 9: </span>  <span style="color: #51afef;">return</span> curr;
<span class="linenr">10: </span>}
</pre>
</div>
<p>
時間複雜度為 O(n)，因為只遍歷一次迴圈。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1d48271" class="outline-5">
<h5 id="org1d48271">(b) 鏈結串列操作</h5>
<div class="outline-text-5" id="text-org1d48271">
<ul class="org-ul">
<li>將鏈結串列複製一份並反轉，然後比較反轉後的鏈結串列是否與原鏈結串列相同。 * 可以使用快慢指針找到鏈結串列的中點，然後反轉後一半的鏈結串列，再與前半部比較。<br /></li>
<li>時間複雜度：O(n)，需走訪鏈結串列一次。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga2f4d39" class="outline-5">
<h5 id="orga2f4d39">(c) 二元樹與搜尋</h5>
<div class="outline-text-5" id="text-orga2f4d39">
<ul class="org-ul">
<li>使用中序走訪 (inorder traversal) 可以按照排序順序訪問二元搜尋樹的所有節點。<br /></li>
<li>使用一個計數器追蹤走訪的節點數，當計數器等於 k 時，返回當前節點的值。<br /></li>
<li>時間複雜度：O(n) 最差情況下需要走訪所有節點。平均情況下為 O(k)，如果樹平衡良好，則可以在 O(h) 的時間找到，h是樹的高度。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org12437d5" class="outline-4">
<h4 id="org12437d5"><span class="section-number-4">4.3.2.</span> 2. 計算機組織與結構</h4>
<div class="outline-text-4" id="text-4-3-2">
</div>
<div id="outline-container-orga0f8a66" class="outline-5">
<h5 id="orga0f8a66">(a) 浮點數表示法</h5>
<div class="outline-text-5" id="text-orga0f8a66">
<ul class="org-ul">
<li>-5.625 的二進制表示為 -101.101。<br /></li>
<li>將其標準化為 -1.01101 x 2^2。<br /></li>
<li>符號位元：1 (負數)<br /></li>
<li>指數：2 + 15 = 17，二進制為 10001<br /></li>
<li>尾數：01101 (取小數部分，不足補 0)<br /></li>
<li>因此，表示為 1 10001 0110。<br /></li>
<li>最大可表示數字：約為 (1.1111) 2^15<br /></li>
<li>最小可表示數字：約為 (1.0000) 2^-15<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org39b5b6f" class="outline-5">
<h5 id="org39b5b6f">(b) 記憶體階層</h5>
<div class="outline-text-5" id="text-org39b5b6f">
<ul class="org-ul">
<li>快取記憶體是一個小而快的記憶體，用於儲存經常存取的資料，以減少 CPU 從主記憶體讀取資料的時間。 * 直接映射快取：每個主記憶體區塊只能映射到快取中的一個特定位置。<br /></li>
<li>集合關聯快取：每個主記憶體區塊可以映射到快取中多個特定位置的集合，提供更高的靈活性和較低的碰撞率。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge644ea2" class="outline-5">
<h5 id="orge644ea2">(c) 指令集架構</h5>
<div class="outline-text-5" id="text-orge644ea2">
<ul class="org-ul">
<li>RISC：指令集簡化，指令長度固定，硬體實現簡單，執行速度快。例如：ARM。<br /></li>
<li>CISC：指令集複雜，指令長度不固定，硬體實現複雜，功能強大。例如：Intel x86。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb221495" class="outline-4">
<h4 id="orgb221495"><span class="section-number-4">4.3.3.</span> 3. 作業系統與網路</h4>
<div class="outline-text-4" id="text-4-3-3">
</div>
<div id="outline-container-org572b04a" class="outline-5">
<h5 id="org572b04a">(a) 行程管理</h5>
<div class="outline-text-5" id="text-org572b04a">
<ul class="org-ul">
<li>行程：程式執行時的實例，包含程式碼、資料、堆疊、和程式計數器等資源，是作業系統進行資源分配和調度的基本單位。<br /></li>
<li>執行緒：行程內的一個執行單元，多個執行緒共享同一行程的資源，因此執行緒間的切換比行程切換快。<br /></li>
<li>行程排程演算法：<br />
<ul class="org-ul">
<li>FCFS (First Come First Served)：先到先服務，依據行程到達的先後順序執行。<br /></li>
<li>SJF (Shortest Job First)：最短工作優先，優先執行所需時間最短的行程。<br /></li>
<li>Round Robin：循環排程，每個行程執行一段時間後，輪流執行下一個行程。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org08522f5" class="outline-5">
<h5 id="org08522f5">(b) 網路協定</h5>
<div class="outline-text-5" id="text-org08522f5">
<ul class="org-ul">
<li><p>
TCP 三次握手：<br />
</p>
<ol class="org-ol">
<li>客戶端發送 SYN 封包到伺服器。<br /></li>
<li>伺服器收到 SYN 後，回覆 SYN-ACK 封包給客戶端。<br /></li>
<li>客戶端收到 SYN-ACK 後，發送 ACK 封包給伺服器。<br /></li>
</ol>
<p>
此過程用於建立可靠的 TCP 連線，並協商雙方初始序列號。<br />
</p></li>
<li>TCP：可靠傳輸、面向連線、有流量控制和擁塞控制。適用於檔案傳輸、網頁瀏覽。<br /></li>
<li>UDP：不可靠傳輸、無連線、速度快，但沒有流量控制。適用於串流媒體、線上遊戲。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgac407ec" class="outline-5">
<h5 id="orgac407ec">(c) 雲端運算</h5>
<div class="outline-text-5" id="text-orgac407ec">
<ul class="org-ul">
<li>雲端運算：通過網路提供可擴展的計算資源。<br /></li>
<li>IaaS：提供虛擬機、儲存和網路等基礎設施，用戶需自行管理作業系統和應用程式。<br /></li>
<li>PaaS：提供開發平台和工具，用戶可在此平台上開發和部署應用程式。<br /></li>
<li>SaaS：提供現成的應用軟體，用戶直接使用即可。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3498df9" class="outline-4">
<h4 id="org3498df9"><span class="section-number-4">4.3.4.</span> 4. 演算法與新興技術</h4>
<div class="outline-text-4" id="text-4-3-4">
</div>
<div id="outline-container-orge793134" class="outline-5">
<h5 id="orge793134">(a) 圖論演算法</h5>
<div class="outline-text-5" id="text-orge793134">
<ul class="org-ul">
<li>Dijkstra 演算法：從起點開始，維護一個最短路徑集合，並逐步擴展到其他節點，直到找到所有節點的最短路徑。<br /></li>
<li>時間複雜度：O(E log V)，其中 E 為邊的數量，V 為頂點的數量。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga401d08" class="outline-5">
<h5 id="orga401d08">(b) 機器學習基礎</h5>
<div class="outline-text-5" id="text-orga401d08">
<ul class="org-ul">
<li>監督式學習：使用標記過的資料進行訓練，讓模型學習從輸入到輸出的對應關係。例如：圖像分類、語音辨識。<br /></li>
<li>非監督式學習：使用未標記的資料進行訓練，讓模型自行找出資料中的模式和結構。例如：分群、降維。<br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org9cd3f92" class="outline-2">
<h2 id="org9cd3f92"><span class="section-number-2">5.</span> 成大</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org3bedff2" class="outline-3">
<h3 id="org3bedff2"><span class="section-number-3">5.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org01172ef" class="outline-3">
<h3 id="org01172ef"><span class="section-number-3">5.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-org1ff9937" class="outline-2">
<h2 id="org1ff9937"><span class="section-number-2">6.</span> 中央</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org7eac970" class="outline-3">
<h3 id="org7eac970"><span class="section-number-3">6.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-orgef6ff46" class="outline-3">
<h3 id="orgef6ff46"><span class="section-number-3">6.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-org53b088e" class="outline-2">
<h2 id="org53b088e"><span class="section-number-2">7.</span> 北大</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org189bbe2" class="outline-3">
<h3 id="org189bbe2"><span class="section-number-3">7.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-orge00e048" class="outline-3">
<h3 id="orge00e048"><span class="section-number-3">7.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-org33e9a81" class="outline-2">
<h2 id="org33e9a81"><span class="section-number-2">8.</span> 林北的考前猜題</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org75906f2" class="outline-3">
<h3 id="org75906f2"><span class="section-number-3">8.1.</span> 網路</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-org73cb32b" class="outline-4">
<h4 id="org73cb32b"><span class="section-number-4">8.1.1.</span> 簡單的概念知識</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
看這章：<a href="https://data.slhs.tp.edu.tw/shien/bcc/download/book/C221A1_ch14.pdf">https://data.slhs.tp.edu.tw/shien/bcc/download/book/C221A1_ch14.pdf</a><br />
</p>
<ul class="org-ul">
<li>ISO的OSI(網路七層): 14-1<br /></li>
<li>TCP/IP: 14-2<br /></li>
<li>WIFI, 藍芽, RFID, NFC: 14-3<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb13a181" class="outline-4">
<h4 id="orgb13a181"><span class="section-number-4">8.1.2.</span> 如何計算IP位址與網路遮罩</h4>
<div class="outline-text-4" id="text-8-1-2">
</div>
<div id="outline-container-org37cadc4" class="outline-5">
<h5 id="org37cadc4">IP的等級</h5>
<div class="outline-text-5" id="text-org37cadc4">
<ul class="org-ul">
<li>IP(例如8.8.8.8)分為A,B,C三級<br /></li>
<li>每一組IP都是一個 8-bit 的二進位數字,﹐每組數字為一個“octet”﹐合共起來就是一個 32-bit 的 IP 位址﹐亦即是 IP v4 (Version 4) 版本的位址<br /></li>
<li>所以 8.8.8.8 的完整二進位格式是：00001000.00001000.00001000.00001000<br /></li>
<li>128.10.20.30 的二進位格式是：10000000.00001010.00010100.00011110<br /></li>
<li>192.168.1.1 的二進位格式是：11000000.10101000.00000001.00000001<br /></li>
<li>上面三個IP分別是A,B,C級網路IP<br /></li>
<li>可以由二進位來判斷一個IP是哪一級：<br />
<ul class="org-ul">
<li>如果是以“0”開頭的﹐這是一個 A Class的 IP<br /></li>
<li>如果是以“10”開頭的﹐這是一個 B Class的 IP<br /></li>
<li>如果是以“110”為開頭的﹐則屬於 C Class的 IP<br /></li>
</ul></li>
<li>也可以死記﹕<br />
<ul class="org-ul">
<li>由 1 到 126 開頭的 IP 是 A Class<br /></li>
<li>由 128 到 191開頭的 IP是 B Class<br /></li>
<li>由 192 到 223 開頭的則為 C Class<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org82a1eec" class="outline-5">
<h5 id="org82a1eec">不同等級的網路，差異在於這組網路有多少可用IP</h5>
<div class="outline-text-5" id="text-org82a1eec">
<ul class="org-ul">
<li>A,B,C級網路的可用IP(可以用算的 C級的254=2^16 - 2, 原因看底下)<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">等級</th>
<th scope="col" class="org-right">開首</th>
<th scope="col" class="org-left">網路數目</th>
<th scope="col" class="org-left">主機數目</th>
<th scope="col" class="org-left">使用範圍</th>
<th scope="col" class="org-left">申請領域</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">0</td>
<td class="org-left">127</td>
<td class="org-left">16,777,214</td>
<td class="org-left">1.x.x.x 到 126.x.x.x</td>
<td class="org-left">國家級</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">10</td>
<td class="org-left">16,384</td>
<td class="org-left">65,534</td>
<td class="org-left">128.x.x.x 到 191.x.x.x</td>
<td class="org-left">跨國組織</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-right">110</td>
<td class="org-left">2,097,152</td>
<td class="org-left">254</td>
<td class="org-left">192.x.x.x 到 223.x.x.x</td>
<td class="org-left">企業組織</td>
</tr>

<tr>
<td class="org-left">D</td>
<td class="org-right">1110</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">224.- 到 239.-</td>
<td class="org-left">特殊用途</td>
</tr>

<tr>
<td class="org-left">E</td>
<td class="org-right">1111</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">240.- 到 255.-</td>
<td class="org-left">保留範圍</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li><p>
IP 的 Net_ID 和 Host_ID﹕<br />
</p>
<ul class="org-ul">
<li>A Class 的 IP 使用最前面一組數字來做 Net ID﹐其余三組做 Host ID<br /></li>
<li>B Class 的 IP 使用前面兩組數字來做 Net ID﹐另兩組做 Host ID<br /></li>
<li>C Class 的 IP 使用前面三組數字來做 Net ID﹐剩下的一組做 Host ID<br /></li>
</ul>
<p>
如下圖<br />
</p>

<div id="org0db29b2" class="figure">
<p><img src="images/林北的考前猜題/2025-01-27_17-20-33_ip1.png" alt="2025-01-27_17-20-33_ip1.png" width="500" /><br />
</p>
</div></li>
<li>後面的Host ID就是這組網路能用的IP，例如C級網路前面的Net ID是固定的，所以能用的就只有後面的Host ID, 0 - 255<br /></li>
<li>例如，南一中分配到的一組網路ID是210.70.137,<br />
<ul class="org-ul">
<li>預設的子網路遮罩就是255.255.255.0<br /></li>
<li>我們能用的IP就是210.70.137.0 - 210.70.137.255,共256個<br /></li>
<li>但是要扣掉兩組IP, 所以剩254個能用<br />
<ul class="org-ul">
<li>網路 ID：210.70.137.0<br /></li>
<li>廣播地址：210.70.137.255<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge8e1914" class="outline-5">
<h5 id="orge8e1914">IP與NetMask</h5>
<div class="outline-text-5" id="text-orge8e1914">
<ul class="org-ul">
<li>因為IP位址分為主機和網路號碼，所以在Internet的網路上找尋電腦時，我們需要先找到網路號碼，然後在子網路中找到目的地的主機，所以電腦IP位址的設定除了IP位址外，另一個重要的號碼就是子網路遮罩。<br /></li>
<li>「子網路遮罩」(Subnet Mask)是一個固定的值，在電腦的定址計算中是使用子網路遮罩的值將IP位址分為網路號碼和主機號碼，子網路遮罩的值依網路等級的預設值，如下所示：<br />
<ul class="org-ul">
<li>Class A：255.0.0.0<br /></li>
<li>Class B：255.255.0.0<br /></li>
<li>Class C：255.255.255.0<br /></li>
</ul></li>
<li>簡單的說255的二進位值能夠遮掉IP位址中的網路號碼，經過運算後剩下的就是主機號碼，如此可以識別IP位址所屬的網路。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc592bfe" class="outline-5">
<h5 id="orgc592bfe">網路分割(分成兩個)</h5>
<div class="outline-text-5" id="text-orgc592bfe">
<ul class="org-ul">
<li>可以透過NetMask來把一個網路切成兩個或更多<br /></li>
<li><p>
例如把一個C級網路切成兩個，分給電個學校，這樣就不能用預設的netmask 255.255.255.0<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">子網</th>
<th scope="col" class="org-right">網路 ID</th>
<th scope="col" class="org-right">廣播地址</th>
<th scope="col" class="org-left">可用 IP 範圍</th>
<th scope="col" class="org-right">子網掩碼</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">子網 1</td>
<td class="org-right">210.70.137.0</td>
<td class="org-right">210.70.137.127</td>
<td class="org-left">210.70.137.1 ~ 210.70.137.126</td>
<td class="org-right">255.255.255.128</td>
</tr>

<tr>
<td class="org-left">子網 2</td>
<td class="org-right">210.70.137.128</td>
<td class="org-right">210.70.137.255</td>
<td class="org-left">210.70.137.129 ~ 210.70.137.254</td>
<td class="org-right">255.255.255.128</td>
</tr>
</tbody>
</table></li>
<li>之後這個C級網路就會變成以下兩個子網路，可以分配給兩個學校<br />
<ul class="org-ul">
<li>子網 1：210.70.137.0/25<br /></li>
<li>子網 2：210.70.137.128/25<br /></li>
<li>25的意思是netmask有25個1(11111111.11111111.11111111.10000000)<br /></li>
<li>沒分割的C級網路netmask預設是24(11111111.11111111.11111111.00000000)<br /></li>
</ul></li>
<li>每分割一次，就會損失掉兩個IP（第一個和最後一個IP位址是保留作為特殊的用途, 第一個位址代表的是Network ID, 最後一個位址代表的是廣播位址), 所以分割越細浪費越多IP<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc099127" class="outline-5">
<h5 id="orgc099127">分成4個</h5>
<div class="outline-text-5" id="text-orgc099127">
<ul class="org-ul">
<li><p>
將 210.70.137.0/24 分成 4 個子網後的分配如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">子網</th>
<th scope="col" class="org-right">網路 ID</th>
<th scope="col" class="org-right">廣播地址</th>
<th scope="col" class="org-left">可用 IP 範圍</th>
<th scope="col" class="org-right">子網掩碼</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">子網 1</td>
<td class="org-right">210.70.137.0</td>
<td class="org-right">210.70.137.63</td>
<td class="org-left">210.70.137.1 ~ 210.70.137.62</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 2</td>
<td class="org-right">210.70.137.64</td>
<td class="org-right">210.70.137.127</td>
<td class="org-left">210.70.137.65 ~ 210.70.137.126</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 3</td>
<td class="org-right">210.70.137.128</td>
<td class="org-right">210.70.137.191</td>
<td class="org-left">210.70.137.129 ~ 210.70.137.190</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 4</td>
<td class="org-right">210.70.137.192</td>
<td class="org-right">210.70.137.255</td>
<td class="org-left">210.70.137.193 ~ 210.70.137.254</td>
<td class="org-right">255.255.255.192</td>
</tr>
</tbody>
</table></li>
<li>之後這個C級網路就會變成以下4個子網路，可以分配給兩個學校<br />
<ul class="org-ul">
<li>子網 1：210.70.137.1 ~ 210.70.137.62<br /></li>
<li>子網 2：210.70.137.65 ~ 210.70.137.126<br /></li>
<li>子網 3：210.70.137.129 ~ 210.70.137.190<br /></li>
<li>子網 4：210.70.137.193 ~ 210.70.137.254<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb12970b" class="outline-5">
<h5 id="orgb12970b">公共 IP&ldquo; 與 &rdquo;私有 IP"</h5>
<div class="outline-text-5" id="text-orgb12970b">
<ul class="org-ul">
<li>一個學校分配一個C級網路一定不夠用，我們學校光電腦教室用掉的IP就有300個，怎麼辦？<br /></li>
<li>在 A﹑B﹑C 這三個層級裡面﹐各劃出一些位址範圍保留給私有位址所用﹐它們分別是﹕<br />
<ul class="org-ul">
<li>10.0.0.0 - 10.255.255.255<br /></li>
<li>172.16.0.0 - 172.31.255.255<br /></li>
<li>192.168.0.0 - 192.168.255.255<br /></li>
</ul></li>
<li>像中華電信其實只分配一個IP給我們家，那為什麼家裡每台電腦、手機都能用WIFI上網，原因就是都用這種virtual ip<br /></li>
<li>使用virtual IP必須要配合NAT( NAT &#x2014; Network Addresss Translation)<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org6e27734"></a>NAT運作原理<br />
<div class="outline-text-6" id="text-org6e27734">
<p>
NAT 是路由器實現的技術，用於解決內部多台設備共用一個公網 IP 的問題。工作流程：<br />
</p>
<ol class="org-ol">
<li>內部設備請求上網：你的電腦（私網 IP：192.168.1.100）想訪問 Google（例如 IP 為 142.250.190.46）。請求會發送到路由器。<br /></li>
<li>路由器轉換請求：路由器會用它的公網 IP（例如 123.45.67.89）替換電腦的私網 IP，並將請求轉發到 Google。<br /></li>
<li>路由器保存對應關係：路由器會記錄內部設備的私網 IP 和使用的連接埠（Port）。例如：<br />
<ul class="org-ul">
<li>內部 IP:Port -&gt; 公網 IP:Port<br /></li>
<li>192.168.1.100:54321 -&gt; 123.45.67.89:54321<br /></li>
</ul></li>
<li>回應轉發：當 Google 的回應到達你的公網 IP 時，路由器會根據對應關係將回應轉發給正確的內部設備（如 192.168.1.100）。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org627176e" class="outline-5">
<h5 id="org627176e">DHCP</h5>
<div class="outline-text-5" id="text-org627176e">
<ul class="org-ul">
<li>家裡的每台電腦或手機為什麼不用自己設定IP就能上網？<br /></li>
<li>路由器通常啟用 DHCP（動態主機配置協議），自動給每台設備分配私網 IP。這樣你家裡的電腦、手機都會獲得唯一的內部 IP。<br /></li>
<li>範例：假設路由器的 IP 是 192.168.1.1，你的設備可能分配到：<br />
<ul class="org-ul">
<li>電腦：192.168.1.100<br /></li>
<li>手機：192.168.1.101<br /></li>
<li>平板：192.168.1.102<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org4d17610" class="outline-3">
<h3 id="org4d17610"><span class="section-number-3">8.2.</span> 資料庫</h3>
<div class="outline-text-3" id="text-8-2">
</div>
<div id="outline-container-org9c8d66c" class="outline-4">
<h4 id="org9c8d66c"><span class="section-number-4">8.2.1.</span> NoSQL v.s. RDBM</h4>
<div class="outline-text-4" id="text-8-2-1">
</div>
<div id="outline-container-org64d8218" class="outline-5">
<h5 id="org64d8218">關聯式資料庫(RDBMS, Relational Database Management System)</h5>
<div class="outline-text-5" id="text-org64d8218">
<p>
資料以資料表(table)的形式存在資料庫中，資料表之間有事先定義的關係，資料表中的一欄(column)代表某項屬性、一列(row)代表一個實體相關屬性的數值，每個資料表都具有主鍵(primary key)方便查詢，並且資料表間的關係可以透過外鍵(foreign key)建立。<br />
</p>

<div id="org5a3ddf6" class="figure">
<p><img src="images/林北的考前猜題/2025-01-28_12-43-42_1*hsMO1oCL5d1US9LcRztT-Q.png" alt="2025-01-28_12-43-42_1*hsMO1oCL5d1US9LcRztT-Q.png" width="500" /><br />
</p>
</div>
</div>
<ul class="org-ul">
<li><a id="org1c933de"></a>RDBMS的優點<br />
<div class="outline-text-6" id="text-org1c933de">
<ul class="org-ul">
<li>有ACID的特性，ACID 代表不可分割性 、一致性、獨立性和耐用性。 具有ACID 屬性的事務可確保資料庫操作的正確且可預測的執行，從而改善分析結果，最終有助於企業做出更明智的決策。<br />
<ol class="org-ol">
<li>不可分割性 (Atomic):交易必須整體成功執行，若是交易有一部分操作失敗，整個交易都會失效<br /></li>
<li>一致性 (Consistent)：做為交易的一部分寫入資料庫的資料，必須遵守所有明定規則以及約束<br /></li>
<li>獨立性 (Isolated)：達成並行控制的重要關鍵，可以確保每一個交易都是獨立的<br /></li>
<li>耐用性 (Durable)：在一個交易成功完成後，對資料庫所做的變更都是永久性的<br /></li>
</ol></li>
<li>不可分割性 (Atomic):交易必須整體成功執行，若是交易有一部分操作失敗，整個交易都會失效<br /></li>
<li>一致性 (Consistent)：做為交易的一部分寫入資料庫的資料，必須遵守所有明定規則以及約束<br /></li>
<li>獨立性 (Isolated)：達成並行控制的重要關鍵，可以確保每一個交易都是獨立的<br /></li>
<li>耐用性 (Durable)：在一個交易成功完成後，對資料庫所做的變更都是永久性的<br /></li>
<li>查詢複雜性：可以透過SQL語法，進行較複雜的查詢<br /></li>
<li>語言標準化:不像NoSQL各種資料庫有各自的操作語法，RDBMS都可使用SQL(Structured Querying Language)語言進行資料查詢與管理。<br /></li>
<li>資料庫正規化<br /></li>
<li>安全性高<br /></li>
</ul>
</div>
</li>
<li><a id="org52d807a"></a>DBMS的缺點<br />
<div class="outline-text-6" id="text-org52d807a">
<ul class="org-ul">
<li>橫向擴展能力低，透過垂直擴展比較能發揮優勢，但是成本較高。<br />
<ol class="org-ol">
<li>橫向擴展(Horizontal Scaling)可以想像成增加機器的數量，用不同的機器進行同一個服務，除了減緩單一機器的負擔，也可以避免當單一機器故障時，整個服務就無法使用的狀況。<br /></li>
<li>垂直擴展(Vertical Scaling)在現有的硬體上進行升級，例如升級CPU、增加RAM等。<br /></li>
</ol></li>
<li>儲存與維護成本高<br /></li>
<li>速度較慢，尤其當資料量龐大或多人同時使用服務的時候<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org80c55e9" class="outline-5">
<h5 id="org80c55e9">非關聯式資料庫(NoSQL, Not only SQL)</h5>
<div class="outline-text-5" id="text-org80c55e9">
<ul class="org-ul">
<li>不同於SQL系統，NoSQL中的資料儲存不需要定義schema、也沒有固定架構，不保證ACID的特性，常用於分散式雲端系統。<br /></li>
<li><p>
典型的NOSQL如下列的JSON（JavaScript Object Notation）:<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>[
<span class="linenr"> 2: </span>   {
<span class="linenr"> 3: </span>       <span style="color: #98be65;">"year"</span> : <span style="color: #da8548; font-weight: bold;">2013</span>,
<span class="linenr"> 4: </span>       <span style="color: #98be65;">"title"</span> : <span style="color: #98be65;">"Turn It Down, Or Else!"</span>,
<span class="linenr"> 5: </span>       <span style="color: #98be65;">"info"</span> : {
<span class="linenr"> 6: </span>           <span style="color: #98be65;">"directors"</span> : [ <span style="color: #98be65;">"Alice Smith"</span>, <span style="color: #98be65;">"Bob Jones"</span>],
<span class="linenr"> 7: </span>           <span style="color: #98be65;">"release_date"</span> : <span style="color: #98be65;">"2013-01-18T00:00:00Z"</span>,
<span class="linenr"> 8: </span>           <span style="color: #98be65;">"rating"</span> : <span style="color: #da8548; font-weight: bold;">6.2</span>,
<span class="linenr"> 9: </span>           <span style="color: #98be65;">"genres"</span> : [<span style="color: #98be65;">"Comedy"</span>, <span style="color: #98be65;">"Drama"</span>],
<span class="linenr">10: </span>           <span style="color: #98be65;">"image_url"</span> : <span style="color: #98be65;">"http://ia.media-imdb.com/images/N/O9ERWAU7FS797AJ7LU8HN09AMUP908RLlo5JF90EWR7LJKQ7@@._V1_SX400_.jpg"</span>,
<span class="linenr">11: </span>           <span style="color: #98be65;">"plot"</span> : <span style="color: #98be65;">"A rock band plays their music at high volumes, annoying the neighbors."</span>,
<span class="linenr">12: </span>           <span style="color: #98be65;">"actors"</span> : [<span style="color: #98be65;">"David Matthewman"</span>, <span style="color: #98be65;">"Jonathan G. Neff"</span>]
<span class="linenr">13: </span>       }
<span class="linenr">14: </span>   },
<span class="linenr">15: </span>   {
<span class="linenr">16: </span>       <span style="color: #98be65;">"year"</span>: <span style="color: #da8548; font-weight: bold;">2015</span>,
<span class="linenr">17: </span>       <span style="color: #98be65;">"title"</span>: <span style="color: #98be65;">"The Big New Movie"</span>,
<span class="linenr">18: </span>       <span style="color: #98be65;">"info"</span>: {
<span class="linenr">19: </span>           <span style="color: #98be65;">"plot"</span>: <span style="color: #98be65;">"Nothing happens at all."</span>,
<span class="linenr">20: </span>           <span style="color: #98be65;">"rating"</span>: <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">21: </span>       }
<span class="linenr">22: </span>   }
<span class="linenr">23: </span>]
</pre>
</div></li>
<li>你有看到NOSQL如何儲存二進位的資料（圖片）嗎？很簡單，就是只存網址，這樣一來，圖片、影片這種資料就不用全部存在資料庫中，可以存放在其他檔案伺服器裡，不只彈性大，而且也可以降低資料庫伺服器的網路頻寬負擔，因為客戶在存取圖片或影片時可以由其他檔案伺服器去抓資料。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org10cc1b4"></a>NoSQL的優點<br />
<div class="outline-text-6" id="text-org10cc1b4">
<ul class="org-ul">
<li>橫向擴展能力佳 (Scalability):不必增加伺服器來擴大規模，可以透過分散式架構提供服務，以橫向擴展(Horizontal Scaling)的方式增加效能。<br /></li>
<li>彈性較高 (Flexibility)：NoSQL不像關聯式資料庫需要schema，可以隨意定義資料模型，因此NoSQL可以處理無特定結構或半結構式(semi-structured)的資料<br /></li>
<li>速度優勢：因為NoSQL不包含資料關聯性，查詢速度相對較快。<br /></li>
</ul>
</div>
</li>
<li><a id="orgbfaaa0c"></a>NoSQL的缺點<br />
<div class="outline-text-6" id="text-orgbfaaa0c">
<ul class="org-ul">
<li>資料完整度:不同於關聯式資料庫通常遵循ACID原則 (atomicity, consistency, isolation, durability)以確保資料的完整度，NoSQL較難提供ACID的保證，而是遵循BASE(basic availability, soft state, and eventual consistency) 的原則，並且可能犧牲資料的完整度。<br /></li>
<li>語言標準化:不像關聯式資料庫大多可以使用SQL語言操作，NoSQL不同的資料庫有各自獨特的語言來管理資料。<br /></li>
<li>查詢複雜性：NoSQL針對單一表格的查詢效果佳，但當資料複雜度增加，使用RDBMS的效果會更好。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8345db9" class="outline-4">
<h4 id="org8345db9"><span class="section-number-4">8.2.2.</span> JSON</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
JSON是一種基於文本的數據交換格式，源於JavaScript語言，但已被許多其他編程語言所支持。由於其簡單、易讀的語法和跨平台的兼容性，JSON成為了Web開發中廣泛使用的數據格式，尤其適用於API和AJAX應用。<br />
</p>
</div>
</div>
<div id="outline-container-org3c86aab" class="outline-4">
<h4 id="org3c86aab"><span class="section-number-4">8.2.3.</span> 雲端資料庫</h4>
</div>
<div id="outline-container-org50da19c" class="outline-4">
<h4 id="org50da19c"><span class="section-number-4">8.2.4.</span> Entity-relationship model</h4>
</div>
</div>
<div id="outline-container-orge255b95" class="outline-3">
<h3 id="orge255b95"><span class="section-number-3">8.3.</span> 軟體工程</h3>
<div class="outline-text-3" id="text-8-3">
</div>
<div id="outline-container-orge69c4eb" class="outline-4">
<h4 id="orge69c4eb"><span class="section-number-4">8.3.1.</span> Unit Test</h4>
</div>
</div>
<div id="outline-container-orgce35bd7" class="outline-3">
<h3 id="orgce35bd7"><span class="section-number-3">8.4.</span> AI</h3>
<div class="outline-text-3" id="text-8-4">
</div>
<div id="outline-container-org4ddaff1" class="outline-4">
<h4 id="org4ddaff1"><span class="section-number-4">8.4.1.</span> Turing Machine</h4>
</div>
<div id="outline-container-orgffb7e0c" class="outline-4">
<h4 id="orgffb7e0c"><span class="section-number-4">8.4.2.</span> Turing Test</h4>
</div>
<div id="outline-container-org7853460" class="outline-4">
<h4 id="org7853460"><span class="section-number-4">8.4.3.</span> Cloud Computing</h4>
</div>
<div id="outline-container-org1350820" class="outline-4">
<h4 id="org1350820"><span class="section-number-4">8.4.4.</span> Iot</h4>
</div>
<div id="outline-container-orga1c828d" class="outline-4">
<h4 id="orga1c828d"><span class="section-number-4">8.4.5.</span> supervised learning, unsupervised learning, reinforcement learning。</h4>
</div>
<div id="outline-container-orgd6f6dc6" class="outline-4">
<h4 id="orgd6f6dc6"><span class="section-number-4">8.4.6.</span> 計算梯度下降</h4>
</div>
</div>
<div id="outline-container-org9118d1f" class="outline-3">
<h3 id="org9118d1f"><span class="section-number-3">8.5.</span> 資管</h3>
<div class="outline-text-3" id="text-8-5">
</div>
<div id="outline-container-org3a72779" class="outline-4">
<h4 id="org3a72779"><span class="section-number-4">8.5.1.</span> Information security management</h4>
</div>
</div>
<div id="outline-container-orga6f348c" class="outline-3">
<h3 id="orga6f348c"><span class="section-number-3">8.6.</span> 其他</h3>
<div class="outline-text-3" id="text-8-6">
</div>
<div id="outline-container-org24773ab" class="outline-4">
<h4 id="org24773ab"><span class="section-number-4">8.6.1.</span> 區塊鏈</h4>
</div>
<div id="outline-container-org4210e18" class="outline-4">
<h4 id="org4210e18"><span class="section-number-4">8.6.2.</span> RSA 加密</h4>
</div>
<div id="outline-container-org2e8478c" class="outline-4">
<h4 id="org2e8478c"><span class="section-number-4">8.6.3.</span> 開源/閉源軟體</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Yung-Chin Yen</p>
<p class="date">Created: 2025-01-29 Wed 00:59</p>
</div>
</body>
</html>
