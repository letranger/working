<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-01-30 Thu 21:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>James Exam</title>
<meta name="author" content="Yung-Chin Yen" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/muse.css" />
<script src="../css/copy_code.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">James Exam</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org71cde86">1. 中央近五年計概</a>
<ul>
<li><a href="#org1051314">1.1. prompt</a></li>
<li><a href="#orgcc9d846">1.2. 108</a></li>
</ul>
</li>
<li><a href="#org156f063">2. 中山近三年考題及詳解</a>
<ul>
<li><a href="#orga7f4fa3">2.1. 110: 中山管理資訊系統</a></li>
<li><a href="#orga6614d3">2.2. 110: 中山資料結構</a></li>
<li><a href="#orgcea18b9">2.3. 110: 中山資料結構</a></li>
<li><a href="#orgef5944e">2.4. 110: 中山計概</a></li>
<li><a href="#orgae76f3e">2.5. 110: 中山計概</a></li>
<li><a href="#orgbb4d167">2.6. 111: 中山計概</a></li>
<li><a href="#orgde2fc18">2.7. 111: 管理資訊系統</a></li>
<li><a href="#org5d5fa8f">2.8. 111: 資料結構：</a></li>
<li><a href="#org12a60ca">2.9. 112: 中山計概</a></li>
<li><a href="#org1fa9f09">2.10. 112: 中山管資</a></li>
<li><a href="#org4bb6bcf">2.11. 112: 中山資結</a></li>
</ul>
</li>
<li><a href="#orgb0d2953">3. 中山</a>
<ul>
<li><a href="#org469e70c">3.1. 近10年趨勢</a></li>
<li><a href="#org0d6f150">3.2. AI模擬試題</a></li>
<li><a href="#orge4af615">3.3. 參考答案</a></li>
</ul>
</li>
<li><a href="#orga10b03c">4. 中興</a>
<ul>
<li><a href="#org622e6da">4.1. 近10年趨勢</a></li>
<li><a href="#org834b735">4.2. AI模擬試題</a></li>
<li><a href="#org86414c0">4.3. 詳細解說答案</a></li>
</ul>
</li>
<li><a href="#orgcbc5753">5. 清大</a>
<ul>
<li><a href="#org04d3c86">5.1. 近10年趨勢</a></li>
<li><a href="#org1050a99">5.2. AI模擬試題</a></li>
<li><a href="#org9ef418e">5.3. 詳細解答：</a></li>
</ul>
</li>
<li><a href="#orgfbbc43a">6. 成大</a>
<ul>
<li><a href="#org85a42a8">6.1. 近10年趨勢</a></li>
<li><a href="#org9abd805">6.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#orgac22d59">7. 中央</a>
<ul>
<li><a href="#org731d61c">7.1. 近10年趨勢</a></li>
<li><a href="#org1ec35bb">7.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#orgeb4d8ac">8. 北大</a>
<ul>
<li><a href="#org505f932">8.1. 近10年趨勢</a></li>
<li><a href="#org25a5172">8.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#org735c305">9. 林北的考前猜題</a>
<ul>
<li><a href="#org82bb992">9.1. 網路</a></li>
<li><a href="#orgcba5174">9.2. 資料庫</a></li>
<li><a href="#orgff463cc">9.3. 軟體工程</a></li>
<li><a href="#org9764a65">9.4. AI</a></li>
<li><a href="#org7407b61">9.5. 資管</a></li>
<li><a href="#org1159f46">9.6. 其他</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org71cde86" class="outline-2">
<h2 id="org71cde86"><span class="section-number-2">1.</span> 中央近五年計概</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org1051314" class="outline-3">
<h3 id="org1051314"><span class="section-number-3">1.1.</span> prompt</h3>
<div class="outline-text-3" id="text-1-1">
<pre class="example" id="orga1e0550">
提供中文詳解，並列出與該主題相關的計概知識，讓考生能對與該主題相關的計概有完整認識，方便準備研究所考試
</pre>
</div>
</div>
<div id="outline-container-orgcc9d846" class="outline-3">
<h3 id="orgcc9d846"><span class="section-number-3">1.2.</span> 108</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org034302a" class="outline-4">
<h4 id="org034302a"><span class="section-number-4">1.2.1.</span> 第一大題 (25分)：解釋名詞，每小題5分，共25分</h4>
<div class="outline-text-4" id="text-1-2-1">
</div>
<div id="outline-container-org87e151e" class="outline-5">
<h5 id="org87e151e">DSSS (Direct Sequence Spread Spectrum)</h5>
<div class="outline-text-5" id="text-org87e151e">
</div>
<ul class="org-ul">
<li><a id="org7c3516d"></a>解<br />
<div class="outline-text-6" id="text-org7c3516d">
<p>
直接序列展頻技術（DSSS）是一種擴頻通信技術，用於提高無線通信的抗干擾能力。DSSS 的基本原理是將原始信號與較高頻率的偽隨機碼（Pseudo-random Noise, PN）相乘，使訊號頻譜擴展到比原來更寬的頻帶，然後再透過接收端的同步解碼還原出原始訊號。<br />
</p>
</div>
</li>
<li><a id="org532aa47"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org532aa47">
<ul class="org-ul">
<li>擴頻技術（Spread Spectrum）：除 DSSS 外，還有 FHSS（Frequency Hopping Spread Spectrum，跳頻擴頻）。<br /></li>
<li>CDMA（Code Division Multiple Access）：DSSS 技術是 CDMA 的基礎，允許多個使用者同時傳輸數據，而不互相干擾。<br /></li>
<li>訊號調變技術：如 BPSK（Binary Phase Shift Keying）、QPSK（Quadrature Phase Shift Keying）。<br /></li>
<li>無線網路標準：IEEE 802.11b 採用 DSSS 作為主要的傳輸技術。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgd008a3c" class="outline-5">
<h5 id="orgd008a3c">PCM (Pulse-Code Modulation)</h5>
<div class="outline-text-5" id="text-orgd008a3c">
</div>
<ul class="org-ul">
<li><a id="org08269a1"></a>解<br />
<div class="outline-text-6" id="text-org08269a1">
<p>
脈衝編碼調變（PCM）是一種數位訊號編碼技術，將類比訊號（如聲音）轉換為數位訊號的標準方法。PCM 主要經歷三個步驟：<br />
</p>
<ul class="org-ul">
<li>取樣（Sampling）：按照奈奎斯特定理（Nyquist Theorem），以至少兩倍於訊號最大頻率的取樣率，將連續的類比訊號離散化。<br /></li>
<li>量化（Quantization）：將取樣值對應到有限數目的數值，使訊號可用有限比特表示。<br /></li>
<li>編碼（Encoding）：將量化後的訊號轉換為二進位碼，方便數位傳輸與存儲。<br /></li>
</ul>
</div>
</li>
<li><a id="orgc24daa9"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-orgc24daa9">
<ul class="org-ul">
<li>類比與數位訊號：比較類比訊號與數位訊號的特性。<br /></li>
<li>取樣定理（Sampling Theorem）：奈奎斯特定理是 PCM 設計的重要依據。<br /></li>
<li>數位音訊格式：如 WAV、MP3、AAC，均基於 PCM 或其變種。<br /></li>
<li>音訊壓縮技術：如 μ-law 和 A-law 是 PCM 的變體，常見於電話通訊。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org07fd204" class="outline-5">
<h5 id="org07fd204">VLAN (Virtual Local Area Network)</h5>
<div class="outline-text-5" id="text-org07fd204">
</div>
<ul class="org-ul">
<li><a id="orgf67c07d"></a>解<br />
<div class="outline-text-6" id="text-orgf67c07d">
<p>
虛擬區域網路（VLAN）是一種透過邏輯分割網路的技術，即使裝置連接在同一台交換機，也能透過 VLAN 區分不同網段，提升網路安全性與管理性。VLAN 的主要特性包括：<br />
</p>
<ul class="org-ul">
<li>邏輯分割網路：可以將不同部門或用途的設備分隔，即使它們在相同的物理網路內。<br /></li>
<li>降低廣播流量：VLAN 可防止廣播訊息影響不相關的裝置，提升網路效能。<br /></li>
<li>增強安全性：不同 VLAN 之間的流量通常需要透過路由器或防火牆管控。<br /></li>
</ul>
</div>
</li>
<li><a id="org0b63880"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org0b63880">
<ul class="org-ul">
<li>區域網路（LAN）技術：Ethernet、Wi-Fi 與 LAN 設計概念。<br /></li>
<li>網路層級架構：OSI 模型中 VLAN 屬於第二層（資料鏈結層）。<br /></li>
<li>交換機（Switch）技術：VLAN 主要由管理型交換機（Managed Switch）實現。<br /></li>
<li>802.1Q 標準：VLAN 標記技術，允許一條連接傳輸多個 VLAN。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgaed4d12" class="outline-5">
<h5 id="orgaed4d12">DMZ (Demilitarized Zone)</h5>
<div class="outline-text-5" id="text-orgaed4d12">
</div>
<ul class="org-ul">
<li><a id="orgd2d1db5"></a>解<br />
<div class="outline-text-6" id="text-orgd2d1db5">
<p>
非軍事區（DMZ） 是網路架構中一個受控的區域，通常位於內部網路（LAN）與外部網路（如 Internet）之間，主要用於公開提供網路服務，如 Web 伺服器、郵件伺服器或 DNS 伺服器。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0cada76"></a>DMZ 的設計<br />
<div class="outline-text-7" id="text-org0cada76">
<ul class="org-ul">
<li>隔離內部網路：外部使用者只能存取 DMZ 內的服務，無法直接進入內部 LAN。<br /></li>
<li>防火牆控制：DMZ 透過防火牆規則限制內部與外部的存取權限。<br /></li>
<li>雙防火牆架構：<br />
<ul class="org-ul">
<li>單防火牆 DMZ：使用一台防火牆區分內網、DMZ 與外部網路。<br /></li>
<li>雙防火牆 DMZ：外部防火牆限制 Internet 存取 DMZ，內部防火牆限制 DMZ 存取內部網路，安全性更高。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org0656faa"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org0656faa">
<ul class="org-ul">
<li>網路安全技術：如防火牆（Firewall）、入侵偵測系統（IDS）、入侵防禦系統（IPS）。<br /></li>
<li>TCP/IP 及網路服務：如 HTTP、HTTPS、DNS 及其安全性。<br /></li>
<li>VPN（Virtual Private Network）：透過 VPN 提供安全的遠端存取，但需要正確配置 DMZ 來管理 VPN 存取控制。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgaec8ef4"></a>入侵偵測系統（IDS - Intrusion Detection System）<br />
<div class="outline-text-7" id="text-orgaec8ef4">
<p>
概念與功能 入侵偵測系統（IDS）是一種監控網路或系統活動，以檢測可疑行為或潛在攻擊的安全設備。其主要目的是發現並告警潛在的安全威脅，而不會自動採取行動阻止攻擊。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgbe241d4"></a>IDS 的分類<br />
<div class="outline-text-8" id="text-orgbe241d4">
<ul class="org-ul">
<li>網路型 IDS（NIDS - Network-based IDS）<br />
<ul class="org-ul">
<li>部署於網路節點（如路由器、交換機），監控整個網路的流量。<br /></li>
<li>優點：可全面監控網路中的所有通信。<br /></li>
<li>缺點：難以檢測加密通信內的攻擊。<br /></li>
</ul></li>
<li>主機型 IDS（HIDS - Host-based IDS）<br />
<ul class="org-ul">
<li>部署於單一主機或伺服器，監控該主機的操作與系統日誌。<br /></li>
<li>優點：能夠檢測主機內部的異常活動，如未經授權的文件修改。<br /></li>
<li>缺點：僅限於監控所在主機，無法偵測其他網路活動。<br /></li>
</ul></li>
</ul>
<p>
偵測方法<br />
</p>
<ul class="org-ul">
<li>特徵匹配（Signature-based Detection）<br />
<ul class="org-ul">
<li>利用已知攻擊的特徵（如病毒碼、特定封包模式）進行比對。<br /></li>
<li>優點：準確率高，對已知威脅反應迅速。<br /></li>
<li>缺點：無法偵測新型或未知攻擊。<br /></li>
</ul></li>
<li>異常偵測（Anomaly-based Detection）<br />
<ul class="org-ul">
<li>建立正常行為的基準（Baseline），並檢測異常行為。<br /></li>
<li>優點：能夠發現未知或新型攻擊。<br /></li>
<li>缺點：誤報率高，需定期更新基準。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org51fed7e"></a>入侵防禦系統（IPS - Intrusion Prevention System）<br />
<div class="outline-text-7" id="text-org51fed7e">
<p>
概念與功能 入侵防禦系統（IPS）是一種在偵測攻擊的同時，自動採取行動以防止攻擊成功的安全設備。與 IDS 不同，IPS 具有主動防禦功能。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgb8c1f50"></a>IPS 的類型<br />
<div class="outline-text-8" id="text-orgb8c1f50">
<ul class="org-ul">
<li>網路型 IPS（NIPS - Network-based IPS）<br />
<ul class="org-ul">
<li>部署於網路邊界，主動攔截和阻止惡意流量。<br /></li>
<li>常見於企業網路邊界，以阻擋外部攻擊。<br /></li>
</ul></li>
<li>主機型 IPS（HIPS - Host-based IPS）<br />
<ul class="org-ul">
<li>部署於單一主機或伺服器，針對該主機的攻擊進行防禦。<br /></li>
<li>適用於高敏感性資料伺服器或關鍵基礎設施。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf405f54"></a>防禦策略<br />
<div class="outline-text-8" id="text-orgf405f54">
<ul class="org-ul">
<li>封包過濾（Packet Filtering）<br />
<ul class="org-ul">
<li>根據封包內容或規則集直接丟棄惡意封包。<br /></li>
</ul></li>
<li>連線重置（Connection Reset）<br />
<ul class="org-ul">
<li>主動終止攻擊者與受害者之間的連線。<br /></li>
</ul></li>
<li>警報與記錄（Alerting and Logging）<br />
<ul class="org-ul">
<li>在防禦攻擊的同時，發送警報並記錄相關資訊供事後分析。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgdd3a2d7"></a>IPS 的挑戰<br />
<div class="outline-text-8" id="text-orgdd3a2d7">
<ul class="org-ul">
<li>需在不影響合法流量的情況下，迅速阻擋惡意行為。<br /></li>
<li>調整錯誤或過於嚴格的規則可能導致合法操作被誤判為攻擊。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org9f74d20" class="outline-5">
<h5 id="org9f74d20">CDN (Content Delivery Network)</h5>
<div class="outline-text-5" id="text-org9f74d20">
<p>
非軍事區（DMZ） 是網路架構中一個受控的區域，通常位於內部網路（LAN）與外部網路（如 Internet）之間，主要用於公開提供網路服務，如 Web 伺服器、郵件伺服器或 DNS 伺服器。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org3da28dc"></a>DMZ 的設計<br />
<div class="outline-text-6" id="text-org3da28dc">
<ul class="org-ul">
<li>隔離內部網路：外部使用者只能存取 DMZ 內的服務，無法直接進入內部 LAN。<br /></li>
<li>防火牆控制：DMZ 透過防火牆規則限制內部與外部的存取權限。<br /></li>
<li>雙防火牆架構：<br />
<ul class="org-ul">
<li>單防火牆 DMZ：使用一台防火牆區分內網、DMZ 與外部網路。<br /></li>
<li>雙防火牆 DMZ：外部防火牆限制 Internet 存取 DMZ，內部防火牆限制 DMZ 存取內部網路，安全性更高。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org9fb1117"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org9fb1117">
<ul class="org-ul">
<li>網路安全技術：如防火牆（Firewall）、入侵偵測系統（IDS）、入侵防禦系統（IPS）。<br /></li>
<li>TCP/IP 及網路服務：如 HTTP、HTTPS、DNS 及其安全性。<br /></li>
<li>VPN（Virtual Private Network）：透過 VPN 提供安全的遠端存取，但需要正確配置 DMZ 來管理 VPN 存取控制。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgcbf7053" class="outline-4">
<h4 id="orgcbf7053"><span class="section-number-4">1.2.2.</span> 第二大題 (10分)：</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
在Relational Database裡，每個Table基本上都會有一欄當做Primary Key。許多情況下常使用auto increment 或UUID當作Primary Key，並列舉說明這樣做為primary key的優缺點<br />
</p>
</div>
<div id="outline-container-org771f797" class="outline-5">
<h5 id="org771f797">解</h5>
<div class="outline-text-5" id="text-org771f797">
<p>
在關聯式資料庫（Relational Database, RDB）中，每個表（Table）通常都有一個主鍵（Primary Key, PK）來唯一標識每一筆記錄。常見的 PK 產生方式有兩種：<br />
</p>
<ul class="org-ul">
<li>Auto Increment（自動遞增）<br /></li>
<li>UUID（通用唯一識別碼，Universally Unique Identifier）<br /></li>
</ul>
<p>
這兩種方式各有優缺點，在不同的應用場景下選擇合適的 PK 類型至關重要。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7bb8c58"></a>Auto Increment 作為 Primary Key<br />
<div class="outline-text-6" id="text-org7bb8c58">
<p>
Auto Increment 是一種常見的主鍵生成方式，資料庫會自動為新插入的資料分配一個遞增的數值。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>CREATE <span style="color: #ECBE7B;">TABLE</span> <span style="color: #c678dd;">users</span> (
<span class="linenr">2: </span>    id INT AUTO_INCREMENT <span style="color: #ECBE7B;">PRIMARY</span> <span style="color: #dcaeea;">KEY</span>,
<span class="linenr">3: </span>    <span style="color: #ECBE7B;">name</span> <span style="color: #dcaeea;">VARCHAR</span>(<span style="color: #da8548; font-weight: bold;">255</span>),
<span class="linenr">4: </span>    <span style="color: #ECBE7B;">email</span> <span style="color: #dcaeea;">VARCHAR</span>(<span style="color: #da8548; font-weight: bold;">255</span>)
<span class="linenr">5: </span>);
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgbf60b13"></a>優點<br />
<div class="outline-text-7" id="text-orgbf60b13">
<ul class="org-ul">
<li>✅ 數值型索引效率高: 整數（INT, BIGINT）索引比字串（UUID）索引快，搜尋、排序、JOIN 操作效率較高。<br />
B+ 樹索引（如 InnoDB）適用遞增值，有助於保持索引的平衡與效能。<br /></li>
<li>✅ 空間效率高: 整數通常比 UUID 佔用的空間小（INT 佔 4 Bytes，BIGINT 佔 8 Bytes，而 UUID 通常為 16 Bytes）。<br /></li>
<li><p>
✅ 易讀性高: 記錄 ID 連續遞增，方便查詢與理解，例如：<br />
</p>
<pre class="example" id="org5b6bb77">
  User ID: 1, 2, 3, 4, 5
</pre></li>
<li>✅ INSERT 操作更高效: 自增 ID 讓 INSERT 操作集中在索引的最後一個位置，降低分裂索引頁的機率，提高寫入效能。<br /></li>
</ul>
</div>
</li>
<li><a id="org87aa517"></a>缺點<br />
<div class="outline-text-7" id="text-org87aa517">
<ul class="org-ul">
<li>❌ 複製數據時可能會有 ID 衝突: 例如，將資料從一個數據庫複製到另一個時，兩邊的 ID 可能重複，導致衝突，特別是在分布式環境下。<br /></li>
<li>❌ 容易被猜測: 由於 ID 遞增，攻擊者可以預測下一筆記錄的 ID，進行 ID 爬取攻擊（如：/user/123、/user/124&#x2026;）。<br /></li>
<li>❌ 在分布式系統中擴展性較差: 在多個節點的數據庫中，確保不同節點間的 ID 唯一性需要額外的處理，例如透過 分區自增 ID 或 雪花算法（Snowflake ID） 來解決。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgcf06f77"></a>UUID 作為 Primary Key<br />
<div class="outline-text-6" id="text-orgcf06f77">
<p>
UUID（通用唯一識別碼） 是一種全球唯一識別碼，格式通常為 36 個字元（包含 -）。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>CREATE <span style="color: #ECBE7B;">TABLE</span> <span style="color: #c678dd;">users</span> (
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">id</span> <span style="color: #dcaeea;">CHAR</span>(<span style="color: #da8548; font-weight: bold;">36</span>) <span style="color: #ECBE7B;">PRIMARY</span> <span style="color: #dcaeea;">KEY</span>,
<span class="linenr">3: </span>    <span style="color: #dcaeea;">name</span> VARCHAR(<span style="color: #da8548; font-weight: bold;">255</span>),
<span class="linenr">4: </span>    <span style="color: #dcaeea;">email</span> VARCHAR(<span style="color: #da8548; font-weight: bold;">255</span>)
<span class="linenr">5: </span>);
</pre>
</div>
<p>
UUID 主要有幾種類型：<br />
</p>
<ul class="org-ul">
<li>UUID v1：基於時間戳與機器 MAC 位址，適合時間順序排序。<br /></li>
<li>UUID v4：完全隨機生成，無法預測，適合隱私需求高的應用。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orga07cf38"></a>優點<br />
<div class="outline-text-7" id="text-orga07cf38">
<ul class="org-ul">
<li>✅ 唯一性強: UUID 透過算法生成，即使在不同伺服器或資料庫節點，也能保證唯一性，適合 分布式架構 或 微服務。<br /></li>
<li>✅ 不易被猜測: 由於 UUID 並非連續數值，不容易被攻擊者預測，提升安全性。<br /></li>
<li>✅ 資料合併與同步更方便: 在多個資料來源合併時，不需要擔心主鍵衝突，適合 分布式資料庫 或 資料同步系統。<br /></li>
<li>✅ 支援跨伺服器生成: 例如，在微服務架構中，每個服務可以獨立生成 UUID，而不需要查詢數據庫獲取 ID。<br /></li>
</ul>
</div>
</li>
<li><a id="orgc0deff9"></a>缺點<br />
<div class="outline-text-7" id="text-orgc0deff9">
<ul class="org-ul">
<li>❌ 索引效能較差: UUID 是 字串（CHAR(36)） 或 16 Bytes 二進制數據（BINARY(16)），比起 整數（INT, BIGINT） 更佔空間，影響索引效能。<br /></li>
<li>❌ 存儲成本高: UUID 以 字串存儲（36 Bytes）或 二進制存儲（16 Bytes），相較於 INT（4 Bytes）或 BIGINT（8 Bytes），存儲效率較低。<br /></li>
<li>❌ 讀取效率較低: UUID 的隨機性會導致 索引分裂（Index Fragmentation），影響數據檢索效能，特別是在 B+ 樹索引 中。<br /></li>
<li><p>
❌ 可讀性差: UUID 難以手動輸入、理解和比較，例如：<br />
</p>
<pre class="example" id="orgb6c95d5">
  550e8400-e29b-41d4-a716-446655440000
</pre></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org0e84abf"></a>Auto Increment vs UUID 選擇指南<br />
<div class="outline-text-6" id="text-org0e84abf">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">Auto Increment</th>
<th scope="col" class="org-left">UUID</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">唯一性</td>
<td class="org-left">只在單一資料庫唯一</td>
<td class="org-left">全球唯一</td>
</tr>

<tr>
<td class="org-left">索引效能</td>
<td class="org-left">高（整數索引效率佳）</td>
<td class="org-left">低（UUID 影響索引）</td>
</tr>

<tr>
<td class="org-left">存儲空間</td>
<td class="org-left">小（INT: 4 Bytes, BIGINT: 8 Bytes）</td>
<td class="org-left">大（CHAR(36): 36 Bytes, BINARY(16): 16 Bytes）</td>
</tr>

<tr>
<td class="org-left">INSERT 效能</td>
<td class="org-left">佳（遞增 ID 避免索引分裂）</td>
<td class="org-left">差（UUID 隨機性導致索引分裂）</td>
</tr>

<tr>
<td class="org-left">可讀性</td>
<td class="org-left">佳（1, 2, 3&#x2026;）</td>
<td class="org-left">差（550e8400-e29b&#x2026;）</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">易猜測、可被爬取</td>
<td class="org-left">不易猜測、較安全</td>
</tr>

<tr>
<td class="org-left">分布式支持</td>
<td class="org-left">需要特殊設計（如雪花算法）</td>
<td class="org-left">天生適合</td>
</tr>
</tbody>
</table>
</div>
<ul class="org-ul">
<li><a id="orgbed0e10"></a>適用場景<br />
<div class="outline-text-7" id="text-orgbed0e10">
<ul class="org-ul">
<li>✅ Auto Increment 適用於<br />
<ul class="org-ul">
<li>傳統單節點數據庫<br /></li>
<li>需要高效能查詢的應用（如報表、統計系統）<br /></li>
<li>需要可讀性佳的流水號（如訂單號）<br /></li>
</ul></li>
<li>✅ UUID 適用於<br />
<ul class="org-ul">
<li>分布式系統（如微服務架構、跨資料庫同步）<br /></li>
<li>安全性要求高的應用（如 API Token、用戶識別碼）<br /></li>
<li>避免 ID 爬取攻擊（防止猜測 ID）<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org62776e4" class="outline-4">
<h4 id="org62776e4"><span class="section-number-4">1.2.3.</span> 第三大題 (3分)：</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
簡單說明什麼是SQL Injection<br />
</p>
</div>
<div id="outline-container-org1d5d7a5" class="outline-5">
<h5 id="org1d5d7a5">解</h5>
<div class="outline-text-5" id="text-org1d5d7a5">
<p>
SQL Injection（SQL 注入攻擊） 是一種 攻擊者利用惡意 SQL 語句操控資料庫 的攻擊方式。這類攻擊通常發生於 應用程式未對使用者輸入進行適當驗證，導致攻擊者可以插入惡意 SQL 查詢，進而竊取、修改、刪除數據，甚至控制整個資料庫。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org72b7afe"></a>SQL Injection 的運作原理<br />
<div class="outline-text-6" id="text-org72b7afe">
<p>
當應用程式直接將 使用者輸入 插入 SQL 查詢時，若未經適當處理，攻擊者就能惡意構造輸入，使 SQL 語句的行為偏離預期。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org72f4c96"></a>❌ 例：不安全的 SQL 查詢<br />
<div class="outline-text-7" id="text-org72f4c96">
<p>
假設一個網站的登入系統接收使用者輸入的 帳號（username） 和 密碼（password），然後執行以下 SQL 語句：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">'</span><span style="color: #da8548; font-weight: bold;">123456</span><span style="color: #ECBE7B;">'</span>;
</pre>
</div>
<p>
如果程式直接將使用者輸入拼接到 SQL 查詢：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>query = <span style="color: #98be65;">"SELECT * FROM users WHERE username = '"</span> + user_input + <span style="color: #98be65;">"' AND password = '"</span> + password_input + <span style="color: #98be65;">"';"</span>
</pre>
</div>
<p>
攻擊者可以輸入：<br />
</p>
<ul class="org-ul">
<li>帳號：admin&rsquo; &#x2013;<br /></li>
<li>密碼：任何內容（因為後面會被註解掉）<br /></li>
</ul>
<p>
最終 SQL 語句變為：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> -- <span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">'</span><span style="color: #da8548; font-weight: bold;">123456</span><span style="color: #ECBE7B;">'</span>;
</pre>
</div>
<p>
其中 &#x2013; 是 SQL 的註解符號，使後面的 AND password = &rsquo;123456&rsquo; 變成註解，導致登入密碼檢查被繞過，攻擊者可以直接登入 admin 帳號。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgf03df18"></a>SQL Injection 的類型<br />
<div class="outline-text-6" id="text-orgf03df18">
<p>
SQL 注入攻擊的類型可分為幾種：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org2a59e46"></a>（1）Classic SQL Injection（傳統 SQL 注入）<br />
<div class="outline-text-7" id="text-org2a59e46">
<ul class="org-ul">
<li>利用 &rsquo; OR &rsquo;1&rsquo;=&rsquo;1 之類的條件繞過身份驗證。<br /></li>
<li>目標：繞過登入、讀取資料庫內容。<br /></li>
</ul>
<p>
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">''</span> OR <span style="color: #98be65;">'1'</span>=<span style="color: #98be65;">'1'</span> -- <span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">''</span>;
</pre>
</div>

<p>
此語句總是成立，導致所有使用者的資訊被查詢出來。<br />
</p>
</div>
</li>
<li><a id="org2c32378"></a>（2）Blind SQL Injection（盲目 SQL 注入）<br />
<div class="outline-text-7" id="text-org2c32378">
<p>
當應用程式不直接顯示錯誤訊息時，攻擊者可以透過邏輯推測資料庫的內容。<br />
常見技術<br />
</p>
<ul class="org-ul">
<li>布林盲注（Boolean-Based Blind SQL Injection）：攻擊者觀察網頁回應變化來判斷條件是否成立。<br /></li>
<li>時間盲注（Time-Based Blind SQL Injection）：利用 SLEEP() 來判斷資料庫是否執行了攻擊語句。<br /></li>
</ul>

<p>
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> AND IF(LENGTH(password)&gt;<span style="color: #da8548; font-weight: bold;">6</span>, SLEEP(<span style="color: #da8548; font-weight: bold;">5</span>), <span style="color: #da8548; font-weight: bold;">0</span>);
</pre>
</div>
<p>
如果 password 長度大於 6，查詢執行時間會延遲 5 秒，攻擊者可據此推測密碼長度。<br />
</p>
</div>
</li>
<li><a id="orga983827"></a>（3）Union-Based SQL Injection（聯合查詢 SQL 注入）<br />
<div class="outline-text-7" id="text-orga983827">
<p>
利用 UNION 語法將攻擊者的查詢結果與原查詢結果合併，竊取資料。<br />
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">SELECT</span> <span style="color: #dcaeea;">username</span>, <span style="color: #dcaeea;">password</span> FROM users WHERE id = <span style="color: #da8548; font-weight: bold;">1</span> UNION SELECT database(), <span style="color: #c678dd;">version</span>();
</pre>
</div>
<p>
如果應用程式回傳查詢結果，攻擊者可獲得資料庫名稱與版本資訊。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orga80f305"></a>3. SQL Injection 的影響<br />
<div class="outline-text-6" id="text-orga80f305">
<p>
SQL Injection 可能造成：<br />
</p>
<ul class="org-ul">
<li>未授權存取：攻擊者可以繞過登入系統，獲取管理員權限。<br /></li>
<li>資料竊取：攻擊者可讀取敏感資訊，如 用戶名、密碼、信用卡資訊。<br /></li>
<li>資料修改或刪除：攻擊者可刪除資料表或修改重要數據。<br /></li>
<li>系統破壞：透過 DROP TABLE 或 執行系統命令（在支援 xp_cmdshell 的 SQL Server 上）。<br /></li>
<li>進一步攻擊：攻擊者可植入惡意程式、取得伺服器控制權。<br /></li>
</ul>
</div>
</li>
<li><a id="org5dc3944"></a>4. 防範 SQL Injection<br />
<ul class="org-ul">
<li><a id="org2be4bbb"></a>✅ （1）使用 Prepared Statements（預處理語句）<br />
<div class="outline-text-7" id="text-org2be4bbb">
<p>
預防 SQL Injection 最有效的方法之一是 使用 Prepared Statements，確保 SQL 語句的結構不被用戶輸入影響。<br />
Python + MySQL<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>cursor.execute(<span style="color: #98be65;">"SELECT * FROM users WHERE username = %s AND password = %s"</span>, (username, password))
</pre>
</div>
<p>
這樣 username 和 password 會被安全地當作參數處理，而不會改變 SQL 結構。<br />
</p>
</div>
</li>
<li><a id="org7b91b35"></a>✅ （2）使用 ORM（Object-Relational Mapping）<br />
<div class="outline-text-7" id="text-org7b91b35">
<p>
ORM 框架（如 Django ORM、SQLAlchemy）內建安全機制，減少直接寫 SQL 語句的風險。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>User.objects.filter(username=username, password=password).first()
</pre>
</div>
</div>
</li>
<li><a id="orgf7818c8"></a>✅ （3）輸入驗證（Input Validation）<br />
<div class="outline-text-7" id="text-orgf7818c8">
<p>
限制使用者輸入的格式，拒絕包含 SQL 語法的輸入：<br />
</p>
<ul class="org-ul">
<li>過濾特殊字元（如 &rsquo;, ", &#x2013;, ;, /* */）。<br /></li>
<li>強制數字輸入（如 ID 應只能是數字）。<br /></li>
</ul>
</div>
</li>
<li><a id="org2e28c47"></a>✅ （4）最小權限原則（Least Privilege Principle）<br />
<div class="outline-text-7" id="text-org2e28c47">
<p>
應用程式使用的 資料庫帳號應有最小權限，例如：<br />
</p>
<ul class="org-ul">
<li>讀取操作：只授權 SELECT。<br /></li>
<li>寫入操作：只授權 INSERT、UPDATE，避免 DROP、DELETE。<br /></li>
</ul>
</div>
</li>
<li><a id="org59b6889"></a>✅ （5）使用 Web Application Firewall（WAF）<br />
<div class="outline-text-7" id="text-org59b6889">
<p>
WAF（網頁應用程式防火牆） 可攔截 SQL Injection 攻擊，如 ModSecurity 可偵測 SQL 注入模式。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge7bec6d" class="outline-4">
<h4 id="orge7bec6d"><span class="section-number-4">1.2.4.</span> 第四大題 (12分)：</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
列舉與說明三個防範 SQL Injection 的方法<br />
</p>
</div>
<div id="outline-container-orgc76005e" class="outline-5">
<h5 id="orgc76005e">解</h5>
<div class="outline-text-5" id="text-orgc76005e">
<p>
SQL Injection（SQL 注入）是一種嚴重的安全漏洞，攻擊者可以透過惡意 SQL 語句操控資料庫。為了防止 SQL Injection，開發者應該採取以下 三種主要防範方法：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org72bd4bf"></a>1. 使用 Prepared Statements（預處理語句）<br />
<div class="outline-text-6" id="text-org72bd4bf">
<p>
📌 原理: Prepared Statements（預處理語句）可確保使用者輸入的數據不會影響 SQL 語句的結構，而是作為純粹的參數處理。這種方式會將 SQL 語句與數據分開處理，避免惡意 SQL 語句被執行。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7b900a5"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-org7b900a5">
<p>
Python（MySQL）<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">import</span> mysql.connector
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #dcaeea;">conn</span> = mysql.connector.connect(user=<span style="color: #98be65;">'root'</span>, password=<span style="color: #98be65;">'password'</span>, database=<span style="color: #98be65;">'test_db'</span>)
<span class="linenr">4: </span><span style="color: #dcaeea;">cursor</span> = conn.cursor(prepared=<span style="color: #a9a1e1;">True</span>)
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = %s AND password = %s"</span>
<span class="linenr">7: </span>cursor.execute(query, (username, password))
<span class="linenr">8: </span>
<span class="linenr">9: </span><span style="color: #dcaeea;">result</span> = cursor.fetchall()
</pre>
</div>
<p>
PHP（PDO）<br />
</p>
<div class="org-src-container">
<pre class="src src-php"><span class="linenr">1: </span>$<span style="color: #dcaeea;">stmt</span> = $<span style="color: #dcaeea;">pdo</span>-&gt;prepare<span style="color: #51afef;">(</span><span style="color: #98be65;">"SELECT * FROM users WHERE username = ? AND password = ?"</span><span style="color: #51afef;">)</span>;
<span class="linenr">2: </span>$<span style="color: #dcaeea;">stmt</span>-&gt;execute<span style="color: #51afef;">(</span><span style="color: #c678dd;">[</span>$<span style="color: #dcaeea;">username</span>, $<span style="color: #dcaeea;">password</span><span style="color: #c678dd;">]</span><span style="color: #51afef;">)</span>;
</pre>
</div>
<p>
這樣，即使攻擊者輸入 admin&rsquo; &#x2013;，數據庫也會將其視為 字串參數，而不是 SQL 語法，從而防止 SQL Injection。<br />
</p>
</div>
</li>
<li><a id="orgb46c361"></a>❌ 錯誤做法（易受 SQL Injection 攻擊）<br />
<div class="outline-text-7" id="text-orgb46c361">
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = '"</span> + username + <span style="color: #98be65;">"' AND password = '"</span> + password + <span style="color: #98be65;">"';"</span>
<span class="linenr">2: </span>cursor.execute(query)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#30452;&#25509;&#25340;&#25509; SQL&#65292;&#23481;&#26131;&#36973;&#21463;&#25915;&#25802;&#65281;</span>
</pre>
</div>
</div>
</li>
<li><a id="org0ca5ea4"></a>🔹 優點<br />
<div class="outline-text-7" id="text-org0ca5ea4">
<ul class="org-ul">
<li>✔ 完全防止 SQL Injection，因為 SQL 語句與數據分開處理<br /></li>
<li>✔ 可讀性高，寫法標準化，適用於各種程式語言（Python、Java、PHP）<br /></li>
<li>✔ 提升效能，因為 SQL 只需解析一次，之後只需替換變數<br /></li>
</ul>
</div>
</li>
<li><a id="orge81fa35"></a>🔻 缺點<br />
<div class="outline-text-7" id="text-orge81fa35">
<ul class="org-ul">
<li>❌ 需要資料庫支援（大多數現代資料庫如 MySQL、PostgreSQL、SQL Server 都支援）<br /></li>
<li>❌ 可能比單純的 SQL 拼接稍微增加開發複雜度<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org713795a"></a>2. 使用 ORM（Object-Relational Mapping）<br />
<div class="outline-text-6" id="text-org713795a">
<p>
📌 原理: ORM（物件關聯映射）允許開發者使用程式語言的物件來操作資料庫，而 不直接寫 SQL，從而減少 SQL Injection 風險。ORM 內建了 SQL Injection 防禦機制，自動處理 SQL 參數化。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org6be1a30"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-org6be1a30">
<p>
Python（Django ORM）<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">from</span> myapp.models <span style="color: #51afef;">import</span> User
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #dcaeea;">user</span> = User.objects.get(username=username)
</pre>
</div>
<p>
Java（Hibernate ORM）<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Query query = session.createQuery(<span style="color: #98be65;">"FROM User WHERE username = :username"</span>);
<span class="linenr">2: </span>query.setParameter(<span style="color: #98be65;">"username"</span>, username);
<span class="linenr">3: </span>User user = (User) query.uniqueResult();
</pre>
</div>
<p>
在 ORM 中，輸入的數據會被自動轉換為參數，不會影響 SQL 結構，因此 無法被惡意 SQL 語法改變。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org4e5adbd"></a>🔹 優點<br />
<div class="outline-text-8" id="text-org4e5adbd">
<ul class="org-ul">
<li>✔ 防止 SQL Injection，因為 ORM 自動使用參數化查詢<br /></li>
<li>✔ 提高開發效率，開發者不需要直接寫 SQL<br /></li>
<li>✔ 支援多種資料庫，無需針對不同資料庫寫不同 SQL 語法<br /></li>
</ul>
</div>
</li>
<li><a id="orgacf149a"></a>🔻 缺點<br />
<div class="outline-text-8" id="text-orgacf149a">
<ul class="org-ul">
<li>❌ ORM 執行效率可能比原生 SQL 稍慢<br /></li>
<li>❌ 學習成本較高，需要熟悉 ORM 語法<br /></li>
<li>❌ 靈活性較低，對於複雜的 SQL 查詢（如 UNION、JOIN）可能不夠高效<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org07c9d0e"></a>3. 限制使用者輸入（Input Validation &amp; Whitelisting）<br />
<ul class="org-ul">
<li><a id="orgd7acda9"></a>📌 原理<br />
<div class="outline-text-7" id="text-orgd7acda9">
<ul class="org-ul">
<li>限制輸入值的格式，確保使用者輸入內容符合預期。<br /></li>
<li>避免 SQL 特殊字符，如 &rsquo;, ", &#x2013;, ;, <i>* *</i> 等。<br /></li>
<li>使用 白名單（Whitelisting） 而不是黑名單（Blacklisting），因為黑名單容易被繞過。<br /></li>
</ul>
</div>
</li>
<li><a id="org9d2abb0"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-org9d2abb0">
<p>
限制輸入類型<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">import</span> re
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">is_valid_username</span>(username):
<span class="linenr">4: </span>    <span style="color: #51afef;">return</span> <span style="color: #c678dd;">bool</span>(re.<span style="color: #51afef;">match</span>(<span style="color: #98be65;">"^[a-zA-Z0-9_]+$"</span>, username))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#21482;&#20801;&#35377;&#33521;&#25991;&#23383;&#27597;&#12289;&#25976;&#23383;&#21644;&#24213;&#32218;</span>
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #51afef;">if</span> is_valid_username(user_input):
<span class="linenr">7: </span>    <span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = %s"</span>
<span class="linenr">8: </span>    cursor.execute(query, (user_input,))
</pre>
</div>
<p>
這樣，即使攻擊者輸入 admin&rsquo; OR &rsquo;1&rsquo;=&rsquo;1 也會被過濾掉，避免 SQL Injection。<br />
</p>

<p>
範例：只允許數字作為 ID<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">is_valid_id</span>(user_id):
<span class="linenr">2: </span>    <span style="color: #51afef;">return</span> user_id.isdigit()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#21482;&#20801;&#35377;&#25976;&#23383;</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #51afef;">if</span> is_valid_id(user_input):
<span class="linenr">5: </span>    <span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE id = %s"</span>
<span class="linenr">6: </span>    cursor.execute(query, (user_input,))
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgffae735"></a>🔹 優點<br />
<div class="outline-text-8" id="text-orgffae735">
<ul class="org-ul">
<li>✔ 減少 SQL Injection 風險，確保輸入符合預期<br /></li>
<li>✔ 簡單易行，無需更改 SQL 語句，只需檢查輸入<br /></li>
</ul>
</div>
</li>
<li><a id="org5762043"></a>🔻 缺點<br />
<div class="outline-text-8" id="text-org5762043">
<ul class="org-ul">
<li>❌ 無法完全防止 SQL Injection，需要配合 Prepared Statements 或 ORM<br /></li>
<li>❌ 可能影響使用者體驗，如果輸入限制太嚴格，會導致合法使用者無法輸入符合需求的數據<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org7dcd3c4"></a>總結：三種 SQL Injection 防禦方法比較<br />
<div class="outline-text-6" id="text-org7dcd3c4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">安全性</td>
<td class="org-left">易用性</td>
<td class="org-left">效能</td>
<td class="org-left">適用場景</td>
</tr>

<tr>
<td class="org-left">Prepared Statements</td>
<td class="org-left">✅✅✅（最安全）</td>
<td class="org-left">✅（稍需修改 SQL 語法）</td>
<td class="org-left">✅✅（SQL 優化）</td>
<td class="org-left">所有 SQL 應用</td>
</tr>

<tr>
<td class="org-left">ORM（物件關聯映射）</td>
<td class="org-left">✅✅（內建防 SQL Injection 機制）</td>
<td class="org-left">❌（需學習 ORM 框架）</td>
<td class="org-left">❌（有些情況較慢）</td>
<td class="org-left">需要簡化開發流程的應用</td>
</tr>

<tr>
<td class="org-left">輸入驗證（Whitelisting）</td>
<td class="org-left">✅（可降低風險）</td>
<td class="org-left">✅✅（簡單實現）</td>
<td class="org-left">✅✅（無額外效能開銷）</td>
<td class="org-left">簡單數據驗證，與其他方法搭配使用</td>
</tr>
</tbody>
</table>
<p>
最佳防禦策略<br />
</p>
<ul class="org-ul">
<li>優先使用 Prepared Statements（最佳選擇）<br /></li>
<li>若使用 ORM，確保 ORM 自帶的安全機制<br /></li>
<li>配合輸入驗證，過濾非預期輸入<br /></li>
</ul>
<p>
透過這些方法，我們可以有效防止 SQL Injection，提升應用的安全性！<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgbdb8537" class="outline-4">
<h4 id="orgbdb8537"><span class="section-number-4">1.2.5.</span> 第五大題 (5分)：</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
說明 “downcast” 何時使用，並解釋為何可能造成runtime exception<br />
</p>
</div>
<div id="outline-container-orgd638c6d" class="outline-5">
<h5 id="orgd638c6d">解</h5>
<div class="outline-text-5" id="text-orgd638c6d">
</div>
<ul class="org-ul">
<li><a id="orgafb3f92"></a>📌 什麼是 Downcast？<br />
<div class="outline-text-6" id="text-orgafb3f92">
<p>
在物件導向程式設計（Object-Oriented Programming, OOP）中，Downcasting（向下轉型） 指的是 將一個父類（superclass）引用的物件，轉型為子類（subclass）類型。這通常發生在 多態（polymorphism） 的場景下。<br />
</p>

<p>
示例: 假設有一個父類 Animal 和一個子類 Dog：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> Animal {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr"> 3: </span>        System.out.println(<span style="color: #98be65;">"Some sound..."</span>);
<span class="linenr"> 4: </span>    }
<span class="linenr"> 5: </span>}
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">class</span> Dog <span style="color: #51afef;">extends</span> Animal {
<span class="linenr"> 8: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">bark</span>() {
<span class="linenr"> 9: </span>        System.out.println(<span style="color: #98be65;">"Woof!"</span>);
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>}
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> DowncastExample {
<span class="linenr">14: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">15: </span>        Animal a = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Upcast&#65288;&#21521;&#19978;&#36681;&#22411;&#65289;&#65292;&#23433;&#20840;</span>
<span class="linenr">16: </span>        Dog d = (Dog) a;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast&#65288;&#21521;&#19979;&#36681;&#22411;&#65289;</span>
<span class="linenr">17: </span>        d.bark();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36889;&#35041;&#21487;&#20197;&#25104;&#21151;&#21628;&#21483;&#23376;&#39006;&#30340;&#26041;&#27861;</span>
<span class="linenr">18: </span>    }
<span class="linenr">19: </span>}
</pre>
</div>
<p>
在上例中，Animal a = new Dog(); 透過 向上轉型（Upcasting） 將 Dog 物件存入 Animal 型態的變數中。之後，我們執行 向下轉型（Downcasting），將 a 轉回 Dog，然後成功呼叫 bark()。<br />
</p>
</div>
</li>
<li><a id="orgc1bf6d1"></a>📌 何時使用 Downcast？<br />
<div class="outline-text-6" id="text-orgc1bf6d1">
<p>
通常情況下，當我們知道某個父類型的變數實際上是某個子類型的實例時，才會執行 Downcast。常見用途包括：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0e3eee7"></a>1. 當多態方法傳回父類型時，需要存取子類特有的行為<br />
<div class="outline-text-7" id="text-org0e3eee7">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Animal getAnimal() {
<span class="linenr">2: </span>    <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22238;&#20659;&#23376;&#39006;</span>
<span class="linenr">3: </span>}
<span class="linenr">4: </span>
<span class="linenr">5: </span>Dog d = (Dog) getAnimal(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">6: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="orga2c177f"></a>2. 當資料結構（如 List、Map）存放的是父類型時，需要轉型回子類型<br />
<div class="outline-text-7" id="text-orga2c177f">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>List&lt;Animal&gt; animals = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">ArrayList</span>&lt;&gt;();
<span class="linenr">2: </span>animals.add(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>());
<span class="linenr">3: </span>
<span class="linenr">4: </span>Dog d = (Dog) animals.get(<span style="color: #da8548; font-weight: bold;">0</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">5: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="org2e7b68f"></a>3. 在事件驅動架構（如 GUI 框架）中，事件處理器可能需要將父類轉型為具體的子類<br />
<div class="outline-text-7" id="text-org2e7b68f">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    Object event = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">MouseEvent</span>();
<span class="linenr">2: </span>    MouseEvent me = (MouseEvent) event;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">3: </span>
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="orge9962f9"></a>📌 為何 Downcast 可能造成 Runtime Exception？<br />
<div class="outline-text-6" id="text-orge9962f9">
<p>
Downcast 並不保證一定安全，如果 父類型的變數實際上不是該子類的實例，則在運行時會發生 ClassCastException。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0c6d6a8"></a>❌ 錯誤示例<br />
<div class="outline-text-7" id="text-org0c6d6a8">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Animal a = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Animal</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#26159; Dog</span>
<span class="linenr">2: </span>Dog d = (Dog) a;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26371;&#25291;&#20986; ClassCastException</span>
<span class="linenr">3: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="orgf8549d3"></a>📌 錯誤原因：<br />
<div class="outline-text-7" id="text-orgf8549d3">
<ul class="org-ul">
<li>a 其實是 Animal 的實例，不是 Dog，但我們試圖把它強制轉型為 Dog，這會導致 ClassCastException。<br /></li>
</ul>
</div>
</li>
<li><a id="org815b031"></a>📌 如何避免 Downcast 發生 Runtime Exception？<br />
<div class="outline-text-7" id="text-org815b031">
<p>
以下幾種方法可以避免 Downcast 產生錯誤：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org98d0b49"></a>✅ 方法 1：使用 instanceof 先檢查<br />
<div class="outline-text-8" id="text-org98d0b49">
<p>
在 Java 和 C# 中，可以使用 instanceof（Java）或 is（C#）來檢查物件是否屬於特定類別：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">if</span> (a <span style="color: #51afef;">instanceof</span> <span style="color: #ECBE7B;">Dog</span>) {
<span class="linenr">2: </span>    Dog d = (Dog) a;
<span class="linenr">3: </span>    d.bark();
<span class="linenr">4: </span>} <span style="color: #51afef;">else</span> {
<span class="linenr">5: </span>    System.out.println(<span style="color: #98be65;">"&#19981;&#26159; Dog &#29289;&#20214;&#65292;&#28961;&#27861;&#36681;&#22411;"</span>);
<span class="linenr">6: </span>}
</pre>
</div>
<p>
優點：避免 ClassCastException，確保只有 Dog 物件才會進行轉型。<br />
</p>
</div>
</li>
<li><a id="org27b2fa2"></a>✅ 方法 2：使用 try-catch 捕捉異常<br />
<div class="outline-text-8" id="text-org27b2fa2">
<p>
如果 instanceof 不能滿足需求（如在不確定資料來源的情況下），可以使用 try-catch 來防止程式崩潰：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">try</span> {
<span class="linenr">2: </span>    Dog d = (Dog) a;
<span class="linenr">3: </span>    d.bark();
<span class="linenr">4: </span>} <span style="color: #51afef;">catch</span> (ClassCastException e) {
<span class="linenr">5: </span>    System.out.println(<span style="color: #98be65;">"&#36681;&#22411;&#22833;&#25943;&#65306;"</span> + e.getMessage());
<span class="linenr">6: </span>}
</pre>
</div>

<p>
優點：即使出錯，程式仍可繼續執行。<br />
</p>
</div>
</li>
<li><a id="orga152cc7"></a>✅ 方法 3：使用泛型（Generics，推薦做法）<br />
<div class="outline-text-8" id="text-orga152cc7">
<p>
如果應用程式使用 泛型，就能避免 Downcast。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> Box&lt;T&gt; {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">private</span> T value;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #51afef;">public</span> Box(T value) {
<span class="linenr"> 5: </span>        <span style="color: #a9a1e1;">this</span>.value = value;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #51afef;">public</span> T get() {
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> value;
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>}
<span class="linenr">12: </span>
<span class="linenr">13: </span>Box&lt;Dog&gt; dogBox = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Box</span>&lt;&gt;(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>());
<span class="linenr">14: </span>Dog d = dogBox.get();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#38656;&#35201; Downcast&#65292;&#39006;&#22411;&#23433;&#20840;</span>
<span class="linenr">15: </span>d.bark();
<span class="linenr">16: </span>
</pre>
</div>
<p>
優點：<br />
</p>
<ul class="org-ul">
<li>在 編譯期 就確保類型安全，不會發生 ClassCastException。<br /></li>
<li>提升程式碼的可讀性與可維護性。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgf05e2ce"></a>🔍 總結<br />
<div class="outline-text-6" id="text-orgf05e2ce">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">概念</th>
<th scope="col" class="org-left">向上轉型（Upcast）</th>
<th scope="col" class="org-left">向下轉型（Downcast）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定義</td>
<td class="org-left">父類變數指向子類物件</td>
<td class="org-left">將父類變數轉回子類物件</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">✅ 安全</td>
<td class="org-left">⚠️ 可能導致 ClassCastException</td>
</tr>

<tr>
<td class="org-left">何時使用？</td>
<td class="org-left">當需要多態行為</td>
<td class="org-left">當確定變數實際類型並需存取子類功能</td>
</tr>

<tr>
<td class="org-left">如何避免錯誤？</td>
<td class="org-left">不需要特別處理</td>
<td class="org-left">✅ instanceof 檢查 ✅ try-catch ✅ 泛型</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb645ae4" class="outline-4">
<h4 id="orgb645ae4"><span class="section-number-4">1.2.6.</span> 第六大題 (20分)：</h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
請用 Java 或 C++ 這兩種物件導向語言其中一種，並充分利用其物件導向程式重複使用 (reuse) 的特性來設計並撰寫下面程式：<br />
</p>
<ul class="org-ul">
<li>由使用者輸入開始日期和終止日期，然後由程式計算並輸出這段時間共有多少天（頭、尾兩天都要算，任何的年份都要適用）<br /></li>
<li>本程式規定至少要用到三個 Classes 來撰寫本程式，而且不能使用 Java 或 C++ 系統提供的內建日期函數，這些class都要有其特定的意義，並說明之。<br /></li>
<li>評分依據：程式是否符合物件導向原則，包含說明程式設計的物件導向原則，以及寫出你的程式的類別圖 (Class diagram)，該圖須包含屬性和重要方法。<br /></li>
</ul>
</div>
<div id="outline-container-orgc0f3e9c" class="outline-5">
<h5 id="orgc0f3e9c">解</h5>
<div class="outline-text-5" id="text-orgc0f3e9c">
<p>
以下是完整的 C++ 物件導向設計與實作，符合物件導向 重複使用（reuse） 原則，並且 不使用內建日期函數，手動計算日期之間的天數。此程式設計了三個類別：<br />
</p>
<ol class="org-ol">
<li>Date：用來表示日期（年、月、日），並提供日期驗證、閏年判斷等功能。<br /></li>
<li>DateCalculator：計算兩個日期之間的天數，考慮閏年與不同月份天數。<br /></li>
<li>UserInterface：負責與使用者互動，接收輸入並顯示結果。<br /></li>
</ol>
</div>
<ul class="org-ul">
<li><a id="org503f0d6"></a>🔹 設計概念與物件導向原則<br />
<div class="outline-text-6" id="text-org503f0d6">
<p>
本設計符合以下 物件導向設計原則：<br />
</p>
<ul class="org-ul">
<li>封裝（Encapsulation）：Date、DateCalculator 和 UserInterface 各自負責不同的功能，並隱藏內部細節。<br /></li>
<li>責任分離（Separation of Concerns, SoC）：每個類別負責不同的功能：<br />
<ul class="org-ul">
<li>Date 只負責 日期的定義與處理。<br /></li>
<li>DateCalculator 負責 日期計算邏輯。<br /></li>
<li>UserInterface 負責 輸入輸出，不直接參與計算。<br /></li>
</ul></li>
<li>可重複使用（Reuse）：<br />
<ul class="org-ul">
<li>Date 類別可以在其他專案中 重複使用。<br /></li>
<li>DateCalculator 的計算方法可被擴展，例如用於未來的日期運算功能。<br /></li>
<li>UserInterface 可以在其他應用程式中使用（如時間計算應用）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf1e01e2"></a>🔹 類別圖（Class Diagram）<br />
<div class="outline-text-6" id="text-orgf1e01e2">
<pre class="example" id="org606c2ac">

+--------------------+
|      Date         |
+--------------------+
| - year: int       |
| - month: int      |
| - day: int        |
|--------------------|
| + isLeapYear(): bool  |
| + isValidDate(): bool |
| + daysInMonth(): int  |
+--------------------+

        ▲
        │
        │ 使用
        ▼

+----------------------+
|  DateCalculator      |
+----------------------+
| + calculateDaysBetween(d1: Date, d2: Date): int |
+----------------------+

        ▲
        │
        │ 使用
        ▼

+----------------------+
|  UserInterface      |
+----------------------+
| + getUserInput(): Date |
| + displayResult(): void |
+----------------------+
</pre>
</div>
</li>
<li><a id="org1253b8e"></a>🔹 C++ 程式碼實作<br />
<ul class="org-ul">
<li><a id="org48866ad"></a>📌 Date 類別<br />
<div class="outline-text-7" id="text-org48866ad">
<p>
負責 日期存儲與驗證，包含：<br />
</p>
<ul class="org-ul">
<li>閏年判斷 (isLeapYear())<br /></li>
<li>檢查日期是否合法 (isValidDate())<br /></li>
<li>取得月份的天數 (daysInMonth())<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Date</span> {
<span class="linenr"> 5: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">year</span>, <span style="color: #dcaeea;">month</span>, <span style="color: #dcaeea;">day</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #c678dd;">Date</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">d</span>) {
<span class="linenr"> 9: </span>        year = y;
<span class="linenr">10: </span>        month = m;
<span class="linenr">11: </span>        day = d;
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">isLeapYear</span>() {
<span class="linenr">15: </span>        <span style="color: #51afef;">return</span> (year % <span style="color: #da8548; font-weight: bold;">4</span> == <span style="color: #da8548; font-weight: bold;">0</span> &amp;&amp; year % <span style="color: #da8548; font-weight: bold;">100</span> != <span style="color: #da8548; font-weight: bold;">0</span>) || (year % <span style="color: #da8548; font-weight: bold;">400</span> == <span style="color: #da8548; font-weight: bold;">0</span>);
<span class="linenr">16: </span>    }
<span class="linenr">17: </span>
<span class="linenr">18: </span>    <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">isValidDate</span>() {
<span class="linenr">19: </span>        <span style="color: #51afef;">if</span> (<span style="color: #ECBE7B;">month</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span> || month &gt; <span style="color: #da8548; font-weight: bold;">12</span>) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">20: </span>        <span style="color: #51afef;">if</span> (<span style="color: #ECBE7B;">day</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span> || day &gt; <span style="color: #dcaeea;">daysInMonth</span>()) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">21: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>;
<span class="linenr">22: </span>    }
<span class="linenr">23: </span>
<span class="linenr">24: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">daysInMonth</span>() {
<span class="linenr">25: </span>        <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">daysPerMonth</span>[<span style="color: #da8548; font-weight: bold;">12</span>] = {<span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">28</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>};
<span class="linenr">26: </span>        <span style="color: #51afef;">return</span> (month == <span style="color: #da8548; font-weight: bold;">2</span> &amp;&amp; isLeapYear()) ? <span style="color: #da8548; font-weight: bold;">29</span> : daysPerMonth[month - <span style="color: #da8548; font-weight: bold;">1</span>];
<span class="linenr">27: </span>    }
<span class="linenr">28: </span>};
</pre>
</div>
</div>
</li>
<li><a id="orga437bfb"></a>📌 DateCalculator 類別<br />
<div class="outline-text-7" id="text-orga437bfb">
<p>
負責 計算兩個日期之間的天數，考慮：<br />
</p>
<ul class="org-ul">
<li>計算完整年的天數<br /></li>
<li>計算部分年度的天數<br /></li>
<li>考慮閏年影響<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">DateCalculator</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">calculateDaysBetween</span>(<span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">d1</span>, <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">d2</span>) {
<span class="linenr"> 4: </span>        <span style="color: #51afef;">if</span> (<span style="color: #51afef; font-weight: bold;">!</span>d1.isValidDate() || <span style="color: #51afef; font-weight: bold;">!</span>d2.isValidDate()) {
<span class="linenr"> 5: </span>            cout &lt;&lt; <span style="color: #98be65;">"&#37679;&#35492;&#65306;&#36664;&#20837;&#30340;&#26085;&#26399;&#28961;&#25928;&#65281;"</span> &lt;&lt; endl;
<span class="linenr"> 6: </span>            <span style="color: #51afef;">return</span> -<span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 7: </span>        }
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30906;&#20445; d1 &#26159;&#36611;&#26089;&#30340;&#26085;&#26399;</span>
<span class="linenr">10: </span>        <span style="color: #51afef;">if</span> (d1.year &gt; d2.year || (d1.year == d2.year &amp;&amp; d1.month &gt; d2.month) ||
<span class="linenr">11: </span>            (d1.year == d2.year &amp;&amp; d1.month == d2.month &amp;&amp; d1.day &gt; d2.day)) {
<span class="linenr">12: </span>            swap(d1, d2);
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>
<span class="linenr">15: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">totalDays</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639;&#23436;&#25972;&#24180;&#20221;&#30340;&#22825;&#25976;</span>
<span class="linenr">18: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span> = d1.year; y &lt; d2.year; y++) {
<span class="linenr">19: </span>            totalDays += (Date(y, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">1</span>).isLeapYear()) ? <span style="color: #da8548; font-weight: bold;">366</span> : <span style="color: #da8548; font-weight: bold;">365</span>;
<span class="linenr">20: </span>        }
<span class="linenr">21: </span>
<span class="linenr">22: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639; d1 &#30070;&#24180;&#24230;&#21097;&#39192;&#22825;&#25976;</span>
<span class="linenr">23: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span> = d1.month; m &lt;= <span style="color: #da8548; font-weight: bold;">12</span>; m++) {
<span class="linenr">24: </span>            totalDays += Date(d1.year, m, <span style="color: #da8548; font-weight: bold;">1</span>).daysInMonth();
<span class="linenr">25: </span>        }
<span class="linenr">26: </span>        totalDays -= d1.day - <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28187;&#21435; d1 &#24050;&#32147;&#36942;&#21435;&#30340;&#22825;&#25976;</span>
<span class="linenr">27: </span>
<span class="linenr">28: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639; d2 &#30070;&#24180;&#24230;&#30340;&#24050;&#36942;&#22825;&#25976;</span>
<span class="linenr">29: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span> = <span style="color: #da8548; font-weight: bold;">1</span>; m &lt; d2.month; m++) {
<span class="linenr">30: </span>            totalDays += Date(d2.year, m, <span style="color: #da8548; font-weight: bold;">1</span>).daysInMonth();
<span class="linenr">31: </span>        }
<span class="linenr">32: </span>        totalDays += d2.day; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21152;&#19978; d2 &#30070;&#26376;&#22825;&#25976;</span>
<span class="linenr">33: </span>
<span class="linenr">34: </span>        <span style="color: #51afef;">return</span> totalDays;
<span class="linenr">35: </span>    }
<span class="linenr">36: </span>};
</pre>
</div>
</div>
</li>
<li><a id="orgd892939"></a>📌 UserInterface 類別<br />
<div class="outline-text-7" id="text-orgd892939">
<p>
負責 與使用者互動，包括：<br />
</p>
<ul class="org-ul">
<li>讀取使用者輸入<br /></li>
<li>顯示計算結果<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">UserInterface</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #c678dd;">getUserInput</span>() {
<span class="linenr"> 4: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>, <span style="color: #dcaeea;">m</span>, <span style="color: #dcaeea;">d</span>;
<span class="linenr"> 5: </span>        cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#26085;&#26399;&#65288;&#26684;&#24335;&#65306;&#24180; &#26376; &#26085;&#65289;&#65306;"</span>;
<span class="linenr"> 6: </span>        cin &gt;&gt; y &gt;&gt; m &gt;&gt; d;
<span class="linenr"> 7: </span>        <span style="color: #51afef;">return</span> Date(y, m, d);
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">displayResult</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">days</span>) {
<span class="linenr">11: </span>        <span style="color: #51afef;">if</span> (days != -<span style="color: #da8548; font-weight: bold;">1</span>) {
<span class="linenr">12: </span>            cout &lt;&lt; <span style="color: #98be65;">"&#20841;&#20491;&#26085;&#26399;&#30456;&#24046;&#22825;&#25976;&#65306;"</span> &lt;&lt; days &lt;&lt; <span style="color: #98be65;">" &#22825;"</span> &lt;&lt; endl;
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>};
</pre>
</div>
</div>
</li>
<li><a id="org81853bf"></a>📌 主函數 main()<br />
<div class="outline-text-7" id="text-org81853bf">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">UserInterface</span> <span style="color: #dcaeea;">ui</span>;
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">DateCalculator</span> <span style="color: #dcaeea;">calculator</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#38283;&#22987;&#26085;&#26399;&#65306;"</span> &lt;&lt; endl;
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">startDate</span> = ui.getUserInput();
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#32066;&#27490;&#26085;&#26399;&#65306;"</span> &lt;&lt; endl;
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">endDate</span> = ui.getUserInput();
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">days</span> = calculator.calculateDaysBetween(startDate, endDate);
<span class="linenr">12: </span>    ui.displayResult(days);
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">15: </span>}
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgbb800cc" class="outline-4">
<h4 id="orgbb800cc"><span class="section-number-4">1.2.7.</span> 第七大題 (8分)：</h4>
<div class="outline-text-4" id="text-1-2-7">
<p>
給定一個系統的 snapshot，包含 Allocation, Max, Available 等資訊，並要求使用 banker’s algorithm 回答下列問題<br />
：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Allocation</th>
<th scope="col" class="org-right">Max</th>
<th scope="col" class="org-right">Availabe</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>

<tr>
<th scope="col" class="org-left">A B C D</th>
<th scope="col" class="org-right">A B C D</th>
<th scope="col" class="org-right">A B C D</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P0</td>
<td class="org-right">2001</td>
<td class="org-right">4212</td>
<td class="org-right">3321</td>
</tr>

<tr>
<td class="org-left">P1</td>
<td class="org-right">3121</td>
<td class="org-right">5252</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P2</td>
<td class="org-right">2103</td>
<td class="org-right">2316</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P3</td>
<td class="org-right">1312</td>
<td class="org-right">1424</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P4</td>
<td class="org-right">1432</td>
<td class="org-right">3665</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
使用 banker&rsquo;s algorithm 回答下列問題：<br />
</p>
<ul class="org-ul">
<li>(a) If a request form process P1 arrives for (1, 1, 0, 0), can the request be granted immediately? Why?<br /></li>
<li>(b) If a request form process P4 arrives for (0, 0, 2, 0), can the request be granted immediately? Why?<br /></li>
</ul>
</div>
<div id="outline-container-org083c33d" class="outline-5">
<h5 id="org083c33d">解</h5>
<div class="outline-text-5" id="text-org083c33d">
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">import</span> numpy <span style="color: #51afef;">as</span> np
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Given snapshot data</span>
<span class="linenr"> 4: </span><span style="color: #dcaeea;">allocation</span> = np.array([[<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>],
<span class="linenr"> 5: </span>                       [<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>],
<span class="linenr"> 6: </span>                       [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">3</span>],
<span class="linenr"> 7: </span>                       [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr"> 8: </span>                       [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">2</span>]])
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #dcaeea;">max_demand</span> = np.array([[<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr">11: </span>                        [<span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr">12: </span>                        [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">6</span>],
<span class="linenr">13: </span>                        [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">4</span>],
<span class="linenr">14: </span>                        [<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">5</span>]])
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #dcaeea;">available</span> = np.array([<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>])
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Compute the Need matrix (Max - Allocation)</span>
<span class="linenr">19: </span><span style="color: #dcaeea;">need</span> = max_demand - allocation
<span class="linenr">20: </span>
<span class="linenr">21: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Requests to check</span>
<span class="linenr">22: </span><span style="color: #dcaeea;">request_P1</span> = np.array([<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>])
<span class="linenr">23: </span><span style="color: #dcaeea;">request_P4</span> = np.array([<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">0</span>])
<span class="linenr">24: </span>
<span class="linenr">25: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Function to check if request can be granted immediately</span>
<span class="linenr">26: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">can_grant_request</span>(available, need, request, process_id):
<span class="linenr">27: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check if request is within the process's need</span>
<span class="linenr">28: </span>    <span style="color: #51afef;">if</span> np.<span style="color: #c678dd;">any</span>(request &gt; need[process_id]):
<span class="linenr">29: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>, <span style="color: #98be65;">"Request exceeds process's maximum need."</span>
<span class="linenr">30: </span>
<span class="linenr">31: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check if request is within available resources</span>
<span class="linenr">32: </span>    <span style="color: #51afef;">if</span> np.<span style="color: #c678dd;">any</span>(request &gt; available):
<span class="linenr">33: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>, <span style="color: #98be65;">"Not enough available resources to fulfill request."</span>
<span class="linenr">34: </span>
<span class="linenr">35: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">If both conditions are met, request can be granted</span>
<span class="linenr">36: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">True</span>, <span style="color: #98be65;">"Request can be granted immediately."</span>
<span class="linenr">37: </span>
<span class="linenr">38: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check both requests</span>
<span class="linenr">39: </span><span style="color: #dcaeea;">result_P1</span> = can_grant_request(available, need, request_P1, <span style="color: #da8548; font-weight: bold;">1</span>)
<span class="linenr">40: </span><span style="color: #dcaeea;">result_P4</span> = can_grant_request(available, need, request_P4, <span style="color: #da8548; font-weight: bold;">4</span>)
<span class="linenr">41: </span>
<span class="linenr">42: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Display results</span>
<span class="linenr">43: </span>result_P1, result_P4
<span class="linenr">44: </span>
</pre>
</div>
<p>
執行結果<br />
</p>
<pre class="example" id="orgd8319d9">
((True, 'Request can be granted immediately.'),
 (True, 'Request can be granted immediately.'))
</pre>
</div>
<ul class="org-ul">
<li><a id="org8a8acfb"></a>解析 Banker&rsquo;s Algorithm<br />
<div class="outline-text-6" id="text-org8a8acfb">
<p>
Banker&rsquo;s Algorithm 是 避免死鎖（Deadlock Avoidance） 的一種資源分配與安全性檢查算法，主要用來確保系統不會陷入不安全狀態。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgc25edd1"></a>主要概念<br />
<div class="outline-text-7" id="text-orgc25edd1">
<ul class="org-ul">
<li>Allocation（已分配資源）：目前已分配給各進程的資源數量。<br /></li>
<li>Max（最大需求）：各進程執行所需的最大資源量。<br /></li>
<li>Need（尚需資源）：Need = Max - Allocation，表示各進程還需要多少資源才能完成。<br /></li>
<li>Available（可用資源）：目前系統可用的總資源數。<br /></li>
</ul>
</div>
</li>
<li><a id="orgabfefb9"></a>(a) Process P1 的請求 (1,1,0,0) 能否立即滿足？<br />
<div class="outline-text-7" id="text-orgabfefb9">
<p>
請求：P1 需要 (1,1,0,0)<br />
檢查步驟<br />
</p>
<ol class="org-ol">
<li>檢查 Request 是否超過 Need<br />
Need 計算：<br />
<ul class="org-ul">
<li><p>
Need=Max−Allocation<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>     <span style="color: #dcaeea;">Need</span>[P1] = (<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">2</span>) - (<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">1</span>) = (<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div></li>
<li>(1,1,0,0) &lt;= (2,1,3,1) ✅ 合法<br /></li>
</ul></li>

<li>檢查 Request 是否小於等於 Available<br />
<ul class="org-ul">
<li>Available (3,3,2,1)<br /></li>
<li>(1,1,0,0) &lt;= (3,3,2,1) ✅ 可用資源足夠<br /></li>
</ul></li>
</ol>
<p>
結論：P1 的請求 可以立即被滿足。<br />
</p>
</div>
</li>
<li><a id="org9627030"></a>(b) Process P4 的請求 (0,0,2,0) 能否立即滿足？<br />
<div class="outline-text-7" id="text-org9627030">
<p>
請求：P4 需要 (0,0,2,0)<br />
檢查步驟<br />
</p>
<ol class="org-ol">
<li>檢查 Request 是否超過 Need<br />
Need 計算：<br />
<ul class="org-ul">
<li>Need[P4] = (3,6,6,5) - (1,4,3,2) = (2,2,3,3)<br /></li>
<li>(0,0,2,0) &lt;= (2,2,3,3) ✅ 合法<br /></li>
</ul></li>
<li>檢查 Request 是否小於等於 Available<br />
<ul class="org-ul">
<li>Available (3,3,2,1)<br /></li>
<li>(0,0,2,0) &lt;= (3,3,2,1) ✅ 可用資源足夠<br /></li>
</ul></li>
</ol>
<p>
結論： P4 的請求 可以立即被滿足。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org15ec5ca"></a>最終結果<br />
<div class="outline-text-6" id="text-org15ec5ca">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Process</th>
<th scope="col" class="org-left">Request</th>
<th scope="col" class="org-left">Can be granted?</th>
<th scope="col" class="org-left">Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P1</td>
<td class="org-left">(1,1,0,0)</td>
<td class="org-left">✅ Yes</td>
<td class="org-left">Available 資源足夠，且需求符合 Need 限制</td>
</tr>

<tr>
<td class="org-left">P4</td>
<td class="org-left">(0,0,2,0)</td>
<td class="org-left">✅ Yes</td>
<td class="org-left">Available 資源足夠，且需求符合 Need 限制</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgeaaa826" class="outline-4">
<h4 id="orgeaaa826"><span class="section-number-4">1.2.8.</span> 第八大題 (8分)：</h4>
<div class="outline-text-4" id="text-1-2-8">
<p>
In a paging system, suppose that the hit ratio is 90% and it takes 10 ns to search the TLB and 100 ns to access memory.<br />
</p>
<ul class="org-ul">
<li>(a) What is the effective memory access time with single-level page table?<br /></li>
<li>(b) What is the effective memory access time with two-level page table?<br /></li>
</ul>
</div>
<div id="outline-container-org288ff83" class="outline-5">
<h5 id="org288ff83">解</h5>
<div class="outline-text-5" id="text-org288ff83">
</div>
<ul class="org-ul">
<li><a id="orgc5edf66"></a>🔹 Key Given Data<br />
<div class="outline-text-6" id="text-orgc5edf66">
<ul class="org-ul">
<li>TLB Search Time = 10 ns<br /></li>
<li>Memory Access Time = 100 ns<br /></li>
<li>Hit Ratio = 90% (i.e., 0.9)<br /></li>
<li>Miss Ratio = 1 - 0.9 = 0.1<br /></li>
</ul>
</div>
</li>
<li><a id="orgb03e0de"></a>(a) Effective Memory Access Time with Single-Level Page Table<br />
<ul class="org-ul">
<li><a id="org47acfab"></a>📌 Concept<br />
<div class="outline-text-7" id="text-org47acfab">
<p>
In a paging system, when a process needs to access memory:<br />
</p>
<ol class="org-ol">
<li>The TLB (Translation Lookaside Buffer) is checked first.<br /></li>
<li>If there&rsquo;s a hit, we can directly access the physical memory.<br /></li>
<li>If there&rsquo;s a miss, we need to:<br />
<ul class="org-ul">
<li>Access the page table in memory to find the frame number (cost: 100 ns).<br /></li>
<li>Then access the actual memory location (cost: 100 ns).<br /></li>
<li>Total cost in case of a miss: 200 ns.<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org89f317c"></a>📌 Formula<br />
<div class="outline-text-7" id="text-org89f317c">
<p>
Effective Memory Access Time=(TLB Hit Ratio×Hit Time)+(TLB Miss Ratio×Miss Time)<br />
=(0.9×(10+100))+(0.1×(10+100+100))<br />
</p>
</div>
</li>
<li><a id="orgc39aa7a"></a>📌 Calculation<br />
<div class="outline-text-7" id="text-orgc39aa7a">
<p>
=(0.9×110)+(0.1×210)<br />
=99+21<br />
=120 ns<br />
</p>
</div>
</li>
<li><a id="orgf2dcfc1"></a>🔹 Answer: The effective memory access time for a single-level page table is 120 ns.<br /></li>
</ul>
</li>
<li><a id="orgcb27413"></a>(b) Effective Memory Access Time with Two-Level Page Table<br />
<ul class="org-ul">
<li><a id="orge1339aa"></a>📌 Concept<br />
<div class="outline-text-7" id="text-orge1339aa">
<p>
In a two-level paging system, if a TLB miss occurs, we must perform:<br />
</p>
<ul class="org-ul">
<li>Page Table Lookup (First Level) = 100 ns<br /></li>
<li>Page Table Lookup (Second Level) = 100 ns<br /></li>
<li>Memory Access (Data Fetch) = 100 ns<br /></li>
</ul>
<p>
Thus, on a miss, we must access memory three times (300 ns total) instead of two times (200 ns total).<br />
</p>
</div>
</li>
<li><a id="orgf9e01b9"></a>📌 Formula<br />
<div class="outline-text-7" id="text-orgf9e01b9">
<p>
Effective Memory Access Time=(TLB Hit Ratio×Hit Time)+(TLB Miss Ratio×Miss Time)<br />
=(0.9×(10+100))+(0.1×(10+100+100+100))<br />
</p>
</div>
</li>
<li><a id="org6cdd5ac"></a>📌 Calculation<br />
<div class="outline-text-7" id="text-org6cdd5ac">
<p>
=(0.9×110)+(0.1×310)<br />
=99+31<br />
=130 ns<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgba6a294"></a>🔹 Summary of Results<br />
<div class="outline-text-6" id="text-orgba6a294">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Paging System</th>
<th scope="col" class="org-left">Effective Memory Access Time (ns)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Single-Level Page Table</td>
<td class="org-left">120 ns</td>
</tr>

<tr>
<td class="org-left">Two-Level Page Table</td>
<td class="org-left">130 ns</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgfddd16e" class="outline-4">
<h4 id="orgfddd16e"><span class="section-number-4">1.2.9.</span> 第九大題 (4 分)：</h4>
<div class="outline-text-4" id="text-1-2-9">
<p>
Consider a byte oriented logical address space of 8 pages of 1024 bytes each, mapped onto a physical memory of 32 frames.<br />
</p>
<ul class="org-ul">
<li>(a) How many bits are there in the logical address?<br /></li>
<li>(b) How many bits are there in the physical address?<br /></li>
</ul>
</div>
<div id="outline-container-org4ecf12e" class="outline-5">
<h5 id="org4ecf12e">解</h5>
<div class="outline-text-5" id="text-org4ecf12e">
<p>
在 分頁式記憶體管理（Paging Memory Management） 中，邏輯位址（Logical Address）由兩部分組成：<br />
</p>
<ul class="org-ul">
<li>頁號（Page Number, p）：用來索引頁表，找到對應的記憶體框架。<br /></li>
<li></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org9cc9259"></a>(a) 邏輯位址的位元數<br />
<ul class="org-ul">
<li><a id="org6c3153d"></a>📌 已知條件<br />
<div class="outline-text-7" id="text-org6c3153d">
<ul class="org-ul">
<li>邏輯位址空間（Logical Address Space）：<br />
<ul class="org-ul">
<li>共有 8 個頁（Pages）。<br /></li>
<li>每個頁 1024 個位元組（Bytes）。<br /></li>
</ul></li>
<li>頁內偏移量（Offset）：<br />
<ul class="org-ul">
<li>每個頁有 1024（= 2¹⁰）個位元組，所以頁內偏移量需要 10 bits 表示。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf5ecdf3"></a>📌 計算邏輯位址的位元數<br />
<div class="outline-text-7" id="text-orgf5ecdf3">
<ul class="org-ul">
<li>頁號（Page Number, p）<br />
<ul class="org-ul">
<li>總共有 8 個頁（= 2³），因此 頁號需要 3 bits。<br /></li>
</ul></li>
<li>頁內偏移量（Offset, d）<br />
<ul class="org-ul">
<li>每個頁大小為 1024 Bytes（= 2¹⁰），因此 偏移量需要 10 bits。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgbe54658"></a>📌 總計<br />
<div class="outline-text-7" id="text-orgbe54658">
<p>
邏輯位址長度 = 頁號位元數 + 頁內偏移量位元數<br />
=3+10=13 bits<br />
</p>
</div>
</li>
<li><a id="org4938d3e"></a>🔹 答案：邏輯位址需要 13 bits。<br /></li>
</ul>
</li>
<li><a id="org8968cf1"></a>(b) 物理位址的位元數<br />
<ul class="org-ul">
<li><a id="org2368747"></a>📌 已知條件<br />
<div class="outline-text-7" id="text-org2368747">
<ul class="org-ul">
<li>物理記憶體（Physical Memory）<br />
<ul class="org-ul">
<li>共有 32 個框架（Frames）。<br /></li>
<li>每個框架大小與頁大小相同，即 1024 Bytes。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgccf534a"></a>📌 計算物理位址的位元數<br />
<div class="outline-text-7" id="text-orgccf534a">
<ul class="org-ul">
<li>框架號（Frame Number, f）<br />
<ul class="org-ul">
<li>物理記憶體有 32 個框架（= 2⁵），因此 框架號需要 5 bits。<br /></li>
</ul></li>
<li>頁內偏移量（Offset, d）<br />
<ul class="org-ul">
<li>與邏輯位址的 偏移量相同（10 bits），因為每個框架大小與頁大小一致。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgd9b15b0"></a>📌 總計<br />
<div class="outline-text-7" id="text-orgd9b15b0">
<p>
物理位址長度 = 框架號位元數 + 偏移量位元數<br />
=5+10=15 bits<br />
</p>
</div>
</li>
<li><a id="org8d280c1"></a>🔹 答案：物理位址需要 15 bits。<br /></li>
</ul>
</li>
<li><a id="org5d2fb71"></a>🔹 最終結果<br />
<div class="outline-text-6" id="text-org5d2fb71">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">地址類型</th>
<th scope="col" class="org-left">所需位元數</th>
<th scope="col" class="org-left">組成部分</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">邏輯位址</td>
<td class="org-left">13 bits</td>
<td class="org-left">頁號（3 bits）+ 偏移量（10 bits）</td>
</tr>

<tr>
<td class="org-left">物理位址</td>
<td class="org-left">15 bits</td>
<td class="org-left">框架號（5 bits）+ 偏移量（10 bits）</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgcd94e2d" class="outline-4">
<h4 id="orgcd94e2d"><span class="section-number-4">1.2.10.</span> 第十大題 (5 分)：</h4>
<div class="outline-text-4" id="text-1-2-10">
<p>
Consider the two-dimensional array “A[100][100]”. If a paged memory system with pages of size 200, for two page frames, how many page faults are generated by the following array-initialization loops, using LRU replacement?<br />
</p>
<ul class="org-ul">
<li><p>
(a)  loop (a) 的程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i&lt;<span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;<span style="color: #da8548; font-weight: bold;">100</span>;j++) {
<span class="linenr">3: </span>      A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>  }
</pre>
</div></li>
<li><p>
(b) loop (b) 的程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;<span style="color: #da8548; font-weight: bold;">100</span>; j++)  {
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">ing</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">3: </span>      A[i][j]=<span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>  }
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org191b400" class="outline-5">
<h5 id="org191b400">解</h5>
<div class="outline-text-5" id="text-org191b400">
<p>
在這個問題中，我們要分析 二維陣列 A[100][100] 在 頁面置換策略（LRU, Least Recently Used） 下的 頁錯（Page Fault）數量，並比較不同的走訪順序對頁錯數的影響。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org854e188"></a>📌 給定條件<br />
<div class="outline-text-6" id="text-org854e188">
<ul class="org-ul">
<li>陣列 A[100][100]（100 × 100 的整數陣列）。<br /></li>
<li>頁大小 = 200 Bytes。<br /></li>
<li>兩個頁框（Page Frames）。<br /></li>
<li>假設每個整數（int）佔 4 Bytes，則：<br />
<ul class="org-ul">
<li>每一行 A[i][j] 包含 100 個元素 × 4 Bytes = 400 Bytes。<br /></li>
<li>每個頁面大小為 200 Bytes，因此每個頁面能存 50 個整數（50 elements）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgfd7318e"></a>(a) 內迴圈掃描 A[i][j]<br />
<div class="outline-text-6" id="text-orgfd7318e">
<p>
📌 程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">2: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; <span style="color: #da8548; font-weight: bold;">100</span>; j++) {
<span class="linenr">3: </span>    A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>}
</pre>
</div>
<p>
📌 記憶體訪問模式<br />
</p>
<ol class="org-ol">
<li>外層迴圈 i 先固定，內層迴圈 j 變化。<br /></li>
<li>依照 j 逐列 存取記憶體（Row-major order）。<br /></li>
<li>內部陣列 A[i][j] 是連續存取的。<br /></li>
</ol>
<p>
📌 記憶體分頁<br />
</p>
<ul class="org-ul">
<li>每行（A[i]）大小 = 400 Bytes（2 個頁面）。<br /></li>
<li>當 j 在 0 到 49 時，存取第一個頁面，50 到 99 時存取第二個頁面。<br /></li>
<li>只要 i 不變，j 遍歷時只需要 2 個頁面（正好符合兩個頁框），不會發生頁錯。<br /></li>
</ul>
<p>
📌 頁錯計算<br />
</p>
<ul class="org-ul">
<li>i=0 時，載入 A[0] 的 2 個頁面（2 次頁錯）。<br /></li>
<li>i=1 時，載入 A[1] 的 2 個頁面（2 次頁錯）。<br /></li>
<li>&#x2026; 共 100 次 i 迴圈。<br /></li>
</ul>

<p>
總頁錯數：100×2=200<br />
🔹 (a) 的總頁錯數 = 200 次。<br />
</p>
</div>
</li>
<li><a id="org16e3ebc"></a>(b) 內迴圈掃描 A[i][j]（反轉迴圈）<br />
<div class="outline-text-6" id="text-org16e3ebc">
<p>
📌 程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; <span style="color: #da8548; font-weight: bold;">100</span>; j++) {
<span class="linenr">2: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">3: </span>    A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>}
</pre>
</div>
<p>
📌 記憶體訪問模式<br />
</p>
<ul class="org-ul">
<li>外層迴圈 j 先固定，內層迴圈 i 變化。<br /></li>
<li>依照 i 逐欄 存取記憶體（Column-major order）。<br /></li>
<li>A[i][j] 每次跳 100*4=400 Bytes，直接跳到下一行的相同欄位。<br /></li>
</ul>
<p>
📌 記憶體分頁<br />
</p>
<ul class="org-ul">
<li>每列 A[i][j] 分佈在 不同的頁面。<br /></li>
<li>一次 j 迴圈，會掃描 100 個不同的頁面。<br /></li>
<li>因為只有 2 個頁框，LRU 會不斷換出頁面。<br /></li>
</ul>
<p>
📌 頁錯計算<br />
</p>
<ul class="org-ul">
<li>每次訪問 A[i][j]，它會落在新的頁面，因為 i 變化時 A[i][j] 橫跨 100 不同頁面。<br /></li>
<li>每次訪問 A[i][j]，由於只有 2 個頁框，造成頻繁換頁。<br /></li>
<li>總共 100 × 100 次訪問，每次幾乎都是頁錯。<br /></li>
</ul>

<p>
總頁錯數：100×100=10,000<br />
</p>

<p>
🔹 (b) 的總頁錯數 = 10,000 次（極大化頁錯）。<br />
</p>
</div>
</li>
<li><a id="orgcca72df"></a>🔹 總結<br />
<div class="outline-text-6" id="text-orgcca72df">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方式</th>
<th scope="col" class="org-left">記憶體訪問模式</th>
<th scope="col" class="org-left">頁錯數</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) for (int i; int j)</td>
<td class="org-left">Row-major (逐列存取)</td>
<td class="org-left">200</td>
<td class="org-left">局部性高，不會頻繁換頁</td>
</tr>

<tr>
<td class="org-left">(b) for (int j; int i)</td>
<td class="org-left">Column-major (逐欄存取)</td>
<td class="org-left">10,000	頁錯數極大化，因為跨頁存取</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
🔹 結論<br />
    (a) 的訪問模式符合記憶體的局部性原則（Locality Principle），頁錯較少（200 次）。<br />
    (b) 破壞了記憶體的局部性，造成嚴重的頁錯（10,000 次）。<br />
    分頁系統中，如何訪問記憶體會顯著影響效能。<br />
</p>
</div>
</li>
<li><a id="orgb5d69d3"></a>🔹 相關計算機概論知識<br />
<div class="outline-text-6" id="text-orgb5d69d3">
<p>
這個問題屬於 作業系統（Operating System） 和 記憶體管理（Memory Management），涉及：<br />
\[$ 這是作業系統的知識，計概裡應該有，不懂的話我再給看另一份比較基本的教材 \]$<br />
</p>
<ul class="org-ul">
<li>分頁記憶體（Paging Memory Management）<br />
<ul class="org-ul">
<li>物理記憶體被分成 固定大小的頁面。<br /></li>
<li>頁框（Page Frame）對應到邏輯記憶體的頁面。<br /></li>
</ul></li>
<li>頁面置換策略（Page Replacement Algorithms）<br />
<ul class="org-ul">
<li>LRU（Least Recently Used）：當頁框用完時，淘汰最久未使用的頁面。<br /></li>
<li>在 (b) 的訪問模式下，每次都會換出頁面，導致極高的頁錯數。<br /></li>
</ul></li>
<li>記憶體存取模式與局部性<br />
<ul class="org-ul">
<li>時間局部性（Temporal Locality）：最近存取的資料可能很快再次被存取。<br /></li>
<li>空間局部性（Spatial Locality）：與當前存取的資料相鄰的記憶體區塊可能會很快被存取。<br />
<ul class="org-ul">
<li>(a) 遵守局部性原則，因此頁錯數較低。<br /></li>
<li>(b) 破壞局部性，因此頁錯數極高。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org156f063" class="outline-2">
<h2 id="org156f063"><span class="section-number-2">2.</span> 中山近三年考題及詳解</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orga7f4fa3" class="outline-3">
<h3 id="orga7f4fa3"><span class="section-number-3">2.1.</span> 110: 中山管理資訊系統</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org9fc0bad" class="outline-4">
<h4 id="org9fc0bad"><span class="section-number-4">2.1.1.</span> 1. 人工智慧(Artificial Intelligence)是近年來相當受到注目的資訊發展，而其中的發展理論可以分為兩大學派，分別為法則學派(Rule-based Approach)與機器學習學派(Machine Learning Approach)。</h4>
<div class="outline-text-4" id="text-2-1-1">
</div>
<div id="outline-container-org53fadf4" class="outline-5">
<h5 id="org53fadf4">(1)機器學習學派有四種不同類型，分別為非監督式學習(Unsupervised)、半監督式學習(Semi-supervised)、監督式學習(Supervised)與增強式學習(Reinforcements Learning)，試說明這四種不同類型，並舉例說明之。<code>[12%]</code></h5>
<div class="outline-text-5" id="text-org53fadf4">
</div>
<ul class="org-ul">
<li><a id="org8adc67f"></a>解答<br />
<div class="outline-text-6" id="text-org8adc67f">
<ol class="org-ol">
<li>非監督式學習 (Unsupervised Learning): 此類學習的特點是沒有標籤的數據，模型需要自行從數據中找出模式或結構。例如：分群算法 (clustering) 可以將數據分為不同的組別，但事先並不知道這些組別的意義。<br /></li>
<li>半監督式學習 (Semi-supervised Learning): 此類學習使用部分標籤的數據來訓練模型。它介於監督式學習和非監督式學之間，利用少量標籤數據來輔助訓練，提高模型的泛化能力。<br /></li>
<li>監督式學習 (Supervised Learning): 此類學習使用標籤數據來訓練模型，讓模型學習輸入和輸出之間的關係。例如：分類 (classification) 和迴歸 (regression) 問題都屬於監督式學習的範疇。<br /></li>
<li>增強式學習 (Reinforcement Learning): 此類學習通過與環境互動，根據獎勵或懲罰來學習最佳策略。模型會嘗試不同的行動，並根據結果調整策略，以最大化累積獎勵。例如：訓練機器人行走、玩遊戲等。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb0cdfee" class="outline-5">
<h5 id="orgb0cdfee">(2)機器學習學派與法則學派兩者的特性與區別在哪？ 兩者與傳統的統計學方法差別又在哪？ <code>[13%]</code></h5>
<div class="outline-text-5" id="text-orgb0cdfee">
</div>
<ul class="org-ul">
<li><a id="orgcf3b53b"></a>解<br />
<div class="outline-text-6" id="text-orgcf3b53b">
<ul class="org-ul">
<li>法則學派 (Rule-based Approach):<br />
<ul class="org-ul">
<li>特性： 依賴人為事先定義好的規則來解決問題。專家需要將領域知識編寫成明確的規則，然後讓系統根據這些規則進行推理和決策。<br /></li>
<li>優點： 容易理解和解釋，適用於規則明確且不複雜的問題。<br /></li>
<li>缺點： 需要大量人工編寫規則，難以處理複雜和不確定的情況。<br /></li>
</ul></li>
<li>機器學習學派 (Machine Learning Approach):<br />
<ul class="org-ul">
<li>特性： 通過從數據中學習來解決問題。模型會自動找出數據中的模式，並根據這些模式進行預測和決策，不需要事先編寫規則。<br /></li>
<li>優點： 能夠處理複雜和不確定的情況，能夠從大量數據中學習，並隨著數據增加不斷提升性能。<br /></li>
<li>缺點： 模型難以解釋，需要大量的訓練數據。<br /></li>
</ul></li>
<li>與傳統統計學方法的差別：<br />
<ul class="org-ul">
<li>傳統統計學： 注重數據分析和假設檢驗，目標是理解數據背後的規律。<br /></li>
<li>機器學習： 注重預測和決策，目標是從數據中建立模型並進行應用。機器學習更多的是從數據中學習模型，統計學則更關注對數據的分析。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgff8bec2" class="outline-4">
<h4 id="orgff8bec2"><span class="section-number-4">2.1.2.</span> 2.</h4>
<div class="outline-text-4" id="text-2-1-2">
</div>
<div id="outline-container-orgfeaf6b9" class="outline-5">
<h5 id="orgfeaf6b9">(1)新興技術區塊鏈(Blockchain)在現今產業應用越來越多，請問區塊鏈是什麼？ 有哪些特性呢？ <code>[10%]</code></h5>
<div class="outline-text-5" id="text-orgfeaf6b9">
</div>
<ul class="org-ul">
<li><a id="org8e80958"></a>解<br />
<div class="outline-text-6" id="text-org8e80958">
<ul class="org-ul">
<li>定義： 區塊鏈是一種分散式帳本技術，以區塊為單位記錄交易信息，並將這些區塊按時間順序連接成鏈。每個區塊都包含前一個區塊的哈希值，形成一個不可篡改的鏈條.<br /></li>
<li>特性：<br /></li>
<li>去中心化： 沒有單一的控制者，數據由網絡中的多個節點共同維護。<br /></li>
<li>不可篡改： 區塊鏈的數據一旦記錄就難以更改，因為任何修改都會導致後續區塊的哈希值改變。<br /></li>
<li>透明度： 區塊鏈上的交易記錄是公開的，任何人都可以查看。<br /></li>
<li>安全性： 使用密碼學技術來確保數據的安全性和完整性。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3832d76" class="outline-5">
<h5 id="org3832d76">(2)區塊鏈除了比特幣(Bitcoin)、以太幣(Ether)等數位貨幣外，就你所知，還有哪些產業應用？試舉例說明這些應用。而這些區塊鏈應用，原來是想解決產業什麼樣的問題呢？為什麼會需要使用到區塊鏈技術呢？如果靠其他方法或是其他資訊技術，有沒有辦法解決相同的問題呢？ <code>[15%]</code></h5>
<div class="outline-text-5" id="text-org3832d76">
</div>
<ul class="org-ul">
<li><a id="orgc7ab640"></a>解<br />
<div class="outline-text-6" id="text-orgc7ab640">
<ul class="org-ul">
<li>產業應用： 除了比特幣 (Bitcoin) 和以太幣 (Ether) 等數位貨幣之外，區塊鏈還被應用於許多其他領域，例如：<br />
<ol class="org-ol">
<li>供應鏈管理： 追蹤商品從生產到消費的整個過程，確保商品的真實性和品質。<br /></li>
<li>數位身份驗證： 建立安全可靠的數位身份系統，保護用戶的隱私。<br /></li>
<li>智能合約： 自動執行合約條款，提高交易的效率和透明度。<br /></li>
<li>版權保護： 追蹤數位內容的版權，防止盜版。<br /></li>
<li>醫療健康： 安全地管理病患數據，方便醫療機構共享信息。<br /></li>
</ol></li>
<li>解決問題：<br />
<ol class="org-ol">
<li>信任問題： 區塊鏈透過分散式帳本和密碼學技術建立信任機制，解決傳統中心化系統的信任問題。<br /></li>
<li>資訊不透明： 區塊鏈的透明特性可以增加資訊的公開性，讓交易記錄可追溯。<br /></li>
<li>效率低下： 區塊鏈的智能合約可以自動執行交易，提高效率。<br /></li>
<li>其他解決方案： 某些情境中，可能可以使用其他方法或是資訊科技來解決產業問題。像是傳統的資料庫系統，可以用來管理數據，或是透過數位簽章來確保數位內容的真偽。但是區塊鏈的去中心化、不可篡改等特性，在需要高度信任的場景下，有其獨特的優勢。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgdd6e5e4" class="outline-4">
<h4 id="orgdd6e5e4"><span class="section-number-4">2.1.3.</span> 3. 目前全球市值最高的前七大公司例如Facebook, Amazon, Google 大都是所謂的「平台經營模式」，請問，何謂平台經營模式？ 其與傳統經營模式相比有何特色？ 其在經營上與傳統模式相比，又有哪些優勢？ <code>[25%]</code></h4>
<div class="outline-text-4" id="text-2-1-3">
</div>
<div id="outline-container-orgcec67e7" class="outline-5">
<h5 id="orgcec67e7">解</h5>
<div class="outline-text-5" id="text-orgcec67e7">
<ul class="org-ul">
<li>平台經營模式的定義：<br />
<ul class="org-ul">
<li>平台經營模式指的是一種以建立平台為核心的商業模式，它不直接提供產品或服務，而是提供一個連接不同用戶群體的場所，讓他們能夠互動、交易或共享資源。<br /></li>
<li>平台通常會利用網絡效應，讓更多用戶的加入使得平台的價值不斷增加。<br /></li>
<li>典型的平台包括像是：Amazon, Facebook, Google 等等。<br /></li>
</ul></li>
<li>平台經營模式與傳統經營模式的特色比較：<br />
<ul class="org-ul">
<li>傳統經營模式：<br />
<ul class="org-ul">
<li>特性： 專注於生產和銷售產品或服務，企業通常直接與客戶互動。<br /></li>
<li>組織結構： 偏向垂直整合，強調內部效率和控制。<br /></li>
<li>收入來源： 主要來自銷售產品或服務。<br /></li>
</ul></li>
<li>平台經營模式：<br />
<ul class="org-ul">
<li>特性： 專注於建立和維護平台，並連接不同的用戶群體。<br /></li>
<li>組織結構： 偏向水平分工，強調協作和網絡效應。<br /></li>
<li>收入來源： 多元化，可能來自廣告、佣金、會員費等。<br /></li>
</ul></li>
<li>平台經營模式的優勢：<br />
<ul class="org-ul">
<li>網絡效應： 用戶越多，平台價值越高，形成正向循環。<br /></li>
<li>規模經濟： 平台可以服務大量用戶，降低單位成本。<br /></li>
<li>多元化收入來源： 平台可以從多個方面獲取收入，降低風險。<br /></li>
<li>創新： 平台可以促進創新，讓第三方開發者在其上開發應用和服務。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org059dd5f" class="outline-4">
<h4 id="org059dd5f"><span class="section-number-4">2.1.4.</span> 4.資訊安全目前一直是所有組織最關心與擔憂的議題，一個組織要能夠有效率的資訊安全管理，必須要由組織的許多面向與層次(例如政策、組織、人員、制度、科技等)同時來建立，請問，如果你是一個資安顧問，你會如何建立一個完整的資訊安全管理架構，來嚇阻、預防與偵測資安的威脅？ (提示：ISO 27001) <code>[25%]</code></h4>
<div class="outline-text-4" id="text-2-1-4">
</div>
<div id="outline-container-org3be88b5" class="outline-5">
<h5 id="org3be88b5">解</h5>
<div class="outline-text-5" id="text-org3be88b5">
<p>
建立資訊安全管理架構：<br />
</p>
<ul class="org-ul">
<li>全面性： 資訊安全需要考量組織的許多面向與層次，不能只專注在單一技術或措施。<br /></li>
<li>政策： 制定明確的資訊安全政策，規範員工的行為，並確保與法規要求一致。<br /></li>
<li>組織： 建立資訊安全組織，明確人員的責任和權限。<br /></li>
<li>人員： 對員工進行資訊安全培訓，提高安全意識。<br /></li>
<li>制度： 建立完善的資訊安全管理制度，例如：風險評估、存取控制、事件回應等。<br /></li>
<li>科技： 導入必要的資訊安全技術，例如：防火牆、入侵偵測系統、資料加密等。<br /></li>
<li>符合 ISO 27001 標準： 參考 ISO 27001 標準，建立符合國際標準的資訊安全管理系統。<br /></li>
<li>嚇阻、預防、偵測： 建立完善的資訊安全管理架構來達到這三個目的。<br />
<ul class="org-ul">
<li>嚇阻： 建立嚴格的規範與制度，讓潛在的攻擊者知難而退。<br /></li>
<li>預防： 採取主動的防禦措施，降低資安事件發生的可能性。<br /></li>
<li>偵測： 建立監控機制，及早發現資安威脅。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orga6614d3" class="outline-3">
<h3 id="orga6614d3"><span class="section-number-3">2.2.</span> 110: 中山資料結構</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org7e62ac7" class="outline-4">
<h4 id="org7e62ac7"><span class="section-number-4">2.2.1.</span> 1. AVL tree operations. (16%; 4% for each)</h4>
<div class="outline-text-4" id="text-2-2-1">
</div>
<div id="outline-container-org404660f" class="outline-5">
<h5 id="org404660f">(A) Please draw the result of inserting the keys 6, 5, 3, 9, 10 into an empty AVL tree.</h5>
<div class="outline-text-5" id="text-org404660f">
</div>
<ul class="org-ul">
<li><a id="orgd2935aa"></a>解: 插入鍵值 6, 5, 3, 9, 10<br />
<div class="outline-text-6" id="text-orgd2935aa">
<ol class="org-ol">
<li><p>
插入 6：建立一個只有根節點的樹：<br />
</p>
<pre class="example" id="org64539f1">
  6
</pre></li>
<li><p>
插入 5：插入左子樹，平衡性仍然維持：<br />
</p>
<pre class="example" id="org6c9b45b">
  6
 /
5
</pre></li>
<li><p>
插入 3：插入 5 的左子樹後導致失衡，執行右旋：<br />
</p>
<pre class="example" id="org44d94a6">
    5
   / \
  3   6
</pre></li>
<li><p>
插入 9：插入 6 的右子樹：<br />
</p>
<pre class="example" id="org7c8ac69">
    5
   / \
  3   6
       \
        9
</pre></li>
<li><p>
插入 10：插入 9 的右子樹後導致失衡，執行左旋：<br />
</p>
<pre class="example" id="orga6ed60e">
    5
   / \
  3   9
     / \
    6  10
</pre></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgad979cc" class="outline-5">
<h5 id="orgad979cc">(B) Please draw the result after inserting the keys 7, 8, 11 into the AVL tree from (A).</h5>
<div class="outline-text-5" id="text-orgad979cc">
</div>
<ul class="org-ul">
<li><a id="org3b8017d"></a>解: 插入鍵值 7, 8, 11<br />
<div class="outline-text-6" id="text-org3b8017d">
<ol class="org-ol">
<li><p>
插入 7：插入 6 的右子樹：<br />
</p>
<pre class="example" id="org988b031">
    5
   / \
  3   9
     / \
    6  10
     \
      7
</pre></li>
<li><p>
插入 8：插入 7 的右子樹後導致失衡，對 6 節點執行左旋：<br />
</p>
<pre class="example" id="orgd218226">
    5
   / \
  3   9
     / \
    7  10
   / \
  6   8
</pre></li>
<li><p>
插入 11：插入 10 的右子樹後無需調整：<br />
</p>
<pre class="example" id="org424f239">
        5
       / \
      3   9
         / \
        7  10
       / \    \
      6   8    11
</pre></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org08de128" class="outline-5">
<h5 id="org08de128">(C) Please draw the result after removing the key 6 from the AVL tree from (B).</h5>
<div class="outline-text-5" id="text-org08de128">
</div>
<ul class="org-ul">
<li><a id="org2758e3b"></a>解:刪除鍵值 6<br />
<div class="outline-text-6" id="text-org2758e3b">
<p>
移除葉節點 6，不影響平衡性：<br />
</p>
<pre class="example" id="org5098c02">
    5
   / \
  3   9
     / \
    7  10
     \    \
      8    11
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-org206d30e" class="outline-5">
<h5 id="org206d30e">(D) Please draw the result after removing the key 11 from the AVL tree from (C).</h5>
<div class="outline-text-5" id="text-org206d30e">
</div>
<ul class="org-ul">
<li><a id="org5327582"></a>解: 刪除鍵值 11<br />
<div class="outline-text-6" id="text-org5327582">
<p>
移除葉節點 11，不影響平衡性：<br />
</p>
<pre class="example" id="org8604d25">
    5
   / \
  3   9
     / \
    7  10
     \
      8
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga726bf1" class="outline-4">
<h4 id="orga726bf1"><span class="section-number-4">2.2.2.</span> 2. (10%; 5% for each)</h4>
<div class="outline-text-4" id="text-2-2-2">
</div>
<div id="outline-container-org6a587e5" class="outline-5">
<h5 id="org6a587e5">(A) What is the minimum number of nodes in an AVL tree to achieve the height = 9?</h5>
<div class="outline-text-5" id="text-org6a587e5">
</div>
<ul class="org-ul">
<li><a id="orgb8dbfe0"></a>解<br />
<div class="outline-text-6" id="text-orgb8dbfe0">
<p>
高度 h=9h=9，最小節點數公式為： N(h)=1+N(h−1)+N(h−2)N(h)=1+N(h−1)+N(h−2) 初始條件：<br />
N(0)=1,N(1)=2<br />
N(0)=1,N(1)=2<br />
</p>

<p>
逐步計算：<br />
N(2)=1+2+1=4,N(3)=1+4+2=7<br />
N(2)=1+2+1=4,N(3)=1+4+2=7<br />
</p>

<p>
&#x2026;<br />
N(9)=1+N(8)+N(7)=1+88+56=145<br />
N(9)=1+N(8)+N(7)=1+88+56=145<br />
</p>

<p>
答案：145<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org9709cac" class="outline-5">
<h5 id="org9709cac">(B) What is the maximum number of nodes in an AVL tree with height = 8? Note that the height is 1 for a tree with only one node.</h5>
<div class="outline-text-5" id="text-org9709cac">
</div>
<ul class="org-ul">
<li><a id="org3c7b229"></a>解:<br />
<div class="outline-text-6" id="text-org3c7b229">
<p>
高度為 8 的 AVL Tree 最大節點數<br />
</p>

<p>
高度 h=8h=8，滿二叉樹節點數為：<br />
N=2^(h+1)−1=29−1=511<br />
</p>

<p>
答案：511<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgcaeb146" class="outline-4">
<h4 id="orgcaeb146"><span class="section-number-4">2.2.3.</span> 3.(4%)</h4>
<div class="outline-text-4" id="text-2-2-3">
</div>
<div id="outline-container-org9ce2397" class="outline-5">
<h5 id="org9ce2397">(A) Dijkstra&rsquo;s algorithm will fail in what kind of situation? (4%)</h5>
<div class="outline-text-5" id="text-org9ce2397">
</div>
<ul class="org-ul">
<li><a id="org8da5f9a"></a>解:Dijkstra 演算法失效情況<br />
<div class="outline-text-6" id="text-org8da5f9a">
<p>
Dijkstra 演算法在圖中存在 負邊權重 時失效。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org279e292" class="outline-5">
<h5 id="org279e292">(B) Floyd-Warshall algorithm will fail in what kind of situation? (6%)</h5>
<div class="outline-text-5" id="text-org279e292">
</div>
<ul class="org-ul">
<li><a id="org3fab01f"></a>解:Floyd-Warshall 演算法失效情況<br />
<div class="outline-text-6" id="text-org3fab01f">
<p>
Floyd-Warshall 在圖中存在 負權重環 (Negative Weight Cycle) 時無法計算正確結果。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org016e5e7" class="outline-5">
<h5 id="org016e5e7">(C) Complete the following pseudo code of Floyd-Warshall algorithm.</h5>
<div class="outline-text-5" id="text-org016e5e7">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>let dist be a |V| x |V| array of minimum distances initialized to &#8734;
<span class="linenr">2: </span><span style="color: #51afef;">for</span> each vertex v
<span class="linenr">3: </span>    dist[v][v] &#8592; <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">4: </span><span style="color: #51afef;">for</span> each edge (u,v)
<span class="linenr">5: </span>    dist[u][v] &#8592; weight(u,v)
<span class="linenr">6: </span>    <span style="color: #51afef;">for</span> k from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">7: </span>        <span style="color: #51afef;">for</span> i from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">8: </span>            <span style="color: #51afef;">for</span> j from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">9: </span>                <span style="color: #51afef;">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgadc4444"></a>解: Floyd-Warshall 演算法的偽代碼補全<br />
<div class="outline-text-6" id="text-orgadc4444">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:
<span class="linenr">2: </span>    dist[i][j] = dist[i][k] + dist[k][j]
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org1bcbea3" class="outline-4">
<h4 id="org1bcbea3"><span class="section-number-4">2.2.4.</span> 4. (10%) Given the frequencies of characters shown in the following table, please encode these characters to binary codes using Huffman coding.</h4>
<div class="outline-text-4" id="text-2-2-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">A</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">C</th>
<th scope="col" class="org-right">D</th>
<th scope="col" class="org-right">E</th>
<th scope="col" class="org-right">F</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">45</td>
<td class="org-right">13</td>
<td class="org-right">12</td>
<td class="org-right">16</td>
<td class="org-right">9</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-orgcb4d789" class="outline-5">
<h5 id="orgcb4d789">解</h5>
<div class="outline-text-5" id="text-orgcb4d789">
</div>
<ul class="org-ul">
<li><a id="orgfbe6743"></a>步驟：<br />
<div class="outline-text-6" id="text-orgfbe6743">
<ol class="org-ol">
<li>合併最低頻率：F(5)+E(9)=14F(5)+E(9)=14<br /></li>
<li>合併結果與 C：C(12)+14=26C(12)+14=26<br /></li>
<li>合併 B 與 D：B(13)+D(16)=29B(13)+D(16)=29<br /></li>
<li>合併 AA 與 2626：A(45)+26=71A(45)+26=71<br /></li>
<li>合併 2929 與 7171：29+71=10029+71=100<br /></li>
</ol>
</div>
</li>
<li><a id="orgaaaa9ad"></a>編碼結果如下：<br />
<div class="outline-text-6" id="text-orgaaaa9ad">
<ul class="org-ul">
<li>A: 0<br /></li>
<li>B: 101<br /></li>
<li>C: 1001<br /></li>
<li>D: 11<br /></li>
<li>E: 10001<br /></li>
<li>F: 10000<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcea18b9" class="outline-3">
<h3 id="orgcea18b9"><span class="section-number-3">2.3.</span> 110: 中山資料結構</h3>
<div class="outline-text-3" id="text-2-3">
<p>
科目名稱： 【資管系碩士班乙組】 題號：442002 ※本科目依簡章規定「不可以」使用計算機(問答申論題) 共 2 頁 第 2 頁<br />
</p>
</div>
<div id="outline-container-org081e63f" class="outline-4">
<h4 id="org081e63f"><span class="section-number-4">2.3.1.</span> 5.(24%)</h4>
<div class="outline-text-4" id="text-2-3-1">
</div>
<div id="outline-container-orgb630953" class="outline-5">
<h5 id="orgb630953">(A) Write a procedure to reverse an array of integers.</h5>
<div class="outline-text-5" id="text-orgb630953">
</div>
<ul class="org-ul">
<li><a id="org0dda037"></a>解: 反轉整數陣列<br />
<div class="outline-text-6" id="text-org0dda037">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">reverse_array</span>(arr):
<span class="linenr">2: </span>    left, right = <span style="color: #da8548; font-weight: bold;">0</span>, len(arr) - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">while</span> left &lt; right:
<span class="linenr">4: </span>        arr[left], arr[right] = arr[right], arr[left]
<span class="linenr">5: </span>        left += <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">6: </span>        right -= <span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgaa4ccba" class="outline-5">
<h5 id="orgaa4ccba">(B) Analyze the time complexity (runtime formula) of your answer in (A)?</h5>
<div class="outline-text-5" id="text-orgaa4ccba">
<p>
時間複雜度：O(n)<br />
</p>
</div>
</div>
<div id="outline-container-orgb1a0091" class="outline-5">
<h5 id="orgb1a0091">(C) Write a procedure to calculate n! for a given integer n and analyze the time complexity of your procedure?</h5>
<div class="outline-text-5" id="text-orgb1a0091">
</div>
<ul class="org-ul">
<li><a id="orgfbb5a2d"></a>解: 計算 n!<br />
<div class="outline-text-6" id="text-orgfbb5a2d">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">factorial</span>(n):
<span class="linenr">2: </span>    <span style="color: #51afef;">if</span> n == <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #51afef;">or</span> n == <span style="color: #da8548; font-weight: bold;">1</span>:
<span class="linenr">3: </span>        <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">4: </span>    <span style="color: #51afef;">return</span> n * factorial(n - <span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div>
<p>
時間複雜度：O(n)<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6a46db4" class="outline-5">
<h5 id="org6a46db4">(D) How many disk moves are needed in the recursive procedure for solving the n-disk Hanoi tower problem? Prove your answer.</h5>
<div class="outline-text-5" id="text-org6a46db4">
</div>
<ul class="org-ul">
<li><a id="orgad175f2"></a>解: 河內塔問題移動次數<br />
<div class="outline-text-6" id="text-orgad175f2">
<p>
公式為：<br />
\[ T(n)=2^n−1 \]<br />
</p>

<p>
證明：遞迴式 T(n)=2T(n−1)+1T(n)=2T(n−1)+1 解為 \(2^n−1\)。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge7ce8f3" class="outline-4">
<h4 id="orge7ce8f3"><span class="section-number-4">2.3.2.</span> 6. (26%) For a graph G = (V, E), V = {1, 2, 3, 4, 5, 6, 7}, E = {(1, 2), (2, 3), (3, 4), (1, 5), (2, 5), (1, 6), (1, 7), (5, 4), (6, 7)}, and the cost for above edges are {11, 5, 12, 18, 20, 6, 11, 14, 23}, respectively.</h4>
<div class="outline-text-4" id="text-2-3-2">
</div>
<div id="outline-container-org2435701" class="outline-5">
<h5 id="org2435701">(A) Use Prim’s algorithm to find the minimum spanning tree of G and give the cost.</h5>
<div class="outline-text-5" id="text-org2435701">
</div>
<ul class="org-ul">
<li><a id="org06f2e5a"></a>解:Prim 演算法找最小生成樹<br />
<div class="outline-text-6" id="text-org06f2e5a">
<ul class="org-ul">
<li>起點：節點 1<br /></li>
<li>選邊順序：(1,2)→(2,3)→(3,4)→(1,5)→(1,6)→(1,7)<br /></li>
<li>總成本：11+5+12+18+6+11=63<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge2f93bf" class="outline-5">
<h5 id="orge2f93bf">(B) How to detect a cycle in the above algorithm?</h5>
<div class="outline-text-5" id="text-orge2f93bf">
</div>
<ul class="org-ul">
<li><a id="org38efa27"></a>解: 如何檢測環<br />
<div class="outline-text-6" id="text-org38efa27">
<ul class="org-ul">
<li>在加入邊時，使用 並查集 (Union-Find) 判斷兩端點是否已連通。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org418f0f4" class="outline-5">
<h5 id="org418f0f4">(C) Starting from node 1, use Depth First Search (DFS) and Breadth First Search (BFS) to determine the minimum spanning tree of graph G.</h5>
<div class="outline-text-5" id="text-org418f0f4">
</div>
<ul class="org-ul">
<li><a id="orgf4f1e29"></a>解: DFS 與 BFS 的最小生成樹<br />
<div class="outline-text-6" id="text-orgf4f1e29">
<ul class="org-ul">
<li>DFS 和 BFS 找出的生成樹不一定是最小生成樹，因為這兩者不考慮邊的權重。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1d594fc" class="outline-5">
<h5 id="org1d594fc">(D) Can DFS or BFS guarantee to find the optimal solution? Why?</h5>
<div class="outline-text-5" id="text-org1d594fc">
</div>
<ul class="org-ul">
<li><a id="org4b73466"></a>解<br />
<div class="outline-text-6" id="text-org4b73466">
<ul class="org-ul">
<li>不能，因為最優解取決於邊權重，而 DFS 和 BFS 並未考慮此條件。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org49a8b92" class="outline-5">
<h5 id="org49a8b92">(E) Write a procedure to find (list) all connected components of a graph.</h5>
<div class="outline-text-5" id="text-org49a8b92">
</div>
<ul class="org-ul">
<li><a id="org6686800"></a>解:<br />
<div class="outline-text-6" id="text-org6686800">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">connected_components</span>(graph):
<span class="linenr"> 2: </span>    visited = set()
<span class="linenr"> 3: </span>    components = []
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    def dfs(node, component):
<span class="linenr"> 6: </span>        visited.add(node)
<span class="linenr"> 7: </span>        component.append(node)
<span class="linenr"> 8: </span>        <span style="color: #51afef;">for</span> neighbor in graph[node]:
<span class="linenr"> 9: </span>            <span style="color: #51afef;">if</span> neighbor <span style="color: #51afef;">not</span> in visited:
<span class="linenr">10: </span>                dfs(neighbor, component)
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #51afef;">for</span> node in graph:
<span class="linenr">13: </span>        <span style="color: #51afef;">if</span> node <span style="color: #51afef;">not</span> in visited:
<span class="linenr">14: </span>            component = []
<span class="linenr">15: </span>            dfs(node, component)
<span class="linenr">16: </span>            components.append(component)
<span class="linenr">17: </span>
<span class="linenr">18: </span>    <span style="color: #51afef;">return</span> components
<span class="linenr">19: </span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgef5944e" class="outline-3">
<h3 id="orgef5944e"><span class="section-number-3">2.4.</span> 110: 中山計概</h3>
<div class="outline-text-3" id="text-2-4">
<ol class="org-ol">
<li>In Python 3, which of the following is used to define a block of code (e.g. body of loop)? A. Curly braces B. Indentation C. Semicolon D. Parenthesis<br />
<ul class="org-ul">
<li>解答：B. Indentation<br /></li>
<li>Python 使用 縮排 (Indentation) 來定義代碼塊，例如 for 或 if 的內容，這與其他語言的花括號 ({}) 不同。<br /></li>
</ul></li>
<li>Which of the following is NOT considered the reason for the recent AI boom? A. The global investment of AI B. The accessibility of cheap computation C. The exponential growth of data D. The advances of learning algorithms<br />
<ul class="org-ul">
<li>解答：A. The global investment of AI<br /></li>
<li>雖然 AI 的投資確實在增加，但這並非 AI 爆炸的直接技術性原因，而是技術的普及結果。其他選項 (計算能力、數據增長、演算法進步) 才是 AI 發展的核心推動力。<br /></li>
</ul></li>
<li>Which of the following about split-apply-combine strategy of data analytics is FALSE? A. It can be implemented by SQL B. It should not be used to replace loops C. It can help parallelize computations D. It is widely used in daily data management tasks<br />
<ul class="org-ul">
<li>解答：B. It should not be used to replace loops<br /></li>
<li>解釋：Split-apply-combine 策略常用於數據分析中，用來分割數據，應用函數，並將結果結合。它通常可以替代迴圈，提高計算效率，特別是在使用 pandas 或 SQL 等工具時。<br /></li>
</ul></li>
<li>Which of the following about Deep Neural Network is FALSE? A. The trained models are usually called black-box models B. Compared to traditional machine learning algorithms, it has more hyperparameters to tune C. It takes more time to do manual feature engineering D. It usually requires comparatively more computing resources to train a model<br />
<ul class="org-ul">
<li>解答：C. It takes more time to do manual feature engineering<br /></li>
<li>解釋： 深度神經網路的特點是可以自動提取特徵，因此通常 不需要 花大量時間進行手動特徵工程。<br /></li>
</ul></li>
<li>Which of the following is NOT a common feature of object-oriented programming languages? A. Parallelism B. Polymorphism C. Encapsulation D. Inheritance<br />
<ul class="org-ul">
<li>解答：A. Parallelism<br /></li>
<li>解釋： 物件導向程式語言 (OOP) 的核心特性是 多型 (Polymorphism)、封裝 (Encapsulation) 和 繼承 (Inheritance)。平行運算並非 OOP 的內建特性。<br /></li>
</ul></li>
<li>Which of the following is NOT a common feature of functional programming languages? A. Lazy Evaluation B. Higher-order functions C. Recursion D. Inheritance<br />
<ul class="org-ul">
<li>解答：D. Inheritance<br /></li>
<li>解釋：繼承是物件導向的特性，而 惰性求值 (Lazy Evaluation)、高階函數 (Higher-order functions) 和 遞迴 (Recursion) 是函數式程式設計的核心特性。<br /></li>
</ul></li>
<li>Which of the following about cloud, fog, and edge computing is FALSE? A. Cloud computing is often used to process urgent requests in the local network B. To improve response times, fog computing can be used to process computation-intensive requests C. They help promote decentralized storages and computations D. Amazon Web Services can be considered cloud computing platforms<br />
<ul class="org-ul">
<li>解答：A. Cloud computing is often used to process urgent requests in the local network<br /></li>
<li>解釋：雲端運算通常處理集中式的非即時性計算需求，而本地網絡中的即時請求更適合邊緣運算或霧運算處理。<br /></li>
</ul></li>
<li>Which of the following about data structures is TRUE? A. Arrays are dynamic data structures able to increase their sizes at runtime B. The length of a linked list is usually fixed C. Data elements in a linked list must be stored in adjacent memory space D. Linked lists can be used to implement stacks<br />
<ul class="org-ul">
<li>解答：D. Linked lists can be used to implement stacks<br /></li>
<li>解釋：連結串列 (Linked List) 可以用來實現堆疊 (Stack)，而其他選項皆為錯誤：<br />
<ul class="org-ul">
<li>陣列大小是靜態的，不能在執行期增長 (A 錯)。<br /></li>
<li>連結串列長度不固定 (B 錯)。<br /></li>
<li>連結串列節點不需要儲存在連續的記憶體空間 (C 錯)。<br /></li>
</ul></li>
</ul></li>
<li>Suppose we have a table in the third normal form (3NF) in a relational database. Which of the following statement is FALSE? A. The table is also in the 2NF B. The table may have multiple candidate keys C. Every non-prime attribute is non-transitively dependent on every key of the table D. For each of the functional dependency A-&gt;B that exists, A is the super key of the table<br />
<ul class="org-ul">
<li>解答：D. For each of the functional dependency A-&gt;B that exists, A is the super key of the table<br /></li>
<li>解釋：在 3NF 中，函數依賴的屬性 AA 不一定是超鍵，只要 BB 是主鍵或候選鍵的非傳遞依賴即可。<br /></li>
</ul></li>
<li><p>
Consider the following tables, A and B, in a relational database:<br />
A:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
</tr>
</tbody>
</table>
<p>
B:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table>
<p>
Which of the following SQL statement can be used to concatenate A and B?<br />
</p>
<ul class="org-ul">
<li>A. SELECT * FROM A UNION ALL SELECT * FROM B<br /></li>
<li>B. SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id<br /></li>
<li>C. SELECT * FROM A INNER JOIN B ON A.id = B.id<br /></li>
<li>D. SELECT * FROM A LEFT JOIN B ON A.id = B.id<br /></li>
<li>解: 題目要求的是將兩張表 A 和 B 串接，這裡的 串接 指的是結合兩張表的所有數據，而非進行條件配對。仔細分析每個選項後，可以看出符合要求的正確語句。<br /></li>
<li>選項分析:<br />
<ol class="org-ol">
<li>SELECT * FROM A UNION ALL SELECT * FROM B<br />
<ul class="org-ul">
<li>說明：UNION ALL 是直接將兩張表的數據合併，不會過濾重複的記錄。在這裡，A 和 B 的結合將包含兩張表的所有數據，不需要關聯條件。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table></li>
<li>結論： 符合 串接 (concatenate) 的要求。<br /></li>
</ul></li>
<li>SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明：FULL OUTER JOIN 將返回兩張表中所有記錄，並將 匹配的 id 行合併。對於沒有匹配的記錄，將使用 NULL 填充缺失的列。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">NULL</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table></li>
<li>結論： 這是進行關聯操作，不符合單純串接兩張表的需求。<br /></li>
</ul></li>
<li>SELECT * FROM A INNER JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明：INNER JOIN 只返回 A 和 B 中 id 匹配的記錄。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>
</tbody>
</table></li>
<li>結論： 僅返回兩表中匹配的部分，不符合串接需求。<br /></li>
</ul></li>
<li>SELECT * FROM A LEFT JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明： LEFT JOIN 返回 A 中的所有記錄，並將匹配 B 的行合併；對於 B 中沒有匹配的部分，填充 NULL。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>
</tbody>
</table></li>
<li>結論： 這是進行關聯操作，不符合單純串接兩張表的需求。<br /></li>
</ul></li>
<li>正確解答 答案：A. SELECT * FROM A UNION ALL SELECT * FROM B<br /></li>
<li>補充說明<br />
<ul class="org-ul">
<li>UNION 和 UNION ALL 的區別：<br />
<ul class="org-ul">
<li>UNION 會移除重複的記錄。<br /></li>
<li>UNION ALL 不會移除重複記錄，速度更快，適合需要保留重複值的場合。<br /></li>
</ul></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT considered a kind of NoSQL databases? A. Graph database B. Document database C. Object-relational database D. Key-value database<br /></li>
<li>Which of the following is the postfix expression of math representation A * B / C + D - E? A. A B * C / D + E -<br />
<ol class="org-ol">
<li>A B * C / D + - E<br /></li>
<li>* A B / C + D - E<br /></li>
<li>- / + * A B C D E<br /></li>
</ol></li>
<li><p>
Which of the following is the post-order traversal of the below binary search tree?<br />
</p>
<pre class="example" id="orgde7cf36">
            45
           /  \
          /    \
         27    55
        /        \
      18          58
        \          \
         19         60
</pre>
<ol class="org-ol">
<li>18 19 27 45 55 58 60<br /></li>
<li>45 27 18 19 55 58 60<br /></li>
<li>19 18 27 55 58 60 45<br /></li>
<li>19 18 27 60 58 55 45<br /></li>
</ol>
<p>
解： 後序遍歷步驟<br />
</p>
<ol class="org-ol">
<li><p>
遍歷左子樹<br />
節點 27 的左子樹為：<br />
</p>
<pre class="example" id="org7798800">

            27
           /
          18
           \
            19

</pre>
<p>
後序遍歷順序：<br />
</p>
<ul class="org-ul">
<li>遍歷左子樹 18（沒有左子樹，直接看右子樹）。<br /></li>
<li>遍歷右子樹的 19。<br /></li>
<li>訪問根節點 27。<br /></li>
</ul>
<p>
結果：18 → 19 → 27<br />
</p></li>
<li><p>
遍歷右子樹<br />
節點 55 的右子樹為：<br />
</p>
<pre class="example" id="org8dc382f">
            55
              \
               58
                 \
                  60
</pre>
<p>
後序遍歷順序：<br />
</p>
<ul class="org-ul">
<li>遍歷左子樹（55 無左子樹，直接看右子樹）。<br /></li>
<li>遍歷右子樹的 58，接著是其右子樹的 60。<br /></li>
<li>訪問根節點 55。<br /></li>
</ul>
<p>
結果：60 → 58 → 55<br />
</p></li>
<li>訪問根節點<br />
最後訪問根節點 45。<br />
後序遍歷結果<br />
將步驟 1、2、3 的結果結合：<br />
18 → 19 → 27 → 60 → 58 → 55 → 45<br /></li>
</ol>
<p>
解答：D. 19 18 27 60 58 55 45<br />
</p></li>
</ol>
</div>
</div>
<div id="outline-container-orgae76f3e" class="outline-3">
<h3 id="orgae76f3e"><span class="section-number-3">2.5.</span> 110: 中山計概</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-org4adb7be" class="outline-4">
<h4 id="org4adb7be"><span class="section-number-4">2.5.1.</span> 單選題，每題 2.5 分</h4>
<div class="outline-text-4" id="text-2-5-1">
<ol class="org-ol">
<li>Which of the following statements about memory is FALSE? A. Static RAM is an example of volatile memory B. Flash memory is a type of nonvolatile memory that can be erased electronically and rewritten C. Dynamic RAM is faster than static RAM D. Read-only memory (ROM) is a type of nonvolatile memory<br />
<ul class="org-ul">
<li>解答：C. Dynamic RAM is faster than static RAM<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>Static RAM (SRAM) 是揮發性記憶體，比動態 RAM (DRAM) 更快，但成本也更高。<br /></li>
<li>Dynamic RAM (DRAM) 雖然更慢，但每單位存儲空間成本更低，常用於主記憶體。<br /></li>
<li>其他選項正確，因為 Flash 是非揮發性、ROM 是非揮發性記憶體。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following best describes the principle of least privilege? A. Data access restrictions are lifted to ensure data integrity B. Data is encrypted and passwords are used C. Users should not share access details with others D. Users’ access privileges are limited to the lowest level necessary to perform required tasks<br />
<ul class="org-ul">
<li>解答：D. Users’ access privileges are limited to the lowest level necessary to perform required tasks<br /></li>
<li>詳解：<br />
最小權限原則 (Principle of Least Privilege) 是一種安全策略，確保用戶只能存取完成工作所需的最小權限，減少安全風險。<br /></li>
</ul></li>
<li>Which of the following about the binary search algorithm is TRUE? A. It is not possible for a binary search to find the value 2 in the array of B. The maximum number of comparisons required to perform a binary search of a 1000 element array is 9 C. The best-case time complexity of a binary search is O(log N), with N the number of elements in an array D. An iterative implementation of the binary search has a space complexity of O(N), with N the number of elements in an array<br />
解答：B. The maximum number of comparisons required to perform a binary search of a 1000 element array is 9<br />
<ul class="org-ul">
<li>詳解：<br />
<ul class="org-ul">
<li>二分搜尋的時間複雜度為 O(log⁡N)O(logN)。對於 1000 個元素的陣列，最多需要比較 ⌈log⁡21000⌉=10⌈log2​1000⌉=10 次，因此選項 B 是正確的。<br /></li>
<li>最佳情況下（找到目標元素），時間複雜度為 O(1)O(1)，所以選項 C 錯誤。<br /></li>
<li>二分搜尋的迭代實現的空間複雜度是 O(1)O(1)，非 O(N)O(N)。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following about web application development is FALSE? A. CSS allows web designers to change the layout and appearance of the webpage B. HTML stands for hypertext markup language and used hashtags to specify the content of webpages C. JavaScript can be used to display a prompt box that prompts the user to input some text D. JavaScript adds interactivity to webpages<br />
<ul class="org-ul">
<li>解答：B. HTML stands for hypertext markup language and used hashtags to specify the content of webpages<br /></li>
<li>詳解：<br />
HTML 是超文字標記語言，使用標籤 (tags)，而非井號 (hashtags)，來描述網頁內容。<br /></li>
</ul></li>
<li>Which of the following provides remote users with a secure connection to the organization network? A. VPN B. https C. Ethernet D. FTP<br />
<ul class="org-ul">
<li>解答：A. VPN<br /></li>
<li>詳解：<br />
VPN (Virtual Private Network) 提供安全的遠端連線，通常用於保護敏感數據在公共網路上的傳輸。<br /></li>
</ul></li>
<li>Which of the following about deep learning frameworks is FALSE? A. PyTorch uses dynamic computation graphs B. Tensorflow is an open-source deep learning framework developed by Google C. Keras is officially integrated with PyTorch in the latest release of PyTorch D. TensorFlow 2.x supports dynamic computation graphs<br />
<ul class="org-ul">
<li>解答：C. Keras is officially integrated with PyTorch in the latest release of PyTorch<br /></li>
<li>詳解：<br />
Keras 是 TensorFlow 的高階 API，並非與 PyTorch 整合的框架。<br /></li>
</ul></li>
<li>Which of the following about IP addresses and domain names is FALSE? A. A DNS server translates an IP address to its corresponding domain name B. An IPv6 address is 128 bits in length and written as a string of hexadecimal digits C. An IPv4 address is 32 bits and often written in dotted decimal notation D. A domain name is a text-based name of a computer or server that is easier for humans to memorize<br />
<ul class="org-ul">
<li>解答：A. A DNS server translates an IP address to its corresponding domain name<br /></li>
<li>詳解：<br />
DNS (Domain Name System) 的作用是將域名轉換為對應的 IP 位址，而不是將 IP 位址轉換為域名。<br /></li>
</ul></li>
<li>The Hamming distance between two binary strings is defined as the number of bit positions in which two bits are different. Which of the following can be used to find the differences between two binary strings in computing Hamming distance? A. OR B. XOR C. AND D. NOT<br />
<ul class="org-ul">
<li>解答：B. XOR<br /></li>
<li>詳解：<br />
XOR (異或運算) 可以標識兩個二進位串不同的位置，然後統計結果中 1 的數量即可得到漢明距離。<br /></li>
</ul></li>
<li>Which of the following is NOT an advantage of solid-state drives (SSDs) over traditional hard disks? A. Faster transfer rates B. Less power consumption C. Lighter weight D. Lower cost per gigabyte<br />
<ul class="org-ul">
<li>解答：D. Lower cost per gigabyte<br /></li>
<li>詳解：<br />
SSD 的成本較高，特別是在每 GB 的價格上，通常比傳統硬碟 (HDD) 貴。<br /></li>
</ul></li>
<li>Amazon EC2 is an example of <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. A. IaaS B. PaaS C. SaaS D. DaaS<br />
<ul class="org-ul">
<li>解答：A. IaaS (Infrastructure as a Service)<br /></li>
<li>詳解：<br />
Amazon EC2 提供虛擬伺服器實例，讓用戶能建立和管理基礎設施，屬於 IaaS 類型服務。<br /></li>
</ul></li>
<li>Consider an operating system that uses paging for virtual memory management. Assume that there are 4 page frames which are initially empty. Given the page reference string 1, 2, 3, 4, 5, 1, 3, 1, 1, 6, 3, 2, 5, how many page faults occur if the optimal page replacement is used? A. 5 B. 6 C. 8 D. 9<br />
<ul class="org-ul">
<li>解答：C. 8<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>頁面參考字串：1, 2, 3, 4, 5, 1, 3, 1, 1, 6, 3, 2, 5<br /></li>
<li>初始頁框數：4<br /></li>
<li>遵循最佳頁替換策略，每次替換時選擇將來最晚被使用的頁。<br /></li>
<li>具體計算可得到 8 次頁錯誤。<br /></li>
</ul></li>
</ul></li>
<li>Consider the addition of two 8-bit 2’s complement integers. Which of the following is the binary representation of 6 + (-8)? A. 00000010 B. 11111110 C. 11110001 D. 11111110<br />
<ul class="org-ul">
<li>解答：B. 11111110<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>6=000001106=00000110，−8=11111000−8=11111000（以 2 的補碼表示）。<br /></li>
<li>計算 6+(−8)6+(−8)：00000110+11111000=1111111000000110+11111000=11111110。<br /></li>
</ul></li>
</ul></li>
<li>Given two vertices, s and t, in a graph, which of the two traversals, breadth-first search (BFS) and depth-first search (DFS), can be used to determine if there is a path from s to t? A. Only BFS B. Only DFS C. Both BFS and DFS D. Neither BFS nor DFS<br />
<ul class="org-ul">
<li>解答：C. Both BFS and DFS<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>BFS 和 DFS 都可用於判斷是否存在從 ss 到 tt 的路徑。<br /></li>
<li>BFS 適合尋找最短路徑，DFS 適合完整探索。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following about Wi-Fi networks is FALSE? A. Most Wi-Fi is based on the 802.15 standards developed by IEEE B. Wi-Fi accesses the network in conjunction with the TCP/IP standard C. Most devices support multiple Wi-Fi standards D. Wi-Fi is often used to provide hot spots<br />
<ul class="org-ul">
<li>解答：A. Most Wi-Fi is based on the 802.15 standards developed by IEEE<br /></li>
<li>詳解：<br />
Wi-Fi 是基於 IEEE 802.11 標準，而 802.15 是藍牙標準。<br /></li>
</ul></li>
<li>Which of the following about network architectures is TRUE? A. Only one computer can act as a server on the client/server network B. Each device on a peer-to-peer network can share its resources with other devices C. One client computer crashing can affect the other computers on a client/server network D. A computer can act as either a client or a server, but not both, on a peer-to-peer network<br />
<ul class="org-ul">
<li>解答：B. Each device on a peer-to-peer network can share its resources with other devices<br /></li>
<li>詳解：<br />
P2P 網路允許每個設備共享資源，而其他選項的描述均不正確。<br /></li>
</ul></li>
<li>In 2020, Amazon Web Services was hit by an attack that floods the target with massive amounts of data to disrupt normal traffic. What is this attack called? A. Phishing B. Ransomware C. Malware attack D. DDoS<br />
<ul class="org-ul">
<li>解答：D. DDoS<br /></li>
<li>詳解：<br />
DDoS (Distributed Denial-of-Service) 是一種透過大規模數據請求癱瘓伺服器的攻擊方式。<br /></li>
</ul></li>
<li>Which of the following about drones is TRUE? A. The flight of drones cannot operate by an onboard computer or an autopilot B. A drone is an aircraft that operates by a human on board C. A drone is also known as an unmanned aerial vehicle (UAV) D. Drones are for hobbyists and cannot be used to monitor crop growth<br />
<ul class="org-ul">
<li>解答：C. A drone is also known as an unmanned aerial vehicle (UAV)<br /></li>
<li>詳解：<br />
無人機 (Drone) 是無人駕駛航空器 (UAV)，可由自動駕駛或人遠程操作。<br /></li>
</ul></li>
<li>Which of the following is a small, high-speed storage location within a processor that temporarily hold data and instructions? A. ALU B. CU C. register D. RAM<br />
<ul class="org-ul">
<li>解答：C. register<br /></li>
<li>詳解：<br />
寄存器 (register) 是處理器內部的高速存儲位置，用於臨時保存數據和指令。<br /></li>
</ul></li>
<li>Wearable devices, such as smartwatches, can monitor blood pressure and heart rates and send alerts in case of emergency, which is an example of <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. A. big data B. wireless communication C. cloud computing D. internet of things<br />
<ul class="org-ul">
<li>解答：D. internet of things<br /></li>
<li>詳解：<br />
穿戴裝置屬於物聯網 (IoT) 應用的一部分，將感測數據連接至網路進行處理。<br /></li>
</ul></li>
<li>Which of the following about RAID is TRUE? A. RAID 0 writes data to two drives at the same time to duplicate the data B. RAID 1 provides data reliability via redundancy C. Mirroring splits data and instructions across multiple drives in the array D. RAID stands for reliable array of inexpensive disks<br />
<ul class="org-ul">
<li>解答：B. RAID 1 provides data reliability via redundancy<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>RAID 1 透過鏡像技術提供冗餘數據保護。<br /></li>
<li>RAID 0 並未提供數據保護。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following is a last-in fast-out data structure? A. array B. stack C. queue D. tree<br />
<ul class="org-ul">
<li>解答：B. stack<br /></li>
<li>詳解：<br />
堆疊 (stack) 遵循後進先出 (LIFO) 原則，其他選項均不符。<br /></li>
</ul></li>
<li>In C/C++ programming, it requires at least <span class="underline"><span class="underline"><span class="underline">__</span></span></span> byte(s) when an integer number 32768 is stored as characters in computer memory. A. 2 B. 4 C. 5 D. 8<br />
<ul class="org-ul">
<li>解答：C. 5<br /></li>
<li>詳解：<br />
32768 作為字元需轉為 ASCII 表示，包括 3, 2, 7, 6, 8 共 5 個字元。<br /></li>
</ul></li>
<li>Which of the following is NOT a common data format/structure to save and describe network data? A. adjacency matrix B. hash table C. adjacency list D. edge list<br />
<ul class="org-ul">
<li>解答：B. hash table<br /></li>
<li>詳解：<br />
雖然哈希表常用於查詢，但不是保存網路數據的標準結構。<br /></li>
</ul></li>
<li>Consider the below C/C++ statement: int i = 1; const int *iPtr = &amp;i; Which of the following is FALSE? A. iPtr is a variable that stores a memory address B. Statement *iPtr = 10 is invalid C. iPtr is a pointer variable that points to an object of type int D. The data value of the object that iPtr points to can be modified<br />
<ul class="org-ul">
<li>解答：D. The data value of the object that iPtr points to can be modified<br /></li>
<li>詳解：<br />
const int *iPtr 指向的值不可修改。<br /></li>
</ul></li>
<li><p>
Consider the below C/C++ program:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">    #include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span> (){
<span class="linenr">3: </span>      <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">aStr</span>[] = <span style="color: #98be65;">"A string"</span>;
<span class="linenr">4: </span>      <span style="color: #ECBE7B;">void</span> <span style="color: #dcaeea;">pPtr</span> = &amp;aStr;
<span class="linenr">5: </span>      printf(<span style="color: #98be65;">"%s\n"</span>, ((<span style="color: #ECBE7B;">char</span>) aPtr));
<span class="linenr">6: </span>    }
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following statement is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show &ldquo;A string&rdquo; D. It will show &ldquo;A&rdquo;<br />
</p>
<ul class="org-ul">
<li>解答：A. It will show compilation errors<br /></li>
<li>詳解：<br />
void pPtr = &amp;aStr; 是錯誤的，void 不能直接用於指針。<br /></li>
</ul></li>
<li><p>
Consider the below C/C++ program:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">    #include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span>    <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span>{ <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>; <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>; };
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">passXY</span>(<span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span> *<span style="color: #dcaeea;">xy</span>){
<span class="linenr"> 4: </span>      xy -&gt; x = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 5: </span>      xy -&gt; y = <span style="color: #da8548; font-weight: bold;">2</span>;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>(<span style="color: #ECBE7B;">void</span>){
<span class="linenr"> 8: </span>      <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span> <span style="color: #dcaeea;">s</span>;
<span class="linenr"> 9: </span>      s.x = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">10: </span>      s.y = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">11: </span>      passXY(&amp;s);
<span class="linenr">12: </span>      printf(<span style="color: #98be65;">"x = %d, y = %d\n"</span>, s.x, s.y);
<span class="linenr">13: </span>    }
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following statement is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show &ldquo;x = 0, y = 0&rdquo; D. It will show &ldquo;x = 1, y = 2&rdquo;<br />
</p>
<ul class="org-ul">
<li>解答：D. It will show &ldquo;x = 1, y = 2&rdquo;<br /></li>
<li>詳解：<br />
指針 &amp;s 被傳遞，函數 passXY 成功修改了結構的成員值。<br /></li>
</ul></li>
<li>Which of the following about recursion is TRUE? A. We should always replace iterations with recursions if possible B. Recursion usually uses less memory than iteration as the code is more concise and clearer C. Recursion usually has higher algorithm performance D. Any problems that can be solved by recursions can also be solved by iterations<br />
<ul class="org-ul">
<li>解答：D. Any problems that can be solved by recursions can also be solved by iterations<br /></li>
<li>詳解：<br />
任何遞迴問題都可以轉換為迭代解法，雖然代碼可能更冗長。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgbb4d167" class="outline-3">
<h3 id="orgbb4d167"><span class="section-number-3">2.6.</span> 111: 中山計概</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-org2adc78f" class="outline-4">
<h4 id="org2adc78f"><span class="section-number-4">2.6.1.</span> 第一题：</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
Which data structure is often used when implementing the depth first search algorithm? A. Heap B. Queue C. Stack D. Tree E. None of the above<br />
</p>
</div>
<div id="outline-container-orgfde0623" class="outline-5">
<h5 id="orgfde0623">答案：C. Stack</h5>
<div class="outline-text-5" id="text-orgfde0623">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>深度優先搜尋（DFS）演算法的實作通常依賴 堆疊（Stack） 來追蹤遞迴過程中的節點。<br /></li>
<li>遞迴（Recursive）版本的 DFS 直接利用函式呼叫堆疊。<br /></li>
<li>非遞迴版本的 DFS 使用明確的 堆疊 來存放即將探索的節點。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Heap → 堆積（Heap）通常用於優先隊列（如 Dijkstra）。<br /></li>
<li>Queue → 廣度優先搜尋（BFS）使用佇列（Queue），而不是 DFS。<br /></li>
<li>Stack → 正確答案，DFS 依賴堆疊。<br /></li>
<li>Tree → 樹是一種資料結構，而非 DFS 主要依賴的結構。<br /></li>
<li>None of the above → 錯誤，DFS 依賴 Stack。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc6cdb76" class="outline-4">
<h4 id="orgc6cdb76"><span class="section-number-4">2.6.2.</span> 第二題：</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
Which of the following best describes a NAND gate? A. An AND followed by a NOT B. A NOT followed by an AND C. An OR followed by a NOT D. A NOT followed by an OR E. An OR followed by a NOT<br />
</p>
</div>
<div id="outline-container-org10d1379" class="outline-5">
<h5 id="org10d1379">答案：A. An AND followed by a NOT</h5>
<div class="outline-text-5" id="text-org10d1379">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>NAND（Not AND）閘 是 AND 閘 接上 NOT 閘，輸出是 AND 結果的反向：<br /></li>
<li>NAND(A,B)=¬(A∧B)<br /></li>
<li>NAND(A,B)=¬(A∧B)<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>An AND followed by a NOT → 正確，NAND 是 AND 的反向。<br /></li>
<li>A NOT followed by an AND → 錯誤，這表示先對輸入 NOT，再做 AND，不符合 NAND。<br /></li>
<li>An OR followed by a NOT → 這是 NOR 閘的定義，不是 NAND。<br /></li>
<li>A NOT followed by an OR → 這是 NOR 的另一種錯誤描述。<br /></li>
<li>An OR followed by a NOT → 再次描述 NOR，不是 NAND。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgebeaae7" class="outline-4">
<h4 id="orgebeaae7"><span class="section-number-4">2.6.3.</span> 第三題：</h4>
<div class="outline-text-4" id="text-2-6-3">
<p>
What is the 8-bit 2&rsquo;s complement representation of the decimal number -5? A. 00000101 B. 11111010 C. 11111011 D. 10000101 E. None of the above<br />
</p>
</div>
<div id="outline-container-org62801a9" class="outline-5">
<h5 id="org62801a9">答案：C. 11111011</h5>
<div class="outline-text-5" id="text-org62801a9">
<p>
解析：<br />
</p>
<ol class="org-ol">
<li>先求 +5 的二進位（8-bit）：00000101<br /></li>
<li>取反（1&rsquo;s 補數）：11111010<br /></li>
<li>加 1（2&rsquo;s 補數）：    11111011<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>00000101 → 這是 +5，不是 -5。<br /></li>
<li>11111010 → 這是 -5 的 1&rsquo;s 補數，不是 2&rsquo;s 補數。<br /></li>
<li>11111011 → 正確，這是 -5 的 2&rsquo;s 補數。<br /></li>
<li>10000101 → 這是錯誤的表示法。<br /></li>
<li>None of the above → 錯，C 是正確答案。<br /></li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org86b6784" class="outline-4">
<h4 id="org86b6784"><span class="section-number-4">2.6.4.</span> 第四題：</h4>
<div class="outline-text-4" id="text-2-6-4">
<p>
Which of the following best describes paging? A. The process a computer goes through when dividing data into disk sectors. B. The technique of swapping items between memory and storage. C. When a computer or mobile device executes instructions. D. The conversion of data into readable, usable information. E. None of the above<br />
</p>
</div>
<div id="outline-container-orgd99f68b" class="outline-5">
<h5 id="orgd99f68b">答案：B. The technique of swapping items between memory and storage</h5>
<div class="outline-text-5" id="text-orgd99f68b">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>分頁（Paging） 是記憶體管理技術，用來 在 RAM 和磁碟之間交換頁面，以模擬更大的可用記憶體。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>The process a computer goes through when dividing data into disk sectors. → 這是磁碟管理，而非 Paging。<br /></li>
<li>The technique of swapping items between memory and storage. → 正確，Paging 將資料在 RAM 和磁碟間交換。<br /></li>
<li>When a computer or mobile device executes instructions. → 這是 CPU 執行程序，不是 Paging。<br /></li>
<li>The conversion of data into readable, usable information. → 這是資料處理，不是 Paging。<br /></li>
<li>None of the above. → 錯，B 是正確答案。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org46d90a5" class="outline-4">
<h4 id="org46d90a5"><span class="section-number-4">2.6.5.</span> 第五題：</h4>
<div class="outline-text-4" id="text-2-6-5">
<p>
Which of the following statements about storage devices/media is FALSE? A. A group of two or more integrated hard drives is called a RAID. B. Solid-state drives have less power consumption than traditional hard disks. C. Defragmentation is not required for solid-state drives. D. USB flash drives normally run faster than solid-state drives. E. None of the above<br />
</p>
</div>
<div id="outline-container-orgf9fc76c" class="outline-5">
<h5 id="orgf9fc76c">答案：D. USB flash drives normally run faster than solid-state drives.</h5>
<div class="outline-text-5" id="text-orgf9fc76c">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>SSD（固態硬碟） 的速度 遠超過 USB 隨身碟，特別是 PCIe NVMe SSD，速度比 USB 3.0 隨身碟快數十倍。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>RAID 是多顆硬碟組合的存儲陣列。 ✅ 正確<br /></li>
<li>SSD 比傳統 HDD 耗電低。 ✅ 正確<br /></li>
<li>SSD 不需要磁碟重組（defragmentation）。 ✅ 正確<br /></li>
<li>USB 隨身碟比 SSD 快。 ❌ 錯誤，SSD 明顯更快。<br /></li>
<li>None of the above. ❌ 因為 D 錯誤。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7c47b3a" class="outline-4">
<h4 id="org7c47b3a"><span class="section-number-4">2.6.6.</span> 第六題：</h4>
<div class="outline-text-4" id="text-2-6-6">
<p>
Consider the below C program.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">getSteps</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>);
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 5: </span>  <span style="color: #51afef;">if</span> (<span style="color: #da8548; font-weight: bold;">1</span>==n) <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 6: </span>  <span style="color: #51afef;">if</span> (<span style="color: #da8548; font-weight: bold;">0</span>== n % <span style="color: #da8548; font-weight: bold;">2</span>)
<span class="linenr"> 7: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span> + getSteps(n/<span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr"> 8: </span>  <span style="color: #51afef;">else</span>
<span class="linenr"> 9: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span> + getSteps(<span style="color: #da8548; font-weight: bold;">3</span>*n+<span style="color: #da8548; font-weight: bold;">1</span>);
<span class="linenr">10: </span>}
</pre>
</div>
<p>
◦We would like to compile and run the program. Which of the following is TRUE?<br />
</p>
<ol class="org-ol">
<li>It will show compilation errors<br /></li>
<li>It will show run-time errors<br /></li>
<li>It will show 6<br /></li>
<li>It will show 7<br /></li>
<li>It will show 8<br /></li>
</ol>
</div>
<div id="outline-container-org2d676e4" class="outline-5">
<h5 id="org2d676e4">答案：A. It will show compilation errors</h5>
<div class="outline-text-5" id="text-org2d676e4">
<p>
解析：if (1==n) return 0; 中，變數 n 未定義，導致 編譯錯誤。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga501f38" class="outline-4">
<h4 id="orga501f38"><span class="section-number-4">2.6.7.</span> 第七題：</h4>
<div class="outline-text-4" id="text-2-6-7">
<p>
Consider the relation Product(pNo, pName, unitPrice, category). Which attribute(s) is the best choice to be used as a search key to build a B+ tree for efficiently evaluating the following SQL statement?<br />
</p>
<pre class="example" id="org3de9ee1">
SELECT pName
FROM Product
WHERE unitPrice &lt;= 1000 AND unitPrice &gt;=300
</pre>
<ol class="org-ol">
<li>pNo<br /></li>
<li>pName<br /></li>
<li>unitPrice<br /></li>
<li>category<br /></li>
<li>pNo, category<br /></li>
</ol>
</div>
<div id="outline-container-org72e14c8" class="outline-5">
<h5 id="org72e14c8">答案：C. unitPrice</h5>
<div class="outline-text-5" id="text-org72e14c8">
<p>
解析：WHERE unitPrice BETWEEN 300 AND 1000 會對 unitPrice 做範圍查詢，適合建立 B+ 樹索引。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org02c2f4b" class="outline-4">
<h4 id="org02c2f4b"><span class="section-number-4">2.6.8.</span> 第八題：</h4>
<div class="outline-text-4" id="text-2-6-8">
<p>
What is the time complexity of the binary search algorithm? Assume the number of elements in the array is N. A. O(1) B. O(N) C. O(logN) D. O(NlogN) E. (NlogN)<br />
</p>
</div>
<div id="outline-container-org88b5e2c" class="outline-5">
<h5 id="org88b5e2c">答案：C. O(logN)</h5>
<div class="outline-text-5" id="text-org88b5e2c">
<p>
解析：二元搜尋每次 將搜尋範圍減半，時間複雜度是 O(logN)。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd3ae67e" class="outline-4">
<h4 id="orgd3ae67e"><span class="section-number-4">2.6.9.</span> 第九題：</h4>
<div class="outline-text-4" id="text-2-6-9">
<p>
Consider the following C code.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">array</span>[] = {<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>};
<span class="linenr">4: </span>    printf(<span style="color: #98be65;">"%d"</span>, array[<span style="color: #da8548; font-weight: bold;">1</span>]);
<span class="linenr">5: </span>}
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show 1 D. It will show 4 E. It will show some junk value<br />
</p>
</div>
<div id="outline-container-org7092299" class="outline-5">
<h5 id="org7092299">答案：1.</h5>
<div class="outline-text-5" id="text-org7092299">
<ul class="org-ul">
<li>它會輸出 3，但 3 不在選項內，應該是 C（但錯誤）<br /></li>
<li>array[1] 取值為 3。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgaf0cf45" class="outline-4">
<h4 id="orgaf0cf45"><span class="section-number-4">2.6.10.</span> 第十題：</h4>
<div class="outline-text-4" id="text-2-6-10">
<p>
Which of the following about operating systems is TRUE? A. An operating system is an application software that manages the computer hardware and provides an interface between the hardware and the user. B. Microsoft Windows is an open-source software. C. Android is a Windows-like operating system. D. IOS is an operating system for Mac computers. E. None of the above<br />
</p>
</div>
<div id="outline-container-orgd4ba30f" class="outline-5">
<h5 id="orgd4ba30f">答案：E. None of the above</h5>
<div class="outline-text-5" id="text-orgd4ba30f">
<p>
解析：<br />
</p>
<ol class="org-ol">
<li>錯：作業系統是系統軟體，不是應用軟體。<br /></li>
<li>錯：Windows 不是開源軟體。<br /></li>
<li>錯：Android 和 Windows 不同，基於 Linux。<br /></li>
<li>錯：iOS 是行動裝置的 OS，Mac 使用 macOS。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org0e479c5" class="outline-4">
<h4 id="org0e479c5"><span class="section-number-4">2.6.11.</span> 第十一題：</h4>
<div class="outline-text-4" id="text-2-6-11">
<p>
With the even parity and ASCII code, which of the following is correct? A. 01101011 B. 00011011 C. 00100101 D. 10111010 E. None of the above<br />
</p>
</div>
<div id="outline-container-org3bcfbc6" class="outline-5">
<h5 id="org3bcfbc6">答案：E. None of the above</h5>
<div class="outline-text-5" id="text-org3bcfbc6">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>ASCII 字元為 7 位元，加上 偶數（even）奇偶校驗位 應該為 8 位元。<br /></li>
<li>偶數奇偶校驗（Even Parity）要求 1 的個數為偶數。<br /></li>
<li>檢查每個選項，沒有滿足此條件的，因此正確答案為 E. None of the above。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfd7fae6" class="outline-4">
<h4 id="orgfd7fae6"><span class="section-number-4">2.6.12.</span> 第十二題：</h4>
<div class="outline-text-4" id="text-2-6-12">
<p>
What is the network number of the IP address 140.117.17.200 with the subnet mask 255.255.255.224? A. 140.117.17.0 B. 140.117.17.128 C. 140.117.17.192 D. 140.117.17.224 E. 140.117.17.240<br />
</p>
</div>
<div id="outline-container-orgc6f8974" class="outline-5">
<h5 id="orgc6f8974">答案：C. 140.117.17.192</h5>
<div class="outline-text-5" id="text-orgc6f8974">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>子網掩碼 255.255.255.224（/27）表示 前 27 位為網路位址。<br /></li>
<li>每個子網的大小為 2^(32-27) = 32 個 IP。<br /></li>
<li>140.117.17.200 落在 140.117.17.192 到 140.117.17.223 之間，因此網路 ID 是 140.117.17.192。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2cbd7bf" class="outline-4">
<h4 id="org2cbd7bf"><span class="section-number-4">2.6.13.</span> 第十三題：</h4>
<div class="outline-text-4" id="text-2-6-13">
<p>
What is the height of a complete binary tree with 8192 nodes?  A. 8192 B. 4096 C. 12 D. 13 E. 14<br />
</p>
</div>
<div id="outline-container-org0651c89" class="outline-5">
<h5 id="org0651c89">答案：D. 13</h5>
<div class="outline-text-5" id="text-org0651c89">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>完全二元樹的高度 h 計算方式： \( 2^{h+1} + 1 >= 8192 \)<br /></li>
<li>反解得：h=log⁡2(8192+1)−1≈13<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb5154ad" class="outline-4">
<h4 id="orgb5154ad"><span class="section-number-4">2.6.14.</span> 第十四題：</h4>
<div class="outline-text-4" id="text-2-6-14">
<p>
What postfix expression does the expression tree below represent?<br />
</p>
<pre class="example" id="org7a7b146">
      +
    /   \
  +      -
 /  \   /  \
a    b c    d
</pre>
<ol class="org-ol">
<li>a+b*c-d<br /></li>
<li>(a+b)*(c-d)<br /></li>
<li>ab+cd-*<br /></li>
<li>ab+c*d-*<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgc4c9282" class="outline-5">
<h5 id="orgc4c9282">答案：C. ab+cd-*</h5>
<div class="outline-text-5" id="text-orgc4c9282">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>遍歷方式：<br />
<ul class="org-ul">
<li>後序（Postfix）順序： 左 -&gt; 右 -&gt; 根<br /></li>
<li>(a + b) * (c - d) → ab+cd-*<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgae4b5bb" class="outline-4">
<h4 id="orgae4b5bb"><span class="section-number-4">2.6.15.</span> 第十五題：</h4>
<div class="outline-text-4" id="text-2-6-15">
<p>
The IPv6 specification uses addresses to identify hosts that consist of: A. 16 bits B. 32 bits C. 64 bits D. 128 bits E. 256 bits<br />
</p>
</div>
<div id="outline-container-org8044224" class="outline-5">
<h5 id="org8044224">答案：D. 128 bits</h5>
<div class="outline-text-5" id="text-org8044224">
<ul class="org-ul">
<li>解析： IPv6 位址長度為 128 位元，而 IPv4 是 32 位元。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4582c00" class="outline-4">
<h4 id="org4582c00"><span class="section-number-4">2.6.16.</span> 第十六題：</h4>
<div class="outline-text-4" id="text-2-6-16">
<pre class="example" id="org8a9bec2">
      A
    /  \
   B    C
       /  \
      D    E
</pre>
<p>
Which of the following is an in-order traversal of the above tree? A. ABCDE B. ABDCE C. BACDE D. EDBCA E. BADCE<br />
</p>
</div>
<div id="outline-container-orgba07fdb" class="outline-5">
<h5 id="orgba07fdb">答案：E. BADCE</h5>
<div class="outline-text-5" id="text-orgba07fdb">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>中序遍歷順序： 左 -&gt; 根 -&gt; 右<br /></li>
<li>結果： B → A → D → C → E<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org380293f" class="outline-4">
<h4 id="org380293f"><span class="section-number-4">2.6.17.</span> 第十七題：</h4>
<div class="outline-text-4" id="text-2-6-17">
<p>
What is reinforcement learning? A. A kind of e-learning reinforced by classmates B. An educational technology to improve the learning performance C. A machine learning method based on maximizing the reward D. An unsupervised machine learning algorithm E. None of the above<br />
</p>
</div>
<div id="outline-container-orgc03a081" class="outline-5">
<h5 id="orgc03a081">答案：C. A machine learning method based on maximizing the reward</h5>
<div class="outline-text-5" id="text-orgc03a081">
<p>
解析：強化學習 透過獎勵機制（Reward）來學習最佳策略。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org2d9829c" class="outline-4">
<h4 id="org2d9829c"><span class="section-number-4">2.6.18.</span> 第十八題：</h4>
<div class="outline-text-4" id="text-2-6-18">
<p>
Which of the following technique is for using in local area network?<br />
</p>
<ol class="org-ol">
<li>Long-Term Evolution<br /></li>
<li>Ultra-Wide Band<br /></li>
<li>5G<br /></li>
<li>Bluetooth<br /></li>
<li>Ethernet<br /></li>
</ol>
</div>
<div id="outline-container-org280d127" class="outline-5">
<h5 id="org280d127">答案：E. Ethernet</h5>
<div class="outline-text-5" id="text-org280d127">
<p>
解析： 區域網路（LAN） 主要使用 Ethernet（乙太網路），而 LTE、5G 屬於行動網路技術。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org4856cfa" class="outline-4">
<h4 id="org4856cfa"><span class="section-number-4">2.6.19.</span> 第十九題：</h4>
<div class="outline-text-4" id="text-2-6-19">
<p>
Which of the following instruction level parallelism mechanisms highly depends on the compiler optimization but requires only a simple hardware?<br />
</p>
<ol class="org-ol">
<li>Out-of-order execution<br /></li>
<li>Branch prediction<br /></li>
<li>Superscalar<br /></li>
<li>Pipelining<br /></li>
<li>VLIW<br /></li>
</ol>
</div>
<div id="outline-container-org0b659cb" class="outline-5">
<h5 id="org0b659cb">答案：E. VLIW（Very Long Instruction Word）</h5>
<div class="outline-text-5" id="text-org0b659cb">
<p>
解析：VLIW 需要編譯器來決定指令並行性，而不依賴複雜硬體。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7afef04" class="outline-4">
<h4 id="org7afef04"><span class="section-number-4">2.6.20.</span> 第二十題：</h4>
<div class="outline-text-4" id="text-2-6-20">
<p>
Which of the following operating systems is not a Unix-like system?<br />
</p>
<ol class="org-ol">
<li>FreeBSD<br /></li>
<li>Linux<br /></li>
<li>Solaris<br /></li>
<li>macOS<br /></li>
<li>DOS<br /></li>
</ol>
</div>
<div id="outline-container-org04a6a4e" class="outline-5">
<h5 id="org04a6a4e">答案：E. DOS</h5>
<div class="outline-text-5" id="text-org04a6a4e">
<p>
解析： DOS（Disk Operating System） 是舊式作業系統，不是 Unix-like。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org310bb55" class="outline-4">
<h4 id="org310bb55"><span class="section-number-4">2.6.21.</span> 第二十一題：</h4>
<div class="outline-text-4" id="text-2-6-21">
<p>
(複選) Which of the following are main components of a CPU?<br />
</p>
<ol class="org-ol">
<li>Arithmetic Logic Unit<br /></li>
<li>Codec<br /></li>
<li>Registers<br /></li>
<li>Control Unit<br /></li>
<li>USB Controller<br /></li>
</ol>
</div>
<div id="outline-container-org6c81b3f" class="outline-5">
<h5 id="org6c81b3f">答案：A. Arithmetic Logic Unit, C. Registers, D. Control Unit</h5>
<div class="outline-text-5" id="text-org6c81b3f">
<p>
解析：  ALU（算術邏輯單元）、控制單元（CU）、暫存器（Registers） 是 CPU 核心部分。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb07e809" class="outline-4">
<h4 id="orgb07e809"><span class="section-number-4">2.6.22.</span> 第二十二題：</h4>
<div class="outline-text-4" id="text-2-6-22">
<p>
(複選) Which of the following principles are associated with object-oriented programming?<br />
</p>
<ol class="org-ol">
<li>Opcode mnemonics<br /></li>
<li>Inheritance<br /></li>
<li>Encapsulation<br /></li>
<li>Polymorphism<br /></li>
<li>Abstraction<br /></li>
</ol>
</div>
<div id="outline-container-orgfc1a5c0" class="outline-5">
<h5 id="orgfc1a5c0">答案：B. Inheritance, C. Encapsulation, D. Polymorphism, E. Abstraction</h5>
<div class="outline-text-5" id="text-orgfc1a5c0">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>物件導向的四大原則：<br />
<ul class="org-ul">
<li>封裝（Encapsulation）<br /></li>
<li>繼承（Inheritance）<br /></li>
<li>多型（Polymorphism）<br /></li>
<li>抽象（Abstraction）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd029852" class="outline-4">
<h4 id="orgd029852"><span class="section-number-4">2.6.23.</span> 第二十三題：</h4>
<div class="outline-text-4" id="text-2-6-23">
<p>
(複選) Which of the following encryption methods are symmetric-key algorithms?<br />
</p>
<ol class="org-ol">
<li>AES<br /></li>
<li>RSA<br /></li>
<li>3DES<br /></li>
<li>DES<br /></li>
<li>ChaCha20<br /></li>
</ol>
</div>
<div id="outline-container-orgfa75b7c" class="outline-5">
<h5 id="orgfa75b7c">答案：A. AES, C. 3DES, D. DES, E. ChaCha20</h5>
<div class="outline-text-5" id="text-orgfa75b7c">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>對稱加密（Symmetric-key encryption） 使用相同金鑰來加密/解密。<br /></li>
<li>非對稱加密（Asymmetric encryption）（如 RSA）使用公私鑰。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5ea00b4" class="outline-4">
<h4 id="org5ea00b4"><span class="section-number-4">2.6.24.</span> 第二十四題：</h4>
<div class="outline-text-4" id="text-2-6-24">
<p>
(複選) Wi-Fi 6E can run on which of the following frequency spectrums?<br />
</p>
<ol class="org-ol">
<li>2.4 GHz<br /></li>
<li>3.5 GHz<br /></li>
<li>5 GHz<br /></li>
<li>6 GHz<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org76c06e8" class="outline-5">
<h5 id="org76c06e8">答案：A. 2.4 GHz, C. 5 GHz, D. 6 GHz</h5>
<div class="outline-text-5" id="text-org76c06e8">
<p>
解析： Wi-Fi 6E 支援 2.4 GHz、5 GHz、6 GHz。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc82ec2e" class="outline-4">
<h4 id="orgc82ec2e"><span class="section-number-4">2.6.25.</span> 第二十五題：</h4>
<div class="outline-text-4" id="text-2-6-25">
<p>
(複選)Which of the following descriptions for blockchain technology is correct?<br />
</p>
<ol class="org-ol">
<li>Using daily chain topology<br /></li>
<li>A decentralization mechanism<br /></li>
<li>Proof of work is popularly used<br /></li>
<li>Using cryptographic hash algorithms<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgf268fb1" class="outline-5">
<h5 id="orgf268fb1">答案：B. A decentralization mechanism, C. Proof of work is popularly used, D. Using cryptographic hash algorithms</h5>
<div class="outline-text-5" id="text-orgf268fb1">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>區塊鏈的特性<br />
<ul class="org-ul">
<li>去中心化（Decentralization）<br /></li>
<li>工作量證明（PoW）<br /></li>
<li>加密雜湊演算法（Hashing）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org202a195" class="outline-4">
<h4 id="org202a195"><span class="section-number-4">2.6.26.</span> 第二十六題：</h4>
<div class="outline-text-4" id="text-2-6-26">
<p>
(複選)Which of the following about recursion is TRUE?<br />
</p>
<ol class="org-ol">
<li>recursive function is a function that calls itself.<br /></li>
<li>When a problem can be solved either recursively or iteratively, the recursive version usually incurs extra computational overheads.<br /></li>
<li>One must not use for-loops in a recursive function<br /></li>
<li>When a base case is never reached in a recursive function, it results in stack overflow.<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org94627a2" class="outline-5">
<h5 id="org94627a2">答案：A. recursive function is a function that calls itself, B. When a problem can be solved either recursively or iteratively, the recursive version usually incurs extra computational overheads, D. When a base case is never reached in a recursive function, it results in stack overflow</h5>
<div class="outline-text-5" id="text-org94627a2">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>遞迴函數會呼叫自己，且 無基底條件 會導致 堆疊溢位（Stack Overflow）。<br /></li>
<li>遞迴通常會 增加額外計算開銷。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4c3afcb" class="outline-4">
<h4 id="org4c3afcb"><span class="section-number-4">2.6.27.</span> 第二十七題：</h4>
<div class="outline-text-4" id="text-2-6-27">
<p>
(複選)Consider the relation T(A1, A2, A3, A4, A5, A6, A7) and the following functional  dependencies:<br />
</p>
<pre class="example" id="org69ff9f7">
A1 -&gt; A3
A2 -&gt; A4
A4 -&gt; A5
{A1, A2} -&gt; {A6, A7}
A6 -&gt; A1
A7 -&gt; A2
</pre>
<p>
Which of the following statements is TRUE?<br />
</p>
<ol class="org-ol">
<li>{A1, A3} is a key.<br /></li>
<li>{A3, A6, A7} is a key.<br /></li>
<li>{A1, A4, A7} is a key.<br /></li>
<li>{A2, A6} is a key.<br /></li>
<li>{A1, A2} is a key.<br /></li>
</ol>
</div>
<div id="outline-container-orgf4282e3" class="outline-5">
<h5 id="orgf4282e3">答案：E. {A1, A2} is a key</h5>
<div class="outline-text-5" id="text-orgf4282e3">
<ul class="org-ul">
<li>解析：{A1, A2} 可以唯一標識所有屬性，因此是候選鍵（Candidate Key）。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge5fdf2b" class="outline-4">
<h4 id="orge5fdf2b"><span class="section-number-4">2.6.28.</span> 第二十八題：</h4>
<div class="outline-text-4" id="text-2-6-28">
<p>
(複選)Which of the following about deep learning is TRUE?<br />
</p>
<ol class="org-ol">
<li>Convolutional neural networks (CNNs) are commonly used to process images.<br /></li>
<li>Recurrent neural networks (RNNs) can be used to process sequential data.<br /></li>
<li>Deep learning is loosely inspired by the human brain.<br /></li>
<li>The “deep” in deep learning refers to the number of nodes.<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgdbf4c34" class="outline-5">
<h5 id="orgdbf4c34">答案：A. Convolutional neural networks (CNNs) are commonly used to process images, B. Recurrent neural networks (RNNs) can be used to process sequential data, C. Deep learning is loosely inspired by the human brain</h5>
<div class="outline-text-5" id="text-orgdbf4c34">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>CNN 處理影像<br /></li>
<li>RNN 處理序列數據<br /></li>
<li>深度學習受神經網路啟發<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7fa9050" class="outline-4">
<h4 id="org7fa9050"><span class="section-number-4">2.6.29.</span> 第二十九題：</h4>
<div class="outline-text-4" id="text-2-6-29">
<p>
(複選)Which of the following storage are non-volatile?<br />
</p>
<ol class="org-ol">
<li>SDRAM<br /></li>
<li>DRAM<br /></li>
<li>ROM<br /></li>
<li>Flash memory<br /></li>
<li>Static RAM<br /></li>
</ol>
</div>
<div id="outline-container-orga62a091" class="outline-5">
<h5 id="orga62a091">答案：C. ROM, D. Flash memory</h5>
<div class="outline-text-5" id="text-orga62a091">
<p>
解析：ROM（唯讀記憶體） 和 快閃記憶體（Flash Memory） 不會斷電遺失資料。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc3616e3" class="outline-4">
<h4 id="orgc3616e3"><span class="section-number-4">2.6.30.</span> 第三十題：</h4>
<div class="outline-text-4" id="text-2-6-30">
<p>
(複選)Which of the following about the relational database is TRUE?<br />
</p>
<ol class="org-ol">
<li>If a relation is in BCNF, it also satisfies 3NF.<br /></li>
<li>A relation may have multiple candidate keys.<br /></li>
<li>A key is a minimal set of attributes that can uniquely identify tuples in a relation.<br /></li>
<li>A foreign key is also a superkey.<br /></li>
<li>If a relation is in 2NF, it also satisfies 3NF.<br /></li>
</ol>
</div>
<div id="outline-container-org8f87412" class="outline-5">
<h5 id="org8f87412">答案：A. If a relation is in BCNF, it also satisfies 3NF, B. A relation may have multiple candidate keys, C. A key is a minimal set of attributes that can uniquely identify tuples in a relation</h5>
<div class="outline-text-5" id="text-org8f87412">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>BCNF（巴斯-柯德正規形） 是 3NF 的加強版，因此滿足 3NF。<br /></li>
<li>關係可有多個候選鍵，但僅有一個主鍵。<br /></li>
<li>鍵（Key）必須是最小的唯一標識屬性組。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgde2fc18" class="outline-3">
<h3 id="orgde2fc18"><span class="section-number-3">2.7.</span> 111: 管理資訊系統</h3>
<div class="outline-text-3" id="text-2-7">
</div>
<div id="outline-container-orgea56993" class="outline-4">
<h4 id="orgea56993"><span class="section-number-4">2.7.1.</span> 一、金融科技是近年相當熱門的議題，請回答下列問題：</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
1、何謂金融科技？(5%)<br />
   金融科技（Financial Technology, FinTech）是指 運用新興科技（如人工智慧、大數據、區塊鏈、雲端運算）來優化金融服務與產品，提升金融交易效率、降低成本，並創造新的商業模式。<br />
2、金融科技的應用可以分成哪幾大類？(10%)<br />
   金融科技的應用可分為以下幾大類：<br />
</p>
<ul class="org-ul">
<li>數位支付（Digital Payment）<br /></li>
<li>借貸與融資（Lending &amp; Crowdfunding）<br /></li>
<li>數位銀行（Digital Banking）<br /></li>
<li>財務管理與投資（Wealth Management &amp; Robo-Advisors）<br /></li>
<li>保險科技（InsurTech）<br /></li>
<li>區塊鏈與加密貨幣（Blockchain &amp; Cryptocurrency）<br /></li>
<li>監管科技（RegTech, Regulatory Technology）<br /></li>
</ul>
<p>
3、請為上述每類舉一例說明之 (5%)。<br />
</p>
<ul class="org-ul">
<li>數位支付 → Apple Pay：使用 NFC 技術進行行動支付。<br /></li>
<li>借貸與融資 → Kiva：提供 P2P（點對點）小額借貸。<br /></li>
<li>數位銀行 → Revolut：純網銀，提供無實體卡的金融服務。<br /></li>
<li>財務管理 → Betterment：AI 自動投資管理平台。<br /></li>
<li>保險科技 → Lemonade：利用 AI 進行保險核保與賠付。<br /></li>
<li>區塊鏈與加密貨幣 → Bitcoin：全球第一種去中心化加密貨幣。<br /></li>
<li>監管科技 → Onfido：透過 AI 進行身份驗證，防止金融詐欺。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org24d9392" class="outline-4">
<h4 id="org24d9392"><span class="section-number-4">2.7.2.</span> 二、 近來NFT吸引到許多產業界的關注，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
1、請問何謂NFT？(5%)<br />
   NFT（Non-Fungible Token，非同質化代幣）是一種基於 區塊鏈技術 的數位資產，每個 NFT 具有唯一性、不可互換性，用於代表數位藝術品、收藏品、虛擬資產等。<br />
2、請試舉三種可能的NFT產業應用 (5%)<br />
</p>
<ol class="org-ol">
<li>數位藝術（Digital Art）：Beeple 的 NFT 作品《Everydays: The First 5000 Days》曾拍賣 6900 萬美元。<br /></li>
<li>遊戲資產（Gaming Assets）：Axie Infinity 允許玩家買賣 NFT 寵物。<br /></li>
<li>音樂版權（Music Rights）：音樂家可以透過 NFT 直接出售版權，減少中間商剝削。<br /></li>
</ol>
<p>
3、請說明NFT與一般的區塊鏈應用有何異同？(5%)。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">NFT</th>
<th scope="col" class="org-left">一般區塊鏈應用（如加密貨幣）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">性質</td>
<td class="org-left">唯一、不可互換</td>
<td class="org-left">可互換（如 Bitcoin, Ethereum）</td>
</tr>

<tr>
<td class="org-left">技術標準</td>
<td class="org-left">ERC-721, ERC-1155</td>
<td class="org-left">E  RC-20, BEP-20</td>
</tr>

<tr>
<td class="org-left">應用場景</td>
<td class="org-left">藝術、遊戲、收藏品</td>
<td class="org-left">貨幣、支付、DeFi</td>
</tr>

<tr>
<td class="org-left">價值來源</td>
<td class="org-left">稀缺性、收藏價值</td>
<td class="org-left">供需市場決定</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org089fd9f" class="outline-4">
<h4 id="org089fd9f"><span class="section-number-4">2.7.3.</span> 三、近來元宇宙出現在各個媒體中，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
1、何謂元宇宙？(5%)<br />
   元宇宙（Metaverse）是一個 虛擬與現實融合的數位世界，透過 VR、AR、區塊鏈 等技術，讓使用者能夠進行社交、工作、娛樂等活動。<br />
2、請問可應用到的技術有哪些？(10%)<br />
</p>
<ul class="org-ul">
<li>虛擬實境（VR）<br /></li>
<li>擴增實境（AR）<br /></li>
<li>區塊鏈（Blockchain）<br /></li>
<li>人工智慧（AI）<br /></li>
<li>雲端運算（Cloud Computing）<br /></li>
<li>數位孿生（Digital Twin）<br /></li>
</ul>
<p>
3、舉出元宇宙可能的三種應用 (5%)。<br />
</p>
<ol class="org-ol">
<li>虛擬會議（如 Meta Horizon Workrooms）<br /></li>
<li>數位房地產（如 Decentraland）<br /></li>
<li>虛擬演唱會（如 Travis Scott 在 Fortnite 的虛擬音樂會）<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgfe83a4f" class="outline-4">
<h4 id="orgfe83a4f"><span class="section-number-4">2.7.4.</span> 四、隱私悖論近年來常被提出討論，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-2-7-4">
<p>
1、請說明何為隱私悖論？(5%)<br />
   隱私悖論 指的是 人們雖然擔心個資安全，但仍願意在網路上提供個資以換取便利。<br />
2、並舉出兩種情境來說明 (5%)<br />
</p>
<ol class="org-ol">
<li>社群媒體：用戶擔心個資外洩，但仍願意在 Facebook、Instagram 分享個人資訊。<br /></li>
<li>行動支付：使用者擔憂隱私問題，但仍使用 Google Pay、Apple Pay 綁定信用卡。<br /></li>
</ol>
<p>
3、另外請提出至少可能的三種悖論成因 (5%)。<br />
</p>
<ol class="org-ol">
<li>資訊不對稱：使用者不清楚個資的真正用途。<br /></li>
<li>行為習慣：人們習慣免費服務，願意提供個資換取便利。<br /></li>
<li>決策疲勞：隱私設定過於複雜，導致用戶選擇「接受所有條款」。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgf89c95e" class="outline-4">
<h4 id="orgf89c95e"><span class="section-number-4">2.7.5.</span> 五、近來臉書的推薦演算法飽受質疑，請回答下列問題。</h4>
<div class="outline-text-4" id="text-2-7-5">
<p>
1、請問一般推薦系統演算法，主要可分為哪幾類？(10%)<br />
</p>
<ol class="org-ol">
<li>協同過濾（Collaborative Filtering）<br /></li>
<li>內容導向推薦（Content-Based Filtering）<br /></li>
<li>混合式推薦（Hybrid Recommendation）<br /></li>
</ol>
<p>
2、承上，請為每類提出一種代表性的演算法？(5%)<br />
</p>
<ol class="org-ol">
<li>協同過濾 → KNN（K-Nearest Neighbors）<br /></li>
<li>內容導向推薦 → TF-IDF（Term Frequency-Inverse Document Frequency）<br /></li>
<li>混合式推薦 → Netflix 使用的混合推薦系統<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org69a0bb0" class="outline-4">
<h4 id="org69a0bb0"><span class="section-number-4">2.7.6.</span> 六、共享平台以補助金或津貼的方式進行擴張，例如滴滴出行補貼計程車以及消費者，以增加市場佔有率。</h4>
<div class="outline-text-4" id="text-2-7-6">
<p>
1、請以波特的五力模式分析平台需具備什麼特質才適合以補貼方式進行市場擴張？(10%)<br />
   波特五力模型分析（10%）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">五力</th>
<th scope="col" class="org-left">適用補貼的條件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">供應商議價力</td>
<td class="org-left">供應商（司機）較多，議價力較低，適合補貼吸引司機。</td>
</tr>

<tr>
<td class="org-left">買方議價力</td>
<td class="org-left">消費者對價格敏感，補貼可吸引新用戶。</td>
</tr>

<tr>
<td class="org-left">市場競爭</td>
<td class="org-left">競爭激烈時，補貼可提高市占率。</td>
</tr>

<tr>
<td class="org-left">替代品威脅</td>
<td class="org-left">若市場有強替代品（如計程車），補貼可降低用戶轉移風險。</td>
</tr>

<tr>
<td class="org-left">新進者威脅</td>
<td class="org-left">補貼可提高市場門檻，阻止新競爭者加入。</td>
</tr>
</tbody>
</table>
<p>
2、若以上述原則判斷，請問滴滴出行適合採取補貼模式嗎？(5%)<br />
   適合，因為滴滴出行市場競爭激烈（Uber 競爭），且用戶對價格敏感，補貼可提高黏著度。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org5d5fa8f" class="outline-3">
<h3 id="org5d5fa8f"><span class="section-number-3">2.8.</span> 111: 資料結構：</h3>
<div class="outline-text-3" id="text-2-8">
</div>
<div id="outline-container-orgc856671" class="outline-4">
<h4 id="orgc856671"><span class="section-number-4">2.8.1.</span> 第一題：</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
A heap is an implementation of a (3%)<br />
</p>
<ol class="org-ol">
<li>stack<br /></li>
<li>priority queue<br /></li>
<li>linked list<br /></li>
<li>cyclic graph<br /></li>
</ol>
</div>
<div id="outline-container-org841b453" class="outline-5">
<h5 id="org841b453">答案：B. Priority Queue（優先佇列）</h5>
<div class="outline-text-5" id="text-org841b453">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Heap（堆積） 是一種 樹狀結構（通常是二元堆積，Binary Heap），主要應用於 優先佇列（Priority Queue） 的實作。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Stack（堆疊） → 錯誤，堆疊通常使用陣列或連結串列實作，不使用 Heap。<br /></li>
<li>Priority Queue（優先佇列） → 正確，Heap 主要用於實作優先佇列，如 min-heap 和 max-heap。<br /></li>
<li>Linked List（鏈結串列） → 錯誤，鏈結串列不是用 Heap 來實作。<br /></li>
<li>Cyclic Graph（循環圖） → 錯誤，Heap 與圖無關。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2226f44" class="outline-4">
<h4 id="org2226f44"><span class="section-number-4">2.8.2.</span> 第二題：</h4>
<div class="outline-text-4" id="text-2-8-2">
<p>
Which of the following data structure is not based on a binary tree? (3%)<br />
</p>
<ol class="org-ol">
<li>Min Heap<br /></li>
<li>Red Black Tree<br /></li>
<li>AVL Tree<br /></li>
<li>Stack<br /></li>
</ol>
</div>
<div id="outline-container-org96c7fb0" class="outline-5">
<h5 id="org96c7fb0">答案：D. Stack（堆疊）</h5>
<div class="outline-text-5" id="text-org96c7fb0">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>二元樹結構的資料結構：<br />
<ul class="org-ul">
<li>Min Heap（最小堆積） → 基於二元樹（通常是完全二元樹）。<br /></li>
<li>Red-Black Tree（紅黑樹） → 基於自平衡二元搜尋樹（BST）。<br /></li>
<li>AVL Tree（AVL 樹） → 基於自平衡二元搜尋樹。<br /></li>
</ul></li>
<li>非二元樹結構：<br />
<ul class="org-ul">
<li>Stack（堆疊） 是 線性結構（LIFO, Last In First Out），通常使用陣列或鏈結串列來實作，不是基於二元樹。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org33cfb9a" class="outline-4">
<h4 id="org33cfb9a"><span class="section-number-4">2.8.3.</span> 第三題：</h4>
<div class="outline-text-4" id="text-2-8-3">
<p>
What is the breadth-first search order for the following tree? (4%)<br />
</p>
<pre class="example" id="org2c812e3">
              28
            /    \
          /        \
        15         58
       /  \        /
      9    20     46
     / \     \   /  \
    7   11   23 38  51
</pre>
<ol class="org-ol">
<li>28 15 58 9 20 46 7 11 23 38 51<br /></li>
<li>28 15 9 7 11 20 23 58 46 38 51<br /></li>
<li>7 9 11 15 20 23 28 38 46 51 58<br /></li>
<li>7 11 23 38 51 9 20 46 15 58 28<br /></li>
</ol>
<p>
答案：A. 28 15 58 9 20 46 7 11 23 38 51<br />
解析<br />
</p>
<ul class="org-ul">
<li>廣度優先搜尋（BFS） 遵循 層級遍歷（Level Order Traversal），即從 根節點開始，逐層遍歷每一層的節點。<br /></li>
</ul>
<p>
BFS 遍歷順序：<br />
</p>
<ul class="org-ul">
<li>層 1（根節點） → 28<br /></li>
<li>層 2 → 15 58<br /></li>
<li>層 3 → 9 20 46<br /></li>
<li>層 4 → 7 11 23 38 51<br /></li>
</ul>
<p>
所以，BFS 結果為： 28 15 58 9 20 46 7 11 23 38 51<br />
選項分析：<br />
</p>
<ol class="org-ol">
<li>28 15 58 9 20 46 7 11 23 38 51 ✅ 正確<br /></li>
<li>28 15 9 7 11 20 23 58 46 38 51 ❌ 錯誤，58 應該在 20 之後<br /></li>
<li>7 9 11 15 20 23 28 38 46 51 58 ❌ 這是中序（In-order）遍歷，不是 BFS<br /></li>
<li>7 11 23 38 51 9 20 46 15 58 28 ❌ 這是後序（Post-order）遍歷，不是 BFS<br /></li>
</ol>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>Heap 是 Priority Queue（優先佇列）的實作。<br /></li>
<li>Stack（堆疊）不是基於二元樹的資料結構。<br /></li>
<li>BFS（廣度優先搜尋）遍歷順序為：28 15 58 9 20 46 7 11 23 38 51。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org516d870" class="outline-4">
<h4 id="org516d870"><span class="section-number-4">2.8.4.</span> 第四題：</h4>
<div class="outline-text-4" id="text-2-8-4">
<p>
What is the time complexity of the following code? (4%)<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>, <span style="color: #dcaeea;">j</span>, <span style="color: #dcaeea;">sum</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span><span style="color: #51afef;">for</span>(i=<span style="color: #da8548; font-weight: bold;">0</span>; i&lt;n; i++){
<span class="linenr">3: </span>    <span style="color: #51afef;">for</span>(j = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;n; j++){
<span class="linenr">4: </span>        <span style="color: #51afef;">for</span>(k = <span style="color: #da8548; font-weight: bold;">0</span>; k &lt; i; k++){
<span class="linenr">5: </span>             sum++;
<span class="linenr">6: </span>        }
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>}
</pre>
</div>
<ol class="org-ol">
<li>O(1)<br /></li>
<li>O(n)<br /></li>
<li>O(n^2)<br /></li>
<li>O(n^3)<br /></li>
</ol>
</div>
<div id="outline-container-org87539de" class="outline-5">
<h5 id="org87539de">答案：C. O(n^2)</h5>
<div class="outline-text-5" id="text-org87539de">
<p>
解析<br />
程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>, <span style="color: #dcaeea;">j</span>, <span style="color: #dcaeea;">sum</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span><span style="color: #51afef;">for</span>(i = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++) {       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22806;&#23652;&#36852;&#22280;&#22519;&#34892; n &#27425;</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">for</span>(j = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; n; j++) {   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#20108;&#23652;&#36852;&#22280;&#22519;&#34892; n &#27425;</span>
<span class="linenr">4: </span>        <span style="color: #51afef;">for</span>(k = <span style="color: #da8548; font-weight: bold;">0</span>; k &lt; i; k++) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#19977;&#23652;&#36852;&#22280;&#22519;&#34892; i &#27425;</span>
<span class="linenr">5: </span>            sum++;
<span class="linenr">6: </span>        }
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>}
</pre>
</div>
<p>
分析各層迴圈次數：<br />
</p>
<ul class="org-ul">
<li>外層迴圈（變數 i）執行 n 次。<br /></li>
<li>中層迴圈（變數 j）執行 n 次。<br /></li>
<li>內層迴圈（變數 k）執行 i 次。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3a74cc7" class="outline-4">
<h4 id="org3a74cc7"><span class="section-number-4">2.8.5.</span> 第五題：</h4>
<div class="outline-text-4" id="text-2-8-5">
<p>
A binary search tree is generated in order with the following numbers: 3, 7, 1, 2, 5, 6, 10, 17, 4. How many nodes are in the right subtree? (4%)<br />
</p>
<ol class="org-ol">
<li>6<br /></li>
<li>1<br /></li>
<li>3<br /></li>
<li>5<br /></li>
</ol>
</div>
<div id="outline-container-org4876003" class="outline-5">
<h5 id="org4876003">答案：C. 3</h5>
<div class="outline-text-5" id="text-org4876003">
<p>
解析<br />
依序插入數字到二元搜尋樹（BST）：<br />
</p>
<ol class="org-ol">
<li>3 為根節點。<br /></li>
<li>7 插入右子樹。<br /></li>
<li>1 插入左子樹。<br /></li>
<li>2 插入 1 的右子樹。<br /></li>
<li>5 插入 7 的左子樹。<br /></li>
<li>6 插入 5 的右子樹。<br /></li>
<li>10 插入 7 的右子樹。<br /></li>
<li>17 插入 10 的右子樹。<br /></li>
<li>4 插入 5 的左子樹。<br /></li>
</ol>
<p>
右子樹的節點數量（從 7 開始）：<br />
</p>
<ul class="org-ul">
<li>7<br /></li>
<li>10<br /></li>
<li>17<br /></li>
</ul>
<p>
共 3 個節點，答案為 C. 3。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org6fb5a84" class="outline-4">
<h4 id="org6fb5a84"><span class="section-number-4">2.8.6.</span> 第六題：</h4>
<div class="outline-text-4" id="text-2-8-6">
<p>
What is the answer to the following postfix expression? (4%) 912*+62/-<br />
</p>
<ol class="org-ol">
<li>10<br /></li>
<li>30<br /></li>
<li>-1<br /></li>
<li>-15<br /></li>
</ol>
</div>
<div id="outline-container-orgd8082be" class="outline-5">
<h5 id="orgd8082be">答案：C. -1</h5>
<div class="outline-text-5" id="text-orgd8082be">
<p>
解析<br />
後序表示法 912*+62/- 計算步驟：<br />
</p>
<ul class="org-ul">
<li>乘法 1 * 2 = 2 → 9 2 + 2 / -<br /></li>
<li>加法 9 + 2 = 11 → 11 6 2 / -<br /></li>
<li>除法 6 / 2 = 3 → 11 3 -<br /></li>
<li>減法 11 - 3 = 8 → 8<br /></li>
</ul>
<p>
答案應該是 C. -1，但運算結果應該是 8，可能題目有誤。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf7125d1" class="outline-4">
<h4 id="orgf7125d1"><span class="section-number-4">2.8.7.</span> 第七題：</h4>
<div class="outline-text-4" id="text-2-8-7">
<p>
What is the sum of edge weights of the minimal spanning tree of the following graph? (4%)<br />
</p>

<div id="orgce2966a" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_10-59-10.png" alt="2025-01-29_10-59-10.png" width="500" /><br />
</p>
</div>
<pre class="example" id="orgbd97dbe">
圖形表示如下：節點1、2、3、4、5、6、7，邊及權重如下：1-2(2)，1-3(6)，1-7(2)，2-3(4)，2-5(2)，3-4(4)，3-6(10)，4-5(2)，4-6(4)，4-7(2)。
</pre>
<ol class="org-ol">
<li>14<br /></li>
<li>16<br /></li>
<li>18<br /></li>
<li>10<br /></li>
</ol>
</div>
<div id="outline-container-orgab8938e" class="outline-5">
<h5 id="orgab8938e">答案：B. 16</h5>
<div class="outline-text-5" id="text-orgab8938e">
<p>
解析<br />
使用 Kruskal 或 Prim 演算法 建立最小生成樹（MST）：<br />
</p>
<pre class="example" id="org459480c">
圖中節點：1、2、3、4、5、6、7
邊及權重：
1-2(2), 1-3(6), 1-7(2), 2-3(4), 2-5(2),
3-4(4), 3-6(10), 4-5(2), 4-6(4), 4-7(2)
</pre>
<p>
按權重由小到大排序：<br />
</p>
<ol class="org-ol">
<li>1-2（2）<br /></li>
<li>1-7（2）<br /></li>
<li>2-5（2）<br /></li>
<li>4-5（2）<br /></li>
<li>4-7（2）<br /></li>
<li>2-3（4）<br /></li>
<li>3-4（4）<br /></li>
<li>4-6（4）<br /></li>
<li>1-3（6）<br /></li>
<li>3-6（10）<br /></li>
</ol>
<p>
建立最小生成樹（MST）：<br />
</p>
<ol class="org-ol">
<li>1-2（2）<br /></li>
<li>1-7（2）<br /></li>
<li>2-5（2）<br /></li>
<li>4-5（2）<br /></li>
<li>4-7（2）<br /></li>
<li>2-3（4）<br /></li>
<li>4-6（4）<br /></li>
</ol>
<p>
總權重：2+2+2+2+2+4+4=16<br />
</p>

<p>
答案為 B. 16。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc772b3b" class="outline-4">
<h4 id="orgc772b3b"><span class="section-number-4">2.8.8.</span> 第八題：</h4>
<div class="outline-text-4" id="text-2-8-8">
<p>
In a complete graph of n vertices, how many edges are there? (4%)<br />
</p>
<ol class="org-ol">
<li>n^2<br /></li>
<li>n(n-1)/2<br /></li>
<li>n<br /></li>
<li>2n<br /></li>
</ol>
</div>
<div id="outline-container-org96392d5" class="outline-5">
<h5 id="org96392d5">答案：B. \( \frac{n(n-1)}{2} \)</h5>
<div class="outline-text-5" id="text-org96392d5">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>完全圖（Complete Graph）KnKn​ 是指 每個頂點與其他所有頂點都有邊相連。<br /></li>
<li>公式：<br /></li>
<li>邊數= \( \frac{n(n-1)}{2} \)<br /></li>
<li>因為 每兩個頂點之間都有一條邊，但 無重複計數（無向圖）。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>n2n2 ❌ 錯誤，這是錯誤的關係式。<br /></li>
<li>n(n−1)/2n(n−1)/2 ✅ 正確<br /></li>
<li>nn ❌ 錯誤，這是錯誤的關係式。<br /></li>
<li>2n2n ❌ 錯誤，邊數不會是 2n2n。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org01a9861" class="outline-4">
<h4 id="org01a9861"><span class="section-number-4">2.8.9.</span> 第九題：</h4>
<div class="outline-text-4" id="text-2-8-9">
<p>
What is the height of 12345 nodes in an AVL tree? (4%) A. 6172 B. 1 C. 13 D. 14<br />
</p>
</div>
<div id="outline-container-org80032e2" class="outline-5">
<h5 id="org80032e2">答案：C. 13</h5>
<div class="outline-text-5" id="text-org80032e2">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>AVL 樹的最小高度 hh 滿足公式： N(h)=N(h−1)+N(h−2)+1<br /></li>
<li>其中 N(h)N(h) 表示具有 最少節點數量的 AVL 樹 的高度為 hh。<br /></li>
<li>已知 AVL 樹的高度增長類似於費氏數列（Fibonacci sequence），所以：N(h)≈1.44^h<br /></li>
<li>解方程式： 1.44^h=12345<br /></li>
<li>取對數：h=log⁡1.44(12345)≈13<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>6172 ❌ 錯誤，明顯太大<br /></li>
<li>1 ❌ 錯誤，AVL 樹只有 1 個節點時高度才是 1<br /></li>
<li>13 ✅ 正確<br /></li>
<li>14 ❌ 錯誤，12345 個節點的 AVL 樹高度大約是 13 而不是 14<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc902ae1" class="outline-4">
<h4 id="orgc902ae1"><span class="section-number-4">2.8.10.</span> 第十題：</h4>
<div class="outline-text-4" id="text-2-8-10">
<p>
For the following tree, what is the 5th node we visit if we perform a pre-order traversal? (4%)<br />
</p>

<div id="orga057286" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_11-18-16.png" alt="2025-01-29_11-18-16.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org2182861">
圖形表示如下：根節點為30，左子節點為17，右子節點為52。17的左子節點為14，右子節點為20。52的左子節點為47，右子節點為53。14的左子節點為8，右子節點為15。20的左子節點為19，右子節點為21。47的左子節點為40，右子節點為49。40的右子節點為39。
</pre>
<ol class="org-ol">
<li>20<br /></li>
<li>21<br /></li>
<li>39<br /></li>
<li>15<br /></li>
</ol>
</div>
<div id="outline-container-orgc24d4ac" class="outline-5">
<h5 id="orgc24d4ac">解析</h5>
<div class="outline-text-5" id="text-orgc24d4ac">
<p>
前序遍歷（Pre-order Traversal）順序：<br />
</p>
<ol class="org-ol">
<li>根節點<br /></li>
<li>左子樹<br /></li>
<li>右子樹<br /></li>
</ol>
<p>
前序遍歷順序（Pre-order Traversal）：<br />
</p>
<ol class="org-ol">
<li>30（根）<br /></li>
<li>17（左子樹）<br /></li>
<li>14（左子樹）<br /></li>
<li>8（左子樹）<br /></li>
<li>15（右子樹）→ 第 5 個節點<br /></li>
</ol>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>20 ❌ 錯誤，第 6 個節點<br /></li>
<li>21 ❌ 錯誤，還沒訪問到<br /></li>
<li>39 ❌ 錯誤，後面才會訪問<br /></li>
<li>15 ✅ 正確，第 5 個訪問的節點<br /></li>
</ol>
<p>
總結<br />
</p>
<ol class="org-ol">
<li>完全圖的邊數：n(n−1)/2n(n−1)/2<br /></li>
<li>AVL 樹（12345 個節點）的高度：13<br /></li>
<li>前序遍歷第 5 個訪問的節點：15<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org158f957" class="outline-4">
<h4 id="org158f957"><span class="section-number-4">2.8.11.</span> 第十一題：</h4>
<div class="outline-text-4" id="text-2-8-11">
<p>
For the tree in question 10, what is the 10th node we visit if we perform an in-order traversal? (4%)<br />
</p>
<ol class="org-ol">
<li>49<br /></li>
<li>40<br /></li>
<li>47<br /></li>
<li>53<br /></li>
</ol>
</div>
<div id="outline-container-orga8d625d" class="outline-5">
<h5 id="orga8d625d">答案：C. 47</h5>
<div class="outline-text-5" id="text-orga8d625d">
<p>
解析: 中序遍歷（In-order Traversal）順序：<br />
</p>
<ol class="org-ol">
<li>左子樹<br /></li>
<li>根節點<br /></li>
<li>右子樹<br /></li>
</ol>
<p>
中序遍歷順序（從最左邊開始遍歷）：<br />
</p>
<ol class="org-ol">
<li>8<br /></li>
<li>14<br /></li>
<li>15<br /></li>
<li>17<br /></li>
<li>19<br /></li>
<li>20<br /></li>
<li>21<br /></li>
<li>30<br /></li>
<li>39<br /></li>
<li>47 （第 10 個節點）<br /></li>
</ol>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>49 ❌ 錯誤，第 12 個節點<br /></li>
<li>40 ❌ 錯誤，第 11 個節點<br /></li>
<li>47 ✅ 正確，第 10 個節點<br /></li>
<li>53 ❌ 錯誤，第 13 個節點<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org24eba93" class="outline-4">
<h4 id="org24eba93"><span class="section-number-4">2.8.12.</span> 第十二題：</h4>
<div class="outline-text-4" id="text-2-8-12">
<p>
If the following numbers &ldquo;7&rdquo;, &ldquo;3&rdquo;, &ldquo;2&rdquo;, &ldquo;5&rdquo; are inserted into a queue, what would be their order for removal? (4%)<br />
</p>
<ol class="org-ol">
<li>7325<br /></li>
<li>5237<br /></li>
<li>7352<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgd5046dd" class="outline-5">
<h5 id="orgd5046dd">答案：A. 7325</h5>
<div class="outline-text-5" id="text-orgd5046dd">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>FIFO（First In, First Out） 規則：<br />
<ol class="org-ol">
<li>插入 7（隊列：7）<br /></li>
<li>插入 3（隊列：7 3）<br /></li>
<li>插入 2（隊列：7 3 2）<br /></li>
<li>插入 5（隊列：7 3 2 5）<br /></li>
</ol></li>
<li>移除順序： 7 3 2 5<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>7325 ✅ 正確<br /></li>
<li>5237 ❌ 錯誤，不符合 FIFO<br /></li>
<li>7352 ❌ 錯誤，不符合 FIFO<br /></li>
<li>None of the above ❌ 錯誤，因為 A 是正確的<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga77766c" class="outline-4">
<h4 id="orga77766c"><span class="section-number-4">2.8.13.</span> 第十三題：</h4>
<div class="outline-text-4" id="text-2-8-13">
<p>
Which vertex is NOT a cut vertex in the following graph? (4%)<br />
</p>

<div id="org1a1b133" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_11-19-47.png" alt="2025-01-29_11-19-47.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org7a1e3f2">
圖形表示如下：節點A、B、C、D、E、F、G，邊如下：A-B，B-C，B-D，C-E，D-F，E-G。
</pre>
<ol class="org-ol">
<li>B<br /></li>
<li>E<br /></li>
<li>G<br /></li>
<li>A<br /></li>
</ol>
</div>
<div id="outline-container-org44f85e2" class="outline-5">
<h5 id="org44f85e2">答案：C. G</h5>
<div class="outline-text-5" id="text-org44f85e2">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>割點（Cut Vertex）：如果刪除該頂點會導致圖變成兩個或更多的連通部分，則該頂點是割點。<br /></li>
<li>給定圖：<br /></li>
</ul>
<pre class="example" id="org8643769">
  A -- B -- C
       |    |
       D    E
       |    |
       F    G

</pre>
<ul class="org-ul">
<li>A 是割點（移除後 A 和 B 分開）<br /></li>
<li>B 是割點（移除後 A 和 C 分開）<br /></li>
<li>C 是割點（移除後 B 和 E 分開）<br /></li>
<li>D 是割點（移除後 B 和 F 分開）<br /></li>
<li>E 是割點（移除後 C 和 G 分開）<br /></li>
<li>F 不是割點（因為 D 仍然連接其他部分）<br /></li>
<li>G 不是割點（因為移除後不會影響圖的連通性）<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>B ❌ 錯誤，B 是割點<br /></li>
<li>E ❌ 錯誤，E 是割點<br /></li>
<li>G ✅ 正確，G 不是割點<br /></li>
<li>A ❌ 錯誤，A 是割點<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org93fa77c" class="outline-4">
<h4 id="org93fa77c"><span class="section-number-4">2.8.14.</span> 第十四題：</h4>
<div class="outline-text-4" id="text-2-8-14">
<p>
In the implementation of quick sort, we divide the problem on the base of pivot element and: (3%)<br />
</p>
<ol class="org-ol">
<li>there is explicit combine process to conquer the solution<br /></li>
<li>no work is needed to combine the sub-arrays, the array is already sorted<br /></li>
<li>merge the subarrays<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgc4d3f72" class="outline-5">
<h5 id="orgc4d3f72">答案：B. no work is needed to combine the sub-arrays, the array is already sorted</h5>
<div class="outline-text-5" id="text-orgc4d3f72">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>快速排序（Quick Sort） 透過 選擇基準（pivot），並將數列劃分為 小於基準 和 大於基準 兩部分。<br /></li>
<li>不同於合併排序（Merge Sort），快速排序 不需要額外的合併步驟，因為遞迴執行完後陣列已經排序。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>there is explicit combine process to conquer the solution ❌ 錯誤，沒有明確的合併步驟<br /></li>
<li>no work is needed to combine the sub-arrays, the array is already sorted ✅ 正確<br /></li>
<li>merge the subarrays ❌ 錯誤，這描述的是合併排序（Merge Sort）<br /></li>
<li>none of the above ❌ 錯誤，B 是正確的<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org547a15f" class="outline-4">
<h4 id="org547a15f"><span class="section-number-4">2.8.15.</span> 第十五題：</h4>
<div class="outline-text-4" id="text-2-8-15">
<p>
Which of the following is not return optimal solution? (3%)<br />
</p>
<ol class="org-ol">
<li>dynamic programming<br /></li>
<li>backtracking<br /></li>
<li>branch and bound<br /></li>
<li>greedy method<br /></li>
</ol>
</div>
<div id="outline-container-org9e2c69a" class="outline-5">
<h5 id="org9e2c69a">答案：D. Greedy Method（貪婪法）</h5>
<div class="outline-text-5" id="text-org9e2c69a">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>最佳解（Optimal Solution）：<br />
<ol class="org-ol">
<li>動態規劃（Dynamic Programming） ✅ 返回最佳解<br /></li>
<li>回溯法（Backtracking） ✅ 尋找所有可能解，一般能找到最佳解<br /></li>
<li>分支界限法（Branch and Bound） ✅ 尋找最佳解<br /></li>
<li>貪婪法（Greedy Algorithm） ❌ 不一定能找到最佳解<br /></li>
</ol></li>
<li>貪婪法問題：<br />
<ul class="org-ul">
<li>有時選擇當下最佳解，但整體結果不是最佳解，例如：<br />
<ul class="org-ul">
<li>最短路徑問題（Dijkstra 算法適用，但有時 BFS 可能更適合）<br /></li>
<li>換零錢問題（如面額 {1, 3, 4}，找零 6 時貪婪法選 4, 1, 1，但最佳解應該是 3, 3）<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2f5355b" class="outline-4">
<h4 id="org2f5355b"><span class="section-number-4">2.8.16.</span> 第十六題：</h4>
<div class="outline-text-4" id="text-2-8-16">
<p>
Breadth-First-Search is better compared to Depth First Search in the case of: (3%)<br />
</p>
<ol class="org-ol">
<li>the graph’s width is large<br /></li>
<li>the graph’s depth is large<br /></li>
<li>the graph has a large number of nodes<br /></li>
<li>the graph has a large number of edges<br /></li>
</ol>
</div>
<div id="outline-container-org01a5198" class="outline-5">
<h5 id="org01a5198">答案：A. the graph’s width is large</h5>
<div class="outline-text-5" id="text-org01a5198">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>BFS（廣度優先搜尋） 適用於廣度較大的圖（分支多），因為 DFS（深度優先搜尋）在這種情況下會走錯路，導致回溯開銷變大。<br /></li>
<li>DFS 更適合深度大的圖，因為它使用遞迴來深入探索。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>the graph’s width is large ✅ 正確，BFS 適合橫向擴展的圖<br /></li>
<li>the graph’s depth is large ❌ 錯誤，深度大時 DFS 更適合<br /></li>
<li>the graph has a large number of nodes ❌ 錯誤，節點數量多不一定適用 BFS<br /></li>
<li>the graph has a large number of edges ❌ 錯誤，BFS 和 DFS 都能處理<br /></li>
</ol>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>第 10 題的樹在中序遍歷時，第 10 個節點是 47<br /></li>
<li>佇列的 FIFO 出隊順序是 7325<br /></li>
<li>G 不是割點<br /></li>
<li>快速排序不需要合併<br /></li>
<li>貪婪法不一定能找到最佳解<br /></li>
<li>BFS 適合寬度較大的圖<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcbb22ac" class="outline-4">
<h4 id="orgcbb22ac"><span class="section-number-4">2.8.17.</span> 第十七題：</h4>
<div class="outline-text-4" id="text-2-8-17">
<p>
What algorithm technique is used in the implementation of Kruskal&rsquo;s solution for the minimum spanning tree? (3%)<br />
</p>
<ol class="org-ol">
<li>greedy technique<br /></li>
<li>divide-and-conquer technique<br /></li>
<li>dynamic programming technique<br /></li>
<li>the algorithm combines more than one of the above techniques<br /></li>
</ol>
</div>
<div id="outline-container-orgb3284c5" class="outline-5">
<h5 id="orgb3284c5">答案：A. greedy technique（貪婪法）</h5>
<div class="outline-text-5" id="text-orgb3284c5">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Kruskal 演算法 用於找出 最小生成樹（MST, Minimum Spanning Tree），它的核心概念是：<br />
<ol class="org-ol">
<li>依照邊的權重從小到大排序。<br /></li>
<li>依序加入權重最小的邊，確保不形成環（Cycle）。<br /></li>
<li>持續添加邊，直到連通所有頂點。<br /></li>
</ol></li>
<li>演算法分類：<br />
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm） ✅ 正確，Kruskal 在每一步選擇當前最小的邊，這是典型的貪婪策略。<br /></li>
<li>分治法（Divide and Conquer） ❌ 錯誤，Kruskal 並沒有將問題拆分成子問題。<br /></li>
<li>動態規劃（Dynamic Programming） ❌ 錯誤，Kruskal 不依賴子問題的最佳解。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgda0605e" class="outline-4">
<h4 id="orgda0605e"><span class="section-number-4">2.8.18.</span> 第十八題：</h4>
<div class="outline-text-4" id="text-2-8-18">
<p>
Optimal merge pattern is a pattern that relates to the merging of two or more sorted files into a single sorted file. The files f1, f2, f3 are files containing 30, 20, 10 records, respectively. What is the optimal merge value? (4%)<br />
</p>
<ol class="org-ol">
<li>110<br /></li>
<li>90<br /></li>
<li>60<br /></li>
<li>50<br /></li>
</ol>
</div>
<div id="outline-container-org39519e9" class="outline-5">
<h5 id="org39519e9">答案：B. 90</h5>
<div class="outline-text-5" id="text-org39519e9">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Optimal Merge Pattern（最優合併模式）：<br />
<ul class="org-ul">
<li>這是一個 Huffman 編碼問題的變形，利用貪婪法（Greedy Algorithm）。<br /></li>
<li>目標：合併最小的兩個檔案，並反覆執行，直到所有檔案合併完成。<br /></li>
</ul></li>
<li>給定檔案大小：<br />
f1=30，f2=20，f3=10<br /></li>
<li>合併步驟（每次合併都選最小的兩個數字）：<br />
<ul class="org-ul">
<li>合併 10 和 20 → 成為 30（成本 = 30）<br /></li>
<li>合併 30 和 30 → 成為 60（成本 = 60）<br /></li>
</ul></li>
<li>總合併成本：30+60=90<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>110 ❌ 錯誤<br /></li>
<li>90 ✅ 正確<br /></li>
<li>60 ❌ 錯誤<br /></li>
<li>50 ❌ 錯誤<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org9ce9e90" class="outline-4">
<h4 id="org9ce9e90"><span class="section-number-4">2.8.19.</span> 第十九題：</h4>
<div class="outline-text-4" id="text-2-8-19">
<p>
If the graph is represented as an adjacency matrix, the time complexity of Kruskal&rsquo;s algorithm is: (4%)<br />
</p>
<ol class="org-ol">
<li>O(ElogV)<br /></li>
<li>O(ElogE)<br /></li>
<li>O(V^2)<br /></li>
<li>O(logE)<br /></li>
</ol>
</div>
<div id="outline-container-org0828146" class="outline-5">
<h5 id="org0828146">答案：B. O(Elog⁡E)O(ElogE)</h5>
<div class="outline-text-5" id="text-org0828146">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Kruskal 演算法的步驟：<br />
<ol class="org-ol">
<li>對邊排序（使用 O(E log E)）。<br /></li>
<li>使用並查集（Disjoint Set）檢查是否形成環（近乎 O(1)）。<br /></li>
<li>加入最小邊到 MST（最多加 V−1V−1 條邊，O(E)）。<br /></li>
</ol></li>
<li>時間複雜度分析：<br />
<ul class="org-ul">
<li>排序邊的時間： O(Elog⁡E)<br /></li>
<li>查找和合併集合： 近乎 O(1)，所以主要瓶頸在 排序。<br /></li>
</ul></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>O(Elog⁡V)O(ElogV) ❌ 錯誤<br /></li>
<li>O(Elog⁡E)O(ElogE) ✅ 正確<br /></li>
<li>O(V2)O(V2) ❌ 錯誤，這是 Prim 演算法的時間複雜度<br /></li>
<li>O(log⁡E)O(logE) ❌ 錯誤<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org1536f0d" class="outline-4">
<h4 id="org1536f0d"><span class="section-number-4">2.8.20.</span> 第二十題：</h4>
<div class="outline-text-4" id="text-2-8-20">
<p>
In job sequencing problem, each job has a defined deadline and some profit associated with it. The objective is to find a sequence of jobs, which is completed within their deadlines and gives maximum profit. The solution is based on: (4%)<br />
</p>
<ol class="org-ol">
<li>greedy method<br /></li>
<li>branch and bound<br /></li>
<li>dynamic programming<br /></li>
<li>divide and conquer<br /></li>
</ol>
</div>
<div id="outline-container-org8c8769b" class="outline-5">
<h5 id="org8c8769b">答案：A. greedy method（貪婪法）</h5>
<div class="outline-text-5" id="text-org8c8769b">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>工作排序問題（Job Sequencing Problem）：<br />
<ul class="org-ul">
<li>每個工作都有 最後期限（Deadline） 和 利潤（Profit）。<br /></li>
<li>目標：在截止時間內，選擇最大利潤的工作安排方式。<br /></li>
</ul></li>
<li>演算法類型：<br />
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm） ✅ 正確<br />
<ul class="org-ul">
<li>先選擇利潤最高的工作，再將它安排到最晚的可用時段。<br /></li>
</ul></li>
<li>動態規劃（Dynamic Programming） ❌ 錯誤<br /></li>
<li>分支界限法（Branch and Bound） ❌ 錯誤<br /></li>
<li>分治法（Divide and Conquer） ❌ 錯誤<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org092a072" class="outline-5">
<h5 id="org092a072">答案：C. (1, 2, 4)</h5>
<div class="outline-text-5" id="text-org092a072">
<p>
解析<br />
給定工作資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">工作</th>
<th scope="col" class="org-right">利潤</th>
<th scope="col" class="org-right">截止時間</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">15</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">10</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
<p>
貪婪法步驟（先選擇利潤最高的工作）：<br />
</p>
<ol class="org-ol">
<li>排序利潤（由高到低）： (1, 2, 4, 3)<br /></li>
<li>選擇可排程的工作（從最後期限開始）<br />
<ul class="org-ul">
<li>1 放在 第 2 個時段<br /></li>
<li>2 放在 第 1 個時段<br /></li>
<li>4 放在 第 3 個時段<br /></li>
<li>3 無法安排（因為 4 已經佔用）<br /></li>
</ul></li>
</ol>
<p>
最佳排序：(1, 2, 4)<br />
</p>
<ul class="org-ul">
<li>選項分析：<br />
<ol class="org-ol">
<li>(1, 3, 4) ❌ 錯誤<br /></li>
<li>(4, 2, 3) ❌ 錯誤<br /></li>
<li>(1, 2, 4) ✅ 正確<br /></li>
<li>None of the above ❌ 錯誤，C 是正確的<br /></li>
</ol></li>
</ul>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>Kruskal 使用貪婪法（Greedy）<br /></li>
<li>Optimal Merge Pattern 最小成本為 90<br /></li>
<li>Kruskal 在鄰接矩陣中的時間複雜度為 O(Elog⁡E)O(ElogE)<br /></li>
<li>Job Sequencing 使用貪婪法<br /></li>
<li>最佳工作選擇為 (1, 2, 4)<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org771fe38" class="outline-4">
<h4 id="org771fe38"><span class="section-number-4">2.8.21.</span> 第二十一題</h4>
<div class="outline-text-4" id="text-2-8-21">
<p>
Which is the optimal solution in the case of the above problem in which the five jobs have profits 20, 15, 5, 10, 1, and deadlines 2, 2, 3, 3, respectively. (4%)<br />
</p>
<ol class="org-ol">
<li>(1, 3, 4)<br /></li>
<li>(4, 2, 3)<br /></li>
<li>(1, 2, 4)<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-org770a600" class="outline-5">
<h5 id="org770a600">答案：C. (1, 2, 4)</h5>
<div class="outline-text-5" id="text-org770a600">
<p>
解析<br />
給定工作資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">工作</th>
<th scope="col" class="org-right">利潤（Profit）</th>
<th scope="col" class="org-right">截止時間（Deadline）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">15</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">10</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm）解法<br />
<ol class="org-ol">
<li>根據利潤（Profit）由高到低排序：(1, 2, 4, 3, 5)<br /></li>
<li>依序安排，從最後可用時段開始：<br />
<ul class="org-ul">
<li>1 放在 第 2 個時段<br /></li>
<li>2 放在 第 1 個時段<br /></li>
<li>4 放在 第 3 個時段<br /></li>
<li>3 無法安排（因為 4 佔用）<br /></li>
</ul></li>
</ol></li>
<li>最佳排序： (1,2,4)<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>(1, 3, 4) ❌ 錯誤，3 應該無法安排<br /></li>
<li>(4, 2, 3) ❌ 錯誤，1 具有最高利潤，應該被安排<br /></li>
<li>(1, 2, 4) ✅ 正確<br /></li>
<li>None of the above ❌ 錯誤，C 是正確的解答<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org14a424e" class="outline-4">
<h4 id="org14a424e"><span class="section-number-4">2.8.22.</span> 第二十二題</h4>
<div class="outline-text-4" id="text-2-8-22">
<p>
Given a set of items each having a specific value and weight, the fractional knapsack problem is to find the maximal value of fractions of items that can fit into the knapsack. Which is the optimal value in the above problem for the case that the capacity of knapsack is 10, the five items have values 12, 32, 40, 30, 50, and weights 4, 8, 2, 6, 1, respectively: (4%)<br />
</p>
<ol class="org-ol">
<li>128<br /></li>
<li>124<br /></li>
<li>122<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgfb59610" class="outline-5">
<h5 id="orgfb59610">答案：A. 128</h5>
<div class="outline-text-5" id="text-orgfb59610">
<p>
解析<br />
</p>
<ul class="org-ul">
<li><p>
給定物品資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">物品</th>
<th scope="col" class="org-right">價值（Value）</th>
<th scope="col" class="org-right">重量（Weight）</th>
<th scope="col" class="org-right">每單位價值（Value/Weight）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">12</td>
<td class="org-right">4</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">32</td>
<td class="org-right">8</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">40</td>
<td class="org-right">2</td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">30</td>
<td class="org-right">6</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">50</td>
<td class="org-right">1</td>
<td class="org-right">50</td>
</tr>
</tbody>
</table></li>
<li>步驟：<br />
<ol class="org-ol">
<li>根據每單位價值排序：<br />
<ul class="org-ul">
<li>5(50/1) &gt; 3(40/2) &gt; 4(30/6) &gt; 2(32/8) &gt; 1(12/4)<br /></li>
</ul></li>
<li>依序填充背包（容量 10）：<br />
<ul class="org-ul">
<li>取 5（1 重量） → 50<br /></li>
<li>取 3（2 重量） → 50 + 40 = 90<br /></li>
<li>取 4（6 重量） → 90 + 30 = 120<br /></li>
<li>取 2 的 1/2（剩下 1 單位空間，價值 = 32/8 * 2 = 8） → 120 + 8 = 128<br /></li>
</ul></li>
</ol></li>
<li>最優值：128<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>128 ✅ 正確<br /></li>
<li>124 ❌ 錯誤<br /></li>
<li>122 ❌ 錯誤<br /></li>
<li>None of the above ❌ 錯誤，A 是正確答案<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd9f9d0c" class="outline-4">
<h4 id="orgd9f9d0c"><span class="section-number-4">2.8.23.</span> 問答題1</h4>
<div class="outline-text-4" id="text-2-8-23">
<p>
Let comp1(n) be the number of comparisons performed by quick sort when sorting an array of n components. Let comp2(n) and exchange(n) be the number of comparisons and the number of exchange performed by bubble sort, respectively.<br />
</p>
<ol class="org-ol">
<li>Write down equations defining comp1(n) when n &lt;= 1 and when n &gt; 1 for the best case and for the worst case. (6%)<br />
<ul class="org-ul">
<li>定義 comp1(n)：<br /></li>
<li>最佳情況（Best Case）：<br />
<ul class="org-ul">
<li>樞軸（Pivot）每次將數列平分（T(n) = 2T(n/2) + O(n)）<br /></li>
<li>遞迴深度為 log n<br /></li>
<li>比較次數公式：<br /></li>
<li>comp1(n)=O(nlog⁡n)<br /></li>
</ul></li>
<li>最壞情況（Worst Case）：<br />
<ul class="org-ul">
<li>每次選到最小或最大元素作為樞軸，導致遞迴深度為 n<br /></li>
<li>比較次數公式：<br /></li>
<li>comp1(n)=O(n^2)<br /></li>
</ul></li>
</ul></li>
<li>Derive comp2(n) and exchange(n) for the average case and the best case. (6%)<br />
<ul class="org-ul">
<li>平均情況（Average Case）：<br />
<ul class="org-ul">
<li>comp2(n)=O(n^2)<br /></li>
</ul></li>
<li>最佳情況（Best Case，已排序數列）：<br />
<ul class="org-ul">
<li>comp2(n)=O(n)<br /></li>
</ul></li>
<li>交換次數（Exchange(n)）：<br />
<ul class="org-ul">
<li>平均情況：<br />
<ul class="org-ul">
<li>O(n^2)<br /></li>
</ul></li>
<li>最佳情況（已排序）：<br />
<ul class="org-ul">
<li>O(1)<br /></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org031c182" class="outline-4">
<h4 id="org031c182"><span class="section-number-4">2.8.24.</span> 問答2</h4>
<div class="outline-text-4" id="text-2-8-24">
<p>
Design a procedure that takes two arrays, and returns true if the arrays have no elements in common. Your procedure should have time complexity O(nlogm), where n is the size of the larger array and m is the size of the smaller array. (6%)<br />
</p>
<ul class="org-ul">
<li>方法<br />
<ol class="org-ol">
<li>假設 A 是較大的陣列，B 是較小的陣列。<br /></li>
<li>先對 B 進行排序，時間複雜度：O(m log m)<br /></li>
<li>對 A 的每個元素執行二分搜尋（Binary Search）：<br />
<ul class="org-ul">
<li>在 B 中搜尋每個元素，時間複雜度 O(n log m)。<br /></li>
</ul></li>
</ol></li>
<li><p>
程式碼（C++ 或 Python） C++ 版本<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;vector&gt;</span>
<span class="linenr"> 3: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;algorithm&gt;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">hasNoCommonElements</span>(<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">A</span>, <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">B</span>) {
<span class="linenr"> 8: </span>    sort(B.begin(), B.end()); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(m log m)</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">num</span> : A) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(n)</span>
<span class="linenr">11: </span>        <span style="color: #51afef;">if</span> (binary_search(B.begin(), B.end(), num)) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(log m)</span>
<span class="linenr">12: </span>            <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>;
<span class="linenr">16: </span>}
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">19: </span>    <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">A</span> = {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">15</span>};
<span class="linenr">20: </span>    <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">B</span> = {<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">11</span>};
<span class="linenr">21: </span>
<span class="linenr">22: </span>    cout &lt;&lt; (hasNoCommonElements(A, B) ? <span style="color: #98be65;">"True"</span> : <span style="color: #98be65;">"False"</span>) &lt;&lt; endl;
<span class="linenr">23: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">24: </span>}
</pre>
</div></li>
<li><p>
Python 版本<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">has_no_common_elements</span>(A, B):
<span class="linenr"> 3: </span>    B.sort()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">O(m log m)</span>
<span class="linenr"> 4: </span>    <span style="color: #51afef;">for</span> num <span style="color: #51afef;">in</span> A:  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">O(n)</span>
<span class="linenr"> 5: </span>        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Binary search in B, O(log m)</span>
<span class="linenr"> 6: </span>        <span style="color: #dcaeea;">left</span>, <span style="color: #dcaeea;">right</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #c678dd;">len</span>(B) - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr"> 7: </span>        <span style="color: #51afef;">while</span> left &lt;= right:
<span class="linenr"> 8: </span>            <span style="color: #dcaeea;">mid</span> = (left + right) // <span style="color: #da8548; font-weight: bold;">2</span>
<span class="linenr"> 9: </span>            <span style="color: #51afef;">if</span> B[mid] == num:
<span class="linenr">10: </span>                <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>
<span class="linenr">11: </span>            <span style="color: #51afef;">elif</span> B[mid] &lt; num:
<span class="linenr">12: </span>                <span style="color: #dcaeea;">left</span> = mid + <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">13: </span>            <span style="color: #51afef;">else</span>:
<span class="linenr">14: </span>                <span style="color: #dcaeea;">right</span> = mid - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">15: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">True</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span><span style="color: #dcaeea;">A</span> = [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">15</span>]
<span class="linenr">18: </span><span style="color: #dcaeea;">B</span> = [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">11</span>]
<span class="linenr">19: </span><span style="color: #c678dd;">print</span>(has_no_common_elements(A, B))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">True</span>
</pre>
</div></li>
<li>時間複雜度分析<br />
<ol class="org-ol">
<li>排序 B：O(mlog⁡m)O(mlogm)<br /></li>
<li>對 A 的每個元素執行二分搜尋：<br />
<ul class="org-ul">
<li>O(nlog⁡m)O(nlogm)（假設 A 為較大陣列）<br /></li>
</ul></li>
<li>總時間複雜度：<br />
O(mlogm)+O(nlogm)=O(nlogm)<br /></li>
</ol></li>
<li>總結<br />
<ol class="org-ol">
<li>工作排序最佳解：(1,2,4)<br /></li>
<li>分數背包最佳值：128<br /></li>
<li>Quick Sort 與 Bubble Sort 比較次數分析<br /></li>
<li>O(n log m) 方法檢查兩陣列是否有共同元素<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org12a60ca" class="outline-3">
<h3 id="org12a60ca"><span class="section-number-3">2.9.</span> 112: 中山計概</h3>
<div class="outline-text-3" id="text-2-9">
<ol class="org-ol">
<li>A network switch uses a <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> that is very similar to a routing table used in a router. A. hash table B. forwarding table C. contingency table D. reversing table<br />
<ul class="org-ul">
<li>答案：B. Forwarding Table（轉發表）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>交換器（Switch） 透過 轉發表（Forwarding Table） 來決定封包應該被發送到哪個埠口（Port）。<br /></li>
<li>類似路由器（Router） 使用的 路由表（Routing Table），但 Switch 在第二層（Layer 2）運作，而 Router 在第三層（Layer 3）運作。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Hash Table（雜湊表） ❌ 錯誤，雜湊表是用來提高搜尋效率的資料結構，不是交換器的核心機制。<br /></li>
<li>Forwarding Table（轉發表） ✅ 正確，交換器使用的表來決定封包發送方向。<br /></li>
<li>Contingency Table（應急表） ❌ 錯誤，與統計分析有關，與網路設備無關。<br /></li>
<li>Reversing Table（反向表） ❌ 錯誤，沒有這個網路設備的術語。<br /></li>
</ol></li>
</ul></li>
<li>Encryption is the process of A. transmitting information over secure lines to prevent illegal access. B. detecting errors in messages by using mathematical rules. C. preventing errors in messages by using logical rules. D. disguising information by using mathematical rules.<br />
<ul class="org-ul">
<li>答案：D. Disguising information by using mathematical rules（使用數學規則來偽裝資訊）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>加密（Encryption） 透過數學演算法將 原始訊息轉換成無法輕易理解的格式，以保護資料安全。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>對稱加密（AES、DES）<br /></li>
<li>非對稱加密（RSA、ECC）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Transmitting information over secure lines（透過安全線路傳輸資訊） ❌ 錯誤，這是 VPN 或 TLS 的作用，不是加密的本質。<br /></li>
<li>Detecting errors in messages（使用數學規則檢測錯誤） ❌ 錯誤，這描述的是錯誤檢測（如 CRC、Hamming Code）。<br /></li>
<li>Preventing errors in messages（使用邏輯規則防止錯誤） ❌ 錯誤，這描述的是錯誤修正（如 Reed-Solomon、ECC）。<br /></li>
<li>Disguising information by using mathematical rules（使用數學規則來偽裝資訊） ✅ 正確，這是加密的本質。<br /></li>
</ol></li>
</ul></li>
</ul></li>
<li>Public blockchains usually use <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> as the consensus mechanism to validate transactions. A. proof of concept B. proof of payment C. proof of reserve D. proof of work<br />
<ul class="org-ul">
<li>答案：D. Proof of Work（工作量證明，PoW）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>共識機制（Consensus Mechanism） 是區塊鏈用來驗證交易的機制。<br /></li>
<li>公有鏈（Public Blockchain） 常使用 工作量證明（Proof of Work，PoW），如 比特幣（Bitcoin）和以太坊（Ethereum 1.0）。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Proof of Concept（概念驗證） ❌ 錯誤，PoC 是用來測試技術可行性的概念，不是區塊鏈共識機制。<br /></li>
<li>Proof of Payment（付款證明） ❌ 錯誤，這不是區塊鏈的共識機制。<br /></li>
<li>Proof of Reserve（儲備證明） ❌ 錯誤，這是用來證明某個機構擁有足夠的資金儲備。<br /></li>
<li>Proof of Work（工作量證明） ✅ 正確，PoW 是比特幣、以太坊（ETH 1.0）等公有鏈使用的共識機制。<br /></li>
</ol></li>
</ul></li>
<li>What does NFT stand for? A. Non-functional token. B. Non-fungible token. C. New frequency technology. D. Nano-finance technology.<br />
<ul class="org-ul">
<li>答案：B. Non-Fungible Token（非同質化代幣）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>NFT（非同質化代幣） 是一種基於區塊鏈的數位資產，每個 NFT 具有唯一性、不可互換性，用於代表 數位藝術品、收藏品、虛擬資產等。<br /></li>
</ul></li>
<li>例如：<br />
<ul class="org-ul">
<li>Beeple 的 NFT 作品拍賣 6900 萬美元<br /></li>
<li>遊戲 NFT（Axie Infinity、Decentraland）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Non-functional token（非功能性代幣） ❌ 錯誤，NFT 不是這個意思。<br /></li>
<li>Non-fungible token（非同質化代幣） ✅ 正確，NFT 的全名。<br /></li>
<li>New frequency technology（新頻率技術） ❌ 錯誤，這不是 NFT 的概念。<br /></li>
<li>Nano-finance technology（奈米金融技術） ❌ 錯誤，這與 NFT 無關。<br /></li>
</ol></li>
</ul></li>
<li>In the UML, the top compartment of the rectangle modeling a class contains: A. The class&rsquo;s name. B. The class&rsquo;s attributes. C. The class&rsquo;s behaviors. D. All of the above.<br />
<ul class="org-ul">
<li>答案：A. The class&rsquo;s name（類別名稱）<br /></li>
<li>解析: 在 UML 類別圖（Unified Modeling Language Class Diagram） 中：<br />
<ul class="org-ul">
<li>矩形的最上方區塊（Top Compartment） → 類別名稱（Class Name）<br /></li>
<li>中間區塊（Middle Compartment） → 屬性（Attributes）<br /></li>
<li>底部區塊（Bottom Compartment） → 行為/方法（Methods/Behaviors）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>The class&rsquo;s name（類別名稱） ✅ 正確，UML 類別圖的最上層包含類別名稱。<br /></li>
<li>The class&rsquo;s attributes（類別屬性） ❌ 錯誤，屬性在中間區塊。<br /></li>
<li>The class&rsquo;s behaviors（類別行為/方法） ❌ 錯誤，行為在底部區塊。<br /></li>
<li>All of the above（以上皆是） ❌ 錯誤，最上層只包含類別名稱。<br /></li>
</ol></li>
</ul></li>
<li><p>
Which of the following is the inorder traversal of the binary search tree?<br />
</p>
<pre class="example" id="org621ec85">
          7
         / \
        /   \
       5     8
      / \   / \
     4   3 9   1
    /
   2
</pre>
<ol class="org-ol">
<li>24359187. B. 75423891. C. 24537981. D. None of the above.<br /></li>
<li>答案：D. None of the above<br /></li>
<li><p>
解析<br />
</p>
<ul class="org-ul">
<li>中序遍歷（Inorder Traversal） 的順序為：<br />
<ul class="org-ul">
<li>左子樹<br /></li>
<li>根節點<br /></li>
<li>右子樹<br /></li>
</ul></li>
<li><p>
檢查給定的 BST（但該樹的結構有誤）<br />
</p>
<pre class="example" id="orgb932ceb">
               7
              / \
             /   \
            5     8
           / \   / \
          4   3 9   1
         /
        2
</pre>
<ul class="org-ul">
<li>在 BST（Binary Search Tree） 中，左子節點的值應小於根，右子節點的值應大於根。<br /></li>
<li>但此樹結構 有錯誤：<br />
<ul class="org-ul">
<li>節點 3 應該在 5 的左子節點，而非右子節點<br /></li>
<li>節點 1 應該在 8 的左子節點，而非右子節點<br /></li>
</ul></li>
<li>正確的中序遍歷<br /></li>
<li><p>
如果修正 BST 結構，假設樹的正確結構應該是：<br />
</p>
<pre class="example" id="org7ca7f87">
                7
               / \
              5   8
             / \    \
            4   6    9
           /
          2
</pre></li>
<li>則 中序遍歷順序為：<br />
<ul class="org-ul">
<li>2,4,5,6,7,8,9<br /></li>
<li>2,4,5,6,7,8,9<br /></li>
</ul></li>
</ul></li>
</ul>

<ul class="org-ul">
<li>但根據原始題目提供的選項，均不符合正確的 BST 遍歷順序，因此答案為 D（None of the above）。<br /></li>
<li><p>
選項分析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">遍歷順序</th>
<th scope="col" class="org-left">是否正確？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A. 24359187</td>
<td class="org-left">順序錯誤（5 應該在 4 之後，而 9 不能在 1 之前）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">B. 75423891</td>
<td class="org-left">順序錯誤（應該先遍歷左子樹，但 7 在開頭）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">C. 24537981</td>
<td class="org-left">順序錯誤（1 應該在 7 之前，而 9 應該在 8 之後）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">D. None of the above</td>
<td class="org-left">正確，因為選項中無正確的中序遍歷</td>
<td class="org-left">✅</td>
</tr>
</tbody>
</table></li>
<li>結論: 因為給定的樹並非有效的 BST，且所有選項的遍歷順序都不符合中序遍歷的定義，所以答案為 D（None of the above）。<br /></li>
</ul></li>
</ol></li>
<li>What is the subnet number of the IP address 10.0.17.130 with the subnet mask 255.255.255.192? A. 10.0.0.0 B. 10.0.17.0 C. 10.0.17.128 D. 10.0.17.192<br />
<ul class="org-ul">
<li>答案：C. 10.0.17.128<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>給定 IP 地址：10.0.17.130<br /></li>
<li>子網遮罩（Subnet Mask）：255.255.255.192（/26）<br /></li>
</ul></li>
<li>計算子網 ID（Subnet ID）：<br />
<ul class="org-ul">
<li>子網大小：<br /></li>
<li>\( 2^{32-26}=2^6=64 \)<br /></li>
<li>每個子網的範圍為 64 個 IP 地址。<br /></li>
</ul></li>
<li>找出子網範圍：<br />
<ul class="org-ul">
<li>子網範圍：10.0.17.0、10.0.17.64、10.0.17.128、10.0.17.192<br /></li>
<li>10.0.17.130 落在 10.0.17.128 - 10.0.17.191 之間。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>10.0.0.0 ❌ 錯誤，這是更大的網段<br /></li>
<li>10.0.17.0 ❌ 錯誤，這是 10.0.17.0/26<br /></li>
<li>10.0.17.128 ✅ 正確，這是 10.0.17.128/26<br /></li>
<li>10.0.17.192 ❌ 錯誤，這是下一個子網的開始<br /></li>
</ol></li>
</ul></li>
<li>When a client code programmer uses a class whose implementation is in a separate file from its interface, that implementation code is merged with the client&rsquo;s code during the A. programming phase. B. compiling phase. C. linking phase. D. executing phase.<br />
<ul class="org-ul">
<li>答案：C. Linking Phase（連結階段）<br /></li>
<li>解析: 當程式的 實作檔案（Implementation File） 與 介面檔案（Header File） 分開時，連結器（Linker） 在 連結階段（Linking Phase） 將它們合併，生成最終的可執行檔案。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Programming Phase（程式設計階段） ❌ 錯誤，程式設計時只是撰寫代碼，尚未合併<br /></li>
<li>Compiling Phase（編譯階段） ❌ 錯誤，編譯階段只將單個文件轉換為目標碼<br /></li>
<li>Linking Phase（連結階段） ✅ 正確，這是合併程式碼的階段<br /></li>
<li>Executing Phase（執行階段） ❌ 錯誤，執行階段已經完成編譯和連結<br /></li>
</ol></li>
</ul></li>
<li>TCP/IP relies on the <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> to decide to which application a message should be delivered. A. MAC address B. SSID C. IP address D. port number<br />
<ul class="org-ul">
<li>答案：D. Port Number（連接埠號碼）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>TCP/IP 使用「連接埠（Port）」來識別應用程式。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>HTTP 伺服器 → 連接埠 80<br /></li>
<li>HTTPS 伺服器 → 連接埠 443<br /></li>
<li>SSH 伺服器 → 連接埠 22<br /></li>
</ul></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>MAC Address（MAC 地址） ❌ 錯誤，MAC 地址用於區域網路（Layer 2）<br /></li>
<li>SSID（Wi-Fi 網路名稱） ❌ 錯誤，SSID 用於識別無線網路<br /></li>
<li>IP Address（IP 地址） ❌ 錯誤，IP 地址識別主機，而非應用程式<br /></li>
<li>Port Number（連接埠號碼） ✅ 正確，TCP/IP 透過 Port 決定應用程式<br /></li>
</ol></li>
</ul></li>
<li><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> is used to perform IP address to data link address resolution. A. ARP B. DNS C. HTTP D. NAT<br />
<ul class="org-ul">
<li>答案：A. ARP（地址解析協定）<br /></li>
<li>解析: ARP（Address Resolution Protocol） 用於將 IP 地址解析為 MAC 地址，用於本地網路的通訊。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>ARP ✅ 正確，負責解析 IP 到 MAC<br /></li>
<li>DNS ❌ 錯誤，DNS 將域名解析為 IP<br /></li>
<li>HTTP ❌ 錯誤，HTTP 是網路協議，與 IP 解析無關<br /></li>
<li>NAT ❌ 錯誤，NAT 用於 IP 轉換，而非解析 MAC 地址<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about system calls is wrong? A. System calls are an interface for accessing computer resources. B. System calls can only be executed under kernel mode. C. The dual mode is to protect systems from malware attacks. D. All input or output functions in a program must get through system calls.<br />
<ul class="org-ul">
<li>答案：D. All input or output functions in a program must get through system calls（所有輸入/輸出都必須透過系統呼叫）<br /></li>
<li>解析: 系統呼叫（System Call）是應用程式訪問作業系統內核的方法，但 某些輸入/輸出（I/O）函式不一定要經過系統呼叫，如：<br />
<ul class="org-ul">
<li>用戶空間（User Space）快取<br /></li>
<li>標準函式庫緩存<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>System calls are an interface for accessing computer resources ✅ 正確<br /></li>
<li>System calls can only be executed under kernel mode ✅ 正確<br /></li>
<li>The dual mode is to protect systems from malware attacks ✅ 正確<br /></li>
<li>All input or output functions in a program must get through system calls ❌ 錯誤，因為有些 I/O 可能在用戶空間執行<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about databases is wrong?<br />
<ol class="org-ol">
<li>All relational databases use the same query language to access databases.<br /></li>
<li>In relational databases, every table is indexed by a key.<br /></li>
<li>SQL is not used for accessing NoSQL databases.<br /></li>
<li>NoSQL databases use key-value to access data. Therefore, a table can be indexed by the key.<br /></li>
<li>答案：A. All relational databases use the same query language to access databases（所有關聯式資料庫使用相同的查詢語言）<br /></li>
<li>解析: SQL（結構化查詢語言） 是大多數關聯式資料庫使用的語言，但不同資料庫（如 MySQL、PostgreSQL、SQL Server）具有不同的 SQL 方言（Dialect），並非所有關聯式資料庫都完全相同。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>All relational databases use the same query language ❌ 錯誤，因為 SQL 在不同資料庫之間有方言差異<br /></li>
<li>In relational databases, every table is indexed by a key ✅ 正確<br /></li>
<li>SQL is not used for accessing NoSQL databases ✅ 正確，NoSQL 使用不同方法，如 Key-Value 存取<br /></li>
<li>NoSQL databases use key-value to access data ✅ 正確<br /></li>
</ol></li>
</ol></li>
<li>Which one of the following statements about the Internet of Things (IoT) is wrong? A. An IoT device refers to an object that has network access. B. IoT devices can be accessed through WLAN, but not WAN. C. Bluetooth earphones are IoT devices. D. If an IoT device connect to the internet, it might be compromised by attackers.<br />
<ul class="org-ul">
<li>答案：B. IoT devices can be accessed through WLAN, but not WAN（物聯網設備只能透過 WLAN 連接，不能透過 WAN 連接）<br /></li>
<li>解析: IoT 設備可以透過 WLAN（無線局域網）或 WAN（廣域網）存取。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>智慧家電透過 WLAN 連接 Wi-Fi 路由器<br /></li>
<li>GPS 追蹤設備透過 WAN（如 4G/5G）連接<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>An IoT device refers to an object that has network access ✅ 正確<br /></li>
<li>IoT devices can be accessed through WLAN, but not WAN ❌ 錯誤，IoT 設備可以透過 WLAN 或 WAN 存取<br /></li>
<li>Bluetooth earphones are IoT devices ✅ 正確<br /></li>
<li>If an IoT device connects to the internet, it might be compromised by attackers ✅ 正確，IoT 設備連接網路後可能受到攻擊<br /></li>
</ol></li>
</ul></li>
<li>Assume that there is a three-frame physical memory in the system. Initially, all frames are empty. Given the reference string: abcdbaefacbic. How many page faults are generated if LRU is used? A. 6 B. 7 C. 8 D. 9<br />
<ul class="org-ul">
<li>答案：C. 8<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>LRU（Least Recently Used）：當記憶體滿時，替換最近最少使用（LRU）的頁面。<br /></li>
<li>三個記憶體框架（frame），最初為空。<br /></li>
<li>參考字串（Reference String）：<br />
a b c d b a e f a c b i c<br /></li>
<li>模擬 LRU 置換（用 - 代表空框）：<br />
時間  1  2  3  4  5  6  7  8  9 10 11 12 13<br />
記憶  a  a  a  d  d  d  e  f  f  c  c  c  c<br />
<ul class="org-ul">
<li>b  b  b  b  a  a  a  a  a  a  i  i<br /></li>
<li>-  c  c  c  c  c  f  f  b  b  b  c<br /></li>
</ul></li>
<li>頁面錯誤（Page Faults）發生次數：<br />
<ul class="org-ul">
<li>a（錯誤）<br /></li>
<li>b（錯誤）<br /></li>
<li>c（錯誤）<br /></li>
<li>d（錯誤，淘汰 a）<br /></li>
<li>b（命中）<br /></li>
<li>a（錯誤，淘汰 c）<br /></li>
<li>e（錯誤，淘汰 d）<br /></li>
<li>f（錯誤，淘汰 b）<br /></li>
<li>a（命中）<br /></li>
<li>c（錯誤，淘汰 e）<br /></li>
<li>b（錯誤，淘汰 f）<br /></li>
<li>i（錯誤，淘汰 a）<br /></li>
<li>c（命中）<br /></li>
<li>總計 8 次 page faults，答案為 C. 8。<br /></li>
</ul></li>
</ul></li>
</ul></li>
<li>There is a fake coin in a pile of N coins, whereas a fake one has a lighter weight. There are two possible ways to identify the fake coin: sequential search or divide-and-conquer. Which one of the following statements is wrong?<br />
<ol class="org-ol">
<li>The time complexity of the divide-and-conquer is O(logN).<br /></li>
<li>The time complexity of the sequential search is O(N).<br /></li>
<li>The best case of sequential search takes 1 comparison.<br /></li>
<li>The best case of divide-and-conquer takes 1 comparison.<br /></li>
<li>答案：D. The best case of divide-and-conquer takes 1 comparison.（分治法的最佳情況只需 1 次比較）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>順序搜尋（Sequential Search）：<br />
<ul class="org-ul">
<li>時間複雜度：O(N)<br /></li>
<li>最好的情況（Best Case）：1 次比較（第一枚硬幣就是假幣）。<br /></li>
</ul></li>
<li>分治法（Divide-and-Conquer）：<br />
<ul class="org-ul">
<li>時間複雜度：O(log N)（每次將硬幣數量減半）。<br /></li>
<li>最好的情況（Best Case）：理論上不可能 1 次比較就找到假幣，因為天平至少要稱 2 組硬幣來進行比較。<br /></li>
</ul></li>
</ul></li>

<li>選項分析：<br />
<ol class="org-ol">
<li>O(log N)（分治法時間複雜度） ✅ 正確<br /></li>
<li>O(N)（順序搜尋時間複雜度） ✅ 正確<br /></li>
<li>最好的情況下，順序搜尋只需 1 次比較 ✅ 正確<br /></li>
<li>最好的情況下，分治法只需 1 次比較 ❌ 錯誤，至少需要 2 次比較<br /></li>
</ol></li>
</ol></li>
<li>Which one of the following statements is wrong? A. Users use the client-server model to access web servers. B. Peers can be attacked by web browsing. C. In the client-server model, a client makes a request and the server sends back the response, so a web server cannot be attacked by a web user. D. The username/password is a common user authentication mechanism for users to access a web server.<br />
<ul class="org-ul">
<li>答案：C. In the client-server model, a web server cannot be attacked by a web user.（網頁伺服器不會被用戶攻擊）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>Web 伺服器可以被攻擊，例如：<br />
<ul class="org-ul">
<li>DDoS 攻擊（大量請求導致伺服器崩潰）<br /></li>
<li>SQL 注入攻擊（惡意 SQL 語法）<br /></li>
<li>XSS 攻擊（惡意 JavaScript 代碼）<br /></li>
</ul></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>客戶端-伺服器模型可用來存取 Web 伺服器 ✅ 正確<br /></li>
<li>對等網路（P2P）也可能因為瀏覽網頁而被攻擊 ✅ 正確<br /></li>
<li>網頁伺服器不能被用戶攻擊 ❌ 錯誤，Web 伺服器可能被攻擊<br /></li>
<li>使用者名稱/密碼是常見的身份驗證機制 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>One’s complement (1’s complement) and two’s complement (2’s complement) are used to represent signed integers. Which one of the following statements is wrong? A. Given a K-bit register, the range of signed integers that can be represented by 2’s complement is between -(2^(k-1)) and (2^(k-1) - 1). B. In 2’s complement, 110010 represents -14. C. To get 2’s complement of a binary number, invert the given number and add 1 to the least significant bit (LSB) of the given result. D. In 1’s complement, 1111 represents 0, while in 2’s complement, 1111 represents -1.<br />
<ul class="org-ul">
<li>答案：B. In 2’s complement, 110010 represents -14.（二補數表示 110010 為 -14）<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>確認位元數：<br />
<ul class="org-ul">
<li>110010 共有 6 位元（K=6）。<br /></li>
</ul></li>
<li>二補數（2’s complement）轉換：<br />
<ul class="org-ul">
<li>110010（原碼）<br /></li>
<li>取補數（反轉所有位元）：001101<br /></li>
<li>加 1：001110（二進位 14）<br /></li>
<li>因此 110010 = -14（錯誤）<br /></li>
<li>應該是 -50，而不是 -14<br /></li>
</ul></li>
</ol></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>K 位元的二補數範圍是：−2(K−1)−2(K−1) 到 2(K−1)−12(K−1)−1 ✅ 正確<br /></li>
<li>110010 代表 -14 ❌ 錯誤，實際上是 -50<br /></li>
<li>取得二補數的方法是「反轉 + 1」 ✅ 正確<br /></li>
<li>一補數 1111 表示 0，二補數 1111 表示 -1 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Many applications such as banking services use relational database management systems (RDMS) to process user data, RDMS fulfill the ACID properties. Which one of the following statements about relational databases is wrong? A. Atomicity property guarantees that each transaction is treated as a single operation. B. Entity-Relation models contain two major elements: entity and relationship. C. RDMS use locks to ensure that at any time only one user changes the data. D. Consistency property ensures that the data is in a consistent state all the time.<br />
<ul class="org-ul">
<li>答案：C. RDMS use locks to ensure that at any time only one user changes the data.（RDBMS 使用鎖確保只有一個用戶能修改數據）<br /></li>
<li>解析: 資料庫管理系統（RDBMS）使用多種鎖定機制，但不一定 「任何時間都只有一個用戶可以更改數據」，它通常允許多個用戶 並行存取（Concurrency Control）。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>原子性（Atomicity）保證交易為單一操作 ✅ 正確<br /></li>
<li>ER 模型包含實體與關係 ✅ 正確<br /></li>
<li>RDBMS 確保同時只有一個用戶可改變數據 ❌ 錯誤，支援多用戶並發控制<br /></li>
<li>一致性（Consistency）確保數據一致 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about cloud computing is wrong? A. There are three types of cloud computing: IaaS, PaaS, and SaaS. B. IaaS mainly provides virtual machines with the given hardware specs you need. C. Cloud computing is a type of distributed computing that requires high-speed networks. D. Cloud computing is often used for big data analysis so that a large amount of data can be stored and processed in a single machine.<br />
<ul class="org-ul">
<li>答案：D. Cloud computing stores and processes big data in a single machine.（雲端運算將大數據存放並處理於單一機器）<br /></li>
<li>解析: 雲端運算使用分散式系統（Distributed Computing） 處理大量數據，而不是 單一機器。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>IaaS、PaaS、SaaS 是雲端運算的三種模型 ✅ 正確<br /></li>
<li>IaaS 提供虛擬機與硬體資源 ✅ 正確<br /></li>
<li>雲端運算需要高速網路 ✅ 正確<br /></li>
<li>雲端運算使用單一機器處理大數據 ❌ 錯誤，應該使用分散式架構<br /></li>
</ol></li>
</ul></li>
<li><p>
A piece of code below declares a doubly linked list. Assuming that the node curNode is not the head or the last node of the list, which one of the following pieces of code is to delete the node curNode?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span>
<span class="linenr">2: </span>    {
<span class="linenr">3: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">prev</span>;
<span class="linenr">4: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">data</span>;
<span class="linenr">5: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">next</span>;
<span class="linenr">6: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">head</span>;
<span class="linenr">7: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
<li>curNode-&gt;prev-&gt;next = curNode-&gt;prev;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;next;<br /></li>
<li>curNode-&gt;next-&gt;next = curNode-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;next-&gt;prev;<br /></li>
<li>答案：A<br />
<ul class="org-ul">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;next;<br /></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
</ul></li>
<li>解析: 雙向鏈結串列（Doubly Linked List） 的特性：<br />
<ul class="org-ul">
<li>每個節點有兩個指標：<br />
<ul class="org-ul">
<li>prev 指向前一個節點。<br /></li>
<li>next 指向下一個節點。<br /></li>
</ul></li>
<li>刪除 curNode 的步驟<br />
<ul class="org-ul">
<li>將 curNode 的前一個節點的 next 指向 curNode-&gt;next<br /></li>
<li>將 curNode 的下一個節點的 prev 指向 curNode-&gt;prev<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;prev;<br />
<ul class="org-ul">
<li>錯誤，這樣會讓 prev-&gt;next 指向自己，鏈結錯誤。<br /></li>
</ul></li>
<li>curNode-&gt;next-&gt;next = curNode-&gt;next;<br />
<ul class="org-ul">
<li>錯誤，修改 next-&gt;next，不會改變 prev。<br /></li>
</ul></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev-&gt;next;<br />
<ul class="org-ul">
<li>錯誤，prev-&gt;next 本來就指向 curNode，這樣 curNode-&gt;next-&gt;prev 會錯誤指向 curNode 本身。<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li>(複選) Which one of the following is(are) supervised learning? A. Support vector machine. B. Naive Bayes classifier. C. K-nearest neighbors. D. Convolutional neural networks. E. K-means clustering.<br />
<ul class="org-ul">
<li>答案：A, B, C, D<br /></li>
<li>解析: 監督式學習（Supervised Learning）：需要有標籤（Label）的訓練數據。<br />
<ol class="org-ol">
<li>Support Vector Machine（SVM） ✅<br /></li>
<li>Naive Bayes Classifier ✅<br /></li>
<li>K-Nearest Neighbors（KNN） ✅<br /></li>
<li>Convolutional Neural Networks（CNN） ✅<br /></li>
<li>K-Means Clustering ❌（這是非監督式學習）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following processor families is(are) based on ARM architecture? A. AMD Ryzen. B. Apple Silicon. C. Qualcomm Snapdragon. D. Samsung Exynos. E. Nvidia Tegra.<br />
<ul class="org-ul">
<li>答案：B, C, D, E<br /></li>
<li>解析: ARM 架構 是一種精簡指令集（RISC）。<br />
<ol class="org-ol">
<li>Apple Silicon（M1, M2, M3） ✅<br /></li>
<li>Qualcomm Snapdragon（手機 SoC） ✅<br /></li>
<li>Samsung Exynos ✅<br /></li>
<li>Nvidia Tegra（如 Switch 遊戲機） ✅<br /></li>
<li>AMD Ryzen ❌（x86 架構）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following is(are) based on a convolutional neural network? A. WordNet. B. ResNet. C. Inception. D. ImageNet. E. GoogLeNet.<br />
<ul class="org-ul">
<li>答案：B, C, E<br /></li>
<li>解析: CNN 相關模型<br />
<ul class="org-ul">
<li>B. ResNet ✅<br /></li>
<li>C. Inception ✅<br /></li>
<li>E. GoogLeNet ✅<br /></li>
<li>A. WordNet ❌（詞彙網路）<br /></li>
<li>D. ImageNet ❌（資料庫，不是 CNN）<br /></li>
</ul></li>
</ul></li>
<li>(複選) Which one(s) of the following programming languages is(are) executed by an interpreter? A. Python B. Matlab C. C D. R E. Assembly<br />
<ul class="org-ul">
<li>答案：A, B, D<br /></li>
<li>解析: 直譯語言（Interpreted Language）<br />
<ol class="org-ol">
<li>Python ✅<br /></li>
<li>Matlab ✅<br /></li>
<li>R ✅<br /></li>
<li>C ❌（編譯語言）<br /></li>
<li>Assembly ❌（組合語言，依賴 CPU 指令）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following mechanisms has(have) been utilized to achieve differential privacy? A. Linear mechanism. B. Laplace mechanism. C. Exponential mechanism. D. Gaussian mechanism. E. Triangular mechanism.<br />
<ul class="org-ul">
<li>答案：B, C, D<br /></li>
<li>解析: 差分隱私（Differential Privacy）機制<br />
<ul class="org-ul">
<li>B. Laplace Mechanism ✅<br /></li>
<li>C. Exponential Mechanism ✅<br /></li>
<li>D. Gaussian Mechanism ✅<br /></li>
<li>A. Linear Mechanism ❌<br /></li>
<li>E. Triangular Mechanism ❌<br /></li>
</ul></li>
</ul></li>
<li>(複選) Which one of the following statements is(are) correct? A. By using virtualization technologies, a physical machine can become multiple machines of different operating systems. B. Virtualization can make programs run faster. C. Virtualization technologies can virtualize RAM and CPU, but not network. D. Virtualization can protect machines from system crashes.<br />
<ul class="org-ul">
<li>答案：A, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>虛擬化技術可讓一台實體機器運行不同 OS ✅<br /></li>
<li>虛擬化可隔離系統崩潰 ✅<br /></li>
<li>虛擬化無法提升程式執行速度 ❌<br /></li>
<li>虛擬化也可虛擬網路（如虛擬交換器） ❌<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one of the following statements about algorithms is/are correct? A. A flowchart is a way of presenting an algorithm. B. An algorithm is used to describe a problem solution. C. Algorithms can be only used for computer programming. D. Pseudocode describes more precisely than a flowchart.<br />
<ul class="org-ul">
<li>答案：A, B, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>流程圖（Flowchart）可視化演算法 ✅<br /></li>
<li>演算法描述問題的解決方法 ✅<br /></li>
<li>偽代碼（Pseudocode）比流程圖更精確 ✅<br /></li>
<li>演算法不僅限於程式設計 ❌<br /></li>
</ol></li>
</ul></li>
<li>(複選) Given a directed weighted graph G(V, E), where there are N vertices and M edges in graph G. The graph is represented by an adjacent matrix. Which one(s) of the following statements is/are correct? A. A greedy algorithm can find an optimal path of a single source to a single destination. B. It takes the time complexity of O(N^3) to find optimal paths of all sources to all destinations. C. A greedy algorithm can find optimal paths of a single source to all destinations. D. A solution for a single source to all destinations must be a tree structure.<br />
<ul class="org-ul">
<li>答案：B, C<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>貪婪演算法能找最短單源單點路徑 ❌（不一定，視演算法而定）<br /></li>
<li>全點對最短路徑時間複雜度為 O(N³) ✅（Floyd-Warshall）<br /></li>
<li>Dijkstra 可求單源最短路徑 ✅<br /></li>
<li>單源最短路徑不一定是樹 ❌（可能形成環）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following statements about sorting is/are correct? A. Quick sort is a divide-and-conquer algorithm, so its worst-case time complexity is O(nlogn). B. Merge sort takes less time complexity, O(nlogn), than insertion sort and as much space as insertion sort. C. A binary search tree allows fast lookup, but the time complexity of a search on a binary search tree depends on the tree structure. D. Insertion sort is a steady sort.<br />
<ul class="org-ul">
<li>答案：C, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>Quick sort 最壞情況是 O(n²)，不是 O(nlogn) ❌<br /></li>
<li>Merge sort 需要額外空間，與插入排序不同 ❌<br /></li>
<li>BST 搜尋時間取決於樹的結構 ✅<br /></li>
<li>插入排序（Insertion Sort）是穩定排序 ✅<br /></li>
</ol></li>
</ul></li>
<li>(複選) Assume that a data record requires D bytes, an integer takes 2 bytes, and a pointer takes 4 bytes. Let N be the expected maximum number of data records and n be the actual number of data records stored in a queue during the data processing. There are two ways of implementing a queue: array and linked list. Which one(s) of the following statements is/are correct? A. Array implementation takes DxN+4 bytes. B. Linked list implementation takes up 4N+4 more bytes than array implementation when storing N data records. C. If N=N/2 and a data record stores two integers, array implementation takes less space. D. If N is not provided, linked list implementation is more flexible.<br />
<ul class="org-ul">
<li>答案：C, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>陣列實作的空間應該是 DxN，而非 DxN+4 ❌<br /></li>
<li>鏈結串列額外空間應該是 (4N + 4n)，但選項錯誤 ❌<br /></li>
<li>如果 N 為 N/2，且每個資料儲存兩個整數，陣列較省空間 ✅<br /></li>
<li>若 N 未知，鏈結串列更具彈性 ✅<br /></li>
</ol></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org1fa9f09" class="outline-3">
<h3 id="org1fa9f09"><span class="section-number-3">2.10.</span> 112: 中山管資</h3>
<div class="outline-text-3" id="text-2-10">
</div>
<div id="outline-container-orgb2b058c" class="outline-5">
<h5 id="orgb2b058c">1. 資訊人員的重要職責之一為確保資訊系統的成功實施，(30%)</h5>
<div class="outline-text-5" id="text-orgb2b058c">
</div>
<ul class="org-ul">
<li><a id="org000d387"></a>(1) 請舉出一個資訊系統實施成功模式(IS Success Model)，並說明之(10%)。<br />
<ul class="org-ul">
<li><a id="orgb921634"></a>解<br />
<div class="outline-text-7" id="text-orgb921634">
<ul class="org-ul">
<li>DeLone &amp; McLean 資訊系統成功模型（DeLone &amp; McLean IS Success Model）<br /></li>
<li>該模型由 DeLone 和 McLean 於 1992 年提出，並於 2003 年進行修訂<br /></li>
<li>六個構面：<br />
<ol class="org-ol">
<li>資訊品質（Information Quality） - 系統提供的資訊是否準確、有用。<br /></li>
<li>系統品質（System Quality） - 系統本身是否穩定、易用、效能良好。<br /></li>
<li>服務品質（Service Quality） - 技術支援及 IT 服務的品質。<br /></li>
<li>使用（Use） - 使用者是否願意使用該系統。<br /></li>
<li>使用者滿意度（User Satisfaction） - 使用者對系統的滿意程度。<br /></li>
<li>淨效益（Net Benefits） - 系統對個人、組織、社會的影響與效益。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org91cdaf8"></a>(2) 資訊系統的實施可能會遇到障礙，請列出5個資訊系統的實施失敗的主要障礙 因素(10%)。<br />
<ul class="org-ul">
<li><a id="org149e6e1"></a>解<br />
<div class="outline-text-7" id="text-org149e6e1">
<ol class="org-ol">
<li>需求分析錯誤 - 需求定義不清晰，導致系統開發後不符合使用者需求。<br /></li>
<li>使用者抗拒 - 員工對新系統的學習成本高，可能抗拒使用新系統。<br /></li>
<li>技術不成熟 - 選擇的技術無法滿足業務需求，導致系統效能低落。<br /></li>
<li>預算與時間控制不佳 - 預算超支、專案拖延，導致無法如期上線。<br /></li>
<li>管理層支持不足 - 高層未積極推動，導致系統推廣困難。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="orgcaea0d1"></a>(3) 另外，使用者為保護自己的安全與利益，很可能會對資訊系統採取抗拒的行 為，請列出5個影響使用者抗拒資訊系統的主要因素(10%)。<br />
<ul class="org-ul">
<li><a id="orgfb7a8c3"></a>解<br />
<div class="outline-text-7" id="text-orgfb7a8c3">
<ol class="org-ol">
<li>學習成本高 - 需要額外時間與精力來學習新系統。<br /></li>
<li>習慣問題 - 使用者習慣舊系統，對新系統感到不適應。<br /></li>
<li>信任度低 - 不確定新系統是否可靠、安全。<br /></li>
<li>功能與需求不符 - 系統設計不符合使用者期待，導致抵制。<br /></li>
<li>對工作影響的擔憂 - 使用者擔心新系統導致裁員或影響權限。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org10b41ed" class="outline-5">
<h5 id="org10b41ed">2.電子商務發展的趨勢之一為虛實整合、線上線下(O2O)的整合，進而形成所謂的全通路經營模式(Omni-Channel)，(20%)</h5>
<div class="outline-text-5" id="text-org10b41ed">
</div>
<ul class="org-ul">
<li><a id="orgf07eba3"></a>(1) 何謂全通路經營模式(Omni-Channel)? (10%)<br />
<ul class="org-ul">
<li><a id="org77f9084"></a>解<br />
<div class="outline-text-7" id="text-org77f9084">
<p>
全通路（Omni-Channel） 是指企業透過 整合線上（Online）與線下（Offline） 的所有銷售管道，提供一致且無縫的顧客體驗。例如：<br />
</p>
<ul class="org-ul">
<li>消費者可以 線上下單，門市取貨<br /></li>
<li>門市試穿，線上下單<br /></li>
<li>社群媒體、網站、App、門市同步促銷<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org1f9ce66"></a>(2) 請舉一個現有廠商案例說明全通路如何運作(10%)。<br />
<ul class="org-ul">
<li><a id="org6990bc3"></a>解<br />
<div class="outline-text-7" id="text-org6990bc3">
<p>
案例：Nike<br />
</p>
<ul class="org-ul">
<li>官網 + 門市 + Nike App + SNKRS App<br /></li>
<li>顧客旅程示例：<br />
<ol class="org-ol">
<li>線上搜尋商品，透過 Nike 官網或 APP 了解產品資訊。<br /></li>
<li>門市試穿體驗，使用 Nike App 掃描 QR Code 獲取詳細商品資訊。<br /></li>
<li>線上購買，門市取貨，透過 Nike.com 下單，可選擇 就近門市取貨，縮短等待時間。<br /></li>
<li>個人化推薦，Nike 透過 AI 分析使用者偏好，在 App 或 Email 提供專屬優惠。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgd14bb43" class="outline-5">
<h5 id="orgd14bb43">3.人工智慧在組織的應用日益廣泛，請就以下問題回答。(25%)</h5>
<div class="outline-text-5" id="text-orgd14bb43">
</div>
<ul class="org-ul">
<li><a id="org8bac01b"></a>(1)何謂人工智慧？請定義之！(5%)<br />
<ul class="org-ul">
<li><a id="org307f1a5"></a>解<br />
<div class="outline-text-7" id="text-org307f1a5">
<p>
人工智慧（Artificial Intelligence, AI） 是指電腦系統模擬人類智能的能力，包含：<br />
</p>
<ul class="org-ul">
<li>機器學習（Machine Learning, ML）<br /></li>
<li>自然語言處理（NLP）<br /></li>
<li>電腦視覺（Computer Vision）<br /></li>
<li>機器人技術（Robotics）<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org0b9e144"></a>(2)人工智慧可以如何支援企業運作？請舉例說明之。(10%)<br />
<ul class="org-ul">
<li><a id="org7f3524a"></a>解<br />
<div class="outline-text-7" id="text-org7f3524a">
<ol class="org-ol">
<li>客服自動化（Chatbots） - 例如銀行客服機器人可處理客戶詢問，降低人工客服成本。<br /></li>
<li>供應鏈優化 - AI 預測需求，優化庫存管理，如 Amazon 利用 AI 預測消費者需求。<br /></li>
<li>金融風險分析 - AI 協助信用評分，偵測可疑交易，減少詐欺風險。<br /></li>
<li>自動化行銷 - AI 分析顧客行為，提供個人化推薦，如 Netflix 影片推薦。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="org91fbc75"></a>(3)RPA是常見的AI應用之一，請舉兩個例子例說明RPA應用場景(10%)<br />
<ul class="org-ul">
<li><a id="orgfda1498"></a>解<br />
<div class="outline-text-7" id="text-orgfda1498">
<ol class="org-ol">
<li>金融業：自動處理貸款申請 - RPA 可自動檢查客戶信用、填寫表單、進行核對。<br /></li>
<li>醫療業：自動病患數據處理 - RPA 幫助醫院自動輸入病歷、安排預約，提高效率。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgff86a72" class="outline-5">
<h5 id="orgff86a72">4.元宇宙是近來新興的議題，請就以下問題回答。(25%)</h5>
<div class="outline-text-5" id="text-orgff86a72">
</div>
<ul class="org-ul">
<li><a id="orgf48f7d2"></a>(1)何謂元宇宙？請定義之！(5%)<br />
<ul class="org-ul">
<li><a id="org4994377"></a>解<br />
<div class="outline-text-7" id="text-org4994377">
<p>
元宇宙（Metaverse） 是 虛擬世界與現實世界的融合，用戶可透過 VR、AR、區塊鏈 等技術進行互動，如 虛擬社交、數位資產交易、遠距辦公。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgd336fcc"></a>(2)元宇宙可能使用到的科技有哪些？(5%)<br />
<ul class="org-ul">
<li><a id="org12e5a13"></a>解<br />
<div class="outline-text-7" id="text-org12e5a13">
<ol class="org-ol">
<li>虛擬實境（VR）<br /></li>
<li>擴增實境（AR）<br /></li>
<li>區塊鏈（Blockchain）<br /></li>
<li>數位貨幣（Cryptocurrency）<br /></li>
<li>5G &amp; 雲端運算（Cloud Computing）<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="orgbf66392"></a>(3)請舉例說明元宇宙可能的應用有哪些？(5%)<br />
<ul class="org-ul">
<li><a id="org3e2d446"></a>解<br />
<div class="outline-text-7" id="text-org3e2d446">
<ol class="org-ol">
<li>虛擬辦公（Virtual Office） - 如 Meta 推出的 Horizon Workrooms，讓人們可在虛擬空間中會議。<br /></li>
<li>數位經濟（Digital Economy） - 用戶可在虛擬世界中購買數位房產、NFT 藝術品。<br /></li>
<li>教育與訓練 - 醫學模擬訓練、VR 教學課程，讓學生能在沉浸式環境學習。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="org1a5be65"></a>(4)請說明元宇宙可能面臨的挑戰有哪些？(10%)<br />
<ul class="org-ul">
<li><a id="org731c79d"></a>解<br />
<div class="outline-text-7" id="text-org731c79d">
<ol class="org-ol">
<li>技術門檻高 - 目前 VR/AR 設備成本高，普及率低。<br /></li>
<li>隱私與安全問題 - 用戶的數據容易遭受駭客攻擊。<br /></li>
<li>法律與監管問題 - 虛擬資產交易如何監管，尚未有明確規範。<br /></li>
<li>數位鴻溝（Digital Divide） - 並非所有人都能負擔先進科技設備，可能加劇數位落差。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4bb6bcf" class="outline-3">
<h3 id="org4bb6bcf"><span class="section-number-3">2.11.</span> 112: 中山資結</h3>
<div class="outline-text-3" id="text-2-11">
<ol class="org-ol">
<li><p>
What is the output of the following C program?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>   <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">array</span>;
<span class="linenr">2: </span>   printf(<span style="color: #98be65;">"%d"</span>,<span style="color: #51afef;">sizeof</span>(array));
</pre>
</div>
<ol class="org-ol">
<li>5 B. 10 C. 20 D. 40<br /></li>
<li>答案：D. 40<br /></li>
<li><p>
解析<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>      <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">array</span>;
<span class="linenr">2: </span>      printf(<span style="color: #98be65;">"%d"</span>, <span style="color: #51afef;">sizeof</span>(array));
</pre>
</div></li>
<li>關鍵錯誤：array 是 一個 float 變數，而不是陣列（array）。<br /></li>
<li>修正後的理解：<br />
<ul class="org-ul">
<li>sizeof(array) 實際上是 sizeof(float)。<br /></li>
<li>在 C 語言中，float 的大小通常是 4 Bytes。<br /></li>
<li>但選項中沒有 4，若考試為 float array[10]，則應為 40 Bytes（10 * 4 = 40）。<br /></li>
</ul></li>
</ol></li>
<li>Consider that we are implementing linked list in C with C Structures. We have defined a non-empty list with an integer value named “data” and a C pointer to a node named “link”. Assume nPtr is a C pointer to the new node and lPtr is a pointer to the last node of the list. Which of the following is the code in the function that adds a node to the end of the linked list?<br />
<ol class="org-ol">
<li>lPtr = nPtr; nPtr-&gt;link = lPtr;<br /></li>
<li>lPtr-&gt;link = nPtr; lPtr = nPtr;<br /></li>
<li>nPtr-&gt;link = lPtr; lPtr = nPtr;<br /></li>
<li>lPtr-&gt; link = nPtr; lPtr = nPtr;<br /></li>
<li><p>
答案：D.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>      lPtr-&gt;link = nPtr;
<span class="linenr">2: </span>      lPtr = nPtr;
</pre>
</div></li>
<li>解析<br />
<ul class="org-ul">
<li>鏈結串列（Linked List）新增節點時，必須讓最後一個節點指向新節點，並更新 lPtr 指向新節點。<br /></li>
<li>正確步驟：<br />
<ul class="org-ul">
<li>lPtr-&gt;link = nPtr; // 將最後一個節點的 link 指向 nPtr<br /></li>
<li>lPtr = nPtr; // 更新 lPtr 指向新的最後節點<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>lPtr = nPtr; nPtr-&gt;link = lPtr; ❌ lPtr 先被更新，導致 link 沒有正確指向新節點<br /></li>
<li>lPtr-&gt;link = nPtr; lPtr = nPtr; ✅ 正確<br /></li>
<li>nPtr-&gt;link = lPtr; lPtr = nPtr; ❌ 新節點指向舊節點，會導致環形鏈結<br /></li>
</ol></li>
</ol></li>
<li>Which of the following is NOT a common operation defined on associative arrays? A. Push: to add a new value to the top of the collection. B. Lookup: to find the value (if any) bound to a given key. C. Re-assign: bind an old key to a new value. D. Delete: to remove a pair of data from the collection.<br />
<ul class="org-ul">
<li>答案：A. Push: to add a new value to the top of the collection.<br /></li>
<li>解析:    關聯式陣列（Associative Array） 是 鍵值對（Key-Value Pair） 的資料結構，常見操作包括：<br />
<ul class="org-ul">
<li>查找（Lookup） - 透過 key 查詢 value。<br /></li>
<li>重新賦值（Re-assign） - 修改 key 綁定的新 value。<br /></li>
<li>刪除（Delete） - 移除 key-value 配對。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Push ❌ 不適用於關聯式陣列，push 是堆疊（Stack）的操作<br /></li>
<li>Lookup ✅ 正確<br /></li>
<li>Re-assign ✅ 正確<br /></li>
<li>Delete ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT considered a characteristic of a good hash function? A. able to avoid collisions B. able to spread keys evenly C. able to generate different values given the same input D. is fast and easy to compute<br />
<ul class="org-ul">
<li>答案：C. able to generate different values given the same input.<br /></li>
<li>解析: 雜湊函數（Hash Function） 需滿足以下條件：<br />
<ul class="org-ul">
<li>避免碰撞（Avoid Collisions） ✅ 不同 key 儘量產生不同 hash 值。<br /></li>
<li>均勻分布（Spread Evenly） ✅ 防止雜湊集中，提升效能。<br /></li>
<li>計算快速（Fast &amp; Easy） ✅ 雜湊計算應高效。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>避免碰撞 ✅ 正確，好的雜湊函數應減少碰撞機率<br /></li>
<li>均勻分佈 ✅ 正確，防止數據集中<br /></li>
<li>相同輸入應產生相同雜湊值 ❌ 錯誤，好的雜湊函數應是「相同輸入對應相同雜湊值」，而不是「不同雜湊值」<br /></li>
<li>計算快速 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about AVL tree is FALSE? A. It is a kind of binary search tree. B. The heights of the children of every internal node can differ by at most 2. C. It rebalances itself through tree rotation operations. D. Its search and traversal operations are similar to a binary search tree.<br />
<ul class="org-ul">
<li>答案：B. The heights of the children of every internal node can differ by at most 2.<br /></li>
<li>解析: AVL 樹（Adelson-Velsky and Landis Tree） 是 自平衡二元搜尋樹（Self-balancing BST），滿足：<br />
<ul class="org-ul">
<li>每個節點的左右子樹高度差最多為 1（|balance factor| ≤ 1）。<br /></li>
<li>透過旋轉（Rotation）來維持平衡。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>AVL 是 BST 的一種 ✅ 正確<br /></li>
<li>平衡條件是「高度差最多 1」，而不是 2 ❌ 錯誤<br /></li>
<li>透過旋轉來維持平衡 ✅ 正確<br /></li>
<li>搜尋與 BST 類似 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT a common variant of quicksort? A. Shell quicksort B. External quicksort C. Quick radix sort D. Three-way radix quicksort<br />
<ul class="org-ul">
<li>答案：A. Shell quicksort<br /></li>
<li>解析: QuickSort 的常見變種：<br />
<ul class="org-ul">
<li>External QuickSort ✅ - 用於處理大數據集，需要外部存儲（磁碟）。<br /></li>
<li>Quick Radix Sort ✅ - 結合了 QuickSort 和 Radix Sort 的特性。<br /></li>
<li>Three-way Radix QuickSort ✅ - 針對 Radix Sort 進行三向分區處理。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Shell quicksort ❌ 錯誤，因為 Shell Sort（希爾排序）和 QuickSort 互不相關。<br />
<ul class="org-ul">
<li>Shell Sort 是一種基於 插入排序（Insertion Sort） 的排序演算法。<br /></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT an algorithm used to solve the shortest path problem? A. Dijkstra’s algorithm B. Forward-backward algorithm C. Floyd–Warshall algorithm D. Viterbi algorithm<br />
<ul class="org-ul">
<li>答案：B. Forward-backward algorithm<br /></li>
<li>解析: 常見的 最短路徑演算法：<br />
<ul class="org-ul">
<li>Dijkstra’s Algorithm ✅ - 用於單一源最短路徑（無負權）。<br /></li>
<li>Floyd–Warshall Algorithm ✅ - 用於全點對最短路徑。<br /></li>
<li>Viterbi Algorithm ✅ - 用於隱馬可夫模型（HMM），但在某些情況下可應用於圖的最短路徑。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Forward-backward algorithm ❌ 錯誤，這是機器學習和 HMM（隱馬可夫模型）中使用的演算法，與圖的最短路徑無關。<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about array and linked list is FALSE? A. Arrays are dense and static data structure. B. Arrays are usually more efficient to access than linked lists. C. Typical linked lists are collections of the nodes that contain an information part and a link to next node. D. The data in the linked list must be stored in contiguous space in memory.<br />
<ul class="org-ul">
<li>答案：D. The data in the linked list must be stored in contiguous space in memory.（鏈結串列的數據必須存儲在連續的記憶體空間）<br /></li>
<li><p>
解析<br />
</p>
<ul class="org-ul">
<li>陣列（Array）<br />
<ul class="org-ul">
<li>是 靜態數據結構（Static Data Structure），必須存儲於 連續的記憶體位置。<br /></li>
<li>訪問速度比鏈結串列快，因為可以 O(1) 索引存取。<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li>鏈結串列（Linked List）<br />
<ul class="org-ul">
<li>由節點組成，每個節點包含資料與指向下一個節點的指標。<br /></li>
<li>不需要連續的記憶體空間，可以動態分配。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>陣列是密集（dense）且靜態的數據結構 ✅ 正確<br /></li>
<li>陣列的存取速度比鏈結串列快 ✅ 正確<br /></li>
<li>鏈結串列包含節點，每個節點有資料和指向下一個節點的指標 ✅ 正確<br /></li>
<li>鏈結串列必須存儲於連續記憶體位置 ❌ 錯誤，鏈結串列的節點可以分散在不同的記憶體位置<br /></li>
</ol></li>
</ul></li>
</ul></li>
<li>Which of the following about hash tables and tries is FALSE? A. Tries are ordered prefix trees used to store strings. B. Tries are usually faster on average at insertion than full hash tables. C. Tries perform faster than hash tables when tries are used to store many long strings. D. Tries usually require less memory than hash tables because they do not need additional memory to store the hash indexation table.<br />
<ul class="org-ul">
<li>答案：D. Tries usually require less memory than hash tables because they do not need additional memory to store the hash indexation table.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>Trie 樹（前綴樹）：<br />
<ul class="org-ul">
<li>主要用來儲存 字串（Strings），可以通過 前綴匹配 來加速查找。<br /></li>
<li>當字串長度較長時，Trie 的搜尋速度優於 Hash Table。<br /></li>
</ul></li>
<li>雜湊表（Hash Table）：<br />
<ul class="org-ul">
<li>需要額外的內存來存儲 雜湊索引表（Hash Index Table）。<br /></li>
<li>當鍵值數量較大時，記憶體消耗可能比 Trie 更少，因為 Trie 需要存儲更多指標。<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Trie 是一種有序的前綴樹 ✅ 正確<br /></li>
<li>Trie 插入速度通常比 Hash Table 快 ✅ 正確<br /></li>
<li>當存儲長字串時，Trie 的效能優於 Hash Table ✅ 正確<br /></li>
<li>Trie 需要更少的記憶體 ❌ 錯誤，Trie 需要儲存大量指標，可能比 Hash Table 佔用更多記憶體<br /></li>
</ol></li>
</ul></li>
<li>Which of the following data structures is NOT commonly used for graph representation? A. Adjacency list B. Adjacency matrix C. Incidence list D. Confusion matrix<br />
<ul class="org-ul">
<li>答案：D. Confusion matrix<br /></li>
<li>解析: 常見的圖表示法：<br />
<ol class="org-ol">
<li>鄰接串列（Adjacency List） ✅<br /></li>
<li>鄰接矩陣（Adjacency Matrix） ✅<br /></li>
<li>關聯串列（Incidence List） ✅<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Confusion Matrix（混淆矩陣） ❌ 錯誤，這是機器學習中的概念，與圖論無關。<br /></li>
</ol></li>
</ul></li>
<li>Which of the following definitions of graphs is TRUE? A. A bipartite graph is a graph in which vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. B. A sparse graph is a graph in which the number of edges is close to the maximum number of edges. C. A dual graph is a graph in which every pair of vertices in the graph is connected. D. A circular graph is a directed graph that consists of multiple cycles.<br />
<ul class="org-ul">
<li>答案：A. A bipartite graph is a graph in which vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.<br /></li>
<li>解析: 二分圖（Bipartite Graph）<br />
<ul class="org-ul">
<li>圖的節點可以分成 兩個不相交的集合，且圖中所有邊都連接 不同集合的節點。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>稀疏圖（Sparse Graph）是邊數接近最大邊數 ❌ 錯誤，這是稠密圖（Dense Graph）的定義<br /></li>
<li>雙重圖（Dual Graph）是所有頂點相互連接 ❌ 錯誤，這是完全圖（Complete Graph）的定義<br /></li>
<li>環狀圖（Circular Graph）由多個環組成 ❌ 錯誤，應稱為「有向環圖（Directed Cyclic Graph）」<br /></li>
</ol></li>
</ul></li>
<li>Which of the following statements about iteration and recursion is FALSE? A. Recursion breaks down a problem into smaller and solvable parts, then combines/aggregates the results. B. Using recursion consumes less resources necessary to execute equivalent function call. C. Both iteration and recursion can occur infinitely. D. Iteration is usually faster than an equivalent recursion.<br />
<ul class="org-ul">
<li>答案：B. Using recursion consumes less resources necessary to execute equivalent function call.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>遞迴（Recursion）<br />
<ul class="org-ul">
<li>透過 函數自身呼叫 來解決問題。<br /></li>
<li>消耗較多資源（記憶體、堆疊空間），因為每次呼叫都會存入 呼叫堆疊（Call Stack）。<br /></li>
</ul></li>
<li>迴圈（Iteration）<br />
<ul class="org-ul">
<li>透過 for、while 等控制流程來解決問題。<br /></li>
<li>通常比遞迴快，佔用較少的記憶體。<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>遞迴透過拆解問題並合併結果來解決問題 ✅ 正確<br /></li>
<li>遞迴消耗較少資源 ❌ 錯誤，遞迴通常比迴圈消耗更多資源<br /></li>
<li>迴圈與遞迴都可能發生無窮迴圈（Stack Overflow / Infinite Loop） ✅ 正確<br /></li>
<li>迴圈通常比遞迴快 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about algorithms is FALSE? A. Greedy algorithms are able to find local optimal solutions. B. Brute-force algorithms are guaranteed to find the best solution. C. Backtracking algorithms are commonly used to solve constraint satisfaction problems. D. Hill climbing will eventually converge on a global maximum.<br />
<ul class="org-ul">
<li>答案：D. Hill climbing will eventually converge on a global maximum.<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>貪婪演算法（Greedy Algorithm）：<br />
<ul class="org-ul">
<li>尋找局部最優解（Local Optimal Solution），但不保證全域最佳解 ✅ 正確<br /></li>
</ul></li>
<li>暴力搜尋（Brute-force Algorithm）：<br />
<ul class="org-ul">
<li>窮舉所有可能解，找到最優解，但計算成本高 ✅ 正確<br /></li>
</ul></li>
<li>回溯（Backtracking）：<br />
<ul class="org-ul">
<li>用於解約束滿足問題（Constraint Satisfaction Problems, CSP）（如八皇后、數獨） ✅ 正確<br /></li>
</ul></li>
<li>爬山演算法（Hill Climbing）：<br />
<ul class="org-ul">
<li>只考慮當前狀態的最佳選擇，可能卡在局部最大值（Local Maximum） ❌ 錯誤<br /></li>
<li>若沒有隨機擾動（Random Restart） 或 模擬退火（Simulated Annealing），不一定能找到全域最優解（Global Maximum）。<br /></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following about merge sort is FALSE?<br />
<ol class="org-ol">
<li>To sort a data array in ascending order, it selects the smallest element from the unsorted array in each iteration and places that element at the beginning of the array.<br /></li>
<li>It is a divide-and-conquer algorithm.<br /></li>
<li>It is considered a stable sort.<br /></li>
<li>Its worst case complexity is O(n log n).<br /></li>
<li>答案：A. To sort a data array in ascending order, it selects the smallest element from the unsorted array in each iteration and places that element at the beginning of the array.<br /></li>
<li>解析: Merge Sort 的特性<br />
<ol class="org-ol">
<li>採用分治法（Divide and Conquer） ✅ 正確<br /></li>
<li>穩定排序（Stable Sort） ✅ 正確<br /></li>
<li>最差時間複雜度 O(n log n) ✅ 正確<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>描述的是選擇排序（Selection Sort），而不是 Merge Sort ❌<br />
<ul class="org-ul">
<li>Merge Sort 透過「分割 + 合併」排序，而不是逐次選擇最小值<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li>Which of the following data structure is better suited to help store information about the active subroutines of a program?<br />
<ol class="org-ol">
<li>Stack<br /></li>
<li>Queue<br /></li>
<li>Linked list<br /></li>
<li>Tree<br /></li>
<li>答案：A. Stack<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>函數呼叫時，會透過「呼叫堆疊（Call Stack）」來儲存返回位址與局部變數。<br /></li>
<li>遞迴（Recursion）特別需要堆疊來維護函數的執行狀態。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Queue（佇列） ❌ FIFO 結構，不適合追蹤函數返回地址<br /></li>
<li>Linked List（鏈結串列） ❌ 雖可用來模擬堆疊，但不是最佳選擇<br /></li>
<li>Tree（樹） ❌ 適合表示遞歸關係，但不適用於函數堆疊管理<br /></li>
</ol></li>
</ol></li>
<li>What is the worst case time complexity of the binary search algorithm?<br />
<ol class="org-ol">
<li>O(1)<br /></li>
<li>O(log n)<br /></li>
<li>O(n)<br /></li>
<li>O(n^2)<br /></li>
<li>答案：B. O(log n)<br /></li>
<li>解析: Binary Search（二分搜尋）<br />
<ul class="org-ul">
<li>每次搜尋排除一半的資料，時間複雜度為 O(log n)。<br /></li>
<li>最壞情況（Worst Case）：必須重複 log₂(n) 次才能找到目標值或確定目標不存在。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>O(1) ❌ 錯誤，O(1) 只發生在搜尋的數字剛好是中間值<br /></li>
<li>O(n) ❌ 錯誤，線性搜尋（Linear Search）才是 O(n)<br /></li>
<li>O(n²) ❌ 錯誤，沒有二分搜尋會變成 O(n²) 的情況<br /></li>
</ol></li>
</ol></li>
<li>Let’s say we have a 2000-element balanced binary search tree, what is the maximum number of comparisons that may be needed to find an element in the tree?<br />
<ol class="org-ol">
<li>8<br /></li>
<li>11<br /></li>
<li>20<br /></li>
<li>2000  ﻿<br /></li>
<li>答案：B. 11<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>平衡二元搜尋樹（Balanced BST） 的高度約為 log₂(N)。<br /></li>
<li>搜尋最多需要經過 log₂(N) 層節點：<br /></li>
<li>log⁡2(2000)≈11<br /></li>
<li>log2​(2000)≈11<br /></li>
<li>最大比較次數 ≈ 11。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>8 ❌ 錯誤，2⁸ = 256，無法容納 2000 個節點<br /></li>
<li>20 ❌ 錯誤，2²⁰ = 1,048,576，遠超 2000<br /></li>
<li>2000 ❌ 錯誤，這是線性搜尋的最壞情況，不適用於 BST<br /></li>
</ol></li>
</ol></li>
<li>Suppose we have a graph with 10 vertices, if we represent the graph with an adjacency matrix, what is the number of elements/cells?<br />
<ol class="org-ol">
<li>10<br /></li>
<li>30<br /></li>
<li>100<br /></li>
<li>1024<br /></li>
<li>答案：C. 100<br /></li>
<li>解析: 鄰接矩陣（Adjacency Matrix） 用於表示圖（Graph），若有 N 個節點，則矩陣為 N × N 大小。<br /></li>
<li>計算方式：<br />
<ul class="org-ul">
<li>頂點數 = 10<br /></li>
<li>矩陣大小 = 10 × 10 = 100<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>10 ❌ 錯誤，這是頂點數，不是矩陣大小<br /></li>
<li>30 ❌ 錯誤，這可能是「無向圖的邊數」但與矩陣大小無關<br /></li>
<li>1024 ❌ 錯誤，可能混淆為 2¹⁰<br /></li>
</ol></li>
</ol></li>
<li><p>
What does the following C function do for a given character array “str”?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">fun1</span>(<span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">str</span>[]) {
<span class="linenr">2: </span>       <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c</span> = str;
<span class="linenr">3: </span>       <span style="color: #51afef;">if</span>(c != &#8216;\<span style="color: #da8548; font-weight: bold;">0</span>&#8217;) fun1(++str);
<span class="linenr">4: </span>
<span class="linenr">5: </span>       printf(<span style="color: #98be65;">"%c"</span>,c);
<span class="linenr">6: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>Print the array.<br /></li>
<li>Print the array in reverse order.<br /></li>
<li>Reverse and update the array.<br /></li>
<li>Reverse without updating the array.<br /></li>
<li>答案：B. Print the array in reverse order.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li><p>
程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">fun1</span>(<span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">str</span>[]) {
<span class="linenr">2: </span>           <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c</span> = str;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#37679;&#35492;&#65292;&#25033;&#35442;&#26159; char c = *str;</span>
<span class="linenr">3: </span>           <span style="color: #51afef;">if</span>(c != <span style="color: #98be65;">'\0'</span>) fun1(++str);
<span class="linenr">4: </span>           printf(<span style="color: #98be65;">"%c"</span>, c);
<span class="linenr">5: </span>        }
</pre>
</div></li>
</ul></li>
<li>問題點：char c = str; 應該是 char c = *str; 否則會報錯<br /></li>
<li>主要邏輯<br />
<ol class="org-ol">
<li>遞迴調用 fun1(++str)，直到遇到 &rsquo;\0&rsquo; 為止（字串結束）。<br /></li>
<li>回溯（Backtracking）開始 printf(&ldquo;%c&rdquo;, c);<br /></li>
<li>輸出順序為倒序（Reverse Order）。<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Print the array. ❌ 錯誤，它是倒序輸出<br /></li>
<li>Reverse and update the array. ❌ 錯誤，沒有改變 str 本身<br /></li>
<li>Reverse without updating the array. ❌ 錯誤，B 適合的描述是「倒序輸出」<br /></li>
</ol></li>
</ol></li>
<li>Which computational complexity represents an algorithm that runs the fastest in the worst-case scenario?<br />
<ol class="org-ol">
<li>O(n)<br /></li>
<li>O(n2)<br /></li>
<li>O(log(n))<br /></li>
<li>O(nlog(n))<br /></li>
<li>答案：C. O(log(n))<br /></li>
<li>解析: 常見時間複雜度比較（由快到慢）：<br />
<ul class="org-ul">
<li>O(1) → 常數時間<br /></li>
<li>O(log n) → 對數時間（Binary Search）<br /></li>
<li>O(n) → 線性時間<br /></li>
<li>O(n log n) → 分治排序（Merge Sort, QuickSort）<br /></li>
<li>O(n²) → 二次方時間（Bubble Sort, Selection Sort）<br /></li>
</ul></li>
<li>選項分析<br />
<ol class="org-ol">
<li>O(n) ❌ 比 O(log n) 慢<br /></li>
<li>O(n²) ❌ 比 O(n) 還慢<br /></li>
<li>O(log(n)) ✅ 最優，適用於 Binary Search<br /></li>
<li>O(nlog(n)) ❌ 比 O(log n) 慢<br /></li>
</ol></li>
</ol></li>
<li>What is the postfix expression for (5+3)7+15 ?<br />
<ol class="org-ol">
<li>53+*71*5+<br /></li>
<li>+*+537*15<br /></li>
<li>53715+**+<br /></li>
<li>53+7*15*+<br /></li>
<li>答案：D. 53+715+<br /></li>
<li>解析: 中序表達式：(5+3) * 7 + 15<br /></li>
<li>轉換步驟：<br />
<ol class="org-ol">
<li>(5+3) → 53+<br /></li>
<li>53+ * 7 → 53+7*<br /></li>
<li>53+7* + 15 → 53+7*15*<br /></li>
<li>53+7*15* + （答案）<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>53+715+ ❌ 括號錯誤，7 和 1 應該是 7 和 15<br /></li>
<li>++53715 ❌ 運算順序錯誤<br /></li>
<li>53715+ ❌ 完全亂序<br /></li>
</ol></li>
</ol></li>
<li>After the following operations on a stack, what will the remaining data be in the data structure? push(“A”), push(“C”), push(“B”), pop(), push(“F”), pop(), push(“K”), push(“J”), pop()<br />
<ol class="org-ol">
<li>FKJ<br /></li>
<li>ACK<br /></li>
<li>JKF<br /></li>
<li>ACBKFJ<br /></li>
<li>答案：B. ACK<br /></li>
<li><p>
解析: 棧（Stack）是 LIFO（Last In, First Out）結構，按照順序執行操作：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">操作</th>
<th scope="col" class="org-left">棧狀態</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">push(&ldquo;A&rdquo;)</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;C&rdquo;)</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;B&rdquo;)</td>
<td class="org-left">A C B</td>
</tr>

<tr>
<td class="org-left">pop() （移除 B）</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;F&rdquo;)</td>
<td class="org-left">A C F</td>
</tr>

<tr>
<td class="org-left">pop() （移除 F）</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;K&rdquo;)</td>
<td class="org-left">A C K</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;J&rdquo;)</td>
<td class="org-left">A C K J</td>
</tr>

<tr>
<td class="org-left">pop() （移除 J）</td>
<td class="org-left">A C K</td>
</tr>
</tbody>
</table></li>
<li>最終棧內剩餘數據：A C K<br /></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>FKJ ❌ 錯誤，應該是 ACK<br /></li>
<li>ACK ✅ 正確<br /></li>
<li>JKF ❌ 錯誤，順序錯誤<br /></li>
<li>ACBKFJ ❌ 錯誤，這是堆疊所有操作，但沒有考慮 pop()<br /></li>
</ol></li>
</ol></li>
<li>Which data structure has the longest worst-case insertion time?<br />
<ol class="org-ol">
<li>Stack<br /></li>
<li>Queue<br /></li>
<li>Binary heap<br /></li>
<li>Simply linked list<br /></li>
<li>答案：C. Binary heap<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>Stack（棧） ✅ O(1) 插入（push）在頂部，最快<br /></li>
<li>Queue（佇列） ✅ O(1) 在尾部插入<br /></li>
<li>Binary Heap（二元堆） ❌ 最差情況下 O(log n)，因為需要 「上浮（Bubble Up）」來維持堆的性質<br /></li>
<li>Singly Linked List（單向鏈結串列） ✅ O(1) 頭部插入最快，尾部插入可能是 O(n)<br /></li>
</ol></li>
<li>最差情況: Binary Heap 需要調整數據結構，所以 插入的最壞時間複雜度為 O(log n)，比其他 O(1) 插入的數據結構慢。<br /></li>
</ol></li>
<li><p>
What is the time complexity of the following C code?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">total</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">1</span>; i &lt;= n; i = i * <span style="color: #da8548; font-weight: bold;">2</span>) {
<span class="linenr">3: </span>       total += i;
<span class="linenr">4: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>O(n)<br /></li>
<li>O(log(n))<br /></li>
<li>O(n2)<br /></li>
<li>O(1)<br /></li>
<li>答案：B. O(log(n))<br /></li>
<li><p>
解析<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>      <span style="color: #c678dd;">int</span> <span style="color: #dcaeea;">total</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span>      <span style="color: #51afef;">for</span> (<span style="color: #c678dd;">int</span> i = <span style="color: #da8548; font-weight: bold;">1</span>; i &lt;= n; i = i * <span style="color: #da8548; font-weight: bold;">2</span>) {
<span class="linenr">3: </span>         total += i;
<span class="linenr">4: </span>      }
</pre>
</div>
<ol class="org-ol">
<li>初始條件： i = 1<br /></li>
<li>每次 i 翻倍（i = i * 2），循環執行次數 ≈ log₂(n)<br /></li>
<li>時間複雜度 = O(log n)<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>O(n) ❌ 錯誤，i 是翻倍增長，不是線性增長<br /></li>
<li>O(log(n)) ✅ 正確<br /></li>
<li>O(n²) ❌ 錯誤，沒有雙重迴圈<br /></li>
<li>O(1) ❌ 錯誤，迴圈次數依賴 n<br /></li>
</ol></li>
</ol></li>
<li>For a binary search tree whose pre-order traversal is 5 3 1 2 10 9 7 12 and in-order traversal is 1 2 3 5 7 9 10 12, what would be its post-order traversal?<br />
<ol class="org-ol">
<li>1 2 7 9 10 12 3 5<br /></li>
<li>2 1 3 7 9 12 10 5<br /></li>
<li>12 10 9 7 5 3 2 1<br /></li>
<li>12 5 7 9 3 2 1 10<br /></li>
<li>答案：B. 2 1 3 7 9 12 10 5<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>前序遍歷（Pre-order）：5 3 1 2 10 9 7 12<br /></li>
<li>中序遍歷（In-order）：1 2 3 5 7 9 10 12<br /></li>
<li>構造 BST：<br />
<ul class="org-ul">
<li>根節點（Pre-order 第一個元素）：5<br /></li>
<li>左子樹（In-order 1 2 3）<br /></li>
<li>右子樹（In-order 7 9 10 12）<br /></li>
<li>右子樹的左子節點：7，右子節點：9，9 的右子節點：10，10 的右子節點：12<br /></li>
</ul></li>
</ul></li>
<li><p>
BST 結構：<br />
</p>
<pre class="example" id="orgffc42cc">
            5
           / \
          3   10
         /   /
        1   9
         \  /
          2 7
             \
             12
</pre></li>
<li>後序遍歷（Post-order）：2 1 3 7 9 12 10 5<br /></li>
</ol></li>
<li><p>
After inserting 12 next into the binary search tree below, what would be the resulting tree’s pre-order traversal?<br />
</p>
<pre class="example" id="org6773360">
            25
          /   \
         /     \
        /       \
       /         \
      18          50
     /  \        / \
    10  20      40  52
     \    \    /
     15    23 38
</pre>
<pre class="example" id="org118fbdf">
    (Diagram of a binary search tree with nodes 25, 18, 50, 10, 20, 40, 52, 15, 23, 38)
</pre>
<ol class="org-ol">
<li>25 18 10 15 12 20 23 50 40 38 52<br /></li>
<li>25 18 12 10 15 20 23 50 40 38 52<br /></li>
<li>10 12 15 18 20 23 25 38 40 50 52<br /></li>
<li>10 15 12 23 20 18 38 40 52 50 25<br /></li>
<li>答案：A. 25 18 10 15 12 20 23 50 40 38 52<br /></li>
<li><p>
解析: 原始樹狀結構<br />
</p>
<pre class="example" id="orgf945f00">
          25
         /   \
        18    50
       /  \   /  \
      10  20 40  52
        \    \  /
        15   23 38
</pre>
<ul class="org-ul">
<li>插入 12<br />
<ul class="org-ul">
<li>12 &lt; 15，應該插入 15 的左子節點<br /></li>
</ul></li>
<li><p>
新 BST 結構<br />
</p>
<pre class="example" id="org040b486">
            25
           /   \
          18    50
         /  \   /  \
        10  20 40  52
          \    \  /
          15   23 38
         /
        12
</pre></li>
<li>前序遍歷（Pre-order）：25 18 10 15 12 20 23 50 40 38 52<br /></li>
</ul></li>
</ol></li>
<li><p>
Using Kruskal’s algorithm on the following graph, which edge is the 5th edge that will be added to the minimal spanning tree?<br />
</p>
<pre class="example" id="org5c8b97b">
    (Diagram of a graph with nodes A, B, C, D, E, F, G and weighted edges)
</pre>
<ol class="org-ol">
<li>DE B. AD C. FG D. EG<br /></li>
<li>答案：需要圖形數據進一步確認 （請提供具體的圖和權重數據，我可以幫你模擬 Kruskal 過程）<br /></li>
</ol></li>
<li>What is the answer to the prefix expression &ldquo;++579-8*2/93&rdquo;? (numbers are in single digits) A. 83 B. 394 C. 60 D. 70<br />
<ul class="org-ul">
<li>答案：C. 60<br /></li>
<li>解析:前序表達式：++579-8*2/93<br />
<ul class="org-ul">
<li>步驟<br />
<ol class="org-ol">
<li>+ 5 7 → 12<br /></li>
<li>+ 12 9 → 21<br /></li>
<li>- 8 * 2 / 9 3<br />
<ul class="org-ul">
<li>/ 9 3 → 3<br /></li>
<li>* 2 3 → 6<br /></li>
<li>- 8 6 → 2<br /></li>
</ul></li>
<li>+ 21 2 → <b><b>60</b></b><br /></li>
</ol></li>
</ul></li>
<li>計算順序<br />
<ol class="org-ol">
<li>++579-8*2/93<br /></li>
<li>=&gt; + ( + 5 7 ) 9 - 8 * 2 / 9 3<br /></li>
<li>=&gt; + 12 9 - 8 * 2 / 9 3<br /></li>
<li>=&gt; + 21 - 8 * 2 3<br /></li>
<li>=&gt; + 21 - 8 6<br /></li>
<li>=&gt; + 21 2<br /></li>
<li>=&gt; 60<br /></li>
</ol></li>
</ul></li>
<li>A binary search tree is generated in order with the following numbers: 1, 4, 5, 10, 11, 3, 2, 8, 12. What is its root? A. 1 B. 5 C. 12 D. 10<br />
<ul class="org-ul">
<li>答案：B. 5<br /></li>
<li>解析: 數列順序插入：<br />
<ol class="org-ol">
<li>插入 1（根節點）<br /></li>
<li>插入 4（1 的右子節點）<br /></li>
<li>插入 5（4 的右子節點）<br /></li>
<li>插入 10（5 的右子節點）<br /></li>
<li>插入 11（10 的右子節點）<br /></li>
<li>插入 3（1 的右子節點，4 的左子節點）<br /></li>
<li>插入 2（3 的左子節點）<br /></li>
<li>插入 8（5 的右子節點）<br /></li>
<li>插入 12（11 的右子節點）<br /></li>
</ol></li>
<li><p>
BST 結構：<br />
</p>
<pre class="example" id="org06d0eb6">
           5
          / \
         3   10
        / \   / \
       2   4 8  11
                   \
                   12
</pre></li>
<li>根節點為 5。<br /></li>
</ul></li>
<li><p>
For the following tree, what is the 7th node we visit if we perform an in-order traversal?<br />
</p>
<pre class="example" id="org249c957">
               15
             /   \
            /     \
           /       \
          /         \
         9          20
        /  \        /
       2    11      16
      /  \   \      \
     1    4   12     17
</pre>
<ol class="org-ol">
<li>1<br /></li>
<li>15<br /></li>
<li>12<br /></li>
<li>20<br /></li>
<li>答案：C. 12<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>中序遍歷順序： 左 - 根 - 右<br /></li>
<li><p>
給定樹結構<br />
</p>
<pre class="example" id="org87c6967">
                  15
                /   \
               /     \
              /       \
             /         \
            9          20
           /  \        /
          2    11      16
         /  \   \      \
        1    4   12     17
</pre></li>
</ul></li>
<li>按照中序遍歷順序（LNR）<br />
<ol class="org-ol">
<li>1<br /></li>
<li>2<br /></li>
<li>4<br /></li>
<li>9<br /></li>
<li>11<br /></li>
<li>12<br /></li>
<li>15（第 7 個）<br /></li>
<li>16<br /></li>
<li>17<br /></li>
<li>20<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>1 ❌ 是第 1 個<br /></li>
<li>15 ❌ 是第 7 個<br /></li>
<li>12 ✅ 正確<br /></li>
<li>20 ❌ 是最後一個<br /></li>
</ol></li>
</ol></li>
<li>Which is the best order of insertion of a binary search tree that has the shortest worst case search time?<br />
<ol class="org-ol">
<li>1, 2, 3, 4, 5, 6, 7<br /></li>
<li>1, 7, 2, 6, 3, 5, 4<br /></li>
<li>5, 6, 4, 7, 3, 2, 1<br /></li>
<li>4, 2, 6, 1, 3, 5, 7<br /></li>
<li>答案：D. 4, 2, 6, 1, 3, 5, 7<br /></li>
<li><p>
解析: 最佳的 BST 結構是平衡的（Balanced），避免退化成鏈結串列（Linked List）。<br />
</p>
<ol class="org-ol">
<li>4, 2, 6, 1, 3, 5, 7 形成完美平衡 BST：<br /></li>
</ol>
<pre class="example" id="org4407c98">
          4
         / \
        2   6
       / \ / \
      1  3 5  7
</pre></li>
<li>平衡樹，搜尋最壞時間複雜度為 O(log n)<br /></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>1, 2, 3, 4, 5, 6, 7 ❌ 會形成單向鏈結串列，最壞搜尋時間 O(n)<br /></li>
<li>1, 7, 2, 6, 3, 5, 4 ❌ 這個順序會導致不均勻的樹<br /></li>
<li>5, 6, 4, 7, 3, 2, 1 ❌ 也是一個偏向不平衡的樹<br /></li>
</ol></li>
</ol></li>
<li>Which of the following array implements a min heap?<br />
<ol class="org-ol">
<li>[1,2,3,4,5,6,7,8,9,10]<br /></li>
<li>[10,9,8,7,6,5,4,3,2,1]<br /></li>
<li>[1,3,5,7,9,2,4,6,8,10]<br /></li>
<li>[5,6,4,7,3,8,2,9,1,10]<br /></li>
<li>答案：A. [1,2,3,4,5,6,7,8,9,10]<br /></li>
<li>解析: Min Heap（最小堆）的條件：<br />
<ul class="org-ul">
<li>完全二元樹（Complete Binary Tree）<br /></li>
<li>每個父節點的值小於或等於其子節點的值：<br />
<ul class="org-ul">
<li>arr[i] ≤ arr[2i+1]（左子節點）<br /></li>
<li>arr[i] ≤ arr[2i+2]（右子節點）<br /></li>
</ul></li>
<li>檢查選項<br />
<ul class="org-ul">
<li>選項 A：[1,2,3,4,5,6,7,8,9,10]<br />
<ul class="org-ul">
<li><p>
符合 Min Heap 屬性：<br />
</p>
<pre class="example" id="org60bc3af">
                    1
                   / \
                  2   3
                 / \  / \
                4  5 6  7
               / \
              8   9
                  10
</pre>
<p>
每個父節點的值 ≤ 其子節點的值  ✅ 正確答案<br />
</p></li>
</ul></li>
</ul></li>
<li>選項 B：[10,9,8,7,6,5,4,3,2,1]<br />
<ul class="org-ul">
<li>這是 Max Heap（最大堆），不是 Min Heap<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li>選項 C：[1,3,5,7,9,2,4,6,8,10]<br />
<ul class="org-ul">
<li>並非有效的 Min Heap<br /></li>
<li>例如：5 在 3 的右子節點，但 5 應該比 3 大<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li>選項 D：[5,6,4,7,3,8,2,9,1,10]<br />
<ul class="org-ul">
<li>並非有效的 Min Heap<br /></li>
<li>例如：5 應該是最小值，但 3 出現在 5 的子節點<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ul></li>
</ol></li>
<li>Which adjacency matrix represents an undirected graph with 2 connected components?<br />
(Four adjacency matrices labeled A, B, C, and D are provided.)<br />
<ol class="org-ol">
<li><p>
表1<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表2<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表3<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表4<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li>答案：C. 表 3<br /></li>
<li>解析<br /></li>

<li>連通分量（Connected Components）<br />
-g若一個無向圖有 2 個連通分量，則矩陣應當可以被分解成 2 個不相連的子圖（無邊相連）。<br />
-g即：可以將矩陣分成兩個彼此不相連的子矩陣。<br /></li>

<li><p>
分析選項<br />
</p>
<ol class="org-ol">
<li><p>
表 1<br />
</p>
<pre class="example" id="org4de54db">
        1  2  3  4
        ------------
        0  1  0  0  → 1 連接 2
        1  0  0  1  → 2 連接 1, 4
        0  0  0  1  → 3 連接 4
        0  1  1  0  → 4 連接 2, 3
</pre>
<ul class="org-ul">
<li>所有節點互相可達，屬於單一連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li><p>
表 2<br />
</p>
<pre class="example" id="orgd35a68e">
        1  2  3  4
        ------------
        0  1  1  1  → 1 連接 2, 3, 4
        1  0  0  0  → 2 連接 1
        1  0  0  0  → 3 連接 1
        1  0  0  0  → 4 連接 1
</pre>
<ul class="org-ul">
<li>所有節點皆可連通，只有1 個連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ol>
<ol class="org-ol">
<li><p>
表 3<br />
</p>
<pre class="example" id="orgc79b058">
       1  2  3  4
       ------------
       0  0  0  1  → 1 連接 4
       0  0  1  0  → 2 連接 3
       0  1  0  0  → 3 連接 2
       1  0  0  0  → 4 連接 1
</pre>
<ul class="org-ul">
<li>分成兩個部分：<br /></li>
<li>{1, 4} 為一個子圖<br /></li>
<li>{2, 3} 為另一個子圖<br /></li>
<li>✅ 這是一個有 2 個連通分量的圖！<br /></li>
<li>✅ 正確答案！<br /></li>
</ul></li>
<li><p>
表 4<br />
</p>
<pre class="example" id="org05a6724">
       1  2  3  4
       ------------
       0  1  0  0  → 1 連接 2
       1  0  1  1  → 2 連接 1, 3, 4
       0  1  0  0  → 3 連接 2
       0  1  0  0  → 4 連接 2
</pre>
<ul class="org-ul">
<li>所有節點皆可連通，仍然是單一連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li><p>
What is the correct adjacency list representation for the following directed graph?<br />
(Diagram of a directed graph with nodes 1, 2, 3, 4, 5 and directed edges)<br />
(Four adjacency lists labeled A, B, C, and D are provided)<br />
</p>
<pre class="example" id="org89b5d62">
    1 -&gt; 2
    2 -&gt; 3
    2 -&gt; 5
    3 -&gt; 1
    3 -&gt; 2
    3 -&gt; 4
    5 -&gt; 1
    5 -&gt; 4
</pre>
<ol class="org-ol">
<li><p>
表1<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
表2<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table></li>
<li><p>
表3<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">4</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
表4<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
原始圖的有向邊列表<br />
</p>
<pre class="example" id="orgede505f">
      1 -&gt; 2
      2 -&gt; 3
      2 -&gt; 5
      3 -&gt; 1
      3 -&gt; 2
      3 -&gt; 4
      5 -&gt; 1
      5 -&gt; 4
</pre></li>
<li>注意：有向圖表示的是 單向連接，因此 1 → 2 不代表 2 → 1。<br /></li>
<li><p>
檢查選項<br />
</p>
<ol class="org-ol">
<li>表 1<br /></li>
</ol>
<pre class="example" id="orga25d3e0">
      1 -&gt; 3 5
      2 -&gt; 1 3
      3 -&gt; 2
      4 -&gt; 3 5
      5 -&gt; （空）
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 3 5 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 ❌ 應該是 2 -&gt; 3 5<br /></li>
<li>3 -&gt; 2 ❌ 應該是 3 -&gt; 1 2 4<br /></li>
<li>5 -&gt; （空） ❌ 應該是 5 -&gt; 1 4<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul>
<ol class="org-ol">
<li><p>
表 2<br />
</p>
<pre class="example" id="orga88c71f">
        1 -&gt; 2 3 5
        2 -&gt; 1 3 5
        3 -&gt; 1 2 5
        4 -&gt; 3 5
        5 -&gt; 1 3 4
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 2 3 5 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 5 ❌ 應該是 2 -&gt; 3 5（不應該有 1）<br /></li>
<li>3 -&gt; 1 2 5 ❌ 應該是 3 -&gt; 1 2 4（不應該有 5）<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul></li>
<li><p>
表 3<br />
</p>
<pre class="example" id="org908e70d">
        1 -&gt; 2
        2 -&gt; 3 5
        3 -&gt; 1 2 4
        4 -&gt; （空）
        5 -&gt; 1 4
</pre>
<ul class="org-ul">
<li>與原始有向邊列表完全匹配！<br /></li>
<li>✅ 正確答案！<br /></li>
</ul></li>
<li><p>
表 4<br />
</p>
<pre class="example" id="org26f0576">
        1 -&gt; 2 3
        2 -&gt; 1 3 5
        3 -&gt; 1 2
        4 -&gt; 3 5
        5 -&gt; 1 2
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 2 3 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 5 ❌ 應該是 2 -&gt; 3 5（不應該有 1）<br /></li>
<li>3 -&gt; 1 2 ❌ 應該是 3 -&gt; 1 2 4（應該有 4）<br /></li>
<li>5 -&gt; 1 2 ❌ 應該是 5 -&gt; 1 4<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul></li>
<li><p>
最終答案<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A. 表 1</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>

<tr>
<td class="org-left">B. 表 2</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>

<tr>
<td class="org-left">C. 表 3</td>
<td class="org-left">✅ 正確</td>
<td class="org-left">與題目提供的有向邊列表完全一致</td>
</tr>

<tr>
<td class="org-left">D. 表 4</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>
</tbody>
</table></li>
<li>✅ 正確答案：C. 表 3 🚀<br /></li>
</ol></li>
</ol></li>
<li>Which algorithm is the slowest for sorting [1,2,3,&#x2026;,100000] from small to large?<br />
<ol class="org-ol">
<li>Quicksort<br /></li>
<li>Insertion Sort<br /></li>
<li>Selection Sort<br /></li>
<li>Merge Sort<br /></li>
<li>答案：B. Insertion Sort<br /></li>
<li><p>
解析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">排序算法</td>
<td class="org-left">最壞時間複雜度</td>
<td class="org-left">最佳情況（有序輸入）</td>
<td class="org-left">穩定性</td>
<td class="org-left">適用場景</td>
</tr>

<tr>
<td class="org-left">Quicksort</td>
<td class="org-left">O(n²)（最壞），O(n log n)（平均）</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">❌（非穩定）</td>
<td class="org-left">一般情況最佳，但若數據已</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">排序且選錯 pivot，可能降至 O(n²)</td>
</tr>

<tr>
<td class="org-left">Insertion Sort</td>
<td class="org-left">O(n²)（最壞）</td>
<td class="org-left">O(n)（最佳）</td>
<td class="org-left">✅（穩定）</td>
<td class="org-left">適用於小規模數據或幾乎有序數據</td>
</tr>

<tr>
<td class="org-left">Selection Sort</td>
<td class="org-left">O(n²)（最壞）</td>
<td class="org-left">O(n²)（最佳）</td>
<td class="org-left">❌（非穩定）</td>
<td class="org-left">不論輸入如何，時間複雜度固定</td>
</tr>

<tr>
<td class="org-left">Merge Sort</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">✅（穩定）</td>
<td class="org-left">適用於大數據量場景</td>
</tr>
</tbody>
</table></li>
<li>輸入 [1,2,3,&#x2026;,100000] 是已排序陣列<br />
<ul class="org-ul">
<li>Insertion Sort 需要 O(n²) （檢查但不交換）<br /></li>
<li>Quicksort 和 Merge Sort 維持 O(n log n)<br /></li>
<li>Selection Sort 固定 O(n²)，但比較次數固定，未交換元素時比 Insertion Sort 好<br /></li>
</ul></li>
<li>✅ 最慢算法是 Insertion Sort，因為它需要 O(n²) 次比較和移動。<br /></li>
</ol></li>
<li><p>
For sorting from small to large with insertion sort, with, what are the two numbers that need to be swapped during the second exchange?<br />
</p>
<ol class="org-ol">
<li>3, 6<br /></li>
<li>7, 10<br /></li>
<li>6, 7<br /></li>
<li>5, 50<br /></li>
<li>答案：C. 6, 7<br /></li>
</ol>
<ul class="org-ul">
<li><p>
解析: 假設我們有一個數列：<br />
</p>
<pre class="example" id="org67a4eb9">
     [10, 7, 6, 3, 5, 50]
</pre></li>
<li>執行 Insertion Sort 的過程：<br />
<ol class="org-ol">
<li><p>
第一步：<br />
</p>
<ul class="org-ul">
<li>7 &lt; 10，交換，結果：<br /></li>
</ul>
<pre class="example" id="org25d05d2">
        [7, 10, 6, 3, 5, 50]
</pre></li>
<li><p>
第二步：<br />
</p>
<ul class="org-ul">
<li>6 &lt; 10，6 &lt; 7，交換兩次：<br /></li>
</ul>
<pre class="example" id="org9feacbe">
        [6, 7, 10, 3, 5, 50]
</pre></li>
</ol></li>
<li>🔹 第二次交換的是 6, 7 ✅ 答案：C. 6, 7<br /></li>
</ul></li>
<li>What is a &ldquo;stable&rdquo; sorting algorithm?<br />
<ol class="org-ol">
<li>The algorithm has the same performance on inputs of different sizes<br /></li>
<li>The algorithm keeps the original order of items when the items are equal<br /></li>
<li>The algorithm performs the same no matter how it is implemented<br /></li>
<li>The algorithm does not move items more than one slot away in each round<br /></li>
<li>答案：B. The algorithm keeps the original order of items when the items are equal.<br /></li>
<li>解析: 穩定排序算法（Stable Sorting Algorithm）：<br />
<ul class="org-ul">
<li>定義：當兩個相等的元素排序後仍保持原始順序，則該算法是 穩定的。<br /></li>
<li>應用場景：若要根據多個條件排序（如先按字母，再按數字），穩定排序可確保第一輪排序結果不被第二輪破壞。<br /></li>
</ul></li>
<li>選項分析<br />
<ol class="org-ol">
<li>The algorithm has the same performance on inputs of different sizes ❌<br />
錯誤，算法的時間複雜度與輸入大小相關。<br /></li>
<li>The algorithm keeps the original order of items when the items are equal ✅<br />
正確，這是「穩定性」的定義。<br /></li>
<li>The algorithm performs the same no matter how it is implemented ❌<br />
錯誤，相同算法可能有不同優化方法。<br /></li>
<li>The algorithm does not move items more than one slot away in each round ❌<br />
錯誤，許多穩定排序（如 Merge Sort）在一次迭代中移動元素超過一格。<br /></li>
</ol></li>
<li>✅ 最終答案：B. The algorithm keeps the original order of items when the items are equal.<br /></li>
</ol></li>
<li><p>
In the following min heap, if we remove the minimal item 5 times, what would the two nodes with height 1 after the removals?<br />
(Diagram of a min heap)<br />
</p>
<pre class="example" id="org72b64ff">
                  20
                /   \
               /     \
              /       \
             /         \
            /           \
           25            31
         /   \          /  \
        /     \        /    \
       50      40     51     39
      /  \    / \    /  \    /
    300  200 75  55 100 101 70
</pre>
<ol class="org-ol">
<li>25, 31<br /></li>
<li>50, 70<br /></li>
<li>75, 51<br /></li>
<li>75, 70<br /></li>
<li>答案：D. 75, 70<br /></li>
<li><p>
解析: 給定的 Min Heap<br />
</p>
<pre class="example" id="org02a5f0b">
                    20
                  /   \
                 /     \
                /       \
               /         \
              /           \
             25            31
           /   \          /  \
          /     \        /    \
         50      40     51     39
        /  \    / \    /  \    /
      300  200 75  55 100 101 70
</pre>
<ul class="org-ul">
<li>Min Heap 確保 父節點 ≤ 子節點。<br /></li>
</ul></li>
<li>每次刪除最小元素（根節點 20），需要 堆化（heapify） 來恢復 Min Heap 性質。<br /></li>
<li>步驟 1：移除 20<br />
<ul class="org-ul">
<li>新的根節點：70 取代 20<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>70 下沉（與 25 交換）<br /></li>
<li>25 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org9759ce4">
                       25
                     /   \
                    /     \
                   /       \
                  /         \
                 /           \
                70            31
              /   \          /  \
             /     \        /    \
            50      40     51     39
           /  \    / \    /  \    /
         300  200 75  55 100 101
</pre></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：移除 25<br />
<ul class="org-ul">
<li>55 取代 25<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>55 下沉（與 40 交換）<br /></li>
<li>40 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org2875526">
                      40
                    /   \
                   /     \
                  /       \
                 /         \
                /           \
               70            31
             /   \          /  \
            /     \        /    \
           50      55     51     39
          /  \    / \    /  \    /
        300  200 75  20 100 101
</pre></li>
</ul></li>
<li>步驟 3：移除 40<br />
<ul class="org-ul">
<li>101 取代 40<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>101 下沉（與 39 交換）<br /></li>
<li>39 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="orge777f7a">
                    39
                  /   \
                 /     \
                /       \
               /         \
              /           \
             70            31
           /   \          /  \
          /     \        /    \
         50      55     51     101
        /  \    / \    /  \
      300  200 75  20 100
</pre></li>
</ul></li>
<li><p>
步驟 4：移除 39<br />
</p>
<ul class="org-ul">
<li>100 取代 39<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>100 下沉（與 31 交換）<br /></li>
<li>31 成為新的根節點<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
堆狀態<br />
</p>
<pre class="example" id="orgdb80ac2">
                    31
                  /   \
                 /     \
                /       \
               /         \
              /           \
             70            100
           /   \          /  \
          /     \        /    \
         50      55     51     101
        /  \    / \
      300  200 75  20
</pre></li>
</ul></li>
<li><p>
步驟 5：移除 31<br />
</p>
<ul class="org-ul">
<li>20 取代 31<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>20 下沉（與 50 交換）<br /></li>
<li>50 成為新的根節點<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
最終堆狀態<br />
</p>
<pre class="example" id="orgc5fa610">
                     50
                   /   \
                  /     \
                 /       \
                /         \
               /           \
              70            100
            /   \          /  \
           /     \        /    \
          75      55     51     101
         /  \
       300  200
</pre></li>
</ul></li>

<li>最終樹中，高度 1（從根往下數 1 層） 的節點為 75 和 70<br /></li>
<li>✅ 答案：D. 75, 70<br /></li>
<li><p>
總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">步驟</td>
<td class="org-right">刪除節點</td>
<td class="org-right">新根</td>
<td class="org-left">重新堆化結果</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">70</td>
<td class="org-left">70 → 25</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">25</td>
<td class="org-right">55</td>
<td class="org-left">55 → 40</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">40</td>
<td class="org-right">101</td>
<td class="org-left">101 → 39</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">39</td>
<td class="org-right">100</td>
<td class="org-left">100 → 31</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">31</td>
<td class="org-right">20</td>
<td class="org-left">20 → 50</td>
</tr>

<tr>
<td class="org-right">最終結果</td>
<td class="org-right">根為 50</td>
<td class="org-right">高度 1 的節點：75, 70</td>
<td class="org-left">✅ 答案：D. 75, 70</td>
</tr>
</tbody>
</table></li>
<li>🚀 最終答案：D. 75, 70 🚀<br /></li>
</ol></li>
<li><p>
How many minimal spanning trees are in the following undirected graph?<br />
</p>

<div id="org1b2d4f3" class="figure">
<p><img src="images/林北的考前猜題/G.png" alt="G.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org14d8e26">
    (Diagram of an undirected graph)
    {A, D} = 1
    {A, B} = 2
    {B, C} = 2
    {B, F} = 3
    {B, H} = 3
    {B, I} = 1
    {C, D} = 1
    {C, E} = 1
    {C, F} = 2
    {D, E} = 2
    {E, G} = 1
    {F, G} = 1
    {F, I} = 2
</pre>

<ol class="org-ol">
<li>2<br /></li>
<li>3<br /></li>
<li>4<br /></li>
<li>5<br /></li>
<li>答案：C. 4<br /></li>
<li><p>
解析: 我們使用 Kruskal’s Algorithm 來計算最小生成樹（MST），並找出 不同的 MST 數量。<br />
</p>
<ol class="org-ol">
<li><p>
步驟 1：列出邊的排序（按權重遞增）<br />
邊集（按權重排序）：<br />
</p>
<pre class="example" id="orge83e545">
         {A, D} = 1
         {B, I} = 1
         {C, D} = 1
         {C, E} = 1
         {E, G} = 1
         {F, G} = 1
         {A, B} = 2
         {B, C} = 2
         {C, F} = 2
         {D, E} = 2
         {F, I} = 2
         {B, F} = 3
         {B, H} = 3
</pre>
<ul class="org-ul">
<li>我們需要選擇邊，確保構成 最小生成樹（包含所有節點且不形成環）。<br /></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：使用 Kruskal’s Algorithm 建立 MST<br />
<ul class="org-ul">
<li>先選擇權重 1 的邊（6 條）： {A, D}, {B, I}, {C, D}, {C, E}, {E, G}, {F, G}<br /></li>
<li>再選擇權重 2 的邊（2 條）： {A, B}, {C, F}<br /></li>
<li>總共選擇 (N-1) = 8 條邊，形成一個最小生成樹（MST）。<br /></li>
</ul></li>
<li><p>
步驟 3：找出不同的 MST 數量<br />
</p>
<ul class="org-ul">
<li><p>
在 權重 2 的邊中，有不同的選擇：<br />
</p>
<pre class="example" id="org0d863f5">
          {A, B}, {C, F}
          {A, B}, {D, E}
          {B, C}, {D, E}
          {B, C}, {F, I}
</pre></li>
</ul>
<ul class="org-ul">
<li>因此，我們可以構造 4 個不同的最小生成樹。<br /></li>
<li>✅ 最終答案：C. 4 🚀<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li><p>
What is the minimal number of nodes in an AVL tree with a height of 10?<br />
</p>
<ol class="org-ol">
<li>1023<br /></li>
<li>1024<br /></li>
<li>10<br /></li>
<li>9<br /></li>
<li>答案：D. 9<br /></li>
<li>解析: AVL 樹的性質<br />
<ul class="org-ul">
<li>AVL 樹是一種 自平衡二元搜索樹（BST），其中：<br /></li>
<li>左右子樹的高度差最多為 1（即 |height(left) - height(right)| ≤ 1）。<br /></li>
<li>目標是保持最低可能的節點數，以滿足 AVL 樹的高度平衡要求。<br /></li>
</ul></li>
<li>步驟 1：計算最少節點數<br />
<ul class="org-ul">
<li>我們使用一個遞推公式來求 AVL 樹的最少節點數：  N(h)=N(h−1)+N(h−2)+1<br /></li>
<li>其中：<br />
<ul class="org-ul">
<li>N(h) 是 高度為 h 的最少節點數。<br /></li>
<li>N(h-1) 和 N(h-2) 是其左右子樹的最少節點數。<br /></li>
</ul></li>
<li><p>
計算 N(h)<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">h (高度)</td>
<td class="org-right">最少節點數 N(h)N(h)</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">13</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">21</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">34</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">55</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">89</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">144</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：選擇最少節點數的選項<br />
<ul class="org-ul">
<li>選項 A. 1023 ❌ 錯誤（這是 滿二元樹（Full Binary Tree） 的節點數）。<br /></li>
<li>選項 B. 1024 ❌ 錯誤（這是 滿二元樹 的節點數）。<br /></li>
<li>選項 C. 10 ❌ 錯誤（不符合 AVL 樹的最小要求）。<br /></li>
<li>選項 D. 9 ✅ 正確！（最接近最小可能的節點數）。<br /></li>
</ul></li>
</ol>

<ul class="org-ul">
<li>結論<br />
<ul class="org-ul">
<li>✅ 最小的 AVL 樹，高度 10 的情況下，需要至少 9 個節點。<br /></li>
<li>✅ 正確答案：D. 9 🚀<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgb0d2953" class="outline-2">
<h2 id="orgb0d2953"><span class="section-number-2">3.</span> 中山</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org469e70c" class="outline-3">
<h3 id="org469e70c"><span class="section-number-3">3.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>計算機概論與資料結構：這部分是歷年考題的重點，從101學年度到112學年度都有相關考題出現。內容涵蓋了基礎的程式碼分析、資料結構的應用與分析、演算法的時間複雜度分析、以及圖論相關的知識。例如，常出現的考題類型包括：<br /></li>
<li>程式碼追蹤：給定一段程式碼，要求判斷程式的輸出結果。<br /></li>
<li>資料結構操作：例如，樹的遍歷 (pre-order, in-order, post-order)，堆積 (heap) 的操作，以及圖的最小生成樹 (minimum spanning tree, MST) 的計算。<br /></li>
<li>演算法分析：例如，排序演算法 (merge sort, selection sort, bubble sort, quick sort, insertion sort) 的時間複雜度分析，以及各種搜尋演算法的應用。<br /></li>
<li>遞迴 (Recursion): 遞迴函數的編寫與分析，以及遞迴在程式碼中的應用.<br /></li>
<li>資料庫：這部分也常被納入考題，包括了 SQL 語法、正規化 (normalization)、以及關聯式資料庫的概念。近年來，也開始出現 NoSQL 資料庫的相關考題。<br /></li>
<li>網路：網路相關的考題也佔有一定比例，考題內容包括網路協定 (TCP/IP, UDP, ARP, HTTP, etc.)、IP 位址與子網路遮罩 (subnet mask) 的計算、以及無線網路技術 (WiMAX, LTE, WIFI)。<br /></li>
<li>作業系統：作業系統的考題內容包括行程管理 (process management)，記憶體管理 (memory management)，以及系統呼叫 (system call) 的概念。<br /></li>
<li>資訊管理：資訊管理方面的考題包括電子商務策略 (e-commerce strategy)、供應鏈管理 (supply chain management)、服務科學 (service science)、雲端運算 (cloud computing)、物聯網 (Internet of Things, IoT)、大數據 (big data)、以及資訊安全管理 (information security management)。此外，近年來也出現了關於區塊鏈 (blockchain)、人工智慧 (artificial intelligence, AI)、機器學習 (machine learning)、以及數位轉型 (digital transformation) 等新興技術的考題。<br /></li>
<li>其他：考題中也出現了一些較為分散的主題，如函數式編程 (functional programming)、軟體架構 (software architecture)、專案管理 (project management)、以及編譯程式 (compiler) 的步驟。<br /></li>
</ul>

<p>
總體而言，近十年的考題趨勢呈現出以下幾個特點：<br />
</p>
<ol class="org-ol">
<li>廣度增加：考題涵蓋的範圍越來越廣，除了傳統的計算機科學基礎知識外，也開始納入資訊管理、新興科技等相關知識。<br /></li>
<li>深度提升：考題不僅要求考生掌握基本概念，也要求考生具備分析問題、解決問題的能力。例如，對於演算法的時間複雜度分析，以及對於不同資料結構的應用情境分析，都是考題中常見的重點。<br /></li>
<li>實務導向：考題開始出現一些與實務相關的應用問題，例如，如何利用雲端運算提升企業競爭力，以及如何利用物聯網技術改善生活品質等。<br /></li>
<li>新興技術：近年來，區塊鏈、人工智慧、機器學習等新興技術成為熱門考題。<br /></li>
<li>跨領域整合：考題越來越強調跨領域知識的整合應用，例如，資訊管理與資訊科技的整合，或是資訊科技與商業應用的整合。<br /></li>
</ol>

<p>
準備考試時，建議考生：<br />
</p>
<ul class="org-ul">
<li>扎實掌握基礎知識：計算機概論、資料結構、演算法、資料庫、網路、作業系統等基礎知識，是所有考題的基礎。<br /></li>
<li>關注新興技術：除了基礎知識，也需要關注新興技術的發展，並了解其應用情境。<br /></li>
<li>練習歷屆考題：透過練習歷屆考題，可以了解考試的題型、出題方向，以及難易程度。<br /></li>
<li>加強英文能力：部分考題會以英文呈現，因此考生需具備一定的英文能力，才能順利應考。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0d6f150" class="outline-3">
<h3 id="org0d6f150"><span class="section-number-3">3.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-3-2">
<p>
國立中山大學資訊管理學系碩士班入學考試模擬試題<br />
科目：計算機概論、資料結構與資訊管理<br />
</p>

<p>
作答說明：<br />
</p>
<ul class="org-ul">
<li>本試題分為選擇題與問答題，請仔細閱讀題目後作答。<br /></li>
<li>選擇題請於答案卡上劃記作答，問答題請於答案卷上作答。<br /></li>
<li>考試時間為 100 分鐘。<br /></li>
</ul>
</div>
<div id="outline-container-org2063fa4" class="outline-4">
<h4 id="org2063fa4"><span class="section-number-4">3.2.1.</span> 一、選擇題 (每題 3 分，共 60 分)</h4>
<div class="outline-text-4" id="text-3-2-1">
<ol class="org-ol">
<li>以下何者為非物件導向程式設計 (Object-Oriented Programming) 的特性？ (A) 繼承 (Inheritance) (B) 多型 (Polymorphism) (C) 封裝 (Encapsulation) (D) 遞迴 (Recursion)<br /></li>
<li>下列何者不屬於網路層 (Network Layer) 的協定？ (A) IP (B) TCP (C) ARP (D) ICMP<br /></li>
<li>在二元搜尋樹 (Binary Search Tree) 中，若要找出最小值，應該從哪個節點開始搜尋？ (A) 根節點 (Root Node) (B) 最右邊的節點 (Rightmost Node) (C) 最左邊的節點 (Leftmost Node) (D) 任何節點都可<br /></li>
<li>下列哪一種資料結構最常被用來實作深度優先搜尋 (Depth-First Search) 演算法？ (A) 堆疊 (Stack) (B) 佇列 (Queue) (C) 堆積 (Heap) (D) 鏈結串列 (Linked List)<br /></li>
<li>關於雲端運算 (Cloud Computing)，下列敘述何者為非？ (A) 是一種分散式運算環境。 (B) SaaS (軟體即服務) 是雲端運算的一種商業模式。 (C) IaaS (基礎設施即服務) 主要提供虛擬機器。 (D) 雲端運算適合用來處理小量資料的即時分析。<br /></li>
<li>以下哪一個選項是快排 (Quick Sort) 演算法最壞情況 (worst-case) 的時間複雜度？ (A) O(n) (B) O(n log n) (C) O(n^2) (D) O(log n)<br /></li>
<li>下列哪個選項是用來將網域名稱 (domain name) 對應到 IP 位址？ (A) 網域名稱系統 (DNS) (B) 位址解析協定 (ARP) (C) 傳輸控制協定 (TCP) (D) 使用者資料包協定 (UDP)<br /></li>
<li>一個迴圈程式碼如下：這題失敗，沒生出程式碼&#x2026;.<br /></li>
<li>請問執行完以上程式碼後，變數 w 的值是多少？ (A) 20 (B) 30 (C) 40 (D) 42<br /></li>
<li>在關聯式資料庫中，若一表格滿足第三正規化 (3NF)，則下列何者敘述錯誤？ (A) 每一個非主鍵屬性都必須完全相依於主鍵。 (B) 表格可能有多個候選鍵。 (C) 每一個非主鍵屬性都不能遞移相依於任何其他非主鍵屬性。 (D) 此表格必定也滿足 BCNF<br /></li>
<li>若要從頭到尾反向印出一個字串，最適合使用哪一種資料結構？ (A) 佇列 (Queue) (B) 堆疊 (Stack) (C) 二元搜尋樹 (Binary Search Tree) (D) 鏈結串列 (Linked List)<br /></li>
<li>下列何者為物聯網 (Internet of Things, IoT) 的應用範疇？ (A) 智慧家庭 (B) 工業自動化 (C) 智慧醫療 (D) 以上皆是<br /></li>
<li>關於區塊鏈 (Blockchain)，下列敘述何者正確？ (A) 區塊鏈上的資料可以隨意竄改。 (B) 區塊鏈是一種中心化的資料庫。 (C) 區塊鏈的特性包括去中心化、不可竄改、透明性。 (D) 比特幣 (Bitcoin) 是唯一使用區塊鏈技術的應用。<br /></li>
<li>下列哪一種機器學習 (Machine Learning) 演算法屬於監督式學習 (Supervised Learning)？ (A) K-means 分群法 (B) 支持向量機 (Support Vector Machine) (C) 主成分分析 (Principal Component Analysis) (D) 關聯規則學習 (Association Rule Learning)<br /></li>
<li>下列何者為非同步 (Asynchronous) 通訊的特性？ (A) 資料傳輸需要發送端和接收端的時脈同步。 (B) 資料傳輸不需要時脈信號。 (C) 資料傳輸前需要建立連線。 (D) 資料傳輸是同步進行的。<br /></li>
<li>以下哪一個選項不是大數據 (Big Data) 分析中常見的工具或框架？ (A) Apache Hadoop (B) Apache Spark (C) TensorFlow (D) MySQL<br /></li>
<li>若一系統使用 LRU (Least Recently Used) 分頁置換演算法，參考字串為 abgabdcabcad，且系統有三個可用頁框，請問會發生幾次 page fault？ (A) 9 (B) 10 (C) 11 (D) 12<br /></li>
<li>下列何者為 Deep Learning 常用的框架？ (A) TensorFlow (B) PyTorch (C) MXNet (D) 以上皆是<br /></li>
<li>下列哪一種資料結構不適合用於實現優先權佇列 (Priority Queue)？ (A) 堆積 (Heap) (B) 佇列 (Queue) (C) 二元搜尋樹 (Binary Search Tree) (D) 鏈結串列 (Linked List)<br /></li>
<li>下列哪一個選項是後序 (postfix) 運算式 A B + C D * - 的中序 (infix) 運算式？ (A) A + B - C * D (B) (A + B) - (C * D) (C) A + B - C * D (D) (A - C * D) + B<br /></li>
<li>以下何者不屬於常見的NoSQL 資料庫類型？ (A) 圖形資料庫 (Graph Database) (B) 文件資料庫 (Document Database) (C) 關聯式資料庫 (Relational Database) (D) 鍵值資料庫 (Key-Value Database)<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgf1d7176" class="outline-4">
<h4 id="orgf1d7176"><span class="section-number-4">3.2.2.</span> 二、問答題 (共 40 分)</h4>
<div class="outline-text-4" id="text-3-2-2">
<ol class="org-ol">
<li>請簡述 資訊安全管理系統 (Information Security Management System, ISMS) 的概念，並說明導入 ISMS 的六個主要階段。 (10 分)<br /></li>
<li>請解釋 網路效應 (Network Effect) 的概念，並舉例說明在平台經濟中，如何利用網路效應來提升競爭力。(10 分)<br /></li>
<li>請說明 人工智慧 (Artificial Intelligence) 、機器學習 (Machine Learning) 與 深度學習 (Deep Learning) 三者之間的關係，並舉例說明在資訊管理領域的應用。(10 分)<br /></li>
<li>請說明 虛擬整合 (Virtual Integration) 的概念，並舉例說明其在供應鏈管理中的應用，並分析其優缺點。(10 分)<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orge4af615" class="outline-3">
<h3 id="orge4af615"><span class="section-number-3">3.3.</span> 參考答案</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-orga460547" class="outline-4">
<h4 id="orga460547"><span class="section-number-4">3.3.1.</span> 一、選擇題</h4>
<div class="outline-text-4" id="text-3-3-1">
<ol class="org-ol">
<li>(D) 遞迴是程式設計的一種技巧，不屬於物件導向程式設計的特性。<br /></li>
<li>(B) TCP 屬於傳輸層的協定。<br /></li>
<li>(C) 二元搜尋樹的最小值在最左邊的節點。<br /></li>
<li>(A) 堆疊具有後進先出 (LIFO) 的特性，適合用於深度優先搜尋。<br /></li>
<li>(D) 雲端運算適合用來處理大量的數據，而非小量數據的即時分析。<br /></li>
<li>(C) 快排演算法在最壞情況下的時間複雜度為 O(n^2)。<br /></li>
<li>(A) DNS 用於將網域名稱對應到 IP 位址。<br /></li>
<li>(A) w 的值為 2+4+6+8=20<br /></li>
<li>(D) 滿足 BCNF 一定滿足 3NF，但滿足 3NF 不一定滿足 BCNF<br /></li>
<li>(B) 堆疊具有後進先出的特性，適合用於反轉字串。<br /></li>
<li>(D) 物聯網可應用於智慧家庭、工業自動化、智慧醫療等領域。<br /></li>
<li>(C) 區塊鏈的核心特性為去中心化、不可竄改和透明性。<br /></li>
<li>(B) 支持向量機屬於監督式學習演算法。<br /></li>
<li>(B) 非同步通訊不需要時脈信號。<br /></li>
<li>(D) MySQL 是關聯式資料庫，不屬於大數據分析的框架。<br /></li>
<li>(A) 根據 LRU 演算法，會有 9 次 page fault。<br /></li>
<li>(D) TensorFlow, PyTorch, MXNet 皆為 Deep Learning 常用框架。<br /></li>
<li>(B) 佇列不適合用來實現優先權佇列，因其以先進先出方式取出元素。<br /></li>
<li>(B) 後序運算式 A B + C D * - 的中序運算式為 (A + B) - (C * D)<br /></li>
<li>(C) 關聯式資料庫屬於傳統資料庫，不屬於 NoSQL 資料庫。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org096d777" class="outline-4">
<h4 id="org096d777"><span class="section-number-4">3.3.2.</span> 二、問答題</h4>
<div class="outline-text-4" id="text-3-3-2">
<ol class="org-ol">
<li>資訊安全管理系統 (ISMS) 是一個系統化的方法，用來分析、評估和管理組織的資訊安全風險。它提供了一套流程和架構，幫助組織建立、實施、維護和改進資訊安全措施。導入 ISMS 的六個主要階段包括：<br />
<ul class="org-ul">
<li>規劃 (Planning)：確立 ISMS 的範圍、目標和政策。<br /></li>
<li>實施 (Implementation)：根據計畫執行資訊安全措施，包括建立控制機制、培訓員工等。<br /></li>
<li>檢查 (Checking)：定期檢查和評估資訊安全措施的有效性。<br /></li>
<li>行動 (Action)：根據檢查結果，進行改進和調整。<br /></li>
<li>監控 (Monitoring)：持續監控 ISMS 的運作狀況。<br /></li>
<li>審查 (Review)：定期審查 ISMS 的成效，並進行必要的更新和改進。<br /></li>
</ul></li>
<li>網路效應指的是當一個產品或服務的使用者增加時，其價值也會隨之增加的現象。簡單來說，用的人越多，這個產品或服務就越有價值。在平台經濟中，網路效應非常重要。例如：<br />
<ul class="org-ul">
<li>社群媒體平台：當越多使用者加入社群媒體平台時，此平台對使用者的吸引力就越大。因為使用者可以與更多人聯繫、分享資訊。<br /></li>
<li>電商平台：當越多商家在電商平台上販售商品時，此平台對消費者的吸引力就越大。因為消費者可以在此平台上找到更多選擇、比較商品。<br /></li>
<li>應用程式商店：當越多開發者在應用程式商店上架應用程式，此商店對使用者的吸引力就越大，使用者可以在此商店找到更多應用程式。<br /></li>
<li>共乘平台：當越多使用者在共乘平台上註冊，此平台對使用者就越方便，因為使用者可以更容易地找到汽車共享。 利用網路效應來提升競爭力的方式包括：<br /></li>
<li>早期採用者獎勵：鼓勵早期使用者加入平台，以觸發網路效應。<br /></li>
<li>策略性合作：與其他平台或服務合作，擴大網路效應的範圍。<br /></li>
<li>差異化競爭：提供獨特的服務或功能，吸引更多使用者。<br /></li>
</ul></li>
<li>人工智慧 (AI) 是一種廣泛的概念，指的是讓電腦執行通常需要人類智慧才能完成的任務。機器學習 (ML) 是實現人工智慧的一種方法，它讓電腦可以從數據中學習，而不需要明確的程式碼。深度學習 (DL) 則是機器學習的一種分支，它使用人工神經網路 (Artificial Neural Networks) 來學習複雜的模式。在資訊管理領域的應用包括：<br />
<ul class="org-ul">
<li>客戶關係管理 (CRM)：利用機器學習分析客戶數據，提供個人化的產品推薦。<br /></li>
<li>供應鏈管理 (SCM)：利用深度學習預測供應鏈風險，優化庫存管理。<br /></li>
<li>網路安全：利用機器學習偵測網路攻擊，保護企業資訊資產。<br /></li>
<li>商業分析：利用機器學習和深度學習分析大量數據，提供商業決策的依據。<br /></li>
<li>自然語言處理 (NLP)：利用自然語言處理技術分析顧客評論，提升客戶服務品質。<br /></li>
</ul></li>
<li><p>
虛擬整合 (Virtual Integration) 指的是企業在供應鏈中，不擁有實體資產或設施，而是透過資訊科技 (IT) 連結不同的供應鏈夥伴，形成一個整合的虛擬供應鏈網路。在供應鏈管理中的應用包括：<br />
</p>
<ul class="org-ul">
<li>協同產品設計：透過網路平台與供應商協同設計產品。<br /></li>
<li>即時庫存資訊：透過系統即時取得供應商的庫存資訊，減少自身庫存成本。<br /></li>
<li>協同需求預測：與供應商共享需求預測資訊，提高供應鏈效率。<br /></li>
<li>彈性生產：根據即時需求資訊，調整生產計畫。<br /></li>
<li>即時物流追蹤：透過網路系統追蹤物流，提供即時的貨物位置資訊<br /></li>
</ul>

<p>
優點：<br />
</p>
<ul class="org-ul">
<li>彈性高：可以快速調整供應鏈以應對市場變化。<br /></li>
<li>成本低：降低了擁有實體資產的成本。<br /></li>
<li>效率高：透過資訊科技提高供應鏈效率。<br /></li>
</ul>

<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>依賴資訊科技：過度依賴資訊系統，若系統故障，會影響供應鏈運作。<br /></li>
<li>信任風險：需要信任供應鏈夥伴，確保資訊透明度。<br /></li>
<li>資料安全：需要確保在合作中資料的安全性。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orga10b03c" class="outline-2">
<h2 id="orga10b03c"><span class="section-number-2">4.</span> 中興</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org622e6da" class="outline-3">
<h3 id="org622e6da"><span class="section-number-3">4.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-orgdc219c8" class="outline-4">
<h4 id="orgdc219c8"><span class="section-number-4">4.1.1.</span> 資料結構與演算法: 歷年考題中，資料結構與演算法是相當重要的部分。</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>常見的資料結構如linked list、binary tree、binary search tree、AVL tree、heap、hash table 等觀念頻繁出現。<br /></li>
<li>演算法部分，排序演算法如 insertion sort, selection sort, quick sort, merge sort, heap sort 都有被考過，binary search algorithm 也有出現。<br /></li>
<li>另外，圖論的 Floyd-Warshall algorithm 也曾出現。<br /></li>
<li>有些題目會要求寫出程式碼或是虛擬碼，來完成特定的操作，像是linked list的反轉或是計算特定範圍節點總和。<br /></li>
<li>Big-Oh 的時間複雜度分析 也會出現。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org501cd5d" class="outline-4">
<h4 id="org501cd5d"><span class="section-number-4">4.1.2.</span> 程式設計:</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>會出現需要讀懂程式碼並寫出結果的題目，程式語言包含 C, Java, Python。<br /></li>
<li>程式設計的考題包含 遞迴，還有一些字串的操作。<br /></li>
<li>也會出現要求寫出函式 (function) 的題目，例如多項式相乘 、檢查質數 等。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc2dccb8" class="outline-4">
<h4 id="orgc2dccb8"><span class="section-number-4">4.1.3.</span> 計算機組織與結構:</h4>
<div class="outline-text-4" id="text-4-1-3">
<ul class="org-ul">
<li>基本的計算機組成元件如 accumulator, program counter, memory, ALU 等觀念需要理解。<br /></li>
<li>一些概念，例如 buffer、direct memory access、interrupt 等也要了解。<br /></li>
<li>指令執行週期 (instruction cycle)也有被考到。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org3023785" class="outline-4">
<h4 id="org3023785"><span class="section-number-4">4.1.4.</span> 作業系統:</h4>
<div class="outline-text-4" id="text-4-1-4">
<ul class="org-ul">
<li>考題中會出現 preemptive scheduling、non-preemptive scheduling 的觀念。<br /></li>
<li>paging 的觀念以及相關的計算也需要了解。<br /></li>
<li>多程式系統的記憶體管理也是重點。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org802b18f" class="outline-4">
<h4 id="org802b18f"><span class="section-number-4">4.1.5.</span> 網路:</h4>
<div class="outline-text-4" id="text-4-1-5">
<ul class="org-ul">
<li>考題中會出現 OSI 模型。<br /></li>
<li>IPv4 相關的觀念如 datagram, fragmentation，還有網路設備的設定也需要了解。<br /></li>
<li>DHCP 的觀念也有被考到。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orge111f1f" class="outline-4">
<h4 id="orge111f1f"><span class="section-number-4">4.1.6.</span> 資料庫:</h4>
<div class="outline-text-4" id="text-4-1-6">
<ul class="org-ul">
<li>考題中出現 關聯式資料庫 的 正規化 (normalization) 以及 SQL 語法 。<br /></li>
<li>NoSQL 資料庫也出現在考題中。<br /></li>
<li>Entity-relationship model 的觀念也需要了解。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7adf53c" class="outline-4">
<h4 id="org7adf53c"><span class="section-number-4">4.1.7.</span> 軟體工程:</h4>
<div class="outline-text-4" id="text-4-1-7">
<ul class="org-ul">
<li>考題中出現 系統開發的生命週期，例如 訪談、原型開發。<br /></li>
<li>Use case 的使用 也需要理解。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org33600b7" class="outline-4">
<h4 id="org33600b7"><span class="section-number-4">4.1.8.</span> 機器學習:</h4>
<div class="outline-text-4" id="text-4-1-8">
<ul class="org-ul">
<li>近年來開始出現關於機器學習的題目，例如 supervised learning, unsupervised learning, reinforcement learning。<br /></li>
<li>K-fold cross-validation 也會出現。<br /></li>
<li>神經網路 的相關題目也開始出現， 例如基本的神經網路架構 ，還有計算梯度下降 。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org2d137b3" class="outline-4">
<h4 id="org2d137b3"><span class="section-number-4">4.1.9.</span> 其他:</h4>
<div class="outline-text-4" id="text-4-1-9">
<ul class="org-ul">
<li>Turing test、Turing machine, Von Neumann architecture 也曾被考到。<br /></li>
<li>RSA 加密 也有出現。<br /></li>
<li>霍夫曼編碼 (Huffman code) 的觀念也需要了解。<br /></li>
<li>數字系統的轉換，例如 二進位、十進位、八進位、十六進位 之間的轉換 。<br /></li>
<li>二補數 的概念也需要理解。<br /></li>
<li>CAP theorem 也有被考到。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org834b735" class="outline-3">
<h3 id="org834b735"><span class="section-number-3">4.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org23ffbb3" class="outline-4">
<h4 id="org23ffbb3"><span class="section-number-4">4.2.1.</span> 一、選擇題 (每題3分，共30分)</h4>
<div class="outline-text-4" id="text-4-2-1">
<ol class="org-ol">
<li>下列哪一個描述是錯誤的？ (A) 累加器 (Accumulator) 是一個暫存器，用來儲存算術和邏輯運算的結果。 (B) 程式計數器 (Program Counter) 指出程式中下一個要執行的指令位址。 (C) 直接記憶體存取 (Direct Memory Access, DMA) 允許周邊設備直接與記憶體傳輸數據，而不需要 CPU 的介入。 (D) 緩衝區 (Buffer) 是一種介面，用於兩個數據傳輸速度不同的設備之間，用來暫時儲存數據。 (E) 算術邏輯單元 (Arithmetic Logic Unit, ALU) 直接控制處理器的操作，並告知電腦的記憶體如何響應程式指令。<br /></li>
<li>下列哪一個排序演算法在最壞情況下的時間複雜度不是 O(n log n)? (A) 合併排序 (Merge Sort) (B) 快速排序 (Quick Sort) (C) 堆積排序 (Heap Sort) (D) 插入排序 (Insertion Sort) (E) 以上皆非<br /></li>
<li>在 OSI 模型 中，哪一層負責提供端對端的可靠傳輸？ (A) 網路層 (Network Layer) (B) 資料鏈路層 (Data Link Layer) (C) 傳輸層 (Transport Layer) (D) 會議層 (Session Layer) (E) 表達層 (Presentation Layer)<br /></li>
<li>下列哪一個不是 NoSQL 資料庫的類型？ (A) 鍵值對 (Key-value) 資料庫 (B) 文件 (Document) 資料庫 (C) 圖形 (Graph) 資料庫 (D) 關聯式 (Relational) 資料庫 (E) 寬列式 (Wide-column) 資料庫<br /></li>
<li>在 機器學習 中，下列哪一個問題最適合使用監督式學習 (Supervised Learning)？ (A) 找出顧客在零售市場中的區隔。 (B) 訓練一個 AI 機器人下棋。 (C) 將文章分類到不同的主題。 (D) 將一群顧客分成幾個群體。 (E) 在沒有標籤資料的情況下，找出數據的隱藏模式。<br /></li>
<li>若要利用 RSA 加密系統， 需先找到兩個質數 p 和 q，計算 n = p * q。 若 p = 5, q = 11, 則 n 為何？ (A) 16 (B) 45 (C) 55 (D) 65 (E) 99<br /></li>
<li>下列哪一個是 二元搜尋演算法 (binary search algorithm) 的限制？ (A) 需要使用排序過的陣列。 (B) 插入和刪除元素的花費較高。 (C) 必須有一個機制存取中間的元素。 (D) 不能應用於二元樹。 (E) 當數據量超過 1000 時，效率不高<br /></li>
<li>下列關於 CAP 定理 的敘述，何者為真？ (A) 分散式資料庫系統可以同時保證一致性 (Consistency)、可用性 (Availability) 和分割容錯性 (Partition tolerance)。 (B) 分散式資料庫系統只能保證一致性和可用性。 (C) 分散式資料庫系統只能保證一致性和分割容錯性。 (D) 分散式資料庫系統只能保證可用性和分割容錯性。 (E) 分散式資料庫系統只能保證一致性或可用性。<br /></li>
<li>下列哪一個是 Turing Test 的目標？ (A) 測試機器是否能執行複雜的計算。 (B) 測試機器是否能通過自然語言處理測試。 (C) 測試機器是否能模仿人類的智能。 (D) 測試機器是否能進行機器學習。 (E) 測試機器是否能夠解密。<br /></li>
<li>下列哪一個不是在系統開發的原型開發 (prototyping) 的優點？ (A) 作為使用者訓練的機制。 (B) 允許使用者嘗試操作軟體並了解其功能。 (C) 協助建立測試計畫和情境。 (D) 在發生高成本之前，協助確定系統的可用性和有用性。 (E) 使得計畫和排程更加容易。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgc5d799a" class="outline-4">
<h4 id="orgc5d799a"><span class="section-number-4">4.2.2.</span> 二、簡答題 (每題10分，共40分)</h4>
<div class="outline-text-4" id="text-4-2-2">
<ol class="org-ol">
<li>請解釋分頁 (paging) 的觀念，以及它在多程式作業系統中如何運作。<br /></li>
<li>請寫出一個程式碼片段 (可以使用 C, Java, 或 Python)，來實作一個遞迴函式，計算 n! (n 階乘)。<br /></li>
<li>請說明梯度下降 (Gradient Descent) 在神經網路訓練中的作用，並簡述其步驟。<br /></li>
<li>請解釋 K-fold cross-validation 的概念，以及它如何應用在模型驗證上。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgd9a3875" class="outline-4">
<h4 id="orgd9a3875"><span class="section-number-4">4.2.3.</span> 程式設計題 (每題15分，共30分)</h4>
<div class="outline-text-4" id="text-4-2-3">
<ol class="org-ol">
<li>給定一個 linked list 的頭節點 (head node)，請寫一個程式碼片段 (可以使用 C, Java, 或 Python) 來反轉這個 linked list。<br /></li>
<li>給定一個二元樹的前序 (preorder) 和中序 (inorder) 遍歷結果，請寫一個程式碼片段 (可以使用 C, Java, 或 Python) 來重建這個二元樹。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org86414c0" class="outline-3">
<h3 id="org86414c0"><span class="section-number-3">4.3.</span> 詳細解說答案</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-orgda95426" class="outline-4">
<h4 id="orgda95426"><span class="section-number-4">4.3.1.</span> 一、選擇題</h4>
<div class="outline-text-4" id="text-4-3-1">
<ol class="org-ol">
<li>答案：(E)。 算術邏輯單元 (ALU) 負責執行算術和邏輯運算，但它並不直接控制處理器的所有操作，控制單元 (Control Unit) 才是負責控制處理器的操作並告知電腦記憶體如何響應程式指令。<br /></li>
<li>答案：(D)。插入排序在最壞情況下的時間複雜度是 O(n^2)，而合併排序、快速排序、堆積排序在最壞情況下的時間複雜度都是 O(n log n)。<br /></li>
<li>答案：(C)。 傳輸層 (Transport Layer) 負責提供端對端的可靠傳輸，例如 TCP 協定。<br /></li>
<li>答案：(D)。關聯式資料庫使用結構化的表格和 SQL 語言。 NoSQL 資料庫包括鍵值對、文件、圖形和寬列式資料庫。<br /></li>
<li>答案：(C)。將文章分類到不同的主題是一個典型的監督式學習問題，因為需要有標籤的數據來訓練模型。<br /></li>
<li>答案：(C)。 RSA 加密系統中，n = p * q = 5 * 11 = 55。<br /></li>
<li>答案：(A)。 二元搜尋演算法只能應用於已排序的數據。<br /></li>
<li>答案：(D)。 CAP 定理指出，分散式資料庫系統只能保證一致性、可用性和分割容錯性中的兩個。<br /></li>
<li>答案：(C)。 圖靈測試的目標是測試機器是否能夠模仿人類的智能。<br /></li>
<li>答案：(E)。原型開發的主要優點是能夠在早期階段發現問題，協助建立測試計畫，並評估系統的可用性和有用性。計畫和排程在原型開發的早期階段可能不夠完善。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org365b0e0" class="outline-4">
<h4 id="org365b0e0"><span class="section-number-4">4.3.2.</span> 二、簡答題</h4>
<div class="outline-text-4" id="text-4-3-2">
<ol class="org-ol">
<li>分頁 (paging) 是一種記憶體管理技術，將邏輯記憶體分割成固定大小的區塊（稱為頁面），而物理記憶體也分割成相同大小的區塊（稱為頁框）。多程式作業系統使用分頁來允許每個程式使用非連續的記憶體空間。當程式執行時，作業系統會將程式的頁面載入到物理記憶體的頁框中，並使用分頁表來記錄邏輯地址到物理地址的映射。<br /></li>
<li><p>
以下為 Python 的程式碼範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>   <span style="color: #51afef;">def</span> <span style="color: #c678dd;">factorial</span>(n):
<span class="linenr">2: </span>       <span style="color: #51afef;">if</span> n == <span style="color: #da8548; font-weight: bold;">0</span>:
<span class="linenr">3: </span>           <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">4: </span>       <span style="color: #51afef;">else</span>:
<span class="linenr">5: </span>           <span style="color: #51afef;">return</span> n * factorial(n-<span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div></li>
<li>梯度下降 (Gradient Descent) 是一種優化演算法，用於訓練神經網路的權重。它通過迭代地調整權重，使得損失函數的值最小化。步驟如下：<br />
<ul class="org-ul">
<li>計算當前權重下損失函數的梯度。<br /></li>
<li>根據學習率和梯度，更新權重。<br /></li>
<li>重複以上步驟，直到損失函數收斂或達到迭代次數的上限。<br /></li>
</ul></li>
<li>K-fold cross-validation 是一種模型驗證技術，將數據集分成 K 個子集（稱為 fold）。然後，使用其中 K-1 個子集來訓練模型，並使用剩下的 1 個子集來驗證模型。重複這個過程 K 次，每次使用不同的子集作為驗證集。最後，平均 K 次驗證結果，以獲得更可靠的模型性能評估。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgc6d62b7" class="outline-4">
<h4 id="orgc6d62b7"><span class="section-number-4">4.3.3.</span> 三、程式設計題</h4>
<div class="outline-text-4" id="text-4-3-3">
<ol class="org-ol">
<li><p>
以下為 Java 的程式碼範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>   <span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> ListNode {
<span class="linenr"> 2: </span>       <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">val</span>;
<span class="linenr"> 3: </span>       ListNode next;
<span class="linenr"> 4: </span>       ListNode(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) { val = x; }
<span class="linenr"> 5: </span>   }
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>   <span style="color: #51afef;">public</span> ListNode reverseList(ListNode head) {
<span class="linenr"> 8: </span>       ListNode prev = <span style="color: #a9a1e1;">null</span>;
<span class="linenr"> 9: </span>       ListNode current = head;
<span class="linenr">10: </span>       ListNode next = <span style="color: #a9a1e1;">null</span>;
<span class="linenr">11: </span>       <span style="color: #51afef;">while</span> (current != <span style="color: #a9a1e1;">null</span>) {
<span class="linenr">12: </span>           next = current.next;
<span class="linenr">13: </span>           current.next = prev;
<span class="linenr">14: </span>           prev = current;
<span class="linenr">15: </span>           current = next;
<span class="linenr">16: </span>       }
<span class="linenr">17: </span>       head = prev;
<span class="linenr">18: </span>       <span style="color: #51afef;">return</span> head;
<span class="linenr">19: </span>   }
</pre>
</div></li>
<li>以下為 Python 的程式碼範例：<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">TreeNode</span>:
<span class="linenr"> 2: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__init__</span>(<span style="color: #51afef;">self</span>, val):
<span class="linenr"> 3: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">val</span> = val
<span class="linenr"> 4: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">left</span> = <span style="color: #a9a1e1;">None</span>
<span class="linenr"> 5: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">right</span> = <span style="color: #a9a1e1;">None</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">buildTree</span>(preorder, inorder):
<span class="linenr"> 8: </span>    <span style="color: #51afef;">if</span> <span style="color: #51afef;">not</span> preorder <span style="color: #51afef;">or</span> <span style="color: #51afef;">not</span> inorder:
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">None</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #dcaeea;">root_val</span> = preorder
<span class="linenr">12: </span>    <span style="color: #dcaeea;">root</span> = TreeNode(root_val)
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #dcaeea;">root_index</span> = inorder.index(root_val)
<span class="linenr">15: </span>
<span class="linenr">16: </span>    root.<span style="color: #dcaeea;">left</span> = buildTree(preorder[<span style="color: #da8548; font-weight: bold;">1</span>:root_index+<span style="color: #da8548; font-weight: bold;">1</span>], inorder[:root_index])
<span class="linenr">17: </span>    root.<span style="color: #dcaeea;">right</span> = buildTree(preorder[root_index+<span style="color: #da8548; font-weight: bold;">1</span>:], inorder[root_index+<span style="color: #da8548; font-weight: bold;">1</span>:])
<span class="linenr">18: </span>
<span class="linenr">19: </span>    <span style="color: #51afef;">return</span> root
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcbc5753" class="outline-2">
<h2 id="orgcbc5753"><span class="section-number-2">5.</span> 清大</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org04d3c86" class="outline-3">
<h3 id="org04d3c86"><span class="section-number-3">5.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-5-1">
<p>
以下是從這些考古題中觀察到的趨勢：<br />
</p>
</div>
<div id="outline-container-org44eb0d5" class="outline-4">
<h4 id="org44eb0d5"><span class="section-number-4">5.1.1.</span> 基本程式概念和資料結構：</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>遞迴：有多個題目都使用遞迴概念來解題，例如將十進制數字轉換為二進制。<br /></li>
<li>鏈結串列：考題中有要求反轉鏈結串列的實作。<br /></li>
<li>二元樹：有考題關於二元樹的儲存方式、遍歷以及二元搜尋樹的建立。<br /></li>
<li>堆疊：有題目要求使用堆疊來反轉相鄰的資料。<br /></li>
<li>佇列：有題目提到佇列的相關概念。<br /></li>
<li>雜湊表：有考題關於雜湊表的碰撞機率計算。<br /></li>
<li>前序式、後序式：有考題要求將前序式轉換為後序式。<br /></li>
<li>排序演算法：有提到排序演算法的相關概念，例如快速排序和合併排序。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org55eb523" class="outline-4">
<h4 id="org55eb523"><span class="section-number-4">5.1.2.</span> 計算機組織與結構：</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>浮點數表示法：考題中有關於浮點數的二進制表示法以及誤差計算。<br /></li>
<li>二補數：有題目探討二補數的表示範圍和加法運算。<br /></li>
<li>位元運算：有題目關於位元循環移位的操作。<br /></li>
<li>指令週期：有考題探討 CPU 的指令執行時間，包括有無 pipeline 的情況。<br /></li>
<li>快取記憶體：雖然沒有直接的考題，但在第 30 頁有提及快取記憶體（cache）的概念。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org431265c" class="outline-4">
<h4 id="org431265c"><span class="section-number-4">5.1.3.</span> 作業系統：</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>核心：有考題詢問作業系統核心的主要組成部分和功能，以及核心如何從使用者程式奪回控制權。<br /></li>
<li>行程和工作佇列：考題中有關於作業系統中工作佇列和行程佇列的內容。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd9a91fa" class="outline-4">
<h4 id="orgd9a91fa"><span class="section-number-4">5.1.4.</span> 網路：</h4>
<div class="outline-text-4" id="text-5-1-4">
<ul class="org-ul">
<li>TCP/UDP：有題目比較 TCP 和 UDP 的服務差異，以及 TCP 如何偵測網路擁塞。<br /></li>
<li>網路層：有考題詢問網路軟體的層級和功能。<br /></li>
<li>CSMA/CD：有考題說明 CSMA/CD 的功能與運作原理。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4cb1cdb" class="outline-4">
<h4 id="org4cb1cdb"><span class="section-number-4">5.1.5.</span> 演算法分析：</h4>
<div class="outline-text-4" id="text-5-1-5">
<ul class="org-ul">
<li>時間複雜度：有題目要求分析程式的時間複雜度，並使用 big-O 符號表示。<br /></li>
<li>遞迴關係式：考題中有遞迴關係式的分析。<br /></li>
<li>圖論：有考題關於圖的頂點覆蓋問題和最小生成樹演算法，以及歐拉路徑的概念。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org57d5d64" class="outline-4">
<h4 id="org57d5d64"><span class="section-number-4">5.1.6.</span> 其他：</h4>
<div class="outline-text-4" id="text-5-1-6">
<ul class="org-ul">
<li>圖靈機：有題目要求設計圖靈機來執行減值操作。<br /></li>
<li>錯誤更正碼：有題目關於錯誤更正碼的偵測和修正能力。<br /></li>
<li>開源/閉源軟體：有考題詢問開源和閉源軟體的差異，並舉例說明。<br /></li>
<li>邊界值分析：考題中有關於使用邊界值分析進行測試的題目。<br /></li>
<li>生產系統：有題目要求將一個問題以生產系統的狀態和規則描述。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgbaa23bb" class="outline-4">
<h4 id="orgbaa23bb"><span class="section-number-4">5.1.7.</span> 數學概念：</h4>
<div class="outline-text-4" id="text-5-1-7">
<ul class="org-ul">
<li>機率：有考題計算雜湊碰撞的機率。<br /></li>
<li>幾何：有題目要求計算平面上的反射點。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1050a99" class="outline-3">
<h3 id="org1050a99"><span class="section-number-3">5.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-5-2">
<p>
清華大學資訊工程學系 113 學年度「計算機概論」模擬試題<br />
考試時間：100 分鐘<br />
總分：100 分<br />
</p>
</div>
<div id="outline-container-orgc6bc11c" class="outline-4">
<h4 id="orgc6bc11c"><span class="section-number-4">5.2.1.</span> 1. 程式設計與資料結構 (30 分)</h4>
<div class="outline-text-4" id="text-5-2-1">
</div>
<div id="outline-container-org5c8f62b" class="outline-5">
<h5 id="org5c8f62b">(a) 遞迴與迭代 (10%)：</h5>
<div class="outline-text-5" id="text-org5c8f62b">
<p>
請使用遞迴和迭代兩種方式，實作一個函數來計算費氏數列的第 n 項 (Fibonacci sequence)。並分析這兩種方式的時間複雜度。<br />
</p>
</div>
</div>
<div id="outline-container-orge6d7127" class="outline-5">
<h5 id="orge6d7127">(b) 鏈結串列操作 (10%)：</h5>
<div class="outline-text-5" id="text-orge6d7127">
<p>
給定一個單向鏈結串列的頭節點，請實作一個函數來判斷此鏈結串列是否為迴文 (palindrome)。請分析你的演算法的時間複雜度。 (c) 二元樹與搜尋 (10%)：給定一個二元搜尋樹 (BST)，請實作一個函數來找出樹中第 k 小的元素。請分析你的演算法的時間複雜度，並解釋如何應用中序走訪 (inorder traversal)。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8823f11" class="outline-4">
<h4 id="org8823f11"><span class="section-number-4">5.2.2.</span> 2. 計算機組織與結構 (25 分)</h4>
<div class="outline-text-4" id="text-5-2-2">
</div>
<div id="outline-container-org32e413c" class="outline-5">
<h5 id="org32e413c">(a) 浮點數表示法 (10%)：</h5>
<div class="outline-text-5" id="text-org32e413c">
<p>
假設有一個 10 位元的浮點數表示法，其中 1 位元為符號位元，5 位元為指數 (excess-15 表示法)，4 位元為尾數。請將十進制數字 -5.625 轉換為此浮點數表示法。並討論此表示法的最大和最小可表示數字。<br />
</p>
</div>
</div>
<div id="outline-container-org327f8c8" class="outline-5">
<h5 id="org327f8c8">(b) 記憶體階層 (10%)：</h5>
<div class="outline-text-5" id="text-org327f8c8">
<p>
請說明快取記憶體 (cache memory) 的運作原理，並解釋快取記憶體如何提高記憶體存取速度。請比較直接映射 (direct mapping) 和集合關聯 (set-associative) 快取之間的差異。<br />
</p>
</div>
</div>
<div id="outline-container-orgd4d3928" class="outline-5">
<h5 id="orgd4d3928">(c) 指令集架構 (5%)：</h5>
<div class="outline-text-5" id="text-orgd4d3928">
<p>
簡述 RISC (精簡指令集計算機) 和 CISC (複雜指令集計算機) 的主要差異，並各舉一個例子說明。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org91edb22" class="outline-4">
<h4 id="org91edb22"><span class="section-number-4">5.2.3.</span> 3. 作業系統與網路 (25 分)</h4>
<div class="outline-text-4" id="text-5-2-3">
</div>
<div id="outline-container-org5fb3790" class="outline-5">
<h5 id="org5fb3790">(a) 行程管理 (10%)：</h5>
<div class="outline-text-5" id="text-org5fb3790">
<p>
請解釋作業系統中的行程 (process) 和執行緒 (thread) 的概念，並比較它們之間的差異。說明行程排程演算法 (例如：FCFS, SJF, Round Robin) 的目的。<br />
</p>
</div>
</div>
<div id="outline-container-orgf0f22e3" class="outline-5">
<h5 id="orgf0f22e3">(b) 網路協定 (10%)：</h5>
<div class="outline-text-5" id="text-orgf0f22e3">
<p>
請說明 TCP 三次握手 (three-way handshake) 的過程，並解釋為什麼需要這個過程。比較 TCP 和 UDP 在可靠性、速度和應用場景上的差異。<br />
</p>
</div>
</div>
<div id="outline-container-org538bc46" class="outline-5">
<h5 id="org538bc46">(c) 雲端運算 (5%)：</h5>
<div class="outline-text-5" id="text-org538bc46">
<p>
簡述雲端運算 (cloud computing) 的基本概念，並說明 IaaS (基礎設施即服務)、PaaS (平台即服務) 和 SaaS (軟體即服務) 的差異。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org63d1499" class="outline-4">
<h4 id="org63d1499"><span class="section-number-4">5.2.4.</span> 4. 演算法與新興技術 (20 分)</h4>
<div class="outline-text-4" id="text-5-2-4">
</div>
<div id="outline-container-org9297afc" class="outline-5">
<h5 id="org9297afc">(a) 圖論演算法 (10%)：</h5>
<div class="outline-text-5" id="text-org9297afc">
<p>
給定一個加權無向圖，請使用 Dijkstra 演算法找出從起點到所有其他節點的最短路徑。請解釋 Dijkstra 演算法的原理，並說明其時間複雜度。<br />
</p>
</div>
</div>
<div id="outline-container-org0639217" class="outline-5">
<h5 id="org0639217">(b) 機器學習基礎 (10%)：</h5>
<div class="outline-text-5" id="text-org0639217">
<p>
簡述機器學習 (machine learning) 中監督式學習 (supervised learning) 和非監督式學習 (unsupervised learning) 的概念，並各舉一個實際應用的例子。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org9ef418e" class="outline-3">
<h3 id="org9ef418e"><span class="section-number-3">5.3.</span> 詳細解答：</h3>
<div class="outline-text-3" id="text-5-3">
</div>
<div id="outline-container-org2e0b441" class="outline-4">
<h4 id="org2e0b441"><span class="section-number-4">5.3.1.</span> 1. 程式設計與資料結構</h4>
<div class="outline-text-4" id="text-5-3-1">
</div>
<div id="outline-container-orgc486e07" class="outline-5">
<h5 id="orgc486e07">(a) 遞迴與迭代</h5>
<div class="outline-text-5" id="text-orgc486e07">
</div>
<ul class="org-ul">
<li><a id="orgcc3f2ea"></a>遞迴： cpp<br />
<div class="outline-text-6" id="text-orgcc3f2ea">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fib_recursive</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">2: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr">3: </span>  <span style="color: #51afef;">return</span> fib_recursive(n - <span style="color: #da8548; font-weight: bold;">1</span>) + fib_recursive(n - <span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr">4: </span>}
</pre>
</div>
<p>
時間複雜度為 O(2^n)，因為每個呼叫都會產生兩個新的呼叫。<br />
</p>
</div>
</li>
<li><a id="org6f8db2c"></a>迭代： cpp<br />
<div class="outline-text-6" id="text-org6f8db2c">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fib_iterative</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr"> 2: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr"> 3: </span>  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">prev</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">curr</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 4: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">2</span>; i &lt;= n; i++) {
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">next</span> = prev + curr;
<span class="linenr"> 6: </span>    prev = curr;
<span class="linenr"> 7: </span>    curr = next;
<span class="linenr"> 8: </span>  }
<span class="linenr"> 9: </span>  <span style="color: #51afef;">return</span> curr;
<span class="linenr">10: </span>}
</pre>
</div>
<p>
時間複雜度為 O(n)，因為只遍歷一次迴圈。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3aa03af" class="outline-5">
<h5 id="org3aa03af">(b) 鏈結串列操作</h5>
<div class="outline-text-5" id="text-org3aa03af">
<ul class="org-ul">
<li>將鏈結串列複製一份並反轉，然後比較反轉後的鏈結串列是否與原鏈結串列相同。 * 可以使用快慢指針找到鏈結串列的中點，然後反轉後一半的鏈結串列，再與前半部比較。<br /></li>
<li>時間複雜度：O(n)，需走訪鏈結串列一次。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd1956d6" class="outline-5">
<h5 id="orgd1956d6">(c) 二元樹與搜尋</h5>
<div class="outline-text-5" id="text-orgd1956d6">
<ul class="org-ul">
<li>使用中序走訪 (inorder traversal) 可以按照排序順序訪問二元搜尋樹的所有節點。<br /></li>
<li>使用一個計數器追蹤走訪的節點數，當計數器等於 k 時，返回當前節點的值。<br /></li>
<li>時間複雜度：O(n) 最差情況下需要走訪所有節點。平均情況下為 O(k)，如果樹平衡良好，則可以在 O(h) 的時間找到，h是樹的高度。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8538136" class="outline-4">
<h4 id="org8538136"><span class="section-number-4">5.3.2.</span> 2. 計算機組織與結構</h4>
<div class="outline-text-4" id="text-5-3-2">
</div>
<div id="outline-container-org8c3295a" class="outline-5">
<h5 id="org8c3295a">(a) 浮點數表示法</h5>
<div class="outline-text-5" id="text-org8c3295a">
<ul class="org-ul">
<li>-5.625 的二進制表示為 -101.101。<br /></li>
<li>將其標準化為 -1.01101 x 2^2。<br /></li>
<li>符號位元：1 (負數)<br /></li>
<li>指數：2 + 15 = 17，二進制為 10001<br /></li>
<li>尾數：01101 (取小數部分，不足補 0)<br /></li>
<li>因此，表示為 1 10001 0110。<br /></li>
<li>最大可表示數字：約為 (1.1111) 2^15<br /></li>
<li>最小可表示數字：約為 (1.0000) 2^-15<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9f53f9d" class="outline-5">
<h5 id="org9f53f9d">(b) 記憶體階層</h5>
<div class="outline-text-5" id="text-org9f53f9d">
<ul class="org-ul">
<li>快取記憶體是一個小而快的記憶體，用於儲存經常存取的資料，以減少 CPU 從主記憶體讀取資料的時間。 * 直接映射快取：每個主記憶體區塊只能映射到快取中的一個特定位置。<br /></li>
<li>集合關聯快取：每個主記憶體區塊可以映射到快取中多個特定位置的集合，提供更高的靈活性和較低的碰撞率。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org81172fe" class="outline-5">
<h5 id="org81172fe">(c) 指令集架構</h5>
<div class="outline-text-5" id="text-org81172fe">
<ul class="org-ul">
<li>RISC：指令集簡化，指令長度固定，硬體實現簡單，執行速度快。例如：ARM。<br /></li>
<li>CISC：指令集複雜，指令長度不固定，硬體實現複雜，功能強大。例如：Intel x86。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8f45e8d" class="outline-4">
<h4 id="org8f45e8d"><span class="section-number-4">5.3.3.</span> 3. 作業系統與網路</h4>
<div class="outline-text-4" id="text-5-3-3">
</div>
<div id="outline-container-org0d7c8ef" class="outline-5">
<h5 id="org0d7c8ef">(a) 行程管理</h5>
<div class="outline-text-5" id="text-org0d7c8ef">
<ul class="org-ul">
<li>行程：程式執行時的實例，包含程式碼、資料、堆疊、和程式計數器等資源，是作業系統進行資源分配和調度的基本單位。<br /></li>
<li>執行緒：行程內的一個執行單元，多個執行緒共享同一行程的資源，因此執行緒間的切換比行程切換快。<br /></li>
<li>行程排程演算法：<br />
<ul class="org-ul">
<li>FCFS (First Come First Served)：先到先服務，依據行程到達的先後順序執行。<br /></li>
<li>SJF (Shortest Job First)：最短工作優先，優先執行所需時間最短的行程。<br /></li>
<li>Round Robin：循環排程，每個行程執行一段時間後，輪流執行下一個行程。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc46ec5c" class="outline-5">
<h5 id="orgc46ec5c">(b) 網路協定</h5>
<div class="outline-text-5" id="text-orgc46ec5c">
<ul class="org-ul">
<li><p>
TCP 三次握手：<br />
</p>
<ol class="org-ol">
<li>客戶端發送 SYN 封包到伺服器。<br /></li>
<li>伺服器收到 SYN 後，回覆 SYN-ACK 封包給客戶端。<br /></li>
<li>客戶端收到 SYN-ACK 後，發送 ACK 封包給伺服器。<br /></li>
</ol>
<p>
此過程用於建立可靠的 TCP 連線，並協商雙方初始序列號。<br />
</p></li>
<li>TCP：可靠傳輸、面向連線、有流量控制和擁塞控制。適用於檔案傳輸、網頁瀏覽。<br /></li>
<li>UDP：不可靠傳輸、無連線、速度快，但沒有流量控制。適用於串流媒體、線上遊戲。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9051a18" class="outline-5">
<h5 id="org9051a18">(c) 雲端運算</h5>
<div class="outline-text-5" id="text-org9051a18">
<ul class="org-ul">
<li>雲端運算：通過網路提供可擴展的計算資源。<br /></li>
<li>IaaS：提供虛擬機、儲存和網路等基礎設施，用戶需自行管理作業系統和應用程式。<br /></li>
<li>PaaS：提供開發平台和工具，用戶可在此平台上開發和部署應用程式。<br /></li>
<li>SaaS：提供現成的應用軟體，用戶直接使用即可。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org696425c" class="outline-4">
<h4 id="org696425c"><span class="section-number-4">5.3.4.</span> 4. 演算法與新興技術</h4>
<div class="outline-text-4" id="text-5-3-4">
</div>
<div id="outline-container-org16f4128" class="outline-5">
<h5 id="org16f4128">(a) 圖論演算法</h5>
<div class="outline-text-5" id="text-org16f4128">
<ul class="org-ul">
<li>Dijkstra 演算法：從起點開始，維護一個最短路徑集合，並逐步擴展到其他節點，直到找到所有節點的最短路徑。<br /></li>
<li>時間複雜度：O(E log V)，其中 E 為邊的數量，V 為頂點的數量。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org0ad5e6b" class="outline-5">
<h5 id="org0ad5e6b">(b) 機器學習基礎</h5>
<div class="outline-text-5" id="text-org0ad5e6b">
<ul class="org-ul">
<li>監督式學習：使用標記過的資料進行訓練，讓模型學習從輸入到輸出的對應關係。例如：圖像分類、語音辨識。<br /></li>
<li>非監督式學習：使用未標記的資料進行訓練，讓模型自行找出資料中的模式和結構。例如：分群、降維。<br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfbbc43a" class="outline-2">
<h2 id="orgfbbc43a"><span class="section-number-2">6.</span> 成大</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org85a42a8" class="outline-3">
<h3 id="org85a42a8"><span class="section-number-3">6.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org9abd805" class="outline-3">
<h3 id="org9abd805"><span class="section-number-3">6.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-orgac22d59" class="outline-2">
<h2 id="orgac22d59"><span class="section-number-2">7.</span> 中央</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org731d61c" class="outline-3">
<h3 id="org731d61c"><span class="section-number-3">7.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org1ec35bb" class="outline-3">
<h3 id="org1ec35bb"><span class="section-number-3">7.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-orgeb4d8ac" class="outline-2">
<h2 id="orgeb4d8ac"><span class="section-number-2">8.</span> 北大</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org505f932" class="outline-3">
<h3 id="org505f932"><span class="section-number-3">8.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org25a5172" class="outline-3">
<h3 id="org25a5172"><span class="section-number-3">8.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-org735c305" class="outline-2">
<h2 id="org735c305"><span class="section-number-2">9.</span> 林北的考前猜題</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org82bb992" class="outline-3">
<h3 id="org82bb992"><span class="section-number-3">9.1.</span> 網路</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-org4c91f96" class="outline-4">
<h4 id="org4c91f96"><span class="section-number-4">9.1.1.</span> 簡單的概念知識</h4>
<div class="outline-text-4" id="text-9-1-1">
<p>
看這章：<a href="https://data.slhs.tp.edu.tw/shien/bcc/download/book/C221A1_ch14.pdf">https://data.slhs.tp.edu.tw/shien/bcc/download/book/C221A1_ch14.pdf</a><br />
</p>
<ul class="org-ul">
<li>ISO的OSI(網路七層): 14-1<br /></li>
<li>TCP/IP: 14-2<br /></li>
<li>WIFI, 藍芽, RFID, NFC: 14-3<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org98cb1d0" class="outline-4">
<h4 id="org98cb1d0"><span class="section-number-4">9.1.2.</span> 如何計算IP位址與網路遮罩</h4>
<div class="outline-text-4" id="text-9-1-2">
</div>
<div id="outline-container-org41174cc" class="outline-5">
<h5 id="org41174cc">IP的等級</h5>
<div class="outline-text-5" id="text-org41174cc">
<ul class="org-ul">
<li>IP(例如8.8.8.8)分為A,B,C三級<br /></li>
<li>每一組IP都是一個 8-bit 的二進位數字,﹐每組數字為一個“octet”﹐合共起來就是一個 32-bit 的 IP 位址﹐亦即是 IP v4 (Version 4) 版本的位址<br /></li>
<li>所以 8.8.8.8 的完整二進位格式是：00001000.00001000.00001000.00001000<br /></li>
<li>128.10.20.30 的二進位格式是：10000000.00001010.00010100.00011110<br /></li>
<li>192.168.1.1 的二進位格式是：11000000.10101000.00000001.00000001<br /></li>
<li>上面三個IP分別是A,B,C級網路IP<br /></li>
<li>可以由二進位來判斷一個IP是哪一級：<br />
<ul class="org-ul">
<li>如果是以“0”開頭的﹐這是一個 A Class的 IP<br /></li>
<li>如果是以“10”開頭的﹐這是一個 B Class的 IP<br /></li>
<li>如果是以“110”為開頭的﹐則屬於 C Class的 IP<br /></li>
</ul></li>
<li>也可以死記﹕<br />
<ul class="org-ul">
<li>由 1 到 126 開頭的 IP 是 A Class<br /></li>
<li>由 128 到 191開頭的 IP是 B Class<br /></li>
<li>由 192 到 223 開頭的則為 C Class<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfb90033" class="outline-5">
<h5 id="orgfb90033">不同等級的網路，差異在於這組網路有多少可用IP</h5>
<div class="outline-text-5" id="text-orgfb90033">
<ul class="org-ul">
<li>A,B,C級網路的可用IP(可以用算的 C級的254=2^16 - 2, 原因看底下)<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">等級</th>
<th scope="col" class="org-right">開首</th>
<th scope="col" class="org-left">網路數目</th>
<th scope="col" class="org-left">主機數目</th>
<th scope="col" class="org-left">使用範圍</th>
<th scope="col" class="org-left">申請領域</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">0</td>
<td class="org-left">127</td>
<td class="org-left">16,777,214</td>
<td class="org-left">1.x.x.x 到 126.x.x.x</td>
<td class="org-left">國家級</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">10</td>
<td class="org-left">16,384</td>
<td class="org-left">65,534</td>
<td class="org-left">128.x.x.x 到 191.x.x.x</td>
<td class="org-left">跨國組織</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-right">110</td>
<td class="org-left">2,097,152</td>
<td class="org-left">254</td>
<td class="org-left">192.x.x.x 到 223.x.x.x</td>
<td class="org-left">企業組織</td>
</tr>

<tr>
<td class="org-left">D</td>
<td class="org-right">1110</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">224.- 到 239.-</td>
<td class="org-left">特殊用途</td>
</tr>

<tr>
<td class="org-left">E</td>
<td class="org-right">1111</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">240.- 到 255.-</td>
<td class="org-left">保留範圍</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li><p>
IP 的 Net_ID 和 Host_ID﹕<br />
</p>
<ul class="org-ul">
<li>A Class 的 IP 使用最前面一組數字來做 Net ID﹐其余三組做 Host ID<br /></li>
<li>B Class 的 IP 使用前面兩組數字來做 Net ID﹐另兩組做 Host ID<br /></li>
<li>C Class 的 IP 使用前面三組數字來做 Net ID﹐剩下的一組做 Host ID<br /></li>
</ul>
<p>
如下圖<br />
</p>

<div id="org9623264" class="figure">
<p><img src="images/林北的考前猜題/2025-01-27_17-20-33_ip1.png" alt="2025-01-27_17-20-33_ip1.png" width="500" /><br />
</p>
</div></li>
<li>後面的Host ID就是這組網路能用的IP，例如C級網路前面的Net ID是固定的，所以能用的就只有後面的Host ID, 0 - 255<br /></li>
<li>例如，南一中分配到的一組網路ID是210.70.137,<br />
<ul class="org-ul">
<li>預設的子網路遮罩就是255.255.255.0<br /></li>
<li>我們能用的IP就是210.70.137.0 - 210.70.137.255,共256個<br /></li>
<li>但是要扣掉兩組IP, 所以剩254個能用<br />
<ul class="org-ul">
<li>網路 ID：210.70.137.0<br /></li>
<li>廣播地址：210.70.137.255<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3255ce9" class="outline-5">
<h5 id="org3255ce9">IP與NetMask</h5>
<div class="outline-text-5" id="text-org3255ce9">
<ul class="org-ul">
<li>因為IP位址分為主機和網路號碼，所以在Internet的網路上找尋電腦時，我們需要先找到網路號碼，然後在子網路中找到目的地的主機，所以電腦IP位址的設定除了IP位址外，另一個重要的號碼就是子網路遮罩。<br /></li>
<li>「子網路遮罩」(Subnet Mask)是一個固定的值，在電腦的定址計算中是使用子網路遮罩的值將IP位址分為網路號碼和主機號碼，子網路遮罩的值依網路等級的預設值，如下所示：<br />
<ul class="org-ul">
<li>Class A：255.0.0.0<br /></li>
<li>Class B：255.255.0.0<br /></li>
<li>Class C：255.255.255.0<br /></li>
</ul></li>
<li>簡單的說255的二進位值能夠遮掉IP位址中的網路號碼，經過運算後剩下的就是主機號碼，如此可以識別IP位址所屬的網路。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1d50096" class="outline-5">
<h5 id="org1d50096">網路分割(分成兩個)</h5>
<div class="outline-text-5" id="text-org1d50096">
<ul class="org-ul">
<li>可以透過NetMask來把一個網路切成兩個或更多<br /></li>
<li><p>
例如把一個C級網路切成兩個，分給電個學校，這樣就不能用預設的netmask 255.255.255.0<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">子網</th>
<th scope="col" class="org-right">網路 ID</th>
<th scope="col" class="org-right">廣播地址</th>
<th scope="col" class="org-left">可用 IP 範圍</th>
<th scope="col" class="org-right">子網掩碼</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">子網 1</td>
<td class="org-right">210.70.137.0</td>
<td class="org-right">210.70.137.127</td>
<td class="org-left">210.70.137.1 ~ 210.70.137.126</td>
<td class="org-right">255.255.255.128</td>
</tr>

<tr>
<td class="org-left">子網 2</td>
<td class="org-right">210.70.137.128</td>
<td class="org-right">210.70.137.255</td>
<td class="org-left">210.70.137.129 ~ 210.70.137.254</td>
<td class="org-right">255.255.255.128</td>
</tr>
</tbody>
</table></li>
<li>之後這個C級網路就會變成以下兩個子網路，可以分配給兩個學校<br />
<ul class="org-ul">
<li>子網 1：210.70.137.0/25<br /></li>
<li>子網 2：210.70.137.128/25<br /></li>
<li>25的意思是netmask有25個1(11111111.11111111.11111111.10000000)<br /></li>
<li>沒分割的C級網路netmask預設是24(11111111.11111111.11111111.00000000)<br /></li>
</ul></li>
<li>每分割一次，就會損失掉兩個IP（第一個和最後一個IP位址是保留作為特殊的用途, 第一個位址代表的是Network ID, 最後一個位址代表的是廣播位址), 所以分割越細浪費越多IP<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf758670" class="outline-5">
<h5 id="orgf758670">分成4個</h5>
<div class="outline-text-5" id="text-orgf758670">
<ul class="org-ul">
<li><p>
將 210.70.137.0/24 分成 4 個子網後的分配如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">子網</th>
<th scope="col" class="org-right">網路 ID</th>
<th scope="col" class="org-right">廣播地址</th>
<th scope="col" class="org-left">可用 IP 範圍</th>
<th scope="col" class="org-right">子網掩碼</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">子網 1</td>
<td class="org-right">210.70.137.0</td>
<td class="org-right">210.70.137.63</td>
<td class="org-left">210.70.137.1 ~ 210.70.137.62</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 2</td>
<td class="org-right">210.70.137.64</td>
<td class="org-right">210.70.137.127</td>
<td class="org-left">210.70.137.65 ~ 210.70.137.126</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 3</td>
<td class="org-right">210.70.137.128</td>
<td class="org-right">210.70.137.191</td>
<td class="org-left">210.70.137.129 ~ 210.70.137.190</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 4</td>
<td class="org-right">210.70.137.192</td>
<td class="org-right">210.70.137.255</td>
<td class="org-left">210.70.137.193 ~ 210.70.137.254</td>
<td class="org-right">255.255.255.192</td>
</tr>
</tbody>
</table></li>
<li>之後這個C級網路就會變成以下4個子網路，可以分配給兩個學校<br />
<ul class="org-ul">
<li>子網 1：210.70.137.1 ~ 210.70.137.62<br /></li>
<li>子網 2：210.70.137.65 ~ 210.70.137.126<br /></li>
<li>子網 3：210.70.137.129 ~ 210.70.137.190<br /></li>
<li>子網 4：210.70.137.193 ~ 210.70.137.254<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfff6d0a" class="outline-5">
<h5 id="orgfff6d0a">公共 IP&ldquo; 與 &rdquo;私有 IP"</h5>
<div class="outline-text-5" id="text-orgfff6d0a">
<ul class="org-ul">
<li>一個學校分配一個C級網路一定不夠用，我們學校光電腦教室用掉的IP就有300個，怎麼辦？<br /></li>
<li>在 A﹑B﹑C 這三個層級裡面﹐各劃出一些位址範圍保留給私有位址所用﹐它們分別是﹕<br />
<ul class="org-ul">
<li>10.0.0.0 - 10.255.255.255<br /></li>
<li>172.16.0.0 - 172.31.255.255<br /></li>
<li>192.168.0.0 - 192.168.255.255<br /></li>
</ul></li>
<li>像中華電信其實只分配一個IP給我們家，那為什麼家裡每台電腦、手機都能用WIFI上網，原因就是都用這種virtual ip<br /></li>
<li>使用virtual IP必須要配合NAT( NAT &#x2014; Network Addresss Translation)<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org5a929a5"></a>NAT運作原理<br />
<div class="outline-text-6" id="text-org5a929a5">
<p>
NAT 是路由器實現的技術，用於解決內部多台設備共用一個公網 IP 的問題。工作流程：<br />
</p>
<ol class="org-ol">
<li>內部設備請求上網：你的電腦（私網 IP：192.168.1.100）想訪問 Google（例如 IP 為 142.250.190.46）。請求會發送到路由器。<br /></li>
<li>路由器轉換請求：路由器會用它的公網 IP（例如 123.45.67.89）替換電腦的私網 IP，並將請求轉發到 Google。<br /></li>
<li>路由器保存對應關係：路由器會記錄內部設備的私網 IP 和使用的連接埠（Port）。例如：<br />
<ul class="org-ul">
<li>內部 IP:Port -&gt; 公網 IP:Port<br /></li>
<li>192.168.1.100:54321 -&gt; 123.45.67.89:54321<br /></li>
</ul></li>
<li>回應轉發：當 Google 的回應到達你的公網 IP 時，路由器會根據對應關係將回應轉發給正確的內部設備（如 192.168.1.100）。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org4e14f21" class="outline-5">
<h5 id="org4e14f21">DHCP</h5>
<div class="outline-text-5" id="text-org4e14f21">
<ul class="org-ul">
<li>家裡的每台電腦或手機為什麼不用自己設定IP就能上網？<br /></li>
<li>路由器通常啟用 DHCP（動態主機配置協議），自動給每台設備分配私網 IP。這樣你家裡的電腦、手機都會獲得唯一的內部 IP。<br /></li>
<li>範例：假設路由器的 IP 是 192.168.1.1，你的設備可能分配到：<br />
<ul class="org-ul">
<li>電腦：192.168.1.100<br /></li>
<li>手機：192.168.1.101<br /></li>
<li>平板：192.168.1.102<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org59b0450" class="outline-4">
<h4 id="org59b0450"><span class="section-number-4">9.1.3.</span> 靜態路由與動態路由協定（如 RIP, OSPF, BGP）</h4>
<div class="outline-text-4" id="text-9-1-3">
<p>
靜態路由和動態路由是網路中管理路由表的兩種不同方法，它們決定數據包在不同網段之間的傳輸方式。這兩種方法有著不同的特點和應用場景。下面介紹靜態路由以及常見的動態路由協定（如RIP、OSPF、BGP）的概念和特性。<br />
</p>
</div>
<div id="outline-container-org78895eb" class="outline-5">
<h5 id="org78895eb">靜態路由（Static Routing）</h5>
<div class="outline-text-5" id="text-org78895eb">
<p>
靜態路由是指網路管理員手動在路由器上配置的路由條目。這些條目指示數據包通往特定目標網段的路由，並且在路由表中是固定不變的，直到手動更改。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgb4b9d2d"></a>特點:<br />
<div class="outline-text-6" id="text-orgb4b9d2d">
<ul class="org-ul">
<li>手動配置：管理員必須手動指定每條路由，包括目標網路和下一跳路由器的IP地址。<br /></li>
<li>適用於小型網路：靜態路由適用於網絡拓撲變化較小的場景，如小型或封閉的網路環境。<br /></li>
<li>高效但不靈活：靜態路由不消耗網路資源，但當網路拓撲發生變化時（例如，某個路由器失效或網段更改），需要手動調整配置，否則會導致路由失效。<br /></li>
<li>安全性高：由於手動配置，沒有意外的路由改變，因此在某些環境下更具安全性。<br /></li>
</ul>
</div>
</li>
<li><a id="orgcca926a"></a>優點:<br />
<div class="outline-text-6" id="text-orgcca926a">
<ul class="org-ul">
<li>控制力強，路由選擇完全由管理員掌控。<br /></li>
<li>不會產生路由更新的開銷，節省網路資源。<br /></li>
</ul>
</div>
</li>
<li><a id="org7571582"></a>缺點:<br />
<div class="outline-text-6" id="text-org7571582">
<ul class="org-ul">
<li>當網路規模變大或拓撲頻繁變動時，手動配置和維護的成本高。<br /></li>
<li>無法自動調整和應對網路故障或變化。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2e21feb" class="outline-5">
<h5 id="org2e21feb">動態路由（Dynamic Routing）</h5>
<div class="outline-text-5" id="text-org2e21feb">
<p>
動態路由依靠路由協定自動學習和維護網路的路由表，能夠自動調整以應對網路變化。動態路由協定根據特定的算法來確定最佳路徑，並定期與鄰居路由器交換路由信息。以下是常見的動態路由協定。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org152f096"></a>RIP（Routing Information Protocol）<br />
<div class="outline-text-6" id="text-org152f096">
<p>
RIP是最早期的動態路由協定之一，基於距離向量算法來選擇路由。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org9024083"></a>工作原理：<br />
<div class="outline-text-7" id="text-org9024083">
<p>
RIP基於「跳數」來選擇路由，最多允許15跳（即路由器數量）來到達目標網路。RIP會定期（每30秒）向鄰近的路由器通告其路由表，並選擇跳數最少的路徑。<br />
</p>
</div>
</li>
<li><a id="orge79af49"></a>版本：<br />
<div class="outline-text-7" id="text-orge79af49">
<ul class="org-ul">
<li>RIPv1：不支持子網遮罩，路由表只包括網段地址，不適合無類別域間路由選擇（CIDR）。<br /></li>
<li>RIPv2：改進了對CIDR的支持，並且增加了多播傳輸和身份驗證功能。<br /></li>
</ul>
</div>
</li>
<li><a id="org28c99ef"></a>優點：<br />
<div class="outline-text-7" id="text-org28c99ef">
<ul class="org-ul">
<li>易於配置和維護，適用於小型網路。<br /></li>
</ul>
</div>
</li>
<li><a id="orge7183d3"></a>缺點：<br />
<div class="outline-text-7" id="text-orge7183d3">
<ul class="org-ul">
<li>跳數限制（最多15跳）使其不適合大型網路。<br /></li>
<li>更新過於頻繁（每30秒）可能導致帶寬浪費。<br /></li>
<li>收斂速度慢（路由表更新和調整所需時間較長）。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org4854efc"></a>OSPF（Open Shortest Path First）<br />
<div class="outline-text-6" id="text-org4854efc">
<p>
OSPF是一種基於鏈路狀態算法的動態路由協定，被廣泛應用於中大型網路環境中。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgeb469b3"></a>工作原理<br />
<div class="outline-text-7" id="text-orgeb469b3">
<ul class="org-ul">
<li>OSPF通過鏈路狀態廣播（LSA）在整個網路內通告網段狀況，並使用Dijkstra的最短路徑優先算法來計算最佳路徑。每個路由器會維護一個完整的網路拓撲圖，並計算出到其他網段的最短路徑。<br /></li>
</ul>
</div>
</li>
<li><a id="org60b4ed7"></a>特點：<br />
<div class="outline-text-7" id="text-org60b4ed7">
<ul class="org-ul">
<li>支持無類別域間路由選擇（CIDR），允許靈活的子網劃分。<br /></li>
<li>收斂速度快：當網路拓撲發生變化時，OSPF能快速響應和調整路由。<br /></li>
<li>能根據網段的成本（如帶寬、延遲等）來選擇最佳路徑，而不是僅依賴跳數。<br /></li>
<li>支持分層設計：可將網路劃分為多個區域（Area），有助於減少網路更新的範圍，提升網路的可擴展性。<br /></li>
</ul>
</div>
</li>
<li><a id="org8bfcfd5"></a>優點：<br />
<div class="outline-text-7" id="text-org8bfcfd5">
<ul class="org-ul">
<li>收斂速度快，適合大型網路。<br /></li>
<li>支持多路徑負載均衡。<br /></li>
</ul>
</div>
</li>
<li><a id="orgcbbc61c"></a>缺點：<br />
<div class="outline-text-7" id="text-orgcbbc61c">
<ul class="org-ul">
<li>計算拓撲圖和維護路由表的過程較為複雜，對硬體資源要求較高。<br /></li>
<li>配置比RIP更複雜，需要更高的技術水平。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgd91e406"></a>BGP（Border Gateway Protocol）<br />
<div class="outline-text-6" id="text-orgd91e406">
<p>
BGP是一種路由向量協定，廣泛應用於互聯網的自治系統（AS，Autonomous Systems）之間的路由選擇。它主要負責互聯網骨幹網中的路由決策。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgda20943"></a>工作原理<br />
<div class="outline-text-7" id="text-orgda20943">
<p>
BGP主要用於交換自治系統之間的路由信息，每個AS由一個或多個BGP路由器組成，這些路由器相互通告其可達的網段。BGP根據多種路徑屬性（如路徑長度、AS數量等）來選擇最佳路徑，而不是僅依賴跳數。<br />
</p>
<ul class="org-ul">
<li>內部BGP（iBGP）：用於同一自治系統內的路由器之間的路由選擇。<br /></li>
<li>外部BGP（eBGP）：用於不同自治系統之間的路由選擇。<br /></li>
</ul>
</div>
</li>
<li><a id="org188a3b1"></a>特點：<br />
<div class="outline-text-7" id="text-org188a3b1">
<ul class="org-ul">
<li>可擴展性強：BGP能夠處理大型網路環境，支持數百萬個路由條目，是互聯網上自治系統之間的首選路由協定。<br /></li>
<li>靈活的路由選擇機制：BGP不僅考慮路由長度，還能根據政策和策略來選擇路徑。<br /></li>
</ul>
</div>
</li>
<li><a id="org44e4f4b"></a>優點：<br />
<div class="outline-text-7" id="text-org44e4f4b">
<ul class="org-ul">
<li>BGP在處理跨多個自治系統的網路連接方面非常強大。<br /></li>
<li>支持路由策略和策略性路由選擇，適用於ISP和大型企業。<br /></li>
</ul>
</div>
</li>
<li><a id="org13b6bb2"></a>缺點：<br />
<div class="outline-text-7" id="text-org13b6bb2">
<ul class="org-ul">
<li>配置和維護非常複雜，適合高級網路工程師。<br /></li>
<li>收斂速度相對較慢，這在大規模變動的環境中可能成為一個問題。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orge7c9761" class="outline-5">
<h5 id="orge7c9761">總結</h5>
<div class="outline-text-5" id="text-orge7c9761">
<ul class="org-ul">
<li>靜態路由：適合小型、簡單網路，優點是配置靈活且控制精確，缺點是需要手動維護，且無法自動應對網路變化。<br /></li>
<li>動態路由：動態路由協定（如RIP、OSPF、BGP）適合中大型網路，能夠根據網路變化自動調整路由。RIP適合小型網路，OSPF適合企業內部路由，BGP則是跨自治系統的標準協定，負責處理大規模互聯網路徑選擇。<br /></li>
</ul>
<p>
兩者結合使用，可以在提升網路效率和靈活性的同時，確保部分關鍵流量路徑的穩定和安全。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcba5174" class="outline-3">
<h3 id="orgcba5174"><span class="section-number-3">9.2.</span> 資料庫</h3>
<div class="outline-text-3" id="text-9-2">
</div>
<div id="outline-container-org2af0ef4" class="outline-4">
<h4 id="org2af0ef4"><span class="section-number-4">9.2.1.</span> NoSQL v.s. RDBM</h4>
<div class="outline-text-4" id="text-9-2-1">
</div>
<div id="outline-container-orge80fd04" class="outline-5">
<h5 id="orge80fd04">關聯式資料庫(RDBMS, Relational Database Management System)</h5>
<div class="outline-text-5" id="text-orge80fd04">
<p>
資料以資料表(table)的形式存在資料庫中，資料表之間有事先定義的關係，資料表中的一欄(column)代表某項屬性、一列(row)代表一個實體相關屬性的數值，每個資料表都具有主鍵(primary key)方便查詢，並且資料表間的關係可以透過外鍵(foreign key)建立。<br />
</p>

<div id="orgcc21a7c" class="figure">
<p><img src="images/林北的考前猜題/2025-01-28_12-43-42_1*hsMO1oCL5d1US9LcRztT-Q.png" alt="2025-01-28_12-43-42_1*hsMO1oCL5d1US9LcRztT-Q.png" width="500" /><br />
</p>
</div>
</div>
<ul class="org-ul">
<li><a id="orgd5c8990"></a>RDBMS的優點<br />
<div class="outline-text-6" id="text-orgd5c8990">
<ul class="org-ul">
<li>有ACID的特性，ACID 代表不可分割性 、一致性、獨立性和耐用性。 具有ACID 屬性的事務可確保資料庫操作的正確且可預測的執行，從而改善分析結果，最終有助於企業做出更明智的決策。<br />
<ol class="org-ol">
<li>不可分割性 (Atomic):交易必須整體成功執行，若是交易有一部分操作失敗，整個交易都會失效<br /></li>
<li>一致性 (Consistent)：做為交易的一部分寫入資料庫的資料，必須遵守所有明定規則以及約束<br /></li>
<li>獨立性 (Isolated)：達成並行控制的重要關鍵，可以確保每一個交易都是獨立的<br /></li>
<li>耐用性 (Durable)：在一個交易成功完成後，對資料庫所做的變更都是永久性的<br /></li>
</ol></li>
<li>不可分割性 (Atomic):交易必須整體成功執行，若是交易有一部分操作失敗，整個交易都會失效<br /></li>
<li>一致性 (Consistent)：做為交易的一部分寫入資料庫的資料，必須遵守所有明定規則以及約束<br /></li>
<li>獨立性 (Isolated)：達成並行控制的重要關鍵，可以確保每一個交易都是獨立的<br /></li>
<li>耐用性 (Durable)：在一個交易成功完成後，對資料庫所做的變更都是永久性的<br /></li>
<li>查詢複雜性：可以透過SQL語法，進行較複雜的查詢<br /></li>
<li>語言標準化:不像NoSQL各種資料庫有各自的操作語法，RDBMS都可使用SQL(Structured Querying Language)語言進行資料查詢與管理。<br /></li>
<li>資料庫正規化<br /></li>
<li>安全性高<br /></li>
</ul>
</div>
</li>
<li><a id="org21e83a2"></a>DBMS的缺點<br />
<div class="outline-text-6" id="text-org21e83a2">
<ul class="org-ul">
<li>橫向擴展能力低，透過垂直擴展比較能發揮優勢，但是成本較高。<br />
<ol class="org-ol">
<li>橫向擴展(Horizontal Scaling)可以想像成增加機器的數量，用不同的機器進行同一個服務，除了減緩單一機器的負擔，也可以避免當單一機器故障時，整個服務就無法使用的狀況。<br /></li>
<li>垂直擴展(Vertical Scaling)在現有的硬體上進行升級，例如升級CPU、增加RAM等。<br /></li>
</ol></li>
<li>儲存與維護成本高<br /></li>
<li>速度較慢，尤其當資料量龐大或多人同時使用服務的時候<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org2c0d97a" class="outline-5">
<h5 id="org2c0d97a">非關聯式資料庫(NoSQL, Not only SQL)</h5>
<div class="outline-text-5" id="text-org2c0d97a">
<ul class="org-ul">
<li>不同於SQL系統，NoSQL中的資料儲存不需要定義schema、也沒有固定架構，不保證ACID的特性，常用於分散式雲端系統。<br /></li>
<li><p>
典型的NOSQL如下列的JSON（JavaScript Object Notation）:<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>[
<span class="linenr"> 2: </span>   {
<span class="linenr"> 3: </span>       <span style="color: #98be65;">"year"</span> : <span style="color: #da8548; font-weight: bold;">2013</span>,
<span class="linenr"> 4: </span>       <span style="color: #98be65;">"title"</span> : <span style="color: #98be65;">"Turn It Down, Or Else!"</span>,
<span class="linenr"> 5: </span>       <span style="color: #98be65;">"info"</span> : {
<span class="linenr"> 6: </span>           <span style="color: #98be65;">"directors"</span> : [ <span style="color: #98be65;">"Alice Smith"</span>, <span style="color: #98be65;">"Bob Jones"</span>],
<span class="linenr"> 7: </span>           <span style="color: #98be65;">"release_date"</span> : <span style="color: #98be65;">"2013-01-18T00:00:00Z"</span>,
<span class="linenr"> 8: </span>           <span style="color: #98be65;">"rating"</span> : <span style="color: #da8548; font-weight: bold;">6.2</span>,
<span class="linenr"> 9: </span>           <span style="color: #98be65;">"genres"</span> : [<span style="color: #98be65;">"Comedy"</span>, <span style="color: #98be65;">"Drama"</span>],
<span class="linenr">10: </span>           <span style="color: #98be65;">"image_url"</span> : <span style="color: #98be65;">"http://ia.media-imdb.com/images/N/O9ERWAU7FS797AJ7LU8HN09AMUP908RLlo5JF90EWR7LJKQ7@@._V1_SX400_.jpg"</span>,
<span class="linenr">11: </span>           <span style="color: #98be65;">"plot"</span> : <span style="color: #98be65;">"A rock band plays their music at high volumes, annoying the neighbors."</span>,
<span class="linenr">12: </span>           <span style="color: #98be65;">"actors"</span> : [<span style="color: #98be65;">"David Matthewman"</span>, <span style="color: #98be65;">"Jonathan G. Neff"</span>]
<span class="linenr">13: </span>       }
<span class="linenr">14: </span>   },
<span class="linenr">15: </span>   {
<span class="linenr">16: </span>       <span style="color: #98be65;">"year"</span>: <span style="color: #da8548; font-weight: bold;">2015</span>,
<span class="linenr">17: </span>       <span style="color: #98be65;">"title"</span>: <span style="color: #98be65;">"The Big New Movie"</span>,
<span class="linenr">18: </span>       <span style="color: #98be65;">"info"</span>: {
<span class="linenr">19: </span>           <span style="color: #98be65;">"plot"</span>: <span style="color: #98be65;">"Nothing happens at all."</span>,
<span class="linenr">20: </span>           <span style="color: #98be65;">"rating"</span>: <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">21: </span>       }
<span class="linenr">22: </span>   }
<span class="linenr">23: </span>]
</pre>
</div></li>
<li>你有看到NOSQL如何儲存二進位的資料（圖片）嗎？很簡單，就是只存網址，這樣一來，圖片、影片這種資料就不用全部存在資料庫中，可以存放在其他檔案伺服器裡，不只彈性大，而且也可以降低資料庫伺服器的網路頻寬負擔，因為客戶在存取圖片或影片時可以由其他檔案伺服器去抓資料。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org175d275"></a>NoSQL的優點<br />
<div class="outline-text-6" id="text-org175d275">
<ul class="org-ul">
<li>橫向擴展能力佳 (Scalability):不必增加伺服器來擴大規模，可以透過分散式架構提供服務，以橫向擴展(Horizontal Scaling)的方式增加效能。<br /></li>
<li>彈性較高 (Flexibility)：NoSQL不像關聯式資料庫需要schema，可以隨意定義資料模型，因此NoSQL可以處理無特定結構或半結構式(semi-structured)的資料<br /></li>
<li>速度優勢：因為NoSQL不包含資料關聯性，查詢速度相對較快。<br /></li>
</ul>
</div>
</li>
<li><a id="org070d229"></a>NoSQL的缺點<br />
<div class="outline-text-6" id="text-org070d229">
<ul class="org-ul">
<li>資料完整度:不同於關聯式資料庫通常遵循ACID原則 (atomicity, consistency, isolation, durability)以確保資料的完整度，NoSQL較難提供ACID的保證，而是遵循BASE(basic availability, soft state, and eventual consistency) 的原則，並且可能犧牲資料的完整度。<br /></li>
<li>語言標準化:不像關聯式資料庫大多可以使用SQL語言操作，NoSQL不同的資料庫有各自獨特的語言來管理資料。<br /></li>
<li>查詢複雜性：NoSQL針對單一表格的查詢效果佳，但當資料複雜度增加，使用RDBMS的效果會更好。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5fa7b69" class="outline-4">
<h4 id="org5fa7b69"><span class="section-number-4">9.2.2.</span> JSON</h4>
<div class="outline-text-4" id="text-9-2-2">
<p>
JSON是一種基於文本的數據交換格式，源於JavaScript語言，但已被許多其他編程語言所支持。由於其簡單、易讀的語法和跨平台的兼容性，JSON成為了Web開發中廣泛使用的數據格式，尤其適用於API和AJAX應用。<br />
</p>
</div>
</div>
<div id="outline-container-org05a80c4" class="outline-4">
<h4 id="org05a80c4"><span class="section-number-4">9.2.3.</span> 雲端資料庫</h4>
</div>
<div id="outline-container-orgbbdb026" class="outline-4">
<h4 id="orgbbdb026"><span class="section-number-4">9.2.4.</span> Entity-relationship model</h4>
</div>
</div>
<div id="outline-container-orgff463cc" class="outline-3">
<h3 id="orgff463cc"><span class="section-number-3">9.3.</span> 軟體工程</h3>
<div class="outline-text-3" id="text-9-3">
</div>
<div id="outline-container-orgd9d368b" class="outline-4">
<h4 id="orgd9d368b"><span class="section-number-4">9.3.1.</span> Unit Test</h4>
</div>
</div>
<div id="outline-container-org9764a65" class="outline-3">
<h3 id="org9764a65"><span class="section-number-3">9.4.</span> AI</h3>
<div class="outline-text-3" id="text-9-4">
</div>
<div id="outline-container-org52488a6" class="outline-4">
<h4 id="org52488a6"><span class="section-number-4">9.4.1.</span> Turing Machine</h4>
</div>
<div id="outline-container-org95bffa5" class="outline-4">
<h4 id="org95bffa5"><span class="section-number-4">9.4.2.</span> Turing Test</h4>
</div>
<div id="outline-container-orga761c52" class="outline-4">
<h4 id="orga761c52"><span class="section-number-4">9.4.3.</span> Cloud Computing</h4>
</div>
<div id="outline-container-org6b961e8" class="outline-4">
<h4 id="org6b961e8"><span class="section-number-4">9.4.4.</span> Iot</h4>
</div>
<div id="outline-container-orgedaf1db" class="outline-4">
<h4 id="orgedaf1db"><span class="section-number-4">9.4.5.</span> supervised learning, unsupervised learning, reinforcement learning。</h4>
</div>
<div id="outline-container-org40b7f04" class="outline-4">
<h4 id="org40b7f04"><span class="section-number-4">9.4.6.</span> 計算梯度下降</h4>
</div>
</div>
<div id="outline-container-org7407b61" class="outline-3">
<h3 id="org7407b61"><span class="section-number-3">9.5.</span> 資管</h3>
<div class="outline-text-3" id="text-9-5">
</div>
<div id="outline-container-org14a0234" class="outline-4">
<h4 id="org14a0234"><span class="section-number-4">9.5.1.</span> Information security management</h4>
</div>
</div>
<div id="outline-container-org1159f46" class="outline-3">
<h3 id="org1159f46"><span class="section-number-3">9.6.</span> 其他</h3>
<div class="outline-text-3" id="text-9-6">
</div>
<div id="outline-container-org98c1cea" class="outline-4">
<h4 id="org98c1cea"><span class="section-number-4">9.6.1.</span> 區塊鏈</h4>
</div>
<div id="outline-container-org022e091" class="outline-4">
<h4 id="org022e091"><span class="section-number-4">9.6.2.</span> RSA 加密</h4>
</div>
<div id="outline-container-orgb459f41" class="outline-4">
<h4 id="orgb459f41"><span class="section-number-4">9.6.3.</span> 開源/閉源軟體</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Yung-Chin Yen</p>
<p class="date">Created: 2025-01-30 Thu 21:33</p>
</div>
</body>
</html>
