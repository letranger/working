<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-01-31 Fri 14:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>James Exam</title>
<meta name="author" content="Yung-Chin Yen" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../css/muse.css" />
<script src="../css/copy_code.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">James Exam</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc346f4c">1. 中央近五年計概</a>
<ul>
<li><a href="#org76b782a">1.1. prompt</a></li>
<li><a href="#org01abc6b">1.2. 108</a></li>
<li><a href="#orga1aa483">1.3. 109</a></li>
<li><a href="#org837c19d">1.4. 110</a></li>
<li><a href="#org4338374">1.5. 111</a></li>
<li><a href="#org7476fe8">1.6. 112</a></li>
</ul>
</li>
<li><a href="#orgc9cbc38">2. 中山近三年考題及詳解</a>
<ul>
<li><a href="#org3c8b5a2">2.1. 110: 中山管理資訊系統</a></li>
<li><a href="#orgfd8880e">2.2. 110: 中山資料結構</a></li>
<li><a href="#org760661e">2.3. 110: 中山資料結構</a></li>
<li><a href="#org2deba45">2.4. 110: 中山計概</a></li>
<li><a href="#org87de91a">2.5. 110: 中山計概</a></li>
<li><a href="#orgc130218">2.6. 111: 中山計概</a></li>
<li><a href="#org9754d20">2.7. 111: 管理資訊系統</a></li>
<li><a href="#org1262198">2.8. 111: 資料結構：</a></li>
<li><a href="#orgef718f2">2.9. 112: 中山計概</a></li>
<li><a href="#orgbb43d8d">2.10. 112: 中山管資</a></li>
<li><a href="#orge52e206">2.11. 112: 中山資結</a></li>
</ul>
</li>
<li><a href="#orgc91663c">3. 中山</a>
<ul>
<li><a href="#org4cce3f9">3.1. 近10年趨勢</a></li>
<li><a href="#org72aa99e">3.2. AI模擬試題</a></li>
<li><a href="#org493cba4">3.3. 參考答案</a></li>
</ul>
</li>
<li><a href="#org671a19e">4. 中興</a>
<ul>
<li><a href="#org047172b">4.1. 近10年趨勢</a></li>
<li><a href="#org547d1a3">4.2. AI模擬試題</a></li>
<li><a href="#orgb590609">4.3. 詳細解說答案</a></li>
</ul>
</li>
<li><a href="#orgb5393d8">5. 清大</a>
<ul>
<li><a href="#org0b0793e">5.1. 近10年趨勢</a></li>
<li><a href="#orgede288b">5.2. AI模擬試題</a></li>
<li><a href="#org7c0e901">5.3. 詳細解答：</a></li>
</ul>
</li>
<li><a href="#orga94c515">6. 成大</a>
<ul>
<li><a href="#orgb53c330">6.1. 近10年趨勢</a></li>
<li><a href="#org9b04aad">6.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#org0740fe1">7. 中央</a>
<ul>
<li><a href="#org54a4a44">7.1. 近10年趨勢</a></li>
<li><a href="#orga3047e6">7.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#orgef649ae">8. 北大</a>
<ul>
<li><a href="#orgae3087e">8.1. 近10年趨勢</a></li>
<li><a href="#org8dfe1e3">8.2. AI模擬試題</a></li>
</ul>
</li>
<li><a href="#org2eeae4c">9. 林北的考前猜題</a>
<ul>
<li><a href="#org7a5e20a">9.1. 網路</a></li>
<li><a href="#org7950cd3">9.2. 資料庫</a></li>
<li><a href="#org3507883">9.3. 軟體工程</a></li>
<li><a href="#org8b1b0fe">9.4. AI</a></li>
<li><a href="#org8d4462f">9.5. 資管</a></li>
<li><a href="#org2078888">9.6. 其他</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc346f4c" class="outline-2">
<h2 id="orgc346f4c"><span class="section-number-2">1.</span> 中央近五年計概</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org76b782a" class="outline-3">
<h3 id="org76b782a"><span class="section-number-3">1.1.</span> prompt</h3>
<div class="outline-text-3" id="text-1-1">
<pre class="example" id="org791977e">
提供中文詳解，並列出與該主題相關的完整計概知識，讓考生能對與該主題相關的計概有完整認識，方便準備研究所考試
</pre>
</div>
</div>
<div id="outline-container-org01abc6b" class="outline-3">
<h3 id="org01abc6b"><span class="section-number-3">1.2.</span> 108</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org422362a" class="outline-4">
<h4 id="org422362a"><span class="section-number-4">1.2.1.</span> 第一大題 (25分)：解釋名詞，每小題5分，共25分</h4>
<div class="outline-text-4" id="text-1-2-1">
</div>
<div id="outline-container-orgddc5891" class="outline-5">
<h5 id="orgddc5891">DSSS (Direct Sequence Spread Spectrum)</h5>
<div class="outline-text-5" id="text-orgddc5891">
</div>
<ul class="org-ul">
<li><a id="org4fa8d0f"></a>解<br />
<div class="outline-text-6" id="text-org4fa8d0f">
<p>
直接序列展頻技術（DSSS）是一種擴頻通信技術，用於提高無線通信的抗干擾能力。DSSS 的基本原理是將原始信號與較高頻率的偽隨機碼（Pseudo-random Noise, PN）相乘，使訊號頻譜擴展到比原來更寬的頻帶，然後再透過接收端的同步解碼還原出原始訊號。<br />
</p>
</div>
</li>
<li><a id="org58ee1da"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org58ee1da">
<ul class="org-ul">
<li>擴頻技術（Spread Spectrum）：除 DSSS 外，還有 FHSS（Frequency Hopping Spread Spectrum，跳頻擴頻）。<br /></li>
<li>CDMA（Code Division Multiple Access）：DSSS 技術是 CDMA 的基礎，允許多個使用者同時傳輸數據，而不互相干擾。<br /></li>
<li>訊號調變技術：如 BPSK（Binary Phase Shift Keying）、QPSK（Quadrature Phase Shift Keying）。<br /></li>
<li>無線網路標準：IEEE 802.11b 採用 DSSS 作為主要的傳輸技術。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc6b2c2a" class="outline-5">
<h5 id="orgc6b2c2a">PCM (Pulse-Code Modulation)</h5>
<div class="outline-text-5" id="text-orgc6b2c2a">
</div>
<ul class="org-ul">
<li><a id="orgdd3c0df"></a>解<br />
<div class="outline-text-6" id="text-orgdd3c0df">
<p>
脈衝編碼調變（PCM）是一種數位訊號編碼技術，將類比訊號（如聲音）轉換為數位訊號的標準方法。PCM 主要經歷三個步驟：<br />
</p>
<ul class="org-ul">
<li>取樣（Sampling）：按照奈奎斯特定理（Nyquist Theorem），以至少兩倍於訊號最大頻率的取樣率，將連續的類比訊號離散化。<br /></li>
<li>量化（Quantization）：將取樣值對應到有限數目的數值，使訊號可用有限比特表示。<br /></li>
<li>編碼（Encoding）：將量化後的訊號轉換為二進位碼，方便數位傳輸與存儲。<br /></li>
</ul>
</div>
</li>
<li><a id="org60718ef"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org60718ef">
<ul class="org-ul">
<li>類比與數位訊號：比較類比訊號與數位訊號的特性。<br /></li>
<li>取樣定理（Sampling Theorem）：奈奎斯特定理是 PCM 設計的重要依據。<br /></li>
<li>數位音訊格式：如 WAV、MP3、AAC，均基於 PCM 或其變種。<br /></li>
<li>音訊壓縮技術：如 μ-law 和 A-law 是 PCM 的變體，常見於電話通訊。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org25cd9cc" class="outline-5">
<h5 id="org25cd9cc">VLAN (Virtual Local Area Network)</h5>
<div class="outline-text-5" id="text-org25cd9cc">
</div>
<ul class="org-ul">
<li><a id="orgfdc9a20"></a>解<br />
<div class="outline-text-6" id="text-orgfdc9a20">
<p>
虛擬區域網路（VLAN）是一種透過邏輯分割網路的技術，即使裝置連接在同一台交換機，也能透過 VLAN 區分不同網段，提升網路安全性與管理性。VLAN 的主要特性包括：<br />
</p>
<ul class="org-ul">
<li>邏輯分割網路：可以將不同部門或用途的設備分隔，即使它們在相同的物理網路內。<br /></li>
<li>降低廣播流量：VLAN 可防止廣播訊息影響不相關的裝置，提升網路效能。<br /></li>
<li>增強安全性：不同 VLAN 之間的流量通常需要透過路由器或防火牆管控。<br /></li>
</ul>
</div>
</li>
<li><a id="org3de63f9"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org3de63f9">
<ul class="org-ul">
<li>區域網路（LAN）技術：Ethernet、Wi-Fi 與 LAN 設計概念。<br /></li>
<li>網路層級架構：OSI 模型中 VLAN 屬於第二層（資料鏈結層）。<br /></li>
<li>交換機（Switch）技術：VLAN 主要由管理型交換機（Managed Switch）實現。<br /></li>
<li>802.1Q 標準：VLAN 標記技術，允許一條連接傳輸多個 VLAN。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5a25e9b" class="outline-5">
<h5 id="org5a25e9b">DMZ (Demilitarized Zone)</h5>
<div class="outline-text-5" id="text-org5a25e9b">
</div>
<ul class="org-ul">
<li><a id="org5a67fa3"></a>解<br />
<div class="outline-text-6" id="text-org5a67fa3">
<p>
非軍事區（DMZ） 是網路架構中一個受控的區域，通常位於內部網路（LAN）與外部網路（如 Internet）之間，主要用於公開提供網路服務，如 Web 伺服器、郵件伺服器或 DNS 伺服器。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgfab8f74"></a>DMZ 的設計<br />
<div class="outline-text-7" id="text-orgfab8f74">
<ul class="org-ul">
<li>隔離內部網路：外部使用者只能存取 DMZ 內的服務，無法直接進入內部 LAN。<br /></li>
<li>防火牆控制：DMZ 透過防火牆規則限制內部與外部的存取權限。<br /></li>
<li>雙防火牆架構：<br />
<ul class="org-ul">
<li>單防火牆 DMZ：使用一台防火牆區分內網、DMZ 與外部網路。<br /></li>
<li>雙防火牆 DMZ：外部防火牆限制 Internet 存取 DMZ，內部防火牆限制 DMZ 存取內部網路，安全性更高。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orge033637"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-orge033637">
<ul class="org-ul">
<li>網路安全技術：如防火牆（Firewall）、入侵偵測系統（IDS）、入侵防禦系統（IPS）。<br /></li>
<li>TCP/IP 及網路服務：如 HTTP、HTTPS、DNS 及其安全性。<br /></li>
<li>VPN（Virtual Private Network）：透過 VPN 提供安全的遠端存取，但需要正確配置 DMZ 來管理 VPN 存取控制。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org574615d"></a>入侵偵測系統（IDS - Intrusion Detection System）<br />
<div class="outline-text-7" id="text-org574615d">
<p>
概念與功能 入侵偵測系統（IDS）是一種監控網路或系統活動，以檢測可疑行為或潛在攻擊的安全設備。其主要目的是發現並告警潛在的安全威脅，而不會自動採取行動阻止攻擊。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgaae6975"></a>IDS 的分類<br />
<div class="outline-text-8" id="text-orgaae6975">
<ul class="org-ul">
<li>網路型 IDS（NIDS - Network-based IDS）<br />
<ul class="org-ul">
<li>部署於網路節點（如路由器、交換機），監控整個網路的流量。<br /></li>
<li>優點：可全面監控網路中的所有通信。<br /></li>
<li>缺點：難以檢測加密通信內的攻擊。<br /></li>
</ul></li>
<li>主機型 IDS（HIDS - Host-based IDS）<br />
<ul class="org-ul">
<li>部署於單一主機或伺服器，監控該主機的操作與系統日誌。<br /></li>
<li>優點：能夠檢測主機內部的異常活動，如未經授權的文件修改。<br /></li>
<li>缺點：僅限於監控所在主機，無法偵測其他網路活動。<br /></li>
</ul></li>
</ul>
<p>
偵測方法<br />
</p>
<ul class="org-ul">
<li>特徵匹配（Signature-based Detection）<br />
<ul class="org-ul">
<li>利用已知攻擊的特徵（如病毒碼、特定封包模式）進行比對。<br /></li>
<li>優點：準確率高，對已知威脅反應迅速。<br /></li>
<li>缺點：無法偵測新型或未知攻擊。<br /></li>
</ul></li>
<li>異常偵測（Anomaly-based Detection）<br />
<ul class="org-ul">
<li>建立正常行為的基準（Baseline），並檢測異常行為。<br /></li>
<li>優點：能夠發現未知或新型攻擊。<br /></li>
<li>缺點：誤報率高，需定期更新基準。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgf6e951f"></a>入侵防禦系統（IPS - Intrusion Prevention System）<br />
<div class="outline-text-7" id="text-orgf6e951f">
<p>
概念與功能 入侵防禦系統（IPS）是一種在偵測攻擊的同時，自動採取行動以防止攻擊成功的安全設備。與 IDS 不同，IPS 具有主動防禦功能。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8b012be"></a>IPS 的類型<br />
<div class="outline-text-8" id="text-org8b012be">
<ul class="org-ul">
<li>網路型 IPS（NIPS - Network-based IPS）<br />
<ul class="org-ul">
<li>部署於網路邊界，主動攔截和阻止惡意流量。<br /></li>
<li>常見於企業網路邊界，以阻擋外部攻擊。<br /></li>
</ul></li>
<li>主機型 IPS（HIPS - Host-based IPS）<br />
<ul class="org-ul">
<li>部署於單一主機或伺服器，針對該主機的攻擊進行防禦。<br /></li>
<li>適用於高敏感性資料伺服器或關鍵基礎設施。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgb27af1f"></a>防禦策略<br />
<div class="outline-text-8" id="text-orgb27af1f">
<ul class="org-ul">
<li>封包過濾（Packet Filtering）<br />
<ul class="org-ul">
<li>根據封包內容或規則集直接丟棄惡意封包。<br /></li>
</ul></li>
<li>連線重置（Connection Reset）<br />
<ul class="org-ul">
<li>主動終止攻擊者與受害者之間的連線。<br /></li>
</ul></li>
<li>警報與記錄（Alerting and Logging）<br />
<ul class="org-ul">
<li>在防禦攻擊的同時，發送警報並記錄相關資訊供事後分析。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0525602"></a>IPS 的挑戰<br />
<div class="outline-text-8" id="text-org0525602">
<ul class="org-ul">
<li>需在不影響合法流量的情況下，迅速阻擋惡意行為。<br /></li>
<li>調整錯誤或過於嚴格的規則可能導致合法操作被誤判為攻擊。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org2b2ef9c" class="outline-5">
<h5 id="org2b2ef9c">CDN (Content Delivery Network)</h5>
<div class="outline-text-5" id="text-org2b2ef9c">
<p>
非軍事區（DMZ） 是網路架構中一個受控的區域，通常位於內部網路（LAN）與外部網路（如 Internet）之間，主要用於公開提供網路服務，如 Web 伺服器、郵件伺服器或 DNS 伺服器。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org8f1a403"></a>DMZ 的設計<br />
<div class="outline-text-6" id="text-org8f1a403">
<ul class="org-ul">
<li>隔離內部網路：外部使用者只能存取 DMZ 內的服務，無法直接進入內部 LAN。<br /></li>
<li>防火牆控制：DMZ 透過防火牆規則限制內部與外部的存取權限。<br /></li>
<li>雙防火牆架構：<br />
<ul class="org-ul">
<li>單防火牆 DMZ：使用一台防火牆區分內網、DMZ 與外部網路。<br /></li>
<li>雙防火牆 DMZ：外部防火牆限制 Internet 存取 DMZ，內部防火牆限制 DMZ 存取內部網路，安全性更高。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgfcd3a5a"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-orgfcd3a5a">
<ul class="org-ul">
<li>網路安全技術：如防火牆（Firewall）、入侵偵測系統（IDS）、入侵防禦系統（IPS）。<br /></li>
<li>TCP/IP 及網路服務：如 HTTP、HTTPS、DNS 及其安全性。<br /></li>
<li>VPN（Virtual Private Network）：透過 VPN 提供安全的遠端存取，但需要正確配置 DMZ 來管理 VPN 存取控制。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org02b75f7" class="outline-4">
<h4 id="org02b75f7"><span class="section-number-4">1.2.2.</span> 第二大題 (10分)：</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
在Relational Database裡，每個Table基本上都會有一欄當做Primary Key。許多情況下常使用auto increment 或UUID當作Primary Key，並列舉說明這樣做為primary key的優缺點<br />
</p>
</div>
<div id="outline-container-orgb6788bc" class="outline-5">
<h5 id="orgb6788bc">解</h5>
<div class="outline-text-5" id="text-orgb6788bc">
<p>
在關聯式資料庫（Relational Database, RDB）中，每個表（Table）通常都有一個主鍵（Primary Key, PK）來唯一標識每一筆記錄。常見的 PK 產生方式有兩種：<br />
</p>
<ul class="org-ul">
<li>Auto Increment（自動遞增）<br /></li>
<li>UUID（通用唯一識別碼，Universally Unique Identifier）<br /></li>
</ul>
<p>
這兩種方式各有優缺點，在不同的應用場景下選擇合適的 PK 類型至關重要。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgc65d248"></a>Auto Increment 作為 Primary Key<br />
<div class="outline-text-6" id="text-orgc65d248">
<p>
Auto Increment 是一種常見的主鍵生成方式，資料庫會自動為新插入的資料分配一個遞增的數值。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>CREATE <span style="color: #ECBE7B;">TABLE</span> <span style="color: #c678dd;">users</span> (
<span class="linenr">2: </span>    id INT AUTO_INCREMENT <span style="color: #ECBE7B;">PRIMARY</span> <span style="color: #dcaeea;">KEY</span>,
<span class="linenr">3: </span>    <span style="color: #ECBE7B;">name</span> <span style="color: #dcaeea;">VARCHAR</span>(<span style="color: #da8548; font-weight: bold;">255</span>),
<span class="linenr">4: </span>    <span style="color: #ECBE7B;">email</span> <span style="color: #dcaeea;">VARCHAR</span>(<span style="color: #da8548; font-weight: bold;">255</span>)
<span class="linenr">5: </span>);
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org9bcf7bc"></a>優點<br />
<div class="outline-text-7" id="text-org9bcf7bc">
<ul class="org-ul">
<li>✅ 數值型索引效率高: 整數（INT, BIGINT）索引比字串（UUID）索引快，搜尋、排序、JOIN 操作效率較高。<br />
B+ 樹索引（如 InnoDB）適用遞增值，有助於保持索引的平衡與效能。<br /></li>
<li>✅ 空間效率高: 整數通常比 UUID 佔用的空間小（INT 佔 4 Bytes，BIGINT 佔 8 Bytes，而 UUID 通常為 16 Bytes）。<br /></li>
<li><p>
✅ 易讀性高: 記錄 ID 連續遞增，方便查詢與理解，例如：<br />
</p>
<pre class="example" id="org6e3645a">
  User ID: 1, 2, 3, 4, 5
</pre></li>
<li>✅ INSERT 操作更高效: 自增 ID 讓 INSERT 操作集中在索引的最後一個位置，降低分裂索引頁的機率，提高寫入效能。<br /></li>
</ul>
</div>
</li>
<li><a id="org60c98a4"></a>缺點<br />
<div class="outline-text-7" id="text-org60c98a4">
<ul class="org-ul">
<li>❌ 複製數據時可能會有 ID 衝突: 例如，將資料從一個數據庫複製到另一個時，兩邊的 ID 可能重複，導致衝突，特別是在分布式環境下。<br /></li>
<li>❌ 容易被猜測: 由於 ID 遞增，攻擊者可以預測下一筆記錄的 ID，進行 ID 爬取攻擊（如：/user/123、/user/124&#x2026;）。<br /></li>
<li>❌ 在分布式系統中擴展性較差: 在多個節點的數據庫中，確保不同節點間的 ID 唯一性需要額外的處理，例如透過 分區自增 ID 或 雪花算法（Snowflake ID） 來解決。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org23b0d1c"></a>UUID 作為 Primary Key<br />
<div class="outline-text-6" id="text-org23b0d1c">
<p>
UUID（通用唯一識別碼） 是一種全球唯一識別碼，格式通常為 36 個字元（包含 -）。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>CREATE <span style="color: #ECBE7B;">TABLE</span> <span style="color: #c678dd;">users</span> (
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">id</span> <span style="color: #dcaeea;">CHAR</span>(<span style="color: #da8548; font-weight: bold;">36</span>) <span style="color: #ECBE7B;">PRIMARY</span> <span style="color: #dcaeea;">KEY</span>,
<span class="linenr">3: </span>    <span style="color: #dcaeea;">name</span> VARCHAR(<span style="color: #da8548; font-weight: bold;">255</span>),
<span class="linenr">4: </span>    <span style="color: #dcaeea;">email</span> VARCHAR(<span style="color: #da8548; font-weight: bold;">255</span>)
<span class="linenr">5: </span>);
</pre>
</div>
<p>
UUID 主要有幾種類型：<br />
</p>
<ul class="org-ul">
<li>UUID v1：基於時間戳與機器 MAC 位址，適合時間順序排序。<br /></li>
<li>UUID v4：完全隨機生成，無法預測，適合隱私需求高的應用。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgcbce85f"></a>優點<br />
<div class="outline-text-7" id="text-orgcbce85f">
<ul class="org-ul">
<li>✅ 唯一性強: UUID 透過算法生成，即使在不同伺服器或資料庫節點，也能保證唯一性，適合 分布式架構 或 微服務。<br /></li>
<li>✅ 不易被猜測: 由於 UUID 並非連續數值，不容易被攻擊者預測，提升安全性。<br /></li>
<li>✅ 資料合併與同步更方便: 在多個資料來源合併時，不需要擔心主鍵衝突，適合 分布式資料庫 或 資料同步系統。<br /></li>
<li>✅ 支援跨伺服器生成: 例如，在微服務架構中，每個服務可以獨立生成 UUID，而不需要查詢數據庫獲取 ID。<br /></li>
</ul>
</div>
</li>
<li><a id="org3ae8836"></a>缺點<br />
<div class="outline-text-7" id="text-org3ae8836">
<ul class="org-ul">
<li>❌ 索引效能較差: UUID 是 字串（CHAR(36)） 或 16 Bytes 二進制數據（BINARY(16)），比起 整數（INT, BIGINT） 更佔空間，影響索引效能。<br /></li>
<li>❌ 存儲成本高: UUID 以 字串存儲（36 Bytes）或 二進制存儲（16 Bytes），相較於 INT（4 Bytes）或 BIGINT（8 Bytes），存儲效率較低。<br /></li>
<li>❌ 讀取效率較低: UUID 的隨機性會導致 索引分裂（Index Fragmentation），影響數據檢索效能，特別是在 B+ 樹索引 中。<br /></li>
<li><p>
❌ 可讀性差: UUID 難以手動輸入、理解和比較，例如：<br />
</p>
<pre class="example" id="org4bf4acb">
  550e8400-e29b-41d4-a716-446655440000
</pre></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgeaf0349"></a>Auto Increment vs UUID 選擇指南<br />
<div class="outline-text-6" id="text-orgeaf0349">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">Auto Increment</th>
<th scope="col" class="org-left">UUID</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">唯一性</td>
<td class="org-left">只在單一資料庫唯一</td>
<td class="org-left">全球唯一</td>
</tr>

<tr>
<td class="org-left">索引效能</td>
<td class="org-left">高（整數索引效率佳）</td>
<td class="org-left">低（UUID 影響索引）</td>
</tr>

<tr>
<td class="org-left">存儲空間</td>
<td class="org-left">小（INT: 4 Bytes, BIGINT: 8 Bytes）</td>
<td class="org-left">大（CHAR(36): 36 Bytes, BINARY(16): 16 Bytes）</td>
</tr>

<tr>
<td class="org-left">INSERT 效能</td>
<td class="org-left">佳（遞增 ID 避免索引分裂）</td>
<td class="org-left">差（UUID 隨機性導致索引分裂）</td>
</tr>

<tr>
<td class="org-left">可讀性</td>
<td class="org-left">佳（1, 2, 3&#x2026;）</td>
<td class="org-left">差（550e8400-e29b&#x2026;）</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">易猜測、可被爬取</td>
<td class="org-left">不易猜測、較安全</td>
</tr>

<tr>
<td class="org-left">分布式支持</td>
<td class="org-left">需要特殊設計（如雪花算法）</td>
<td class="org-left">天生適合</td>
</tr>
</tbody>
</table>
</div>
<ul class="org-ul">
<li><a id="org2959c64"></a>適用場景<br />
<div class="outline-text-7" id="text-org2959c64">
<ul class="org-ul">
<li>✅ Auto Increment 適用於<br />
<ul class="org-ul">
<li>傳統單節點數據庫<br /></li>
<li>需要高效能查詢的應用（如報表、統計系統）<br /></li>
<li>需要可讀性佳的流水號（如訂單號）<br /></li>
</ul></li>
<li>✅ UUID 適用於<br />
<ul class="org-ul">
<li>分布式系統（如微服務架構、跨資料庫同步）<br /></li>
<li>安全性要求高的應用（如 API Token、用戶識別碼）<br /></li>
<li>避免 ID 爬取攻擊（防止猜測 ID）<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgefc5fb4" class="outline-4">
<h4 id="orgefc5fb4"><span class="section-number-4">1.2.3.</span> 第三大題 (3分)：</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
簡單說明什麼是SQL Injection<br />
</p>
</div>
<div id="outline-container-org89856ce" class="outline-5">
<h5 id="org89856ce">解</h5>
<div class="outline-text-5" id="text-org89856ce">
<p>
SQL Injection（SQL 注入攻擊） 是一種 攻擊者利用惡意 SQL 語句操控資料庫 的攻擊方式。這類攻擊通常發生於 應用程式未對使用者輸入進行適當驗證，導致攻擊者可以插入惡意 SQL 查詢，進而竊取、修改、刪除數據，甚至控制整個資料庫。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgfde8a73"></a>SQL Injection 的運作原理<br />
<div class="outline-text-6" id="text-orgfde8a73">
<p>
當應用程式直接將 使用者輸入 插入 SQL 查詢時，若未經適當處理，攻擊者就能惡意構造輸入，使 SQL 語句的行為偏離預期。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7a3dde9"></a>❌ 例：不安全的 SQL 查詢<br />
<div class="outline-text-7" id="text-org7a3dde9">
<p>
假設一個網站的登入系統接收使用者輸入的 帳號（username） 和 密碼（password），然後執行以下 SQL 語句：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">'</span><span style="color: #da8548; font-weight: bold;">123456</span><span style="color: #ECBE7B;">'</span>;
</pre>
</div>
<p>
如果程式直接將使用者輸入拼接到 SQL 查詢：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>query = <span style="color: #98be65;">"SELECT * FROM users WHERE username = '"</span> + user_input + <span style="color: #98be65;">"' AND password = '"</span> + password_input + <span style="color: #98be65;">"';"</span>
</pre>
</div>
<p>
攻擊者可以輸入：<br />
</p>
<ul class="org-ul">
<li>帳號：admin&rsquo; &#x2013;<br /></li>
<li>密碼：任何內容（因為後面會被註解掉）<br /></li>
</ul>
<p>
最終 SQL 語句變為：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> -- <span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">'</span><span style="color: #da8548; font-weight: bold;">123456</span><span style="color: #ECBE7B;">'</span>;
</pre>
</div>
<p>
其中 &#x2013; 是 SQL 的註解符號，使後面的 AND password = &rsquo;123456&rsquo; 變成註解，導致登入密碼檢查被繞過，攻擊者可以直接登入 admin 帳號。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgf84ec67"></a>SQL Injection 的類型<br />
<div class="outline-text-6" id="text-orgf84ec67">
<p>
SQL 注入攻擊的類型可分為幾種：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgdee5d52"></a>（1）Classic SQL Injection（傳統 SQL 注入）<br />
<div class="outline-text-7" id="text-orgdee5d52">
<ul class="org-ul">
<li>利用 &rsquo; OR &rsquo;1&rsquo;=&rsquo;1 之類的條件繞過身份驗證。<br /></li>
<li>目標：繞過登入、讀取資料庫內容。<br /></li>
</ul>
<p>
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">''</span> OR <span style="color: #98be65;">'1'</span>=<span style="color: #98be65;">'1'</span> -- <span style="color: #ECBE7B;">'</span> AND password = <span style="color: #ECBE7B;">''</span>;
</pre>
</div>

<p>
此語句總是成立，導致所有使用者的資訊被查詢出來。<br />
</p>
</div>
</li>
<li><a id="org0a56d2f"></a>（2）Blind SQL Injection（盲目 SQL 注入）<br />
<div class="outline-text-7" id="text-org0a56d2f">
<p>
當應用程式不直接顯示錯誤訊息時，攻擊者可以透過邏輯推測資料庫的內容。<br />
常見技術<br />
</p>
<ul class="org-ul">
<li>布林盲注（Boolean-Based Blind SQL Injection）：攻擊者觀察網頁回應變化來判斷條件是否成立。<br /></li>
<li>時間盲注（Time-Based Blind SQL Injection）：利用 SLEEP() 來判斷資料庫是否執行了攻擊語句。<br /></li>
</ul>

<p>
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>SELECT * FROM users WHERE username = <span style="color: #ECBE7B;">'</span>admin<span style="color: #ECBE7B;">'</span> AND IF(LENGTH(password)&gt;<span style="color: #da8548; font-weight: bold;">6</span>, SLEEP(<span style="color: #da8548; font-weight: bold;">5</span>), <span style="color: #da8548; font-weight: bold;">0</span>);
</pre>
</div>
<p>
如果 password 長度大於 6，查詢執行時間會延遲 5 秒，攻擊者可據此推測密碼長度。<br />
</p>
</div>
</li>
<li><a id="org2fcfd3d"></a>（3）Union-Based SQL Injection（聯合查詢 SQL 注入）<br />
<div class="outline-text-7" id="text-org2fcfd3d">
<p>
利用 UNION 語法將攻擊者的查詢結果與原查詢結果合併，竊取資料。<br />
範例<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">SELECT</span> <span style="color: #dcaeea;">username</span>, <span style="color: #dcaeea;">password</span> FROM users WHERE id = <span style="color: #da8548; font-weight: bold;">1</span> UNION SELECT database(), <span style="color: #c678dd;">version</span>();
</pre>
</div>
<p>
如果應用程式回傳查詢結果，攻擊者可獲得資料庫名稱與版本資訊。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org5eccc95"></a>3. SQL Injection 的影響<br />
<div class="outline-text-6" id="text-org5eccc95">
<p>
SQL Injection 可能造成：<br />
</p>
<ul class="org-ul">
<li>未授權存取：攻擊者可以繞過登入系統，獲取管理員權限。<br /></li>
<li>資料竊取：攻擊者可讀取敏感資訊，如 用戶名、密碼、信用卡資訊。<br /></li>
<li>資料修改或刪除：攻擊者可刪除資料表或修改重要數據。<br /></li>
<li>系統破壞：透過 DROP TABLE 或 執行系統命令（在支援 xp_cmdshell 的 SQL Server 上）。<br /></li>
<li>進一步攻擊：攻擊者可植入惡意程式、取得伺服器控制權。<br /></li>
</ul>
</div>
</li>
<li><a id="orge7919a1"></a>4. 防範 SQL Injection<br />
<ul class="org-ul">
<li><a id="org9f0240f"></a>✅ （1）使用 Prepared Statements（預處理語句）<br />
<div class="outline-text-7" id="text-org9f0240f">
<p>
預防 SQL Injection 最有效的方法之一是 使用 Prepared Statements，確保 SQL 語句的結構不被用戶輸入影響。<br />
Python + MySQL<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>cursor.execute(<span style="color: #98be65;">"SELECT * FROM users WHERE username = %s AND password = %s"</span>, (username, password))
</pre>
</div>
<p>
這樣 username 和 password 會被安全地當作參數處理，而不會改變 SQL 結構。<br />
</p>
</div>
</li>
<li><a id="orgf5a1f80"></a>✅ （2）使用 ORM（Object-Relational Mapping）<br />
<div class="outline-text-7" id="text-orgf5a1f80">
<p>
ORM 框架（如 Django ORM、SQLAlchemy）內建安全機制，減少直接寫 SQL 語句的風險。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>User.objects.filter(username=username, password=password).first()
</pre>
</div>
</div>
</li>
<li><a id="orgc8809a2"></a>✅ （3）輸入驗證（Input Validation）<br />
<div class="outline-text-7" id="text-orgc8809a2">
<p>
限制使用者輸入的格式，拒絕包含 SQL 語法的輸入：<br />
</p>
<ul class="org-ul">
<li>過濾特殊字元（如 &rsquo;, ", &#x2013;, ;, /* */）。<br /></li>
<li>強制數字輸入（如 ID 應只能是數字）。<br /></li>
</ul>
</div>
</li>
<li><a id="orgb04c193"></a>✅ （4）最小權限原則（Least Privilege Principle）<br />
<div class="outline-text-7" id="text-orgb04c193">
<p>
應用程式使用的 資料庫帳號應有最小權限，例如：<br />
</p>
<ul class="org-ul">
<li>讀取操作：只授權 SELECT。<br /></li>
<li>寫入操作：只授權 INSERT、UPDATE，避免 DROP、DELETE。<br /></li>
</ul>
</div>
</li>
<li><a id="org3d1d825"></a>✅ （5）使用 Web Application Firewall（WAF）<br />
<div class="outline-text-7" id="text-org3d1d825">
<p>
WAF（網頁應用程式防火牆） 可攔截 SQL Injection 攻擊，如 ModSecurity 可偵測 SQL 注入模式。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org7ac929f" class="outline-4">
<h4 id="org7ac929f"><span class="section-number-4">1.2.4.</span> 第四大題 (12分)：</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
列舉與說明三個防範 SQL Injection 的方法<br />
</p>
</div>
<div id="outline-container-org012f382" class="outline-5">
<h5 id="org012f382">解</h5>
<div class="outline-text-5" id="text-org012f382">
<p>
SQL Injection（SQL 注入）是一種嚴重的安全漏洞，攻擊者可以透過惡意 SQL 語句操控資料庫。為了防止 SQL Injection，開發者應該採取以下 三種主要防範方法：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgd3034a7"></a>1. 使用 Prepared Statements（預處理語句）<br />
<div class="outline-text-6" id="text-orgd3034a7">
<p>
📌 原理: Prepared Statements（預處理語句）可確保使用者輸入的數據不會影響 SQL 語句的結構，而是作為純粹的參數處理。這種方式會將 SQL 語句與數據分開處理，避免惡意 SQL 語句被執行。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgba0962a"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-orgba0962a">
<p>
Python（MySQL）<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">import</span> mysql.connector
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #dcaeea;">conn</span> = mysql.connector.connect(user=<span style="color: #98be65;">'root'</span>, password=<span style="color: #98be65;">'password'</span>, database=<span style="color: #98be65;">'test_db'</span>)
<span class="linenr">4: </span><span style="color: #dcaeea;">cursor</span> = conn.cursor(prepared=<span style="color: #a9a1e1;">True</span>)
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = %s AND password = %s"</span>
<span class="linenr">7: </span>cursor.execute(query, (username, password))
<span class="linenr">8: </span>
<span class="linenr">9: </span><span style="color: #dcaeea;">result</span> = cursor.fetchall()
</pre>
</div>
<p>
PHP（PDO）<br />
</p>
<div class="org-src-container">
<pre class="src src-php"><span class="linenr">1: </span>$<span style="color: #dcaeea;">stmt</span> = $<span style="color: #dcaeea;">pdo</span>-&gt;prepare<span style="color: #51afef;">(</span><span style="color: #98be65;">"SELECT * FROM users WHERE username = ? AND password = ?"</span><span style="color: #51afef;">)</span>;
<span class="linenr">2: </span>$<span style="color: #dcaeea;">stmt</span>-&gt;execute<span style="color: #51afef;">(</span><span style="color: #c678dd;">[</span>$<span style="color: #dcaeea;">username</span>, $<span style="color: #dcaeea;">password</span><span style="color: #c678dd;">]</span><span style="color: #51afef;">)</span>;
</pre>
</div>
<p>
這樣，即使攻擊者輸入 admin&rsquo; &#x2013;，數據庫也會將其視為 字串參數，而不是 SQL 語法，從而防止 SQL Injection。<br />
</p>
</div>
</li>
<li><a id="org18f6162"></a>❌ 錯誤做法（易受 SQL Injection 攻擊）<br />
<div class="outline-text-7" id="text-org18f6162">
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = '"</span> + username + <span style="color: #98be65;">"' AND password = '"</span> + password + <span style="color: #98be65;">"';"</span>
<span class="linenr">2: </span>cursor.execute(query)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#30452;&#25509;&#25340;&#25509; SQL&#65292;&#23481;&#26131;&#36973;&#21463;&#25915;&#25802;&#65281;</span>
</pre>
</div>
</div>
</li>
<li><a id="org16ed998"></a>🔹 優點<br />
<div class="outline-text-7" id="text-org16ed998">
<ul class="org-ul">
<li>✔ 完全防止 SQL Injection，因為 SQL 語句與數據分開處理<br /></li>
<li>✔ 可讀性高，寫法標準化，適用於各種程式語言（Python、Java、PHP）<br /></li>
<li>✔ 提升效能，因為 SQL 只需解析一次，之後只需替換變數<br /></li>
</ul>
</div>
</li>
<li><a id="org6ab961a"></a>🔻 缺點<br />
<div class="outline-text-7" id="text-org6ab961a">
<ul class="org-ul">
<li>❌ 需要資料庫支援（大多數現代資料庫如 MySQL、PostgreSQL、SQL Server 都支援）<br /></li>
<li>❌ 可能比單純的 SQL 拼接稍微增加開發複雜度<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orge1b2f79"></a>2. 使用 ORM（Object-Relational Mapping）<br />
<div class="outline-text-6" id="text-orge1b2f79">
<p>
📌 原理: ORM（物件關聯映射）允許開發者使用程式語言的物件來操作資料庫，而 不直接寫 SQL，從而減少 SQL Injection 風險。ORM 內建了 SQL Injection 防禦機制，自動處理 SQL 參數化。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgbfdb0ab"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-orgbfdb0ab">
<p>
Python（Django ORM）<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">from</span> myapp.models <span style="color: #51afef;">import</span> User
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #dcaeea;">user</span> = User.objects.get(username=username)
</pre>
</div>
<p>
Java（Hibernate ORM）<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Query query = session.createQuery(<span style="color: #98be65;">"FROM User WHERE username = :username"</span>);
<span class="linenr">2: </span>query.setParameter(<span style="color: #98be65;">"username"</span>, username);
<span class="linenr">3: </span>User user = (User) query.uniqueResult();
</pre>
</div>
<p>
在 ORM 中，輸入的數據會被自動轉換為參數，不會影響 SQL 結構，因此 無法被惡意 SQL 語法改變。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org153b54b"></a>🔹 優點<br />
<div class="outline-text-8" id="text-org153b54b">
<ul class="org-ul">
<li>✔ 防止 SQL Injection，因為 ORM 自動使用參數化查詢<br /></li>
<li>✔ 提高開發效率，開發者不需要直接寫 SQL<br /></li>
<li>✔ 支援多種資料庫，無需針對不同資料庫寫不同 SQL 語法<br /></li>
</ul>
</div>
</li>
<li><a id="org4876dc2"></a>🔻 缺點<br />
<div class="outline-text-8" id="text-org4876dc2">
<ul class="org-ul">
<li>❌ ORM 執行效率可能比原生 SQL 稍慢<br /></li>
<li>❌ 學習成本較高，需要熟悉 ORM 語法<br /></li>
<li>❌ 靈活性較低，對於複雜的 SQL 查詢（如 UNION、JOIN）可能不夠高效<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org446da3b"></a>3. 限制使用者輸入（Input Validation &amp; Whitelisting）<br />
<ul class="org-ul">
<li><a id="org33a1678"></a>📌 原理<br />
<div class="outline-text-7" id="text-org33a1678">
<ul class="org-ul">
<li>限制輸入值的格式，確保使用者輸入內容符合預期。<br /></li>
<li>避免 SQL 特殊字符，如 &rsquo;, ", &#x2013;, ;, <i>* *</i> 等。<br /></li>
<li>使用 白名單（Whitelisting） 而不是黑名單（Blacklisting），因為黑名單容易被繞過。<br /></li>
</ul>
</div>
</li>
<li><a id="org77a2e03"></a>✅ 正確做法<br />
<div class="outline-text-7" id="text-org77a2e03">
<p>
限制輸入類型<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">import</span> re
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">is_valid_username</span>(username):
<span class="linenr">4: </span>    <span style="color: #51afef;">return</span> <span style="color: #c678dd;">bool</span>(re.<span style="color: #51afef;">match</span>(<span style="color: #98be65;">"^[a-zA-Z0-9_]+$"</span>, username))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#21482;&#20801;&#35377;&#33521;&#25991;&#23383;&#27597;&#12289;&#25976;&#23383;&#21644;&#24213;&#32218;</span>
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #51afef;">if</span> is_valid_username(user_input):
<span class="linenr">7: </span>    <span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE username = %s"</span>
<span class="linenr">8: </span>    cursor.execute(query, (user_input,))
</pre>
</div>
<p>
這樣，即使攻擊者輸入 admin&rsquo; OR &rsquo;1&rsquo;=&rsquo;1 也會被過濾掉，避免 SQL Injection。<br />
</p>

<p>
範例：只允許數字作為 ID<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">is_valid_id</span>(user_id):
<span class="linenr">2: </span>    <span style="color: #51afef;">return</span> user_id.isdigit()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#21482;&#20801;&#35377;&#25976;&#23383;</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #51afef;">if</span> is_valid_id(user_input):
<span class="linenr">5: </span>    <span style="color: #dcaeea;">query</span> = <span style="color: #98be65;">"SELECT * FROM users WHERE id = %s"</span>
<span class="linenr">6: </span>    cursor.execute(query, (user_input,))
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org10aecab"></a>🔹 優點<br />
<div class="outline-text-8" id="text-org10aecab">
<ul class="org-ul">
<li>✔ 減少 SQL Injection 風險，確保輸入符合預期<br /></li>
<li>✔ 簡單易行，無需更改 SQL 語句，只需檢查輸入<br /></li>
</ul>
</div>
</li>
<li><a id="org35f5e92"></a>🔻 缺點<br />
<div class="outline-text-8" id="text-org35f5e92">
<ul class="org-ul">
<li>❌ 無法完全防止 SQL Injection，需要配合 Prepared Statements 或 ORM<br /></li>
<li>❌ 可能影響使用者體驗，如果輸入限制太嚴格，會導致合法使用者無法輸入符合需求的數據<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="org3b4e899"></a>總結：三種 SQL Injection 防禦方法比較<br />
<div class="outline-text-6" id="text-org3b4e899">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">方法</td>
<td class="org-left">安全性</td>
<td class="org-left">易用性</td>
<td class="org-left">效能</td>
<td class="org-left">適用場景</td>
</tr>

<tr>
<td class="org-left">Prepared Statements</td>
<td class="org-left">✅✅✅（最安全）</td>
<td class="org-left">✅（稍需修改 SQL 語法）</td>
<td class="org-left">✅✅（SQL 優化）</td>
<td class="org-left">所有 SQL 應用</td>
</tr>

<tr>
<td class="org-left">ORM（物件關聯映射）</td>
<td class="org-left">✅✅（內建防 SQL Injection 機制）</td>
<td class="org-left">❌（需學習 ORM 框架）</td>
<td class="org-left">❌（有些情況較慢）</td>
<td class="org-left">需要簡化開發流程的應用</td>
</tr>

<tr>
<td class="org-left">輸入驗證（Whitelisting）</td>
<td class="org-left">✅（可降低風險）</td>
<td class="org-left">✅✅（簡單實現）</td>
<td class="org-left">✅✅（無額外效能開銷）</td>
<td class="org-left">簡單數據驗證，與其他方法搭配使用</td>
</tr>
</tbody>
</table>
<p>
最佳防禦策略<br />
</p>
<ul class="org-ul">
<li>優先使用 Prepared Statements（最佳選擇）<br /></li>
<li>若使用 ORM，確保 ORM 自帶的安全機制<br /></li>
<li>配合輸入驗證，過濾非預期輸入<br /></li>
</ul>
<p>
透過這些方法，我們可以有效防止 SQL Injection，提升應用的安全性！<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org263cb26" class="outline-4">
<h4 id="org263cb26"><span class="section-number-4">1.2.5.</span> 第五大題 (5分)：</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
說明 “downcast” 何時使用，並解釋為何可能造成runtime exception<br />
</p>
</div>
<div id="outline-container-org2d80c4e" class="outline-5">
<h5 id="org2d80c4e">解</h5>
<div class="outline-text-5" id="text-org2d80c4e">
</div>
<ul class="org-ul">
<li><a id="orgfae70e4"></a>📌 什麼是 Downcast？<br />
<div class="outline-text-6" id="text-orgfae70e4">
<p>
在物件導向程式設計（Object-Oriented Programming, OOP）中，Downcasting（向下轉型） 指的是 將一個父類（superclass）引用的物件，轉型為子類（subclass）類型。這通常發生在 多態（polymorphism） 的場景下。<br />
</p>

<p>
示例: 假設有一個父類 Animal 和一個子類 Dog：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> Animal {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr"> 3: </span>        System.out.println(<span style="color: #98be65;">"Some sound..."</span>);
<span class="linenr"> 4: </span>    }
<span class="linenr"> 5: </span>}
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">class</span> Dog <span style="color: #51afef;">extends</span> Animal {
<span class="linenr"> 8: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">bark</span>() {
<span class="linenr"> 9: </span>        System.out.println(<span style="color: #98be65;">"Woof!"</span>);
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>}
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> DowncastExample {
<span class="linenr">14: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">15: </span>        Animal a = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Upcast&#65288;&#21521;&#19978;&#36681;&#22411;&#65289;&#65292;&#23433;&#20840;</span>
<span class="linenr">16: </span>        Dog d = (Dog) a;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast&#65288;&#21521;&#19979;&#36681;&#22411;&#65289;</span>
<span class="linenr">17: </span>        d.bark();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36889;&#35041;&#21487;&#20197;&#25104;&#21151;&#21628;&#21483;&#23376;&#39006;&#30340;&#26041;&#27861;</span>
<span class="linenr">18: </span>    }
<span class="linenr">19: </span>}
</pre>
</div>
<p>
在上例中，Animal a = new Dog(); 透過 向上轉型（Upcasting） 將 Dog 物件存入 Animal 型態的變數中。之後，我們執行 向下轉型（Downcasting），將 a 轉回 Dog，然後成功呼叫 bark()。<br />
</p>
</div>
</li>
<li><a id="org4c27090"></a>📌 何時使用 Downcast？<br />
<div class="outline-text-6" id="text-org4c27090">
<p>
通常情況下，當我們知道某個父類型的變數實際上是某個子類型的實例時，才會執行 Downcast。常見用途包括：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org053b22a"></a>1. 當多態方法傳回父類型時，需要存取子類特有的行為<br />
<div class="outline-text-7" id="text-org053b22a">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Animal getAnimal() {
<span class="linenr">2: </span>    <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22238;&#20659;&#23376;&#39006;</span>
<span class="linenr">3: </span>}
<span class="linenr">4: </span>
<span class="linenr">5: </span>Dog d = (Dog) getAnimal(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">6: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="org7f76916"></a>2. 當資料結構（如 List、Map）存放的是父類型時，需要轉型回子類型<br />
<div class="outline-text-7" id="text-org7f76916">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>List&lt;Animal&gt; animals = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">ArrayList</span>&lt;&gt;();
<span class="linenr">2: </span>animals.add(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>());
<span class="linenr">3: </span>
<span class="linenr">4: </span>Dog d = (Dog) animals.get(<span style="color: #da8548; font-weight: bold;">0</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">5: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="org5551f26"></a>3. 在事件驅動架構（如 GUI 框架）中，事件處理器可能需要將父類轉型為具體的子類<br />
<div class="outline-text-7" id="text-org5551f26">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>    Object event = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">MouseEvent</span>();
<span class="linenr">2: </span>    MouseEvent me = (MouseEvent) event;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Downcast</span>
<span class="linenr">3: </span>
</pre>
</div>
</div>
</li>
</ul>
</li>
<li><a id="orgd9f32cf"></a>📌 為何 Downcast 可能造成 Runtime Exception？<br />
<div class="outline-text-6" id="text-orgd9f32cf">
<p>
Downcast 並不保證一定安全，如果 父類型的變數實際上不是該子類的實例，則在運行時會發生 ClassCastException。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgce58a0b"></a>❌ 錯誤示例<br />
<div class="outline-text-7" id="text-orgce58a0b">
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span>Animal a = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Animal</span>();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#26159; Dog</span>
<span class="linenr">2: </span>Dog d = (Dog) a;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26371;&#25291;&#20986; ClassCastException</span>
<span class="linenr">3: </span>d.bark();
</pre>
</div>
</div>
</li>
<li><a id="org477420b"></a>📌 錯誤原因：<br />
<div class="outline-text-7" id="text-org477420b">
<ul class="org-ul">
<li>a 其實是 Animal 的實例，不是 Dog，但我們試圖把它強制轉型為 Dog，這會導致 ClassCastException。<br /></li>
</ul>
</div>
</li>
<li><a id="org35d92ef"></a>📌 如何避免 Downcast 發生 Runtime Exception？<br />
<div class="outline-text-7" id="text-org35d92ef">
<p>
以下幾種方法可以避免 Downcast 產生錯誤：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org6304f4c"></a>✅ 方法 1：使用 instanceof 先檢查<br />
<div class="outline-text-8" id="text-org6304f4c">
<p>
在 Java 和 C# 中，可以使用 instanceof（Java）或 is（C#）來檢查物件是否屬於特定類別：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">if</span> (a <span style="color: #51afef;">instanceof</span> <span style="color: #ECBE7B;">Dog</span>) {
<span class="linenr">2: </span>    Dog d = (Dog) a;
<span class="linenr">3: </span>    d.bark();
<span class="linenr">4: </span>} <span style="color: #51afef;">else</span> {
<span class="linenr">5: </span>    System.out.println(<span style="color: #98be65;">"&#19981;&#26159; Dog &#29289;&#20214;&#65292;&#28961;&#27861;&#36681;&#22411;"</span>);
<span class="linenr">6: </span>}
</pre>
</div>
<p>
優點：避免 ClassCastException，確保只有 Dog 物件才會進行轉型。<br />
</p>
</div>
</li>
<li><a id="org1344a84"></a>✅ 方法 2：使用 try-catch 捕捉異常<br />
<div class="outline-text-8" id="text-org1344a84">
<p>
如果 instanceof 不能滿足需求（如在不確定資料來源的情況下），可以使用 try-catch 來防止程式崩潰：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #51afef;">try</span> {
<span class="linenr">2: </span>    Dog d = (Dog) a;
<span class="linenr">3: </span>    d.bark();
<span class="linenr">4: </span>} <span style="color: #51afef;">catch</span> (ClassCastException e) {
<span class="linenr">5: </span>    System.out.println(<span style="color: #98be65;">"&#36681;&#22411;&#22833;&#25943;&#65306;"</span> + e.getMessage());
<span class="linenr">6: </span>}
</pre>
</div>

<p>
優點：即使出錯，程式仍可繼續執行。<br />
</p>
</div>
</li>
<li><a id="orgfe87008"></a>✅ 方法 3：使用泛型（Generics，推薦做法）<br />
<div class="outline-text-8" id="text-orgfe87008">
<p>
如果應用程式使用 泛型，就能避免 Downcast。例如：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> Box&lt;T&gt; {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">private</span> T value;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #51afef;">public</span> Box(T value) {
<span class="linenr"> 5: </span>        <span style="color: #a9a1e1;">this</span>.value = value;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #51afef;">public</span> T get() {
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> value;
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>}
<span class="linenr">12: </span>
<span class="linenr">13: </span>Box&lt;Dog&gt; dogBox = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Box</span>&lt;&gt;(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>());
<span class="linenr">14: </span>Dog d = dogBox.get();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#38656;&#35201; Downcast&#65292;&#39006;&#22411;&#23433;&#20840;</span>
<span class="linenr">15: </span>d.bark();
<span class="linenr">16: </span>
</pre>
</div>
<p>
優點：<br />
</p>
<ul class="org-ul">
<li>在 編譯期 就確保類型安全，不會發生 ClassCastException。<br /></li>
<li>提升程式碼的可讀性與可維護性。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li><a id="orgff53080"></a>🔍 總結<br />
<div class="outline-text-6" id="text-orgff53080">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">概念</th>
<th scope="col" class="org-left">向上轉型（Upcast）</th>
<th scope="col" class="org-left">向下轉型（Downcast）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定義</td>
<td class="org-left">父類變數指向子類物件</td>
<td class="org-left">將父類變數轉回子類物件</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">✅ 安全</td>
<td class="org-left">⚠️ 可能導致 ClassCastException</td>
</tr>

<tr>
<td class="org-left">何時使用？</td>
<td class="org-left">當需要多態行為</td>
<td class="org-left">當確定變數實際類型並需存取子類功能</td>
</tr>

<tr>
<td class="org-left">如何避免錯誤？</td>
<td class="org-left">不需要特別處理</td>
<td class="org-left">✅ instanceof 檢查 ✅ try-catch ✅ 泛型</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org952febf" class="outline-4">
<h4 id="org952febf"><span class="section-number-4">1.2.6.</span> 第六大題 (20分)：</h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
請用 Java 或 C++ 這兩種物件導向語言其中一種，並充分利用其物件導向程式重複使用 (reuse) 的特性來設計並撰寫下面程式：<br />
</p>
<ul class="org-ul">
<li>由使用者輸入開始日期和終止日期，然後由程式計算並輸出這段時間共有多少天（頭、尾兩天都要算，任何的年份都要適用）<br /></li>
<li>本程式規定至少要用到三個 Classes 來撰寫本程式，而且不能使用 Java 或 C++ 系統提供的內建日期函數，這些class都要有其特定的意義，並說明之。<br /></li>
<li>評分依據：程式是否符合物件導向原則，包含說明程式設計的物件導向原則，以及寫出你的程式的類別圖 (Class diagram)，該圖須包含屬性和重要方法。<br /></li>
</ul>
</div>
<div id="outline-container-orgb85a34b" class="outline-5">
<h5 id="orgb85a34b">解</h5>
<div class="outline-text-5" id="text-orgb85a34b">
<p>
以下是完整的 C++ 物件導向設計與實作，符合物件導向 重複使用（reuse） 原則，並且 不使用內建日期函數，手動計算日期之間的天數。此程式設計了三個類別：<br />
</p>
<ol class="org-ol">
<li>Date：用來表示日期（年、月、日），並提供日期驗證、閏年判斷等功能。<br /></li>
<li>DateCalculator：計算兩個日期之間的天數，考慮閏年與不同月份天數。<br /></li>
<li>UserInterface：負責與使用者互動，接收輸入並顯示結果。<br /></li>
</ol>
</div>
<ul class="org-ul">
<li><a id="orgc0da223"></a>🔹 設計概念與物件導向原則<br />
<div class="outline-text-6" id="text-orgc0da223">
<p>
本設計符合以下 物件導向設計原則：<br />
</p>
<ul class="org-ul">
<li>封裝（Encapsulation）：Date、DateCalculator 和 UserInterface 各自負責不同的功能，並隱藏內部細節。<br /></li>
<li>責任分離（Separation of Concerns, SoC）：每個類別負責不同的功能：<br />
<ul class="org-ul">
<li>Date 只負責 日期的定義與處理。<br /></li>
<li>DateCalculator 負責 日期計算邏輯。<br /></li>
<li>UserInterface 負責 輸入輸出，不直接參與計算。<br /></li>
</ul></li>
<li>可重複使用（Reuse）：<br />
<ul class="org-ul">
<li>Date 類別可以在其他專案中 重複使用。<br /></li>
<li>DateCalculator 的計算方法可被擴展，例如用於未來的日期運算功能。<br /></li>
<li>UserInterface 可以在其他應用程式中使用（如時間計算應用）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org4a8095c"></a>🔹 類別圖（Class Diagram）<br />
<div class="outline-text-6" id="text-org4a8095c">
<pre class="example" id="org68c81b6">

+--------------------+
|      Date         |
+--------------------+
| - year: int       |
| - month: int      |
| - day: int        |
|--------------------|
| + isLeapYear(): bool  |
| + isValidDate(): bool |
| + daysInMonth(): int  |
+--------------------+

        ▲
        │
        │ 使用
        ▼

+----------------------+
|  DateCalculator      |
+----------------------+
| + calculateDaysBetween(d1: Date, d2: Date): int |
+----------------------+

        ▲
        │
        │ 使用
        ▼

+----------------------+
|  UserInterface      |
+----------------------+
| + getUserInput(): Date |
| + displayResult(): void |
+----------------------+
</pre>
</div>
</li>
<li><a id="orgb9ad84a"></a>🔹 C++ 程式碼實作<br />
<ul class="org-ul">
<li><a id="orgc547dce"></a>📌 Date 類別<br />
<div class="outline-text-7" id="text-orgc547dce">
<p>
負責 日期存儲與驗證，包含：<br />
</p>
<ul class="org-ul">
<li>閏年判斷 (isLeapYear())<br /></li>
<li>檢查日期是否合法 (isValidDate())<br /></li>
<li>取得月份的天數 (daysInMonth())<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Date</span> {
<span class="linenr"> 5: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">year</span>, <span style="color: #dcaeea;">month</span>, <span style="color: #dcaeea;">day</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #c678dd;">Date</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">d</span>) {
<span class="linenr"> 9: </span>        year = y;
<span class="linenr">10: </span>        month = m;
<span class="linenr">11: </span>        day = d;
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">isLeapYear</span>() {
<span class="linenr">15: </span>        <span style="color: #51afef;">return</span> (year % <span style="color: #da8548; font-weight: bold;">4</span> == <span style="color: #da8548; font-weight: bold;">0</span> &amp;&amp; year % <span style="color: #da8548; font-weight: bold;">100</span> != <span style="color: #da8548; font-weight: bold;">0</span>) || (year % <span style="color: #da8548; font-weight: bold;">400</span> == <span style="color: #da8548; font-weight: bold;">0</span>);
<span class="linenr">16: </span>    }
<span class="linenr">17: </span>
<span class="linenr">18: </span>    <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">isValidDate</span>() {
<span class="linenr">19: </span>        <span style="color: #51afef;">if</span> (<span style="color: #ECBE7B;">month</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span> || month &gt; <span style="color: #da8548; font-weight: bold;">12</span>) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">20: </span>        <span style="color: #51afef;">if</span> (<span style="color: #ECBE7B;">day</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span> || day &gt; <span style="color: #dcaeea;">daysInMonth</span>()) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">21: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>;
<span class="linenr">22: </span>    }
<span class="linenr">23: </span>
<span class="linenr">24: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">daysInMonth</span>() {
<span class="linenr">25: </span>        <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">daysPerMonth</span>[<span style="color: #da8548; font-weight: bold;">12</span>] = {<span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">28</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>, <span style="color: #da8548; font-weight: bold;">30</span>, <span style="color: #da8548; font-weight: bold;">31</span>};
<span class="linenr">26: </span>        <span style="color: #51afef;">return</span> (month == <span style="color: #da8548; font-weight: bold;">2</span> &amp;&amp; isLeapYear()) ? <span style="color: #da8548; font-weight: bold;">29</span> : daysPerMonth[month - <span style="color: #da8548; font-weight: bold;">1</span>];
<span class="linenr">27: </span>    }
<span class="linenr">28: </span>};
</pre>
</div>
</div>
</li>
<li><a id="orgda32d59"></a>📌 DateCalculator 類別<br />
<div class="outline-text-7" id="text-orgda32d59">
<p>
負責 計算兩個日期之間的天數，考慮：<br />
</p>
<ul class="org-ul">
<li>計算完整年的天數<br /></li>
<li>計算部分年度的天數<br /></li>
<li>考慮閏年影響<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">DateCalculator</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">calculateDaysBetween</span>(<span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">d1</span>, <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">d2</span>) {
<span class="linenr"> 4: </span>        <span style="color: #51afef;">if</span> (<span style="color: #51afef; font-weight: bold;">!</span>d1.isValidDate() || <span style="color: #51afef; font-weight: bold;">!</span>d2.isValidDate()) {
<span class="linenr"> 5: </span>            cout &lt;&lt; <span style="color: #98be65;">"&#37679;&#35492;&#65306;&#36664;&#20837;&#30340;&#26085;&#26399;&#28961;&#25928;&#65281;"</span> &lt;&lt; endl;
<span class="linenr"> 6: </span>            <span style="color: #51afef;">return</span> -<span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 7: </span>        }
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30906;&#20445; d1 &#26159;&#36611;&#26089;&#30340;&#26085;&#26399;</span>
<span class="linenr">10: </span>        <span style="color: #51afef;">if</span> (d1.year &gt; d2.year || (d1.year == d2.year &amp;&amp; d1.month &gt; d2.month) ||
<span class="linenr">11: </span>            (d1.year == d2.year &amp;&amp; d1.month == d2.month &amp;&amp; d1.day &gt; d2.day)) {
<span class="linenr">12: </span>            swap(d1, d2);
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>
<span class="linenr">15: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">totalDays</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639;&#23436;&#25972;&#24180;&#20221;&#30340;&#22825;&#25976;</span>
<span class="linenr">18: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span> = d1.year; y &lt; d2.year; y++) {
<span class="linenr">19: </span>            totalDays += (Date(y, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">1</span>).isLeapYear()) ? <span style="color: #da8548; font-weight: bold;">366</span> : <span style="color: #da8548; font-weight: bold;">365</span>;
<span class="linenr">20: </span>        }
<span class="linenr">21: </span>
<span class="linenr">22: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639; d1 &#30070;&#24180;&#24230;&#21097;&#39192;&#22825;&#25976;</span>
<span class="linenr">23: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span> = d1.month; m &lt;= <span style="color: #da8548; font-weight: bold;">12</span>; m++) {
<span class="linenr">24: </span>            totalDays += Date(d1.year, m, <span style="color: #da8548; font-weight: bold;">1</span>).daysInMonth();
<span class="linenr">25: </span>        }
<span class="linenr">26: </span>        totalDays -= d1.day - <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28187;&#21435; d1 &#24050;&#32147;&#36942;&#21435;&#30340;&#22825;&#25976;</span>
<span class="linenr">27: </span>
<span class="linenr">28: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35336;&#31639; d2 &#30070;&#24180;&#24230;&#30340;&#24050;&#36942;&#22825;&#25976;</span>
<span class="linenr">29: </span>        <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span> = <span style="color: #da8548; font-weight: bold;">1</span>; m &lt; d2.month; m++) {
<span class="linenr">30: </span>            totalDays += Date(d2.year, m, <span style="color: #da8548; font-weight: bold;">1</span>).daysInMonth();
<span class="linenr">31: </span>        }
<span class="linenr">32: </span>        totalDays += d2.day; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21152;&#19978; d2 &#30070;&#26376;&#22825;&#25976;</span>
<span class="linenr">33: </span>
<span class="linenr">34: </span>        <span style="color: #51afef;">return</span> totalDays;
<span class="linenr">35: </span>    }
<span class="linenr">36: </span>};
</pre>
</div>
</div>
</li>
<li><a id="org447d836"></a>📌 UserInterface 類別<br />
<div class="outline-text-7" id="text-org447d836">
<p>
負責 與使用者互動，包括：<br />
</p>
<ul class="org-ul">
<li>讀取使用者輸入<br /></li>
<li>顯示計算結果<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">UserInterface</span> {
<span class="linenr"> 2: </span><span style="color: #51afef;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #c678dd;">getUserInput</span>() {
<span class="linenr"> 4: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>, <span style="color: #dcaeea;">m</span>, <span style="color: #dcaeea;">d</span>;
<span class="linenr"> 5: </span>        cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#26085;&#26399;&#65288;&#26684;&#24335;&#65306;&#24180; &#26376; &#26085;&#65289;&#65306;"</span>;
<span class="linenr"> 6: </span>        cin &gt;&gt; y &gt;&gt; m &gt;&gt; d;
<span class="linenr"> 7: </span>        <span style="color: #51afef;">return</span> Date(y, m, d);
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">displayResult</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">days</span>) {
<span class="linenr">11: </span>        <span style="color: #51afef;">if</span> (days != -<span style="color: #da8548; font-weight: bold;">1</span>) {
<span class="linenr">12: </span>            cout &lt;&lt; <span style="color: #98be65;">"&#20841;&#20491;&#26085;&#26399;&#30456;&#24046;&#22825;&#25976;&#65306;"</span> &lt;&lt; days &lt;&lt; <span style="color: #98be65;">" &#22825;"</span> &lt;&lt; endl;
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>};
</pre>
</div>
</div>
</li>
<li><a id="org527f38f"></a>📌 主函數 main()<br />
<div class="outline-text-7" id="text-org527f38f">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">UserInterface</span> <span style="color: #dcaeea;">ui</span>;
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">DateCalculator</span> <span style="color: #dcaeea;">calculator</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#38283;&#22987;&#26085;&#26399;&#65306;"</span> &lt;&lt; endl;
<span class="linenr"> 6: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">startDate</span> = ui.getUserInput();
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    cout &lt;&lt; <span style="color: #98be65;">"&#35531;&#36664;&#20837;&#32066;&#27490;&#26085;&#26399;&#65306;"</span> &lt;&lt; endl;
<span class="linenr"> 9: </span>    <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">endDate</span> = ui.getUserInput();
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">days</span> = calculator.calculateDaysBetween(startDate, endDate);
<span class="linenr">12: </span>    ui.displayResult(days);
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">15: </span>}
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org21535be" class="outline-4">
<h4 id="org21535be"><span class="section-number-4">1.2.7.</span> 第七大題 (8分)：</h4>
<div class="outline-text-4" id="text-1-2-7">
<p>
給定一個系統的 snapshot，包含 Allocation, Max, Available 等資訊，並要求使用 banker’s algorithm 回答下列問題<br />
：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Allocation</th>
<th scope="col" class="org-right">Max</th>
<th scope="col" class="org-right">Availabe</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>

<tr>
<th scope="col" class="org-left">A B C D</th>
<th scope="col" class="org-right">A B C D</th>
<th scope="col" class="org-right">A B C D</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P0</td>
<td class="org-right">2001</td>
<td class="org-right">4212</td>
<td class="org-right">3321</td>
</tr>

<tr>
<td class="org-left">P1</td>
<td class="org-right">3121</td>
<td class="org-right">5252</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P2</td>
<td class="org-right">2103</td>
<td class="org-right">2316</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P3</td>
<td class="org-right">1312</td>
<td class="org-right">1424</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P4</td>
<td class="org-right">1432</td>
<td class="org-right">3665</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
使用 banker&rsquo;s algorithm 回答下列問題：<br />
</p>
<ul class="org-ul">
<li>(a) If a request form process P1 arrives for (1, 1, 0, 0), can the request be granted immediately? Why?<br /></li>
<li>(b) If a request form process P4 arrives for (0, 0, 2, 0), can the request be granted immediately? Why?<br /></li>
</ul>
</div>
<div id="outline-container-org447a94b" class="outline-5">
<h5 id="org447a94b">解</h5>
<div class="outline-text-5" id="text-org447a94b">
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">import</span> numpy <span style="color: #51afef;">as</span> np
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Given snapshot data</span>
<span class="linenr"> 4: </span><span style="color: #dcaeea;">allocation</span> = np.array([[<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>],
<span class="linenr"> 5: </span>                       [<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>],
<span class="linenr"> 6: </span>                       [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">3</span>],
<span class="linenr"> 7: </span>                       [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr"> 8: </span>                       [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">2</span>]])
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #dcaeea;">max_demand</span> = np.array([[<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr">11: </span>                        [<span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">2</span>],
<span class="linenr">12: </span>                        [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">6</span>],
<span class="linenr">13: </span>                        [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">4</span>],
<span class="linenr">14: </span>                        [<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">5</span>]])
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #dcaeea;">available</span> = np.array([<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>])
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Compute the Need matrix (Max - Allocation)</span>
<span class="linenr">19: </span><span style="color: #dcaeea;">need</span> = max_demand - allocation
<span class="linenr">20: </span>
<span class="linenr">21: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Requests to check</span>
<span class="linenr">22: </span><span style="color: #dcaeea;">request_P1</span> = np.array([<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>])
<span class="linenr">23: </span><span style="color: #dcaeea;">request_P4</span> = np.array([<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">0</span>])
<span class="linenr">24: </span>
<span class="linenr">25: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Function to check if request can be granted immediately</span>
<span class="linenr">26: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">can_grant_request</span>(available, need, request, process_id):
<span class="linenr">27: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check if request is within the process's need</span>
<span class="linenr">28: </span>    <span style="color: #51afef;">if</span> np.<span style="color: #c678dd;">any</span>(request &gt; need[process_id]):
<span class="linenr">29: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>, <span style="color: #98be65;">"Request exceeds process's maximum need."</span>
<span class="linenr">30: </span>
<span class="linenr">31: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check if request is within available resources</span>
<span class="linenr">32: </span>    <span style="color: #51afef;">if</span> np.<span style="color: #c678dd;">any</span>(request &gt; available):
<span class="linenr">33: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>, <span style="color: #98be65;">"Not enough available resources to fulfill request."</span>
<span class="linenr">34: </span>
<span class="linenr">35: </span>    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">If both conditions are met, request can be granted</span>
<span class="linenr">36: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">True</span>, <span style="color: #98be65;">"Request can be granted immediately."</span>
<span class="linenr">37: </span>
<span class="linenr">38: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check both requests</span>
<span class="linenr">39: </span><span style="color: #dcaeea;">result_P1</span> = can_grant_request(available, need, request_P1, <span style="color: #da8548; font-weight: bold;">1</span>)
<span class="linenr">40: </span><span style="color: #dcaeea;">result_P4</span> = can_grant_request(available, need, request_P4, <span style="color: #da8548; font-weight: bold;">4</span>)
<span class="linenr">41: </span>
<span class="linenr">42: </span><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Display results</span>
<span class="linenr">43: </span>result_P1, result_P4
<span class="linenr">44: </span>
</pre>
</div>
<p>
執行結果<br />
</p>
<pre class="example" id="orgbaf8add">
((True, 'Request can be granted immediately.'),
 (True, 'Request can be granted immediately.'))
</pre>
</div>
<ul class="org-ul">
<li><a id="orgf3b87f3"></a>解析 Banker&rsquo;s Algorithm<br />
<div class="outline-text-6" id="text-orgf3b87f3">
<p>
Banker&rsquo;s Algorithm 是 避免死鎖（Deadlock Avoidance） 的一種資源分配與安全性檢查算法，主要用來確保系統不會陷入不安全狀態。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org1f438f7"></a>主要概念<br />
<div class="outline-text-7" id="text-org1f438f7">
<ul class="org-ul">
<li>Allocation（已分配資源）：目前已分配給各進程的資源數量。<br /></li>
<li>Max（最大需求）：各進程執行所需的最大資源量。<br /></li>
<li>Need（尚需資源）：Need = Max - Allocation，表示各進程還需要多少資源才能完成。<br /></li>
<li>Available（可用資源）：目前系統可用的總資源數。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd782090"></a>(a) Process P1 的請求 (1,1,0,0) 能否立即滿足？<br />
<div class="outline-text-7" id="text-orgd782090">
<p>
請求：P1 需要 (1,1,0,0)<br />
檢查步驟<br />
</p>
<ol class="org-ol">
<li>檢查 Request 是否超過 Need<br />
Need 計算：<br />
<ul class="org-ul">
<li><p>
Need=Max−Allocation<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>     <span style="color: #dcaeea;">Need</span>[P1] = (<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">2</span>) - (<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">1</span>) = (<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div></li>
<li>(1,1,0,0) &lt;= (2,1,3,1) ✅ 合法<br /></li>
</ul></li>

<li>檢查 Request 是否小於等於 Available<br />
<ul class="org-ul">
<li>Available (3,3,2,1)<br /></li>
<li>(1,1,0,0) &lt;= (3,3,2,1) ✅ 可用資源足夠<br /></li>
</ul></li>
</ol>
<p>
結論：P1 的請求 可以立即被滿足。<br />
</p>
</div>
</li>
<li><a id="orgef4c8ff"></a>(b) Process P4 的請求 (0,0,2,0) 能否立即滿足？<br />
<div class="outline-text-7" id="text-orgef4c8ff">
<p>
請求：P4 需要 (0,0,2,0)<br />
檢查步驟<br />
</p>
<ol class="org-ol">
<li>檢查 Request 是否超過 Need<br />
Need 計算：<br />
<ul class="org-ul">
<li>Need[P4] = (3,6,6,5) - (1,4,3,2) = (2,2,3,3)<br /></li>
<li>(0,0,2,0) &lt;= (2,2,3,3) ✅ 合法<br /></li>
</ul></li>
<li>檢查 Request 是否小於等於 Available<br />
<ul class="org-ul">
<li>Available (3,3,2,1)<br /></li>
<li>(0,0,2,0) &lt;= (3,3,2,1) ✅ 可用資源足夠<br /></li>
</ul></li>
</ol>
<p>
結論： P4 的請求 可以立即被滿足。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="orgf2b17c8"></a>最終結果<br />
<div class="outline-text-6" id="text-orgf2b17c8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Process</th>
<th scope="col" class="org-left">Request</th>
<th scope="col" class="org-left">Can be granted?</th>
<th scope="col" class="org-left">Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P1</td>
<td class="org-left">(1,1,0,0)</td>
<td class="org-left">✅ Yes</td>
<td class="org-left">Available 資源足夠，且需求符合 Need 限制</td>
</tr>

<tr>
<td class="org-left">P4</td>
<td class="org-left">(0,0,2,0)</td>
<td class="org-left">✅ Yes</td>
<td class="org-left">Available 資源足夠，且需求符合 Need 限制</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge4f1ca8" class="outline-4">
<h4 id="orge4f1ca8"><span class="section-number-4">1.2.8.</span> 第八大題 (8分)：</h4>
<div class="outline-text-4" id="text-1-2-8">
<p>
In a paging system, suppose that the hit ratio is 90% and it takes 10 ns to search the TLB and 100 ns to access memory.<br />
</p>
<ul class="org-ul">
<li>(a) What is the effective memory access time with single-level page table?<br /></li>
<li>(b) What is the effective memory access time with two-level page table?<br /></li>
</ul>
</div>
<div id="outline-container-org090aa5c" class="outline-5">
<h5 id="org090aa5c">解</h5>
<div class="outline-text-5" id="text-org090aa5c">
</div>
<ul class="org-ul">
<li><a id="org4c1d699"></a>🔹 Key Given Data<br />
<div class="outline-text-6" id="text-org4c1d699">
<ul class="org-ul">
<li>TLB Search Time = 10 ns<br /></li>
<li>Memory Access Time = 100 ns<br /></li>
<li>Hit Ratio = 90% (i.e., 0.9)<br /></li>
<li>Miss Ratio = 1 - 0.9 = 0.1<br /></li>
</ul>
</div>
</li>
<li><a id="org842215e"></a>(a) Effective Memory Access Time with Single-Level Page Table<br />
<ul class="org-ul">
<li><a id="org896db84"></a>📌 Concept<br />
<div class="outline-text-7" id="text-org896db84">
<p>
In a paging system, when a process needs to access memory:<br />
</p>
<ol class="org-ol">
<li>The TLB (Translation Lookaside Buffer) is checked first.<br /></li>
<li>If there&rsquo;s a hit, we can directly access the physical memory.<br /></li>
<li>If there&rsquo;s a miss, we need to:<br />
<ul class="org-ul">
<li>Access the page table in memory to find the frame number (cost: 100 ns).<br /></li>
<li>Then access the actual memory location (cost: 100 ns).<br /></li>
<li>Total cost in case of a miss: 200 ns.<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orgcd7bebc"></a>📌 Formula<br />
<div class="outline-text-7" id="text-orgcd7bebc">
<p>
Effective Memory Access Time=(TLB Hit Ratio×Hit Time)+(TLB Miss Ratio×Miss Time)<br />
=(0.9×(10+100))+(0.1×(10+100+100))<br />
</p>
</div>
</li>
<li><a id="org8fbc3a0"></a>📌 Calculation<br />
<div class="outline-text-7" id="text-org8fbc3a0">
<p>
=(0.9×110)+(0.1×210)<br />
=99+21<br />
=120 ns<br />
</p>
</div>
</li>
<li><a id="org1910ae7"></a>🔹 Answer: The effective memory access time for a single-level page table is 120 ns.<br /></li>
</ul>
</li>
<li><a id="org3cad611"></a>(b) Effective Memory Access Time with Two-Level Page Table<br />
<ul class="org-ul">
<li><a id="orgaea3bcf"></a>📌 Concept<br />
<div class="outline-text-7" id="text-orgaea3bcf">
<p>
In a two-level paging system, if a TLB miss occurs, we must perform:<br />
</p>
<ul class="org-ul">
<li>Page Table Lookup (First Level) = 100 ns<br /></li>
<li>Page Table Lookup (Second Level) = 100 ns<br /></li>
<li>Memory Access (Data Fetch) = 100 ns<br /></li>
</ul>
<p>
Thus, on a miss, we must access memory three times (300 ns total) instead of two times (200 ns total).<br />
</p>
</div>
</li>
<li><a id="org7521d38"></a>📌 Formula<br />
<div class="outline-text-7" id="text-org7521d38">
<p>
Effective Memory Access Time=(TLB Hit Ratio×Hit Time)+(TLB Miss Ratio×Miss Time)<br />
=(0.9×(10+100))+(0.1×(10+100+100+100))<br />
</p>
</div>
</li>
<li><a id="org9fedb99"></a>📌 Calculation<br />
<div class="outline-text-7" id="text-org9fedb99">
<p>
=(0.9×110)+(0.1×310)<br />
=99+31<br />
=130 ns<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org58d69b2"></a>🔹 Summary of Results<br />
<div class="outline-text-6" id="text-org58d69b2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Paging System</th>
<th scope="col" class="org-left">Effective Memory Access Time (ns)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Single-Level Page Table</td>
<td class="org-left">120 ns</td>
</tr>

<tr>
<td class="org-left">Two-Level Page Table</td>
<td class="org-left">130 ns</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc8fddda" class="outline-4">
<h4 id="orgc8fddda"><span class="section-number-4">1.2.9.</span> 第九大題 (4 分)：</h4>
<div class="outline-text-4" id="text-1-2-9">
<p>
Consider a byte oriented logical address space of 8 pages of 1024 bytes each, mapped onto a physical memory of 32 frames.<br />
</p>
<ul class="org-ul">
<li>(a) How many bits are there in the logical address?<br /></li>
<li>(b) How many bits are there in the physical address?<br /></li>
</ul>
</div>
<div id="outline-container-org1c5b0d8" class="outline-5">
<h5 id="org1c5b0d8">解</h5>
<div class="outline-text-5" id="text-org1c5b0d8">
<p>
在 分頁式記憶體管理（Paging Memory Management） 中，邏輯位址（Logical Address）由兩部分組成：<br />
</p>
<ul class="org-ul">
<li>頁號（Page Number, p）：用來索引頁表，找到對應的記憶體框架。<br /></li>
<li></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orge5f8e79"></a>(a) 邏輯位址的位元數<br />
<ul class="org-ul">
<li><a id="orgca78164"></a>📌 已知條件<br />
<div class="outline-text-7" id="text-orgca78164">
<ul class="org-ul">
<li>邏輯位址空間（Logical Address Space）：<br />
<ul class="org-ul">
<li>共有 8 個頁（Pages）。<br /></li>
<li>每個頁 1024 個位元組（Bytes）。<br /></li>
</ul></li>
<li>頁內偏移量（Offset）：<br />
<ul class="org-ul">
<li>每個頁有 1024（= 2¹⁰）個位元組，所以頁內偏移量需要 10 bits 表示。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgc23076f"></a>📌 計算邏輯位址的位元數<br />
<div class="outline-text-7" id="text-orgc23076f">
<ul class="org-ul">
<li>頁號（Page Number, p）<br />
<ul class="org-ul">
<li>總共有 8 個頁（= 2³），因此 頁號需要 3 bits。<br /></li>
</ul></li>
<li>頁內偏移量（Offset, d）<br />
<ul class="org-ul">
<li>每個頁大小為 1024 Bytes（= 2¹⁰），因此 偏移量需要 10 bits。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org982dad0"></a>📌 總計<br />
<div class="outline-text-7" id="text-org982dad0">
<p>
邏輯位址長度 = 頁號位元數 + 頁內偏移量位元數<br />
=3+10=13 bits<br />
</p>
</div>
</li>
<li><a id="org5c9335c"></a>🔹 答案：邏輯位址需要 13 bits。<br /></li>
</ul>
</li>
<li><a id="org52cd84e"></a>(b) 物理位址的位元數<br />
<ul class="org-ul">
<li><a id="org8984a32"></a>📌 已知條件<br />
<div class="outline-text-7" id="text-org8984a32">
<ul class="org-ul">
<li>物理記憶體（Physical Memory）<br />
<ul class="org-ul">
<li>共有 32 個框架（Frames）。<br /></li>
<li>每個框架大小與頁大小相同，即 1024 Bytes。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org108c808"></a>📌 計算物理位址的位元數<br />
<div class="outline-text-7" id="text-org108c808">
<ul class="org-ul">
<li>框架號（Frame Number, f）<br />
<ul class="org-ul">
<li>物理記憶體有 32 個框架（= 2⁵），因此 框架號需要 5 bits。<br /></li>
</ul></li>
<li>頁內偏移量（Offset, d）<br />
<ul class="org-ul">
<li>與邏輯位址的 偏移量相同（10 bits），因為每個框架大小與頁大小一致。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0720f4e"></a>📌 總計<br />
<div class="outline-text-7" id="text-org0720f4e">
<p>
物理位址長度 = 框架號位元數 + 偏移量位元數<br />
=5+10=15 bits<br />
</p>
</div>
</li>
<li><a id="orgdd1608d"></a>🔹 答案：物理位址需要 15 bits。<br /></li>
</ul>
</li>
<li><a id="orgf820dcc"></a>🔹 最終結果<br />
<div class="outline-text-6" id="text-orgf820dcc">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">地址類型</th>
<th scope="col" class="org-left">所需位元數</th>
<th scope="col" class="org-left">組成部分</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">邏輯位址</td>
<td class="org-left">13 bits</td>
<td class="org-left">頁號（3 bits）+ 偏移量（10 bits）</td>
</tr>

<tr>
<td class="org-left">物理位址</td>
<td class="org-left">15 bits</td>
<td class="org-left">框架號（5 bits）+ 偏移量（10 bits）</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org9919638" class="outline-4">
<h4 id="org9919638"><span class="section-number-4">1.2.10.</span> 第十大題 (5 分)：</h4>
<div class="outline-text-4" id="text-1-2-10">
<p>
Consider the two-dimensional array “A[100][100]”. If a paged memory system with pages of size 200, for two page frames, how many page faults are generated by the following array-initialization loops, using LRU replacement?<br />
</p>
<ul class="org-ul">
<li><p>
(a)  loop (a) 的程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i&lt;<span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;<span style="color: #da8548; font-weight: bold;">100</span>;j++) {
<span class="linenr">3: </span>      A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>  }
</pre>
</div></li>
<li><p>
(b) loop (b) 的程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;<span style="color: #da8548; font-weight: bold;">100</span>; j++)  {
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">ing</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">3: </span>      A[i][j]=<span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>    }
<span class="linenr">5: </span>  }
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org6c4b106" class="outline-5">
<h5 id="org6c4b106">解</h5>
<div class="outline-text-5" id="text-org6c4b106">
<p>
在這個問題中，我們要分析 二維陣列 A[100][100] 在 頁面置換策略（LRU, Least Recently Used） 下的 頁錯（Page Fault）數量，並比較不同的走訪順序對頁錯數的影響。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org20c053a"></a>📌 給定條件<br />
<div class="outline-text-6" id="text-org20c053a">
<ul class="org-ul">
<li>陣列 A[100][100]（100 × 100 的整數陣列）。<br /></li>
<li>頁大小 = 200 Bytes。<br /></li>
<li>兩個頁框（Page Frames）。<br /></li>
<li>假設每個整數（int）佔 4 Bytes，則：<br />
<ul class="org-ul">
<li>每一行 A[i][j] 包含 100 個元素 × 4 Bytes = 400 Bytes。<br /></li>
<li>每個頁面大小為 200 Bytes，因此每個頁面能存 50 個整數（50 elements）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgfe7223f"></a>(a) 內迴圈掃描 A[i][j]<br />
<div class="outline-text-6" id="text-orgfe7223f">
<p>
📌 程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">2: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; <span style="color: #da8548; font-weight: bold;">100</span>; j++) {
<span class="linenr">3: </span>    A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>}
</pre>
</div>
<p>
📌 記憶體訪問模式<br />
</p>
<ol class="org-ol">
<li>外層迴圈 i 先固定，內層迴圈 j 變化。<br /></li>
<li>依照 j 逐列 存取記憶體（Row-major order）。<br /></li>
<li>內部陣列 A[i][j] 是連續存取的。<br /></li>
</ol>
<p>
📌 記憶體分頁<br />
</p>
<ul class="org-ul">
<li>每行（A[i]）大小 = 400 Bytes（2 個頁面）。<br /></li>
<li>當 j 在 0 到 49 時，存取第一個頁面，50 到 99 時存取第二個頁面。<br /></li>
<li>只要 i 不變，j 遍歷時只需要 2 個頁面（正好符合兩個頁框），不會發生頁錯。<br /></li>
</ul>
<p>
📌 頁錯計算<br />
</p>
<ul class="org-ul">
<li>i=0 時，載入 A[0] 的 2 個頁面（2 次頁錯）。<br /></li>
<li>i=1 時，載入 A[1] 的 2 個頁面（2 次頁錯）。<br /></li>
<li>&#x2026; 共 100 次 i 迴圈。<br /></li>
</ul>

<p>
總頁錯數：100×2=200<br />
🔹 (a) 的總頁錯數 = 200 次。<br />
</p>
</div>
</li>
<li><a id="org7bef9fc"></a>(b) 內迴圈掃描 A[i][j]（反轉迴圈）<br />
<div class="outline-text-6" id="text-org7bef9fc">
<p>
📌 程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; <span style="color: #da8548; font-weight: bold;">100</span>; j++) {
<span class="linenr">2: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">100</span>; i++) {
<span class="linenr">3: </span>    A[i][j] = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>}
</pre>
</div>
<p>
📌 記憶體訪問模式<br />
</p>
<ul class="org-ul">
<li>外層迴圈 j 先固定，內層迴圈 i 變化。<br /></li>
<li>依照 i 逐欄 存取記憶體（Column-major order）。<br /></li>
<li>A[i][j] 每次跳 100*4=400 Bytes，直接跳到下一行的相同欄位。<br /></li>
</ul>
<p>
📌 記憶體分頁<br />
</p>
<ul class="org-ul">
<li>每列 A[i][j] 分佈在 不同的頁面。<br /></li>
<li>一次 j 迴圈，會掃描 100 個不同的頁面。<br /></li>
<li>因為只有 2 個頁框，LRU 會不斷換出頁面。<br /></li>
</ul>
<p>
📌 頁錯計算<br />
</p>
<ul class="org-ul">
<li>每次訪問 A[i][j]，它會落在新的頁面，因為 i 變化時 A[i][j] 橫跨 100 不同頁面。<br /></li>
<li>每次訪問 A[i][j]，由於只有 2 個頁框，造成頻繁換頁。<br /></li>
<li>總共 100 × 100 次訪問，每次幾乎都是頁錯。<br /></li>
</ul>

<p>
總頁錯數：100×100=10,000<br />
</p>

<p>
🔹 (b) 的總頁錯數 = 10,000 次（極大化頁錯）。<br />
</p>
</div>
</li>
<li><a id="org0868b7d"></a>🔹 總結<br />
<div class="outline-text-6" id="text-org0868b7d">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方式</th>
<th scope="col" class="org-left">記憶體訪問模式</th>
<th scope="col" class="org-left">頁錯數</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a) for (int i; int j)</td>
<td class="org-left">Row-major (逐列存取)</td>
<td class="org-left">200</td>
<td class="org-left">局部性高，不會頻繁換頁</td>
</tr>

<tr>
<td class="org-left">(b) for (int j; int i)</td>
<td class="org-left">Column-major (逐欄存取)</td>
<td class="org-left">10,000	頁錯數極大化，因為跨頁存取</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
🔹 結論<br />
    (a) 的訪問模式符合記憶體的局部性原則（Locality Principle），頁錯較少（200 次）。<br />
    (b) 破壞了記憶體的局部性，造成嚴重的頁錯（10,000 次）。<br />
    分頁系統中，如何訪問記憶體會顯著影響效能。<br />
</p>
</div>
</li>
<li><a id="orge266409"></a>🔹 相關計算機概論知識<br />
<div class="outline-text-6" id="text-orge266409">
<p>
這個問題屬於 作業系統（Operating System） 和 記憶體管理（Memory Management），涉及：<br />
\[$ 這是作業系統的知識，計概裡應該有，不懂的話我再給看另一份比較基本的教材 \]$<br />
</p>
<ul class="org-ul">
<li>分頁記憶體（Paging Memory Management）<br />
<ul class="org-ul">
<li>物理記憶體被分成 固定大小的頁面。<br /></li>
<li>頁框（Page Frame）對應到邏輯記憶體的頁面。<br /></li>
</ul></li>
<li>頁面置換策略（Page Replacement Algorithms）<br />
<ul class="org-ul">
<li>LRU（Least Recently Used）：當頁框用完時，淘汰最久未使用的頁面。<br /></li>
<li>在 (b) 的訪問模式下，每次都會換出頁面，導致極高的頁錯數。<br /></li>
</ul></li>
<li>記憶體存取模式與局部性<br />
<ul class="org-ul">
<li>時間局部性（Temporal Locality）：最近存取的資料可能很快再次被存取。<br /></li>
<li>空間局部性（Spatial Locality）：與當前存取的資料相鄰的記憶體區塊可能會很快被存取。<br />
<ul class="org-ul">
<li>(a) 遵守局部性原則，因此頁錯數較低。<br /></li>
<li>(b) 破壞局部性，因此頁錯數極高。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga1aa483" class="outline-3">
<h3 id="orga1aa483"><span class="section-number-3">1.3.</span> 109</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orgd1c33ff" class="outline-4">
<h4 id="orgd1c33ff"><span class="section-number-4">1.3.1.</span> 第一題：解釋名詞 (每題 5 分，共 25 分)</h4>
<div class="outline-text-4" id="text-1-3-1">
</div>
<div id="outline-container-orgc99a2ae" class="outline-5">
<h5 id="orgc99a2ae">(A) CDMA ( Code Division Multiple Access )</h5>
<div class="outline-text-5" id="text-orgc99a2ae">
<p>
概念: CDMA 是一種無線通訊技術，允許多個使用者同時使用相同的頻率進行通訊。它的主要原理是利用獨特的碼序列（spreading code）來區分不同的使用者，而非像 TDMA 或 FDMA 那樣使用不同的時間槽或頻率。<br />
</p>
<ul class="org-ul">
<li>運作方式: 每個使用者被分配一個唯一的碼，發送的訊號會用這個碼進行編碼（spread）。接收端則利用相同的碼進行解碼，從混合的訊號中分離出目標使用者的資訊。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org1b1d665"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-org1b1d665">
<ul class="org-ul">
<li>多工技術: CDMA 屬於多工技術的一種，與 TDMA（時分多址）和 FDMA（頻分多址）並列。<br /></li>
<li>展頻技術: CDMA 運用展頻技術（Spread Spectrum），將訊號頻寬擴大，提高抗干擾能力。<br /></li>
<li>無線通訊: CDMA 常應用於行動通訊系統（如 3G 網路），允許更多使用者同時存取網路資源。<br /></li>
</ul>
</div>
</li>
<li><a id="org0aaa265"></a>CDMA, TDMA, FDMA<br />
<div class="outline-text-6" id="text-org0aaa265">
<p>
CDMA（Code Division Multiple Access）、TDMA（Time Division Multiple Access）、FDMA（Frequency Division Multiple Access）是三種不同的 多重存取技術（Multiple Access Technologies），主要應用於無線通訊系統，以允許多個使用者在同一頻譜中進行通訊。以下是三者的比較：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">特性</td>
<td class="org-left">CDMA（碼分多重存取）</td>
<td class="org-left">TDMA（時分多重存取）</td>
<td class="org-left">FDMA（頻分多重存取）</td>
</tr>

<tr>
<td class="org-left">工作原理</td>
<td class="org-left">每個用戶使用獨特的擴頻碼來區分訊號，所有用戶可在同一頻率和時間內傳輸</td>
<td class="org-left">時間被分成多個時槽，每個使用者輪流佔用時槽來傳輸訊號</td>
<td class="org-left">頻譜被分成多個頻段，每個使用者被分配一個固定的頻段進行傳輸</td>
</tr>

<tr>
<td class="org-left">頻譜使用效率</td>
<td class="org-left">高，所有用戶共享整個頻寬，透過擴頻碼區分</td>
<td class="org-left">中等，因時槽共享，可能有閒置時段</td>
<td class="org-left">低，每個使用者被分配固定頻率，頻譜利用率較低</td>
</tr>

<tr>
<td class="org-left">干擾性</td>
<td class="org-left">低，擴頻技術能降低干擾影響</td>
<td class="org-left">可能受鄰近時槽干擾（時鐘同步問題）</td>
<td class="org-left">易受鄰近頻道干擾（頻譜間干擾）</td>
</tr>

<tr>
<td class="org-left">數據傳輸</td>
<td class="org-left">可支援高數據速率，因為所有使用者可以同時傳輸</td>
<td class="org-left">數據傳輸速率受限於分配的時槽數量</td>
<td class="org-left">受限於可用頻寬，每個頻道傳輸速率固定</td>
</tr>

<tr>
<td class="org-left">同步需求</td>
<td class="org-left">低，不需要精確同步</td>
<td class="org-left">高，所有用戶必須與網路時鐘同步</td>
<td class="org-left">低，但需要精確的頻率規劃</td>
</tr>

<tr>
<td class="org-left">擴展性（Scalability）</td>
<td class="org-left">高，可動態分配用戶數量</td>
<td class="org-left">中等，固定時槽數量限制用戶數</td>
<td class="org-left">低，受限於固定頻率分配</td>
</tr>

<tr>
<td class="org-left">功耗</td>
<td class="org-left">低，因為可以以較低功率擴頻發送</td>
<td class="org-left">中等，需要同步開關發送訊號</td>
<td class="org-left">高，每個頻道需持續發射訊號</td>
</tr>

<tr>
<td class="org-left">應用</td>
<td class="org-left">3G（如 WCDMA、CDMA2000），軍事通信，衛星通訊</td>
<td class="org-left">2G（如 GSM），數位無線電話</td>
<td class="org-left">1G（如 AMPS 模擬通信），無線電廣播</td>
</tr>
</tbody>
</table>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>CDMA：最適合現代高速無線通信，頻譜利用率高，抗干擾能力強，擴展性好，但技術複雜度高。<br /></li>
<li>TDMA：在 2G 時期廣泛使用（如 GSM），需要精確同步，頻譜利用率中等。<br /></li>
<li>FDMA：最早的無線通訊技術，頻譜利用率低，現今較少用於蜂巢式網路，但仍適用於衛星通訊與無線電廣播。<br /></li>
</ul>

<p>
CDMA 由於其優越的頻譜利用效率和抗干擾能力，在 3G 和之後的無線通信技術中被廣泛採用，而 TDMA 和 FDMA 則逐漸被 CDMA 和 OFDMA（正交分頻多工）技術取代。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5cb4eab" class="outline-5">
<h5 id="org5cb4eab">(B) ARP poison attack</h5>
<div class="outline-text-5" id="text-org5cb4eab">
<ul class="org-ul">
<li>概念: ARP 欺騙是一種網路攻擊方式，攻擊者透過偽造 ARP 訊息，將自己的 MAC 位址與目標的 IP 位址關聯，達到攔截或竄改網路流量的目的<br /></li>
<li>運作方式: 攻擊者發送偽造的 ARP 回應，將自己的 MAC 位址對應到受害者的 IP 位址，當受害者發送數據時，會將數據發送到攻擊者的電腦，而非真正的目標。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgcf7dbc7"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-orgcf7dbc7">
<ul class="org-ul">
<li>ARP (Address Resolution Protocol): ARP 是將 IP 位址轉換為 MAC 位址的網路協定。<br /></li>
<li>網路安全: ARP 欺騙屬於中間人攻擊（Man-in-the-Middle Attack）的一種，對網路安全造成威脅。<br /></li>
<li>網路協定: 了解 ARP 運作原理對於理解網路攻擊和防禦至關重要。<br /></li>
</ul>
</div>
</li>
<li><a id="org4a39a06"></a>ARP（Address Resolution Protocol，位址解析協定）<br />
<div class="outline-text-6" id="text-org4a39a06">
<p>
ARP 是一種網路協定，用於在區域網路（LAN）中解析 IP 位址（網路層）對應的 MAC 位址（資料鏈路層）。當一台設備需要發送資料給同一子網內的另一台設備時，它需要知道對方的 MAC 地址，而 ARP 的作用就是負責獲取這個 MAC 位址。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org51e10c0"></a>ARP 工作流程<br />
<div class="outline-text-7" id="text-org51e10c0">
<ul class="org-ul">
<li>發送 ARP Request（請求）：<br />
<ul class="org-ul">
<li>當主機 A（例如 IP：192.168.1.10）需要與主機 B（IP：192.168.1.20）通訊，但不知道 B 的 MAC 位址時，它會發送一個 廣播（Broadcast）ARP 請求，詢問：「誰是 192.168.1.20？請提供你的 MAC 地址。」<br /></li>
<li>這個請求會傳送到子網內的所有設備。<br /></li>
</ul></li>
<li>接收 ARP Reply（回應）：<br />
<ul class="org-ul">
<li>目標設備（IP：192.168.1.20）收到 ARP Request 後，會回應自己的 MAC 位址，例如：「我是 192.168.1.20，我的 MAC 地址是 00:1A:2B:3C:4D:5E。」<br /></li>
<li>這個回應是 單播（Unicast） 回傳給發送者（192.168.1.10）。<br /></li>
</ul></li>
<li>更新 ARP 快取表（ARP Cache）：<br />
<ul class="org-ul">
<li>發送者 A 會將 B 的 MAC 地址存入自己的 ARP 快取表，未來直接使用，無需再次詢問。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org13b5e0b"></a>ARP 欺騙（ARP Spoofing / ARP Poisoning）<br />
<div class="outline-text-6" id="text-org13b5e0b">
<p>
ARP 欺騙 是一種網路攻擊技術，攻擊者透過發送 偽造的 ARP 回應，欺騙網路中的其他設備，使它們將攻擊者的 MAC 地址誤認為是合法設備的 MAC 地址，從而攔截或竄改資料流量。<br />
ARP 欺騙攻擊流程<br />
</p>
<ul class="org-ul">
<li>攻擊者發送偽造 ARP 回應<br />
<ul class="org-ul">
<li>假設受害者 A（IP：192.168.1.10）想要與網關（Gateway，IP：192.168.1.1）通訊。<br /></li>
<li>攻擊者 C（IP：192.168.1.100）偽造 ARP 回應，讓 A 誤以為網關的 MAC 位址是 C 的 MAC 地址。<br /></li>
<li>同時，C 也向網關偽造 ARP 回應，使網關認為 A 的 MAC 地址是 C 的 MAC。<br /></li>
</ul></li>
<li>攔截或修改資料<br />
<ul class="org-ul">
<li>受害者 A 會將所有資料發送到攻擊者 C，然後 C 再將資料轉發給真正的網關（這就是中間人攻擊（MITM，Man-in-the-Middle Attack））。<br /></li>
<li>攻擊者 C 可以：<br />
<ul class="org-ul">
<li>監聽封包（如竊取密碼、信用卡資訊）。<br /></li>
<li>修改數據（如竄改網站內容）。<br /></li>
<li>阻斷網路（不轉發封包，使受害者無法上網）。<br /></li>
</ul></li>
</ul></li>
<li>持續影響：<br />
<ul class="org-ul">
<li>由於 ARP 是無認證機制的，這種攻擊可以不斷發送 ARP 回應，使受害者的 ARP 快取表持續錯誤，導致長時間的流量劫持。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org3e03382"></a>ARP 欺騙的防範方法<br />
<div class="outline-text-6" id="text-org3e03382">
<ul class="org-ul">
<li>靜態 ARP 表（Static ARP Table）：<br />
<ul class="org-ul">
<li>在關鍵設備（如伺服器、網關）上手動設定 ARP 表，使其 IP-MAC 對應關係固定，不接受 ARP 更新。<br /></li>
</ul></li>
<li>使用 ARP 監控工具：<br />
<ul class="org-ul">
<li>工具如 ARPWatch、XArp 可以偵測異常的 ARP 變更。<br /></li>
</ul></li>
<li>啟用動態 ARP 檢測（DAI，Dynamic ARP Inspection）（適用於網管交換機）：<br />
<ul class="org-ul">
<li>限制未授權的 ARP 封包，防止非信任來源發送偽造 ARP 回應。<br /></li>
</ul></li>
<li>使用 VPN 或 HTTPS：<br />
<ul class="org-ul">
<li>確保資料傳輸是加密的，即使遭到攔截，攻擊者也無法直接解讀內容。<br /></li>
</ul></li>
<li>使用防火牆或 IPS（入侵防禦系統）：<br />
<ul class="org-ul">
<li>一些高級防火牆和 IPS 具備 ARP 欺騙防禦機制，可以偵測異常的 ARP 封包。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbd97d61" class="outline-5">
<h5 id="orgbd97d61">(C) ICMP (Internet Control Message Protocol)</h5>
<div class="outline-text-5" id="text-orgbd97d61">
<ul class="org-ul">
<li>概念: ICMP 是一個網路協定，用於傳輸錯誤訊息和控制訊息<br /></li>
<li>它不是用於傳輸用戶數據，而是協助網路設備診斷和回報問題。<br /></li>
<li>運作方式: 當路由器或其他網路設備遇到問題時（如目標無法到達、逾時），會發送 ICMP 訊息給發送端，告知網路問題。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgcfca93f"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-orgcfca93f">
<ul class="org-ul">
<li>網路協定: ICMP 是 TCP/IP 協定族中的一個重要組成部分，與 IP 協定共同運作。<br /></li>
<li>網路診斷工具: 常用的網路診斷工具如 ping 和 traceroute 都基於 ICMP 協定。<br /></li>
<li>網路層: ICMP 運作在網路層，處理 IP 數據包的錯誤和控制訊息。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgb323dd9" class="outline-5">
<h5 id="orgb323dd9">(D) MPLS (Multi-Protocol Label Switch)</h5>
<div class="outline-text-5" id="text-orgb323dd9">
<ul class="org-ul">
<li>概念: MPLS 是一種網路技術，用於加速數據包的轉發。它通過在數據包前添加標籤，讓路由器根據標籤快速轉發數據，而非像傳統 IP 路由那樣需要查詢路由表。<br /></li>
<li>運作方式: 進入 MPLS 網路的數據包會被賦予一個標籤，路由器根據標籤進行轉發，無需檢查 IP 位址，提高了轉發效率。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org4b663bc"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-org4b663bc">
<ul class="org-ul">
<li>網路路由: MPLS 是一種提升路由效率的技術，常應用於大型網路和電信網路。<br /></li>
<li>數據轉發: MPLS 利用標籤交換技術，減少路由器查找路由表的時間。<br /></li>
<li>網路效能: MPLS 有助於提高網路效能，降低延遲，提升 QoS（服務品質）。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5e7b58e" class="outline-5">
<h5 id="org5e7b58e">(E) Reverse proxy server</h5>
<div class="outline-text-5" id="text-org5e7b58e">
<ul class="org-ul">
<li>概念: 反向代理伺服器是一種伺服器，部署在一個或多個伺服器之前，接收來自用戶端的請求，並將這些請求轉發到後端的伺服器。<br /></li>
<li>運作方式: 當用戶端發送請求時，請求首先到達反向代理伺服器，然後由代理伺服器根據規則將請求轉發到合適的後端伺服器，後端伺服器的回應也會通過反向代理伺服器返回用戶端。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgaa52907"></a>相關計概知識:<br />
<div class="outline-text-6" id="text-orgaa52907">
<ul class="org-ul">
<li>網路架構: 反向代理伺服器常應用於網站伺服器，提供負載平衡、安全保護等功能。<br /></li>
<li>伺服器管理: 反向代理伺服器有助於管理多個伺服器，簡化部署和維護。<br /></li>
<li>網路安全: 反向代理伺服器可以隱藏後端伺服器的真實 IP 位址，提高安全性。<br /></li>
</ul>
</div>
</li>
<li><a id="org3596a8b"></a>Proxy Server（代理伺服器）<br />
<div class="outline-text-6" id="text-org3596a8b">
<p>
Proxy Server（代理伺服器） 是一種中介設備或軟體，負責在用戶（Client）與目標伺服器（Server）之間轉發網路請求。當用戶請求網頁或其他網路資源時，請求會先經過 Proxy Server，再由 Proxy Server 代表用戶與目標伺服器通訊，最後將結果回傳給用戶。<br />
</p>

<p>
簡單來說，代理伺服器就像是一個「中間人」，用來提高 安全性、隱私性、速度，或者繞過某些網路限制。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org5419647"></a>Proxy Server 的運作方式<br />
<div class="outline-text-7" id="text-org5419647">
<ol class="org-ol">
<li>用戶發出請求：例如，使用者希望存取 **<a href="https://example.com**，但瀏覽器的網路設置經過代理伺服器">https://example.com**，但瀏覽器的網路設置經過代理伺服器</a>。<br /></li>
<li>請求經過代理伺服器：代理伺服器收到請求後，可能會先檢查快取（Cache），如果先前已經存儲過該網頁，則直接提供快取內容，無需再次請求網頁。<br /></li>
<li>代理伺服器向目標伺服器請求：如果代理伺服器沒有快取，則它會代表用戶向 example.com 發送請求。<br /></li>
<li>目標伺服器回應：example.com 回傳內容給代理伺服器。<br /></li>
<li>代理伺服器回應用戶：代理伺服器收到回應後，可以進行處理（例如壓縮數據、過濾內容），然後將結果傳回用戶。<br /></li>
</ol>
</div>
</li>
<li><a id="org4fdbf26"></a>Proxy Server 的類型<br />
<div class="outline-text-7" id="text-org4fdbf26">
<ol class="org-ol">
<li>正向代理（Forward Proxy）<br />
<ul class="org-ul">
<li>用戶 → 代理伺服器 → 目標伺服器<br /></li>
<li>代理 客戶端，用來幫助使用者存取網路資源。<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>隱藏用戶 IP，保護隱私。<br /></li>
<li>突破網路封鎖（如中國防火長城）。<br /></li>
<li>快取內容，提升瀏覽速度。<br /></li>
</ul></li>
<li>例子：企業內部的 Proxy Server，限制員工只能存取特定網站。<br /></li>
</ul></li>
<li>反向代理（Reverse Proxy）<br />
<ul class="org-ul">
<li>用戶 → 反向代理伺服器 → 內部伺服器<br /></li>
<li>代理 伺服器，用來保護或強化後端伺服器的效能與安全性。<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>負載平衡（Load Balancing）：多台伺服器共同處理流量，提高效能。<br /></li>
<li>安全性：屏蔽內部伺服器的 IP，避免直接暴露於網際網路。<br /></li>
<li>內容快取：減少伺服器負擔，加快網站加載速度。<br /></li>
</ul></li>
<li>例子：Cloudflare 這類 CDN（內容傳遞網路）服務就是一種反向代理。<br /></li>
</ul></li>
<li>透明代理（Transparent Proxy）<br />
<ul class="org-ul">
<li>不需用戶設定，網路管理員強制使用<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>企業或學校監控員工或學生的網路活動。<br /></li>
<li>節省頻寬，透過快取技術提升網路效能。<br /></li>
</ul></li>
<li>缺點：無法隱藏 IP，因為請求仍然顯示使用者的原始 IP。<br /></li>
</ul></li>
<li>匿名代理（Anonymous Proxy）<br />
<ul class="org-ul">
<li>用來隱藏使用者的 IP 位址，提高匿名性。<br /></li>
<li>用途：<br />
<ul class="org-ul">
<li>繞過地區限制（如觀看 Netflix 美國限定內容）。<br /></li>
<li>提供額外的安全性，防止網站追蹤。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org15a36de"></a>Proxy Server 的主要用途<br />
<div class="outline-text-7" id="text-org15a36de">
<ol class="org-ol">
<li>網路安全與隱私保護<br />
<ul class="org-ul">
<li>隱藏用戶 IP，防止網站追蹤。<br /></li>
<li>防止駭客攻擊，保護內部伺服器不被直接攻擊。<br /></li>
</ul></li>
<li>加速網頁存取（快取）<br />
代理伺服器可以儲存（Cache）熱門的網站內容，當用戶再次存取時，直接提供快取內容，減少頻寬使用，提高瀏覽速度。<br /></li>
<li>繞過網路封鎖<br />
許多國家或機構（如學校、公司）會封鎖特定網站，使用代理伺服器可以繞過這些限制，如 Google、Facebook 在中國被封鎖，但透過代理伺服器仍可存取。<br /></li>
<li>負載平衡<br />
企業透過 反向代理 將請求分配到多台伺服器，防止單一伺服器過載，提高網站的可用性。<br /></li>
<li>網路監控與流量管理<br />
企業和學校可以透過 Proxy Server 限制員工或學生的網路使用，例如封鎖 YouTube 或社群媒體網站，以提高工作效率。<br /></li>
</ol>
</div>
</li>
<li><a id="org648c38b"></a>Proxy Server vs VPN 的差異<br />
<div class="outline-text-7" id="text-org648c38b">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">Proxy Server</th>
<th scope="col" class="org-left">VPN（虛擬私人網路）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">功能</td>
<td class="org-left">轉發網頁請求，隱藏 IP</td>
<td class="org-left">建立加密通道，確保安全與匿名</td>
</tr>

<tr>
<td class="org-left">隱私保護</td>
<td class="org-left">只適用於特定應用（如瀏覽器）</td>
<td class="org-left">全部流量加密，適用於所有應用程式</td>
</tr>

<tr>
<td class="org-left">安全性</td>
<td class="org-left">可能無加密，易受攻擊</td>
<td class="org-left">提供加密通訊，較安全</td>
</tr>

<tr>
<td class="org-left">速度</td>
<td class="org-left">可能較快（透過快取）</td>
<td class="org-left">可能較慢（因為加密處理）</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">翻牆、快取、負載平衡</td>
<td class="org-left">繞過政府審查、保護個人隱私</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgdc732c1"></a>總結<br />
<div class="outline-text-7" id="text-orgdc732c1">
<ul class="org-ul">
<li>Proxy Server（代理伺服器） 是一種中介設備，幫助用戶與伺服器之間轉發請求，提升安全性、加速存取、繞過網路封鎖，或實現負載平衡等功能。<br /></li>
<li>根據不同用途，代理伺服器可以分為 正向代理、反向代理、透明代理、匿名代理 等。<br /></li>
<li>企業和個人使用代理伺服器來提高安全性、節省頻寬、監控網路流量，或繞過地區限制。<br /></li>
<li>VPN 提供更強的加密與匿名性，而 Proxy Server 主要用於快取與網路請求轉發。<br /></li>
</ul>
</div>
</li>
<li><a id="orgab4f701"></a>何時使用 Proxy？<br />
<div class="outline-text-7" id="text-orgab4f701">
<ul class="org-ul">
<li>✅ 想加速網站存取（快取）<br /></li>
<li>✅ 想隱藏 IP，但不在乎加密<br /></li>
<li>✅ 企業或學校需要網路監控與流量管理<br /></li>
<li>✅ 負載平衡，提高伺服器效能<br /></li>
</ul>
</div>
</li>
<li><a id="org50576fd"></a>何時使用 VPN？<br />
<div class="outline-text-7" id="text-org50576fd">
<ul class="org-ul">
<li>✅ 想 完全匿名，避免 ISP 或政府監控<br /></li>
<li>✅ 需要加密 上網流量，防止駭客攔截<br /></li>
<li>✅ 繞過網路審查，如中國的防火長城<br /></li>
<li>✅ 不只瀏覽器，而是所有網路流量都要隱藏<br /></li>
</ul>
<p>
如果你只是想要隱藏 IP，Proxy Server 可能就足夠，但如果你想要 完整的隱私保護與資料加密，那麼 VPN 會是更好的選擇。<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org7adcb92" class="outline-4">
<h4 id="org7adcb92"><span class="section-number-4">1.3.2.</span> 第二題(共 25 分)：</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Sometimes we wish to store passwords in a database. When storing passwords, we need to take extra considerations in the database design.<br />
</p>
</div>
<div id="outline-container-org2ee9902" class="outline-5">
<h5 id="org2ee9902">(A) (10 分) Read the following statements. Place a tick in the box if the statement is true, otherwise place a cross.</h5>
<div class="outline-text-5" id="text-org2ee9902">
<ol class="org-ol">
<li>Password hashing can protect the website from being breached.<br /></li>
<li>It’s possible for a hashing algorithm to have a collision or a clash.<br /></li>
<li>A hash is a string or number generated from a string of text.<br /></li>
<li>The best hashing algorithms are designed so that it’s impossible to turn a hash back into its original string.<br /></li>
<li>When a hash algorithm is given the same input, the same output is always produced.<br /></li>
<li>Password hashing must be done on the client-side where the user enters the password.<br /></li>
<li>Fast hashing functions such as MD5, SHA1 are safer than slow hashing algorithms.<br /></li>
<li>A copy of the plain password should be stored securely in the database in case the user forgets his/her password.<br /></li>
<li>If password hashing is done on the client-side, it must be done again on the server-side.<br /></li>
<li>Hashing and Encryption are the same.<br /></li>
</ol>
</div>
<ul class="org-ul">
<li><a id="org9a3e968"></a>解<br />
<div class="outline-text-6" id="text-org9a3e968">
<ol class="org-ol">
<li>密碼雜湊可以保護網站免於被入侵。 (錯誤)<br />
<ul class="org-ul">
<li>詳解： 密碼雜湊的主要目的是保護使用者密碼，而非直接保護網站本身。雖然良好的雜湊機制能降低密碼洩漏的風險，但網站仍可能因其他漏洞（如SQL注入、程式碼漏洞）而被入侵。<br /></li>
</ul></li>
<li>雜湊演算法可能發生碰撞（collision）或衝突（clash）。 (正確)<br />
<ul class="org-ul">
<li>詳解：  雜湊函數的特性是將任意長度的輸入轉換成固定長度的輸出。由於輸入的範圍可能大於輸出的範圍，不同的輸入有可能產生相同的輸出，這種情況就稱為碰撞或衝突。<br /></li>
</ul></li>
<li>雜湊是一個由文字字串產生的字串或數字。 (正確)<br />
<ul class="org-ul">
<li>詳解：  雜湊函數的輸出結果是一個固定長度的字串或數字，此輸出是從輸入的文字字串轉換而來，用來代表原始輸入<br /></li>
</ul></li>
<li>最佳的雜湊演算法設計成無法將雜湊值還原成原始字串。 (正確)<br />
<ul class="org-ul">
<li>詳解：  單向雜湊函數（one-way hash function） 的設計目標是 不可逆性，也就是無法從雜湊值反推出原始輸入。這是為了確保密碼在洩漏時，攻擊者無法輕易還原出原始密碼<br /></li>
</ul></li>
<li>當雜湊演算法給定相同的輸入時，永遠會產生相同的輸出。 (正確)<br />
<ul class="org-ul">
<li>詳解：  確定性雜湊函數 的重要特性之一就是，相同的輸入總是會產生相同的輸出。這確保了雜湊值的一致性和可比性。因此，這句話的敘述是正確的。<br /></li>
</ul></li>
<li>密碼雜湊必須在使用者輸入密碼的客戶端進行。 (錯誤)<br />
<ul class="org-ul">
<li>詳解：  雖然可以在客戶端進行雜湊，但為了安全性考量，密碼雜湊通常會在伺服器端進行。這是為了避免雜湊演算法在客戶端被洩漏或竄改<br /></li>
</ul></li>
<li>像MD5、SHA1這種快速雜湊函數比慢速雜湊函數更安全。 (錯誤)<br />
<ul class="org-ul">
<li>詳解：  快速雜湊函數（如MD5、SHA1）由於設計上的缺陷和容易被破解，反而安全性較低。現代的密碼雜湊應採用更強壯的算法（如SHA-256、bcrypt、scrypt等）<br /></li>
</ul></li>
<li>為了在使用者忘記密碼時使用，應該將明文密碼安全地儲存在資料庫中。 (錯誤)<br />
<ul class="org-ul">
<li>詳解：  絕對不應該儲存明文密碼，這是嚴重的安全漏洞。 應該使用雜湊處理後的密碼儲存在資料庫，忘記密碼時應透過密碼重設流程<br /></li>
</ul></li>
<li>如果密碼雜湊在客戶端進行，就必須在伺服器端再次進行。 (正確)<br />
<ul class="org-ul">
<li>詳解：  為了確保安全性，如果客戶端進行了雜湊，伺服器端必須再次進行雜湊，防止中間人攻擊或客戶端雜湊被破解<br /></li>
</ul></li>
<li>雜湊和加密是相同的。 (錯誤)<br />
<ul class="org-ul">
<li>詳解：  雜湊和加密是不同的概念。雜湊是單向的，不可逆；加密是雙向的，可逆。加密的目的是保護數據的機密性，而雜湊的目的是驗證數據的完整性或密碼的安全性。因此，這句話的敘述是錯誤的<br /></li>
</ul></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8e8b315" class="outline-5">
<h5 id="org8e8b315">(B) (15 分)</h5>
<div class="outline-text-5" id="text-org8e8b315">
<p>
What is a salt? And why it is important when hashing a password?<br />
</p>
<ul class="org-ul">
<li>Salt的定義：Salt是一個隨機產生的字串，在進行雜湊計算之前會附加到密碼上。這個Salt值是隨機產生且唯一的，每個使用者都應該有不同的Salt值<br /></li>
<li>Salt的重要性：防止彩虹表攻擊：彩虹表是一種預先計算好的雜湊值表，攻擊者可以透過查詢表來還原密碼。使用Salt可以使每個密碼的雜湊值都不同，即使是相同的密碼，因為Salt值不同產生的雜湊值也會不同，從而阻止攻擊者使用彩虹表<br /></li>
<li>增加雜湊的複雜度：Salt值可以使雜湊值更加複雜，增加破解難度。即使攻擊者獲取了雜湊值，也很難在沒有Salt值的情況下還原出原始密碼。<br /></li>
<li>強化密碼安全：使用Salt是現代密碼安全實踐的重要一環，可以顯著提高密碼的安全性。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd9e7ba8" class="outline-5">
<h5 id="orgd9e7ba8">相關計概知識：</h5>
<div class="outline-text-5" id="text-orgd9e7ba8">
<ul class="org-ul">
<li>雜湊函數（Hash Function）：<br />
<ul class="org-ul">
<li>將任意長度的輸入轉換為固定長度的輸出。<br /></li>
<li>具有確定性，相同的輸入產生相同的輸出。<br /></li>
<li>理想的雜湊函數具有單向性（不可逆）。<br /></li>
</ul></li>
<li>密碼雜湊（Password Hashing）：<br />
<ul class="org-ul">
<li>使用雜湊函數對密碼進行處理，以保護密碼安全。<br /></li>
<li>通常與鹽值一起使用，提高安全性。<br /></li>
</ul></li>
<li>彩虹表攻擊（Rainbow Table Attack）：<br />
<ul class="org-ul">
<li>一種預先計算好雜湊值的攻擊方式，透過查詢表來還原密碼。<br /></li>
<li>使用Salt可以有效防止此類攻擊。<br /></li>
</ul></li>
<li>單向函數（One-way Function）：<br />
<ul class="org-ul">
<li>一種易於計算但難以反向計算的函數。<br /></li>
<li>雜湊函數是一種單向函數。<br /></li>
</ul></li>
<li>現代密碼雜湊算法：<br />
<ul class="org-ul">
<li>SHA-256、SHA-512、bcrypt、scrypt等，這些算法都經過嚴格的設計和審查，能提供更高的安全性。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcf46d03" class="outline-4">
<h4 id="orgcf46d03"><span class="section-number-4">1.3.3.</span> 第三題：(5 分)</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Choose the correct answer(s) regarding interface and abstract class in Java. [single or multiple choices]<br />
</p>
<ul class="org-ul">
<li>(a) They are the same.<br /></li>
<li>(b) Both can have constants as their attributes.<br /></li>
<li>(c) An abstract class is used in Java to realize multiple inheritances.<br /></li>
<li>(d) An interface cannot define any method implementation, but an abstract class can.<br /></li>
<li>(e) To have any instance of their type instantiated, they both need other class(es).<br /></li>
</ul>
</div>
<div id="outline-container-org8a28022" class="outline-5">
<h5 id="org8a28022">解</h5>
<div class="outline-text-5" id="text-org8a28022">
<ul class="org-ul">
<li>(a) 他們是相同的。 (錯誤)<br />
<ul class="org-ul">
<li>詳解： 介面和抽象類別在Java中是不同的概念，它們有不同的用途和特性。介面定義了類別必須實作的方法，而抽象類別則可以包含實作的方法以及抽象的方法。<br /></li>
</ul></li>
<li>(b) 兩者都可以有常數作為其屬性。 (正確)<br />
<ul class="org-ul">
<li>詳解： 介面中的屬性預設為 public static final，也就是常數。抽象類別中也可以定義 public static final 的常數屬性。因此，這個敘述是正確的。<br /></li>
</ul></li>
<li>(c) 抽象類別在Java中被用來實現多重繼承。 (錯誤)<br />
<ul class="org-ul">
<li>詳解： 在Java中，類別不支援多重繼承，但介面可以實現多重繼承。抽象類別的主要目的是作為一個基底類別，用於定義子類別的共同行為。因此，這個敘述是錯誤的。<br /></li>
</ul></li>
<li>(d) 介面不能定義任何方法的實作，但抽象類別可以。 (正確)<br />
<ul class="org-ul">
<li>詳解： 在Java 8之前，介面只能定義抽象方法（沒有實作）。而在Java 8之後，介面可以定義default方法，提供預設的實作。抽象類別可以包含抽象方法和具體實作的方法。因此，這個敘述是正確的。<br /></li>
</ul></li>
<li>(e) 要實例化它們的任何類型，它們都需要其他類別。 (正確)<br />
<ul class="org-ul">
<li>詳解：  介面和抽象類別都不能直接實例化。必須透過其他類別來實作介面或繼承抽象類別，並建立子類別的實例。因此，這個敘述是正確的。<br /></li>
</ul></li>
</ul>
<p>
正確答案：(b), (d), (e)<br />
</p>
</div>
</div>
<div id="outline-container-org7f62842" class="outline-5">
<h5 id="org7f62842">相關計概知識：</h5>
<div class="outline-text-5" id="text-org7f62842">
<ul class="org-ul">
<li>介面（Interface）：<br />
<ul class="org-ul">
<li>是一種完全抽象的類型，只定義方法簽名（沒有實作）。<br /></li>
<li>可以實現多重繼承。<br /></li>
<li>介面中的屬性預設是 public static final，也就是常數。<br /></li>
<li>從Java 8開始，介面可以使用default關鍵字定義預設實作的方法。<br /></li>
</ul></li>
<li>抽象類別（Abstract Class）：<br />
<ul class="org-ul">
<li>是一種不能直接實例化的類別。<br /></li>
<li>可以包含抽象方法和具體實作的方法。<br /></li>
<li>主要用作基底類別，用於定義子類別的共同行為。<br /></li>
<li>類別只能繼承一個抽象類別。<br /></li>
</ul></li>
<li>抽象方法（Abstract Method）：<br />
<ul class="org-ul">
<li>只有方法簽名，沒有方法實作。<br /></li>
<li>必須在子類別中實作。<br /></li>
</ul></li>
<li>多重繼承 (Multiple Inheritance)<br />
<ul class="org-ul">
<li>在Java中，類別無法直接繼承多個類別，但可以透過實作多個介面來達到類似的效果。<br /></li>
</ul></li>
<li>實例化（Instantiation）：<br />
<ul class="org-ul">
<li>創建一個類別的對象。<br /></li>
<li>抽象類別和介面都不能直接實例化。<br /></li>
</ul></li>
</ul>
<p>
總結: 理解介面和抽象類別的差異是Java程式設計中非常重要的一部分。介面提供了一種定義合約的方式，而抽象類別則提供了一種定義基底類別的方式。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd3db786" class="outline-4">
<h4 id="orgd3db786"><span class="section-number-4">1.3.4.</span> 第四題：(20 分)</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Many programs written with inheritance could be written with composition instead. Please provide an example of rewriting a program with inheritance to a program with composition, and compare the pro and cons of both approaches and examples. Your examples should be of the appropriate depth for illustration.<br />
</p>
</div>
<div id="outline-container-orgc3c1891" class="outline-5">
<h5 id="orgc3c1891">解</h5>
<div class="outline-text-5" id="text-orgc3c1891">
<p>
題目要求我們探討使用組合來替代繼承，並比較兩者的優缺點。以下我將提供一個範例說明，並比較兩種方式的利弊。<br />
範例：使用繼承與組合來設計一個「車輛」系統<br />
假設我們需要設計一個簡單的車輛系統，包含 Car（汽車）和 Engine（引擎）。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orga7aaf5b"></a>1. 使用繼承（Inheritance）的設計：<br />
<div class="outline-text-6" id="text-orga7aaf5b">
<p>
程式碼範例 (使用虛擬碼，概念為主):<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29238;&#39006;&#21029;&#65306;&#24341;&#25806;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Engine</span> {
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">start</span>() {
<span class="linenr"> 4: </span>        print(<span style="color: #98be65;">"Engine started."</span>);
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23376;&#39006;&#21029;&#65306;&#27773;&#36554; (&#32380;&#25215;&#24341;&#25806;)</span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Car</span> <span style="color: #ECBE7B;">extends</span> <span style="color: #dcaeea;">Engine</span> {
<span class="linenr">10: </span>    <span style="color: #ECBE7B;">void</span> drive() {
<span class="linenr">11: </span>        start(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#32380;&#25215;&#20358;&#30340;&#24341;&#25806;&#21855;&#21205;&#26041;&#27861;</span>
<span class="linenr">12: </span>        print(<span style="color: #98be65;">"Car is driving."</span>);
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>}
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">void</span> main(<span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">args</span>[]){
<span class="linenr">17: </span>    <span style="color: #ECBE7B;">Car</span> <span style="color: #dcaeea;">myCar</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Car</span>();
<span class="linenr">18: </span>    myCar.drive();
<span class="linenr">19: </span>}
</pre>
</div>
<p>
說明：<br />
</p>
<ul class="org-ul">
<li>◦Car 類別繼承 Engine 類別，因此 Car 擁有 Engine 的 start() 方法。<br /></li>
<li>◦這種設計方式簡單直接，程式碼較短。<br /></li>
</ul>
</div>
</li>
<li><a id="org41fff54"></a>2. 使用組合（Composition）的設計：<br />
<div class="outline-text-6" id="text-org41fff54">
<p>
程式碼範例 (使用虛擬碼，概念為主):<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24341;&#25806;&#39006;&#21029;</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Engine</span> {
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">start</span>() {
<span class="linenr"> 4: </span>        print(<span style="color: #98be65;">"Engine started."</span>);
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27773;&#36554;&#39006;&#21029; (&#32068;&#21512;&#24341;&#25806;)</span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Car</span> {
<span class="linenr">10: </span>    <span style="color: #51afef;">private</span> Engine engine; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27773;&#36554;&#21253;&#21547;&#19968;&#20491;&#24341;&#25806;</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #51afef;">public</span> Car(<span style="color: #ECBE7B;">Engine</span> <span style="color: #dcaeea;">engine</span>) {
<span class="linenr">13: </span>        <span style="color: #51afef;">this</span>.engine = engine;
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">drive</span>() {
<span class="linenr">17: </span>        engine.start(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#29992;&#32068;&#21512;&#30340;&#24341;&#25806;&#21855;&#21205;&#26041;&#27861;</span>
<span class="linenr">18: </span>        print(<span style="color: #98be65;">"Car is driving."</span>);
<span class="linenr">19: </span>    }
<span class="linenr">20: </span>}
<span class="linenr">21: </span>
<span class="linenr">22: </span>
<span class="linenr">23: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">void</span> main(<span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">args</span>[]){
<span class="linenr">24: </span>  <span style="color: #ECBE7B;">Engine</span> <span style="color: #dcaeea;">myEngine</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Engine</span>();
<span class="linenr">25: </span>  <span style="color: #ECBE7B;">Car</span> <span style="color: #dcaeea;">myCar</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Car</span>(myEngine);
<span class="linenr">26: </span>  myCar.drive();
<span class="linenr">27: </span>}
</pre>
</div>
<p>
說明：<br />
</p>
<ul class="org-ul">
<li>Car 類別包含一個 Engine 物件，而不是繼承自 Engine。<br /></li>
<li>Car 透過呼叫 Engine 物件的 start() 方法來啟動引擎。<br /></li>
<li>這種設計方式更加靈活，可以更容易地更換或修改引擎。<br /></li>
</ul>
<p>
比較：繼承 vs. 組合<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">繼承 (Inheritance)</th>
<th scope="col" class="org-left">組合 (Composition)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">關係</td>
<td class="org-left">「is-a」（是一種）關係 例如: 汽車是一種引擎</td>
<td class="org-left">「has-a」（有一個）關係 例如: 汽車有一個引擎</td>
</tr>

<tr>
<td class="org-left">耦合性</td>
<td class="org-left">高耦合，子類別高度依賴父類別</td>
<td class="org-left">低耦合，類別間獨立性較高</td>
</tr>

<tr>
<td class="org-left">彈性</td>
<td class="org-left">彈性較低，不易修改和擴充</td>
<td class="org-left">彈性較高，易於修改和擴充</td>
</tr>

<tr>
<td class="org-left">程式碼重用</td>
<td class="org-left">透過繼承直接重用父類別的程式碼</td>
<td class="org-left">透過組合重用其他類別的功能</td>
</tr>

<tr>
<td class="org-left">多重繼承</td>
<td class="org-left">在Java等語言中不支援多重類別繼承</td>
<td class="org-left">可以透過組合多個物件實現類似效果</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">類別之間存在明顯的層級關係</td>
<td class="org-left">類別之間需要靈活組合或變更</td>
</tr>
</tbody>
</table>
<p>
優缺點分析：<br />
</p>
<ul class="org-ul">
<li>繼承的優點：<br />
<ul class="org-ul">
<li>程式碼較為簡潔，結構清晰。<br /></li>
<li>易於建立層次結構。<br /></li>
<li>能夠直接使用父類別的方法和屬性，減少重複程式碼。<br /></li>
</ul></li>
<li>繼承的缺點：<br />
<ul class="org-ul">
<li>耦合性高，子類別過於依賴父類別，修改父類別可能會影響子類別。<br /></li>
<li>彈性較低，難以在執行時動態變更繼承關係。<br /></li>
<li>可能導致「脆弱的基底類別」問題，基底類別的修改會影響許多子類別。<br /></li>
<li>在Java中，不支援多重繼承，限制了程式碼的擴展性。<br /></li>
</ul></li>
<li>組合的優點：<br />
<ul class="org-ul">
<li>耦合性低，類別間獨立性高，修改其中一個類別對其他類別影響較小。<br /></li>
<li>彈性高，易於在執行時動態變更組合關係。<br /></li>
<li>可以透過組合不同的類別，實現更複雜的功能。<br /></li>
<li>避免了繼承的「脆弱的基底類別」問題。<br /></li>
</ul></li>
<li>組合的缺點：<br />
<ul class="org-ul">
<li>程式碼可能較為繁瑣，需要處理物件之間的關係。<br /></li>
<li>需要建立額外的物件，可能會增加程式碼的複雜度。<br /></li>
</ul></li>
</ul>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>在設計系統時，應該根據實際情況選擇繼承或組合。<br /></li>
<li>當類別之間存在明顯的「is-a」關係時，可以使用繼承。 例如，汽車是一種交通工具。<br /></li>
<li>當類別之間需要靈活組合或變更時，應該使用組合。 例如，汽車包含引擎、輪胎等元件。<br /></li>
<li>在現代軟體設計中，組合通常比繼承更受推崇，因為它提供了更高的彈性和可維護性。<br /></li>
</ul>
<p>
相關計概知識：<br />
</p>
<ul class="org-ul">
<li>繼承 (Inheritance):<br />
<ul class="org-ul">
<li>一種物件導向程式設計的機制，允許一個類別（子類別）繼承另一個類別（父類別）的屬性和方法。<br /></li>
<li>有助於程式碼重用和建立層次結構。<br /></li>
</ul></li>
<li>組合 (Composition):<br />
<ul class="org-ul">
<li>一種物件導向程式設計的機制，允許一個類別包含另一個類別的物件，並使用該物件的功能。<br /></li>
<li>有助於提高彈性和可維護性，降低耦合性。<br /></li>
</ul></li>
<li>耦合性 (Coupling):<br />
<ul class="org-ul">
<li>衡量不同模組之間相互依賴程度的指標。<br /></li>
<li>高耦合表示模組之間依賴性高，修改一個模組可能影響其他模組。<br /></li>
<li>低耦合表示模組之間獨立性高，修改一個模組對其他模組影響較小。<br /></li>
</ul></li>
<li>物件導向程式設計 (Object-Oriented Programming, OOP):<br />
<ul class="org-ul">
<li>一種程式設計範式，以物件為中心，將資料和操作資料的方法封裝在一起。<br /></li>
<li>OOP 的主要概念包括：封裝、繼承和多型。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org29ea38b" class="outline-4">
<h4 id="org29ea38b"><span class="section-number-4">1.3.5.</span> 第五題：(5 分)</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Please draw the diagram of process state.<br />
</p>
<ul class="org-ul">
<li>直接把這篇看完，背起來，這是最基本的OS考題<br />
<a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html">https://chenhh.gitbooks.io/parallel_processing/content/process.html</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5c062b8" class="outline-4">
<h4 id="org5c062b8"><span class="section-number-4">1.3.6.</span> 第六題：(4 分)</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
What is four conditions of deadlock occurring?<br />
</p>
<ul class="org-ul">
<li>看這篇：<a href="https://medium.com/algorithm-solving/os-deadlock-842b31602908">https://medium.com/algorithm-solving/os-deadlock-842b31602908</a><br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgb8063ba" class="outline-4">
<h4 id="orgb8063ba"><span class="section-number-4">1.3.7.</span> 第七題：(4 分)</h4>
<div class="outline-text-4" id="text-1-3-7">
<p>
Please explain the Belady’s Anomaly. Which page replacement algorithm will suffer this fatal problem?<br />
</p>
</div>
<div id="outline-container-org3083782" class="outline-5">
<h5 id="org3083782">解</h5>
<div class="outline-text-5" id="text-org3083782">
<p>
作業系統的記憶體管理，計概裡應該有<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org573a626"></a>Belady&rsquo;s Anomaly (貝雷迪異常):<br />
<div class="outline-text-6" id="text-org573a626">
<p>
貝雷迪異常是指在某些情況下，當分頁置換演算法分配更多頁框 (page frames) 給程序時，反而導致頁面錯誤 (page faults) 的數量增加 [未在來源中提及]。這種現象違反直覺，因為一般來說，我們期望有更多的記憶體空間可以減少頁面錯誤的發生。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org29a600e"></a>受 Belady&rsquo;s Anomaly 影響的頁面置換演算法<br />
<div class="outline-text-7" id="text-org29a600e">
<ul class="org-ul">
<li>先進先出 (First-In-First-Out, FIFO) 頁面置換演算法 是最常受 Belady&rsquo;s Anomaly 影響的演算法 [未在來源中提及]。<br />
<ul class="org-ul">
<li>FIFO 演算法會置換最早進入記憶體的頁面，而不管該頁面是否經常被使用。<br /></li>
<li>由於這種特性，FIFO 在某些特定的頁面引用順序下，可能會出現增加頁框數反而增加頁面錯誤的情況。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org66cf4ea"></a>為什麼 FIFO 會受到 Belady&rsquo;s Anomaly 的影響？<br />
<div class="outline-text-7" id="text-org66cf4ea">
<p>
FIFO 演算法的缺點在於它 沒有考慮到頁面的使用頻率或重要性。當增加頁框數量時，可能會出現以下情況：<br />
</p>
<ul class="org-ul">
<li>新的頁框可能被分配給了不常使用的頁面。<br /></li>
<li>原來經常使用的頁面，反而因為進入時間較早而被置換出去。<br /></li>
<li>導致後續對這些經常使用頁面的存取，必須再次從主記憶體載入，造成頁面錯誤增加。<br /></li>
</ul>
</div>
</li>
<li><a id="org312c13e"></a>其他頁面置換演算法<br />
<div class="outline-text-7" id="text-org312c13e">
<p>
以下是一些常見的頁面置換演算法，它們的設計目標是減少頁面錯誤，並且通常不會受到 Belady&rsquo;s Anomaly 的影響：<br />
</p>
<ul class="org-ul">
<li>最近最少使用 (Least Recently Used, LRU) 演算法 [未在來源中提及]：<br />
<ul class="org-ul">
<li>LRU 演算法會置換最近最少使用的頁面。<br /></li>
<li>它基於局部性原理，即最近被使用的頁面，在未來也很有可能被使用。<br /></li>
<li>LRU 通常比 FIFO 有更好的效能，且不會有 Belady&rsquo;s Anomaly 的問題。<br /></li>
</ul></li>
<li>最佳化 (Optimal) 演算法 [未在來源中提及]：<br />
<ul class="org-ul">
<li>最佳化演算法會置換未來最久不會被使用的頁面。<br /></li>
<li>它在理論上可以達到最小的頁面錯誤率，但實際中無法實現，因為我們無法預知未來頁面的存取模式。<br /></li>
<li>通常用於評估其他演算法的效能。<br /></li>
</ul></li>
<li>時鐘 (Clock) 演算法 [未在來源中提及]：<br />
<ul class="org-ul">
<li>時鐘演算法是一種近似 LRU 演算法，它使用一個環形緩衝區和一個指針。<br /></li>
<li>它在效能和實作複雜度之間取得了平衡。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org73142dc"></a>相關計算機概論知識：<br />
<div class="outline-text-6" id="text-org73142dc">
<ul class="org-ul">
<li>分頁 (Paging):<br />
<ul class="org-ul">
<li>一種記憶體管理技術，將程式的邏輯位址空間分割成固定大小的頁面，並將實體記憶體分割成大小相同的頁框 [未在來源中提及]。<br /></li>
<li>允許程式使用不連續的記憶體空間，提高記憶體的利用率。<br /></li>
</ul></li>
<li>頁框 (Page Frame):<br />
<ul class="org-ul">
<li>實體記憶體中固定大小的區塊，用於存放程式的頁面 [未在來源中提及]。<br /></li>
</ul></li>
<li>頁面錯誤 (Page Fault):<br />
<ul class="org-ul">
<li>當程式嘗試存取的頁面不在實體記憶體中時，會發生頁面錯誤 [未在來源中提及]。<br /></li>
<li>此時，操作系統必須從輔助儲存裝置（如硬碟）載入該頁面到記憶體中。<br /></li>
</ul></li>
<li>頁面置換 (Page Replacement):<br />
<ul class="org-ul">
<li>當實體記憶體中的頁框被佔滿，需要載入新的頁面時，必須選擇一個頁面置換出去 [未在來源中提及]。<br /></li>
<li>頁面置換演算法的目標是盡量減少頁面錯誤的發生。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org4801add"></a>總結<br />
<div class="outline-text-6" id="text-org4801add">
<ul class="org-ul">
<li>Belady&rsquo;s Anomaly 是一種違反直覺的現象，即增加頁框數量反而會增加頁面錯誤。<br /></li>
<li>FIFO 頁面置換演算法是主要的受害者。<br /></li>
<li>了解 Belady&rsquo;s Anomaly 可以幫助我們更好地選擇和設計有效的頁面置換演算法。<br /></li>
<li>理解分頁、頁框、頁面錯誤等概念，對於理解頁面置換演算法非常重要。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf0adc62" class="outline-4">
<h4 id="orgf0adc62"><span class="section-number-4">1.3.8.</span> 第八題：(6 分)</h4>
<div class="outline-text-4" id="text-1-3-8">
<p>
Without any doubt, real-time scheduler must support preemptive and priority-based scheduling. For hard real-time scheduling must provide ability to meet deadlines. Given two processes P1 and P2, the periodic generated time of P1 and P2 are p1=50 and p2=80, respectively. And the processing time of P1 and P2 are t1=25 and t2=35, respectively. (A) Can these two processes be scheduled using rate-monotonic scheduling? Why? (B) Can these two processes be scheduled using earliest-deadline-first scheduling (EDF)? Why?<br />
</p>
</div>
<div id="outline-container-org8640e9d" class="outline-5">
<h5 id="org8640e9d">解</h5>
<div class="outline-text-5" id="text-org8640e9d">
</div>
<ul class="org-ul">
<li><a id="org11ccc23"></a>即時排程 (Real-Time Scheduling)<br />
<div class="outline-text-6" id="text-org11ccc23">
<p>
即時系統 (real-time system) 指的是那些對於時間有嚴格要求的系統 [未在來源中提及]。即時排程的目標是確保在規定的時間內完成任務。即時系統可分為硬即時 (hard real-time) 和軟即時 (soft real-time) 兩類 [未在來源中提及]：<br />
</p>
<ul class="org-ul">
<li>硬即時系統：必須絕對保證任務在截止時間 (deadline) 前完成，否則可能造成嚴重後果，例如飛機控制系統。<br /></li>
<li>軟即時系統：允許錯過一些截止時間，但會降低系統效能，例如影音串流。<br /></li>
</ul>
<p>
根據題目敘述，硬即時排程必須能夠滿足截止時間的要求。此外，即時排程必須支援搶佔式 (preemptive) 和基於優先權 (priority-based) 的排程<br />
</p>
</div>
</li>
<li><a id="orgf409f91"></a>速率單調排程 (Rate-Monotonic Scheduling, RMS)<br />
<div class="outline-text-6" id="text-orgf409f91">
<ul class="org-ul">
<li>RMS 是一種靜態優先權排程演算法，它根據任務的週期 (period) 來分配優先權 [未在來源中提及]。<br /></li>
<li>週期越短的任務，優先權越高 [未在來源中提及]。<br /></li>
<li>RMS 適用於週期性任務，並且具有易於實現的優點。<br /></li>
</ul>
</div>
</li>
<li><a id="orgc80f554"></a>最早截止時間優先排程 (Earliest-Deadline-First Scheduling, EDF)<br />
<div class="outline-text-6" id="text-orgc80f554">
<ul class="org-ul">
<li>EDF 是一種動態優先權排程演算法，它根據任務的截止時間 (deadline) 來分配優先權 [未在來源中提及]。<br /></li>
<li>截止時間越早的任務，優先權越高 [未在來源中提及]。<br /></li>
<li>EDF 在理論上可以達到 100% 的 CPU 使用率，並且在許多情況下比 RMS 更有效率，但實作上較複雜。<br /></li>
</ul>
</div>
</li>
<li><a id="org2071497"></a>題目分析<br />
<div class="outline-text-6" id="text-org2071497">
<p>
題目中給定兩個程序 P1 和 P2，它們的週期分別為 p1=50 和 p2=80，處理時間分別為 t1=25 和 t2=35。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org0e9f692"></a>(A) 是否可以使用速率單調排程 (RMS)？<br />
<div class="outline-text-7" id="text-org0e9f692">
<p>
首先，根據 RMS 的原則，週期較短的 P1 的優先權較高。要判斷這兩個程序是否可以使用 RMS 排程，需要檢驗 CPU 使用率 (CPU utilization) 是否滿足可排程條件。RMS 的可排程條件可以通過以下公式來驗證：<br />
U &lt;= n * (2^(1/n) - 1)<br />
其中，U 是總的 CPU 使用率，n 是任務的數量。<br />
</p>
<ol class="org-ol">
<li>計算個別的 CPU 使用率:<br />
<ul class="org-ul">
<li>P1 的 CPU 使用率 (u1) = t1 / p1 = 25 / 50 = 0.5<br /></li>
<li>P2 的 CPU 使用率 (u2) = t2 / p2 = 35 / 80 = 0.4375<br /></li>
</ul></li>
<li>計算總 CPU 使用率:<br />
<ul class="org-ul">
<li>U = u1 + u2 = 0.5 + 0.4375 = 0.9375<br /></li>
</ul></li>
<li>檢驗可排程條件:<br />
<ul class="org-ul">
<li>當 n = 2 時，  n * (2^(1/n) - 1) = 2 * (2^(1/2) - 1) ≈ 0.828<br /></li>
<li>由於 U (0.9375) &gt; 0.828， 理論上這兩個程序無法保證用 RMS 排程在所有情況下都能滿足截止時間的要求 [未在來源中提及]。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orgb791a55"></a>(B) 是否可以使用最早截止時間優先排程 (EDF)？<br />
<div class="outline-text-7" id="text-orgb791a55">
<p>
EDF 的可排程條件比較簡單，只要總 CPU 使用率小於等於 1 即可：<br />
U &lt;= 1<br />
</p>
<ul class="org-ul">
<li>由於 U = 0.9375 &lt; 1，這兩個程序可以使用 EDF 排程 [未在來源中提及]。<br /></li>
<li>EDF 可以保證在任何情況下都能滿足截止時間的要求，只要總 CPU 使用率不超過 1。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgdd63e93"></a>相關計算機概論知識：<br />
<div class="outline-text-6" id="text-orgdd63e93">
<ul class="org-ul">
<li>程序 (Process): 正在執行的程式的實例，包含程式碼、資料、堆疊、程式計數器等 [未在來源中提及]。<br /></li>
<li>排程 (Scheduling): 作業系統決定哪個程序應該在 CPU 上執行的過程 [未在來源中提及]。<br /></li>
<li>優先權 (Priority): 程序或任務被排程時的優先程度 [未在來源中提及]。<br /></li>
<li>搶佔式 (Preemptive): 指高優先權的任務可以中斷正在執行的低優先權任務 [未在來源中提及]。<br /></li>
<li>週期性任務 (Periodic Task): 每隔固定時間間隔重複執行的任務 [未在來源中提及]。<br /></li>
<li>截止時間 (Deadline): 任務必須完成的最晚時間 [未在來源中提及]。<br /></li>
<li>CPU 使用率 (CPU Utilization): CPU 被使用的時間比例 [未在來源中提及]。<br /></li>
</ul>
</div>
</li>
<li><a id="org75d7593"></a>總結<br />
<div class="outline-text-6" id="text-org75d7593">
<ul class="org-ul">
<li>硬即時系統必須滿足截止時間的要求，需要搶佔式和基於優先權的排程<br /></li>
<li>RMS 根據週期分配優先權，週期越短優先權越高 [未在來源中提及]。<br /></li>
<li>EDF 根據截止時間分配優先權，截止時間越早優先權越高 [未在來源中提及]。<br /></li>
<li>RMS 的可排程條件是 U &lt;= n * (2^(1/n) - 1)，EDF 的可排程條件是 U &lt;= 1 [未在來源中提及]。<br /></li>
<li>給定的兩個程序，理論上不能保證用 RMS 滿足截止時間的要求，可以使用 EDF 滿足截止時間的要求。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org7451851" class="outline-4">
<h4 id="org7451851"><span class="section-number-4">1.3.9.</span> 第九題：(6 分)</h4>
<div class="outline-text-4" id="text-1-3-9">
<p>
In a paging system, suppose that the hit ratio is 80% and it takes 10 ns to search the TLB and 200 ns to access memory.<br />
</p>
<ul class="org-ul">
<li>(A) What is the effective memory access time with single-level page table?<br /></li>
<li>(B) What is the effective memory access time with three-level page table?<br /></li>
</ul>
</div>
<div id="outline-container-org0edb76f" class="outline-5">
<h5 id="org0edb76f">解:</h5>
<div class="outline-text-5" id="text-org0edb76f">
</div>
<ul class="org-ul">
<li><a id="orgcd21f14"></a>問題背景<br />
<div class="outline-text-6" id="text-orgcd21f14">
<p>
在分頁系統中，為了加快記憶體存取速度，通常會使用轉譯後備緩衝區 (Translation Lookaside Buffer, TLB) 來快取最近使用的頁表條目。當 CPU 產生邏輯位址時，會先查詢 TLB，若 TLB 中存在該頁的實體位址，則稱為 TLB hit，反之則稱為 TLB miss。當 TLB miss 時，需要查詢記憶體中的頁表，才能找到對應的實體位址。<br />
</p>

<p>
題目給定的資訊如下：<br />
</p>
<ul class="org-ul">
<li>TLB hit ratio (命中率) = 80%<br /></li>
<li>TLB search time (搜尋時間) = 10 ns<br /></li>
<li>Memory access time (記憶體存取時間) = 200 ns<br /></li>
</ul>
</div>
</li>
<li><a id="org642db76"></a>有效記憶體存取時間 (Effective Memory Access Time)<br />
<div class="outline-text-6" id="text-org642db76">
<p>
有效記憶體存取時間是指在考慮 TLB hit 和 TLB miss 的情況下，平均存取記憶體所需的時間。其計算公式如下：<br />
有效記憶體存取時間 = (TLB hit ratio * TLB hit time) + (TLB miss ratio * TLB miss time)<br />
其中：<br />
</p>
<ul class="org-ul">
<li>TLB hit time：TLB 命中時的存取時間。<br /></li>
<li>TLB miss time：TLB 未命中時的存取時間。<br /></li>
<li>TLB miss ratio = 1 - TLB hit ratio<br /></li>
</ul>
</div>
</li>
<li><a id="orga225ead"></a>（A）單層頁表 (Single-Level Page Table) 的有效記憶體存取時間<br />
<div class="outline-text-6" id="text-orga225ead">
<p>
在單層頁表的情況下：<br />
</p>
<ul class="org-ul">
<li>TLB hit 時，只需存取 TLB，耗時 10 ns。<br /></li>
<li>TLB miss 時，需要先存取記憶體中的頁表以取得頁框號 (page frame number)，然後再存取記憶體中的目標資料。所以需要存取記憶體兩次。<br /></li>
</ul>
<p>
計算過程如下：<br />
</p>
<ol class="org-ol">
<li>計算 TLB miss ratio:<br />
<ul class="org-ul">
<li>TLB miss ratio = 1 - 0.8 = 0.2<br /></li>
</ul></li>
<li>計算 TLB hit time:<br />
<ul class="org-ul">
<li>TLB hit time = 10 ns<br /></li>
</ul></li>
<li>計算 TLB miss time:<br />
<ul class="org-ul">
<li>TLB miss time = 頁表存取時間 + 資料存取時間 = 200 ns + 200 ns = 400 ns<br /></li>
</ul></li>
<li>計算有效記憶體存取時間:<br />
<ul class="org-ul">
<li>有效記憶體存取時間 = (0.8 * 10 ns) + (0.2 * 400 ns) = 8 ns + 80 ns = 88 ns<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="orga15a079"></a>（B）三層頁表 (Three-Level Page Table) 的有效記憶體存取時間<br />
<div class="outline-text-6" id="text-orga15a079">
<p>
在三層頁表的情況下：<br />
</p>
<ul class="org-ul">
<li>TLB hit 時，只需存取 TLB，耗時 10 ns。<br /></li>
<li>TLB miss 時，需要先存取記憶體中的三層頁表以取得頁框號，然後再存取記憶體中的目標資料。所以需要存取記憶體四次。<br /></li>
</ul>
<p>
計算過程如下：<br />
</p>
<ol class="org-ol">
<li>計算 TLB miss ratio:<br />
<ul class="org-ul">
<li>TLB miss ratio = 1 - 0.8 = 0.2<br /></li>
</ul></li>
<li>計算 TLB hit time:<br />
<ul class="org-ul">
<li>TLB hit time = 10 ns<br /></li>
</ul></li>
<li>計算 TLB miss time:<br />
<ul class="org-ul">
<li>TLB miss time = 三層頁表存取時間 + 資料存取時間 = 200 ns * 3 + 200 ns = 800 ns<br /></li>
</ul></li>
<li>計算有效記憶體存取時間:<br />
<ul class="org-ul">
<li>有效記憶體存取時間 = (0.8 * 10 ns) + (0.2 * 800 ns) = 8 ns + 160 ns = 168 ns<br /></li>
</ul></li>
</ol>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>單層頁表的有效記憶體存取時間為 88 ns。<br /></li>
<li>三層頁表的有效記憶體存取時間為 168 ns。<br /></li>
<li>使用多層頁表會增加 TLB miss 時的記憶體存取次數，從而增加有效記憶體存取時間。<br /></li>
</ul>
<p>
相關計算機概論知識：<br />
</p>
<ul class="org-ul">
<li>分頁 (Paging): 一種記憶體管理技術，將邏輯位址空間分割成固定大小的頁面，並將實體記憶體分割成大小相同的頁框 [未在來源中提及]。<br /></li>
<li>頁表 (Page Table): 儲存邏輯位址的頁面到實體記憶體頁框之間映射的資料結構 [未在來源中提及]。<br /></li>
<li>轉譯後備緩衝區 (TLB): 一種快取記憶體，用於儲存最近使用的頁表條目，以加速位址轉譯過程 [未在來源中提及]。<br /></li>
<li>TLB Hit/Miss: 當要存取的頁表條目存在於TLB中為TLB Hit，反之為TLB Miss [未在來源中提及]。<br /></li>
<li>有效記憶體存取時間 (Effective Memory Access Time): 考慮快取(TLB)命中率和未命中率後，平均存取記憶體所花費的時間 [未在來源中提及]。<br /></li>
</ul>
</div>
</li>
<li><a id="orge1792a5"></a>重要注意事項：<br />
<div class="outline-text-6" id="text-orge1792a5">
<ul class="org-ul">
<li>此計算假設每次記憶體存取時間都固定為 200 ns。<br /></li>
<li>實際情況中，記憶體存取時間可能因多種因素而有所變化。<br /></li>
<li>多層頁表可以減少頁表本身的大小，但在 TLB miss 時會增加記憶體存取次數。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org837c19d" class="outline-3">
<h3 id="org837c19d"><span class="section-number-3">1.4.</span> 110</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orgbee1789" class="outline-4">
<h4 id="orgbee1789"><span class="section-number-4">1.4.1.</span> 一、</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
網路流量一時過大會造成封包延遲或封包丟失等問題，面對此情況，網路管理者通常有下列三種策略：(1)Overprovisioning、(2)Priority、(3) Quality of Service Guarantees。請詳細說明此三種策略的意義及各自的優缺點。(15 分)<br />
</p>
</div>
<div id="outline-container-org9e6245e" class="outline-5">
<h5 id="org9e6245e">解</h5>
<div class="outline-text-5" id="text-org9e6245e">
<p>
網路流量管理策略: 當網路流量過大時，可能導致網路壅塞，造成封包延遲或遺失。為了應對這種情況，網路管理者通常會採用以下三種策略<br />
：<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org45b7706"></a>1. 過度配置 (Overprovisioning)<br />
<div class="outline-text-6" id="text-org45b7706">
<ul class="org-ul">
<li>意義： 增加網路資源（例如：頻寬、設備）的容量，使其遠大於預期的高峰流量，從而確保在正常情況下，網路不會出現壅塞。<br /></li>
<li>優點： 簡單直接，能有效降低網路壅塞的可能性，提升使用者體驗。<br /></li>
<li>缺點： 成本高昂，需要大量投資硬體設備，且資源利用率可能不高，因為大部分時間網路流量可能遠低於配置的容量。<br /></li>
</ul>
</div>
</li>
<li><a id="org34a486e"></a>2. 優先權 (Priority)<br />
<div class="outline-text-6" id="text-org34a486e">
<ul class="org-ul">
<li>意義： 為不同類型的網路流量設定優先級，確保高優先級的流量（例如：語音、視訊）能夠優先通過網路，減少延遲和遺失。<br /></li>
<li>優點： 可以在有限的資源下，確保重要流量的服務品質，提升使用者體驗。<br /></li>
<li>缺點： 可能導致低優先級的流量受到延遲或阻礙，可能造成不公平的資源分配。<br /></li>
</ul>
</div>
</li>
<li><a id="org921b344"></a>3. 服務品質保證 (Quality of Service Guarantees)<br />
<div class="outline-text-6" id="text-org921b344">
<ul class="org-ul">
<li>意義： 使用各種技術和機制（例如：流量塑形、流量監控、資源預留），確保特定類型的網路流量獲得預定的服務品質，例如：延遲、抖動、封包遺失率等方面的保證。<br /></li>
<li>優點： 可以為不同類型的流量提供客製化的服務品質，滿足不同應用程式的需求。<br /></li>
<li>缺點： 設定和管理複雜，需要專業的技術知識，實施成本較高<br /></li>
</ul>
</div>
</li>
<li><a id="org50f564f"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org50f564f">
<p>
為了更深入理解這些網路管理策略，以下列出一些相關的計算機概論知識點，這些知識點在研究所考試中也經常出現：<br />
</p>
<ul class="org-ul">
<li>網路協定： 了解 TCP/IP 協定族，特別是 TCP 和 UDP 的差異，以及它們如何處理網路流量。TCP 具有可靠的傳輸機制，適合需要資料完整性的應用程式（例如：網頁瀏覽），而 UDP 則較為快速，適合即時性較高的應用程式（例如：視訊串流）。<br /></li>
<li>網路壅塞控制： 了解網路壅塞控制的機制，例如：慢啟動、壅塞避免、快速重傳和快速恢復等，這些機制可以幫助網路適應流量變化，減少壅塞發生的機會。<br /></li>
<li>流量工程： 了解流量工程的概念和技術，例如：流量分類、流量標記、流量塑形和流量監控等，這些技術可以幫助網路管理者更好地控制和管理網路流量。<br /></li>
<li>服務品質 (QoS)： 了解服務品質的概念和指標，例如：延遲、抖動、封包遺失率和頻寬等，以及如何使用 QoS 機制來確保不同應用程式的服務品質。<br /></li>
<li>網路設備： 了解路由器、交換器等網路設備的功能和運作原理，它們在網路流量管理中扮演重要的角色。路由器負責選擇最佳路徑來傳輸封包，而交換器則負責在區域網路內轉發封包。<br /></li>
<li>排隊理論: 了解 M/M/1 模型等排隊理論，可以幫助分析網路流量的行為，並評估不同的網路管理策略的效果。<br /></li>
<li>網路安全: 了解 IPSec 協定，這是實現 VPN 的重要技術。IPSec 中的 AH 和 ESP 協定有不同的作用。<br /></li>
</ul>
<p>
總結: 網路流量管理是一個複雜的問題，需要綜合考慮網路的拓撲結構、流量特性和應用需求。上述的三種策略各有優缺點，網路管理者需要根據實際情況選擇最適合的策略。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org727dc64" class="outline-4">
<h4 id="org727dc64"><span class="section-number-4">1.4.2.</span> 二、</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
IPSec (Internet Protocol Security)協定組是實現 VPN(Virtual Private Network)的重要技術，請回答下列問題：<br />
</p>
<ol class="org-ol">
<li>IPSec 中的 AH(Authentication Header)協定和 ESP(Encapsulating Security Payload)協定的作用有何不同？ (5分)<br /></li>
<li>IPSec 中的 Transport mode 和 Tunnel mode 兩種操作方式及優缺點為何？ (5分)<br /></li>
</ol>
</div>
<div id="outline-container-org9a24b92" class="outline-5">
<h5 id="org9a24b92">解</h5>
<div class="outline-text-5" id="text-org9a24b92">
</div>
<ul class="org-ul">
<li><a id="orgc9a5238"></a>IPSec 協定組<br />
<div class="outline-text-6" id="text-orgc9a5238">
<p>
IPSec 是一套用於在網際網路協定 (IP) 網路中提供安全性的協定組。它主要用於建立安全的 VPN 連線，確保數據在傳輸過程中的機密性、完整性和身份驗證。IPSec 包括以下兩個主要的協定：<br />
</p>
<ol class="org-ol">
<li>AH (Authentication Header) 協定<br />
<ul class="org-ul">
<li>作用： AH 協定的主要作用是提供數據的完整性驗證和身份驗證。它會在 IP 封包中加入一個驗證標頭，使用加密雜湊函數來確保數據在傳輸過程中未被篡改。同時，它也驗證數據的發送者身份，防止偽造攻擊。<br /></li>
<li>特點： AH 協定不提供數據加密，只提供身份驗證和完整性驗證。<br /></li>
<li>優缺點：<br />
<ul class="org-ul">
<li>優點： 驗證速度快，開銷較小。<br /></li>
<li>缺點： 不提供數據加密，無法保證數據的機密性。<br /></li>
</ul></li>
</ul></li>
<li>ESP (Encapsulating Security Payload) 協定<br />
<ul class="org-ul">
<li>作用： ESP 協定的主要作用是提供數據的機密性、完整性驗證和身份驗證。它會將 IP 封包中的數據進行加密，並加入一個驗證標頭，以確保數據在傳輸過程中不被竊聽或篡改。<br /></li>
<li>特點： ESP 協定提供數據加密，並可選擇性提供完整性驗證和身份驗證。<br /></li>
<li>優缺點：<br />
<ul class="org-ul">
<li>優點： 提供數據加密，確保數據的機密性。<br /></li>
<li>缺點： 運算開銷較大，處理速度較慢。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org6d753c6"></a>IPSec 的兩種操作模式<br />
<div class="outline-text-6" id="text-org6d753c6">
<p>
IPSec 有兩種主要的操作模式：<br />
</p>
<ol class="org-ol">
<li>傳輸模式 (Transport Mode)<br />
<ul class="org-ul">
<li>運作方式： 在傳輸模式下，IPSec 只會保護 IP 封包中的數據部分（例如：TCP 或 UDP 封包），而原始的 IP 標頭則保持不變。<br /></li>
<li>適用情境： 適用於端對端的安全連線，例如：在同一網路上的兩台主機之間建立安全連線。<br /></li>
<li>優缺點：<br />
<ul class="org-ul">
<li>優點： 開銷較小，處理速度較快。<br /></li>
<li>缺點： 僅保護數據部分，IP 標頭中的資訊（例如：源地址、目標地址）仍然暴露在外，容易受到網路流量分析攻擊。<br /></li>
</ul></li>
</ul></li>
</ol>
<p>
2.隧道模式 (Tunnel Mode)<br />
</p>
<ul class="org-ul">
<li>運作方式： 在隧道模式下，IPSec 會將整個原始 IP 封包都加密，並將其封裝在一個新的 IP 封包中，形成一個安全隧道。<br /></li>
<li>適用情境： 適用於網路對網路的安全連線，例如：在兩個不同網路之間建立 VPN 連線。<br /></li>
<li>優缺點：<br />
<ul class="org-ul">
<li>優點： 保護整個 IP 封包，包括 IP 標頭，提供更全面的安全性。<br /></li>
<li>缺點： 開銷較大，處理速度較慢。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org6355fe6"></a>相關計算機概論知識<br />
<div class="outline-text-6" id="text-org6355fe6">
<p>
為了更深入理解 IPSec 和 VPN，以下列出一些相關的計算機概論知識點：<br />
</p>
<ul class="org-ul">
<li>加密技術： 了解對稱加密 (Symmetric Encryption) 和非對稱加密 (Asymmetric Encryption) 的原理和應用，以及各種加密演算法，例如：AES、RSA 等。<br /></li>
<li>雜湊函數 (Hash Function)： 了解雜湊函數的特性和用途，例如：訊息驗證碼 (MAC) 和數位簽章。<br /></li>
<li>網路安全： 了解各種網路安全威脅和攻擊，例如：竊聽、篡改、偽造、阻斷服務攻擊 (DoS) 等，以及如何使用安全協定和機制來保護網路安全。<br /></li>
<li>VPN (Virtual Private Network)： 了解 VPN 的原理和類型，例如：IPSec VPN、SSL VPN 等。<br /></li>
<li>網路協定： 了解 TCP/IP 協定族，特別是 IP 協定和 IP 封包的結構。<br /></li>
<li>金鑰管理： 了解如何安全地產生、儲存和交換加密金鑰，例如：Diffie-Hellman 金鑰交換演算法。<br /></li>
<li>認證 (Authentication)： 了解身份驗證的原理和方法，例如：密碼驗證、雙因素驗證等。<br /></li>
</ul>
</div>
</li>
<li><a id="org504654f"></a>VPN（虛擬私人網路，Virtual Private Network）<br />
<div class="outline-text-6" id="text-org504654f">
<p>
什麼是 VPN？VPN（Virtual Private Network，虛擬私人網路）是一種技術，允許用戶透過 加密隧道（Encrypted Tunnel） 安全地連接到遠端網路。它主要用來：<br />
</p>
<ul class="org-ul">
<li>保護隱私與安全：加密數據，防止駭客、網路監控。<br /></li>
<li>繞過網路限制：突破地域封鎖（如中國防火長城）、存取被封鎖的內容（如 Netflix 美國限定節目）。<br /></li>
<li>遠端辦公：讓企業員工可以安全地存取公司內部資源。<br /></li>
</ul>
<p>
VPN 的運作方式<br />
</p>
<ul class="org-ul">
<li>使用者連接 VPN 伺服器：透過 VPN 軟體或內建 VPN 功能，與 VPN 伺服器建立連線。<br /></li>
<li>加密資料：VPN 會對數據進行加密，使第三方（如 ISP、駭客）無法監視流量內容。<br /></li>
<li>VPN 伺服器轉發請求：VPN 伺服器將請求轉發至目標網站，網站認為請求來自 VPN 伺服器而非用戶真實 IP。<br /></li>
<li>返回結果：VPN 伺服器將網站回應加密後回傳給用戶，確保數據安全。<br /></li>
</ul>
<p>
VPN 的優勢與缺點<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">優勢</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">保護隱私與匿名性</td>
<td class="org-left">可能影響網速（加密與遠端伺服器）</td>
</tr>

<tr>
<td class="org-left">加密流量，提高安全性</td>
<td class="org-left">需要額外的 VPN 軟體或設定</td>
</tr>

<tr>
<td class="org-left">繞過地理限制與審查</td>
<td class="org-left">免費 VPN 可能不安全，容易洩漏數據</td>
</tr>

<tr>
<td class="org-left">遠端存取企業內部網路</td>
<td class="org-left">可能被政府或企業封鎖</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgdc54fda"></a>IPSec VPN（基於 IP 安全協議的 VPN）<br />
<div class="outline-text-6" id="text-orgdc54fda">
<p>
什麼是 IPSec？: IPSec（Internet Protocol Security） 是一種安全協議套件，專門用來為 IP 層 的數據流量提供加密和驗證，確保通訊安全。它常用於企業內部的 站對站 VPN（Site-to-Site VPN） 或 遠端存取 VPN（Remote Access VPN）。<br />
</p>

<p>
IPSec VPN 的特點<br />
</p>
<ul class="org-ul">
<li>加密 IP 層流量：IPSec VPN 在 IP 層 加密數據包，提供更高的安全性。<br /></li>
<li>支援兩種模式：<br />
<ul class="org-ul">
<li>傳輸模式（Transport Mode）：只加密數據本身（適用於端對端的通訊）。<br /></li>
<li>隧道模式（Tunnel Mode）：加密整個 IP 封包，並包裹在新的 IP 封包中（常用於 VPN）。<br /></li>
</ul></li>
<li>雙向驗證：確保數據來自可信任來源，防止竄改與中間人攻擊（MITM）。<br /></li>
<li>適用於企業網路：<br />
<ul class="org-ul">
<li>企業內部員工遠端連接公司網路。<br /></li>
<li>企業之間的分支機構建立 站對站 VPN 連線。<br /></li>
</ul></li>
</ul>

<p>
IPSec VPN 的優勢與缺點<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">優勢</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">提供高度加密與完整性驗證</td>
<td class="org-left">設定較為複雜</td>
</tr>

<tr>
<td class="org-left">支援 站對站 VPN，適用於企業內網</td>
<td class="org-left">需要特殊的 VPN 軟體或設備</td>
</tr>

<tr>
<td class="org-left">適用於大規模企業 VPN 部署</td>
<td class="org-left">可能需要高效能路由器與防火牆支持</td>
</tr>
</tbody>
</table>

<p>
IPSec VPN 的常見應用<br />
 企業內部 VPN（遠端辦公使用）<br />
 站對站 VPN（Site-to-Site VPN）（企業總部與分公司連線）<br />
 政府機構、金融機構的安全通訊<br />
</p>
</div>
</li>
<li><a id="org778b732"></a>SSL VPN（基於 SSL/TLS 的 VPN）<br />
<div class="outline-text-6" id="text-org778b732">
<p>
什麼是 SSL VPN？: SSL VPN（Secure Sockets Layer VPN） 使用 SSL/TLS 加密 確保通訊安全，允許用戶透過 網頁瀏覽器 連接到 VPN，而 不需要安裝額外的 VPN 客戶端軟體。<br />
</p>

<p>
SSL VPN 的特點<br />
</p>
<ul class="org-ul">
<li>基於瀏覽器的 VPN：不需要額外的 VPN 軟體，用戶可以直接透過 HTTPS（SSL/TLS） 連接 VPN。<br /></li>
<li>更容易部署：不需要特定的 VPN 客戶端，任何支援 HTTPS 的裝置（如筆電、手機、平板）都能使用。<br /></li>
<li>提供應用層的安全性：不像 IPSec VPN 加密整個 IP 流量，SSL VPN 主要保護 應用層（Application Layer） 流量，如 Web 服務、遠端桌面等。<br /></li>
<li>支援部分應用程式：<br />
<ul class="org-ul">
<li>入口 VPN（Portal Mode）：使用 Web 介面提供企業內部應用服務（如郵件、文件）。<br /></li>
<li>全通道模式（Tunnel Mode）：類似傳統 VPN，提供更廣泛的應用支援，如 RDP、VoIP、ERP 系統。<br /></li>
</ul></li>
</ul>

<p>
SSL VPN 的優勢與缺點<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">優勢</th>
<th scope="col" class="org-left">缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">使用方便，無需額外安裝 VPN 軟體</td>
<td class="org-left">可能無法支援所有應用（部分應用需特殊配置）</td>
</tr>

<tr>
<td class="org-left">只需透過 瀏覽器（HTTPS） 即可存取</td>
<td class="org-left">企業級 SSL VPN 需額外授權或設備支持</td>
</tr>

<tr>
<td class="org-left">支援遠端存取，適用於臨時使用者</td>
<td class="org-left">可能比 IPSec VPN 慢（受 TLS 處理影響）</td>
</tr>
</tbody>
</table>

<p>
SSL VPN 的常見應用<br />
</p>
<ul class="org-ul">
<li>遠端存取企業內部資源（如 Web 應用、郵件系統）<br /></li>
<li>行動辦公環境（適合不願安裝 VPN 軟體的設備）<br /></li>
<li>臨時存取企業內網（例如外部承包商或訪客使用）<br /></li>
</ul>

<p>
IPSec VPN vs SSL VPN 比較<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">比較項目</th>
<th scope="col" class="org-left">IPSec VPN</th>
<th scope="col" class="org-left">SSL VPN</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">安全層級</td>
<td class="org-left">IP 層（整個流量加密）</td>
<td class="org-left">應用層（HTTPS）</td>
</tr>

<tr>
<td class="org-left">傳輸模式</td>
<td class="org-left">傳輸模式 / 隧道模式</td>
<td class="org-left">入口模式 / 隧道模式</td>
</tr>

<tr>
<td class="org-left">設備需求</td>
<td class="org-left">需要 VPN 軟體或路由器</td>
<td class="org-left">只需瀏覽器，無需額外軟體</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">企業內部、站對站連線</td>
<td class="org-left">遠端辦公、臨時存取</td>
</tr>

<tr>
<td class="org-left">連線速度</td>
<td class="org-left">更快（IP 層加密）</td>
<td class="org-left">可能較慢（TLS 負擔）</td>
</tr>

<tr>
<td class="org-left">設定難易度</td>
<td class="org-left">設定較複雜</td>
<td class="org-left">設定簡單</td>
</tr>

<tr>
<td class="org-left">應用程式支援</td>
<td class="org-left">適用於所有應用</td>
<td class="org-left">主要適用於 Web 應用</td>
</tr>
</tbody>
</table>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>VPN 透過加密技術保護數據，確保安全性、隱私性，並允許用戶遠端存取網路資源。<br /></li>
<li>IPSec VPN 適合企業內部網路，提供強大加密和驗證，但需要額外的 VPN 設備與軟體。<br /></li>
<li>SSL VPN 允許用戶透過瀏覽器存取企業內部應用，設定簡單，適合遠端存取，但可能無法支援所有應用。<br /></li>
</ul>
<p>
何時選擇哪種 VPN？<br />
</p>
<ul class="org-ul">
<li>✅ 需要全面保護、企業內網：選擇 IPSec VPN<br /></li>
<li>✅ 需要臨時存取、瀏覽器存取：選擇 SSL VPN<br /></li>
<li>✅ 一般用戶想繞過封鎖、保護隱私：選擇商用 VPN（如 NordVPN、ExpressVPN）<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf102bba" class="outline-4">
<h4 id="orgf102bba"><span class="section-number-4">1.4.3.</span> 三、</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
在資料庫寫入或更新的過程中，為確保交易(transaction)可以正確執行，須確保滿足 ACID (Atomicity, Consistency, Isolation, Durability) property。請詳細說明此四個特性。(8%)<br />
</p>
</div>
<div id="outline-container-org321e735" class="outline-5">
<h5 id="org321e735">解</h5>
<div class="outline-text-5" id="text-org321e735">
<p>
ACID 特性: 在資料庫中，為了確保交易 (transaction) 的正確性和可靠性，必須滿足 ACID 特性。ACID 是指 Atomicity (原子性), Consistency (一致性), Isolation (隔離性), 和 Durability (持久性) 四個特性。<br />
</p>
<ol class="org-ol">
<li>原子性 (Atomicity)<br />
<ul class="org-ul">
<li>定義： 原子性指的是一個交易必須被視為一個不可分割的單位，交易中的所有操作要么全部成功完成，要么全部失敗回滾。換句話說，一個交易不能只完成一部分操作，而留下未完成的部分。<br /></li>
<li>例子： 假設一個銀行轉帳操作，從帳戶 A 轉帳 100 元到帳戶 B。這個轉帳操作包含兩個步驟：(1) 從帳戶 A 扣除 100 元；(2) 在帳戶 B 增加 100 元。如果這個轉帳交易滿足原子性，則這兩個步驟要么都成功完成，要么都失敗回滾。如果只扣除 A 帳戶的錢，而沒有增加 B 帳戶的錢，則違反原子性。<br /></li>
<li>重要性： 原子性確保交易的完整性，防止因部分操作失敗而導致資料庫狀態不一致。<br /></li>
</ul></li>
<li>一致性 (Consistency)<br />
<ul class="org-ul">
<li>定義： 一致性指的是一個交易必須將資料庫從一個一致的狀態轉換到另一個一致的狀態。所謂一致的狀態，是指資料庫的資料必須符合預先定義的規則和約束條件（例如：主鍵約束、外鍵約束、資料類型約束）。<br /></li>
<li>例子： 假設一個資料庫中，帳戶餘額必須大於等於零。在一個轉帳交易中，如果從帳戶 A 扣除 100 元後，導致 A 帳戶餘額變成負數，則違反一致性。<br /></li>
<li>重要性: 一致性確保資料庫的資料始終處於有效的狀態，防止資料庫中出現錯誤或不合理的資料。<br /></li>
</ul></li>
<li>隔離性 (Isolation)<br />
<ul class="org-ul">
<li>定義： 隔離性指的是多個交易同時執行時，必須相互隔離，互不干擾。一個交易的執行不應該受到其他交易的影響。每個交易都應該感覺自己是獨立操作資料庫，就像沒有其他交易在並行執行一樣。<br /></li>
<li>例子： 假設兩個交易同時執行，交易 T1 要讀取帳戶 A 的餘額，交易 T2 要從帳戶 A 轉帳 100 元到帳戶 B。如果沒有隔離性，T1 可能會讀取到 T2 還未完成轉帳時的餘額，導致讀取到不一致的資料。<br /></li>
<li>重要性： 隔離性確保並發交易的正確性，防止因多個交易同時執行而導致資料庫資料錯誤。隔離性有不同的隔離級別，例如：讀取未提交 (Read Uncommitted)、讀取提交 (Read Committed)、可重複讀取 (Repeatable Read) 和序列化 (Serializable)，不同的隔離級別在效能和資料一致性之間做權衡。<br /></li>
</ul></li>
<li>持久性 (Durability)<br />
<ul class="org-ul">
<li>定義： 持久性指的是一個交易成功提交後，對資料庫的變更必須永久保存下來，即使系統發生故障，例如：斷電或硬碟損壞，也必須能夠恢復這些變更。<br /></li>
<li>例子： 假設一個轉帳交易成功提交後，即使資料庫伺服器斷電，當伺服器重新啟動後，轉帳交易的結果仍然必須存在，帳戶餘額必須正確更新。<br /></li>
<li>重要性： 持久性確保資料的可靠性和安全性，防止資料遺失。通常使用交易日誌 (transaction log) 和資料庫備份來實現持久性。<br /></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgbbc38a0" class="outline-5">
<h5 id="orgbbc38a0">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-orgbbc38a0">
<p>
為了更深入理解 ACID 特性，以下列出一些相關的計算機概論知識點：<br />
</p>
<ul class="org-ul">
<li>資料庫管理系統 (DBMS)： 了解資料庫管理系統的功能和架構，例如：交易管理器 (Transaction Manager)、鎖管理器 (Lock Manager)、日誌管理器 (Log Manager) 等。<br /></li>
<li>併發控制 (Concurrency Control)： 了解併發控制的機制，例如：鎖定 (Locking)、時間戳記 (Timestamping)、多版本併發控制 (MVCC) 等，這些機制用於實現交易的隔離性。<br /></li>
<li>交易日誌 (Transaction Log)： 了解交易日誌的原理和用途，交易日誌用於記錄交易的執行過程和資料變更，用於實現交易的原子性和持久性。<br /></li>
<li>資料庫備份和恢復： 了解資料庫備份和恢復的策略和方法，確保資料庫在系統故障時能夠恢復到一致的狀態。<br /></li>
<li>分散式資料庫: 了解分散式資料庫中的交易管理，包括如何保證分散式交易的 ACID 特性。<br /></li>
<li>NoSQL 資料庫: 了解 NoSQL 資料庫的特性及其在 ACID 方面的取捨。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org29fbc50" class="outline-4">
<h4 id="org29fbc50"><span class="section-number-4">1.4.4.</span> 四、</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
請詳細說明 homogeneous distributed database 與 heterogeneous distributed database 兩者之差異。(10%)<br />
</p>
</div>
<div id="outline-container-org3d3cfe6" class="outline-5">
<h5 id="org3d3cfe6">解</h5>
<div class="outline-text-5" id="text-org3d3cfe6">
</div>
<ul class="org-ul">
<li><a id="org2150c7a"></a>同質分散式資料庫 (Homogeneous Distributed Database)<br />
<div class="outline-text-6" id="text-org2150c7a">
<ul class="org-ul">
<li>定義： 同質分散式資料庫是指多個資料庫系統使用相同的資料庫管理系統 (DBMS) 軟體，並以相同的資料模型 (data model) 和綱要 (schema) 協同運作。也就是說，所有的資料庫節點都使用相同的資料庫軟體，並且具有相同的資料結構和格式。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>所有節點都使用相同的 DBMS 軟體，例如：全部都是 Oracle 資料庫，或全部都是 MySQL 資料庫。<br /></li>
<li>所有節點的資料結構和綱要都相同，資料格式也一致。<br /></li>
<li>管理和維護相對較為簡單，因為所有節點的環境都相同。<br /></li>
<li>查詢處理和資料存取較為直接，因為所有節點的資料都以相同的方式儲存和管理。<br /></li>
</ul></li>
<li>優點：<br />
<ul class="org-ul">
<li>易於設計和實施：因為所有節點都使用相同的技術，所以設計和實施相對簡單。<br /></li>
<li>查詢處理效率高：由於資料格式和結構相同，查詢處理可以在不同的節點之間高效地傳輸和合併。<br /></li>
<li>管理和維護成本較低：因為所有節點的環境都相同，所以管理和維護的成本較低。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>彈性較低：如果需要升級或更換 DBMS 軟體，則所有節點都需要同時進行更新，這可能造成不便。<br /></li>
<li>單點故障風險：如果某個關鍵節點發生故障，可能會影響整個系統的運行。<br /></li>
</ul></li>
<li>範例： 一個公司在多個分公司使用相同的 Oracle 資料庫系統來管理客戶資料，每個分公司都維護自己的資料庫，並且通過分散式資料庫技術將它們整合成一個邏輯上的整體。<br /></li>
</ul>
</div>
</li>
<li><a id="org7736450"></a>異質分散式資料庫 (Heterogeneous Distributed Database)<br />
<div class="outline-text-6" id="text-org7736450">
<ul class="org-ul">
<li>定義： 異質分散式資料庫是指多個資料庫系統使用不同的 DBMS 軟體，且可能使用不同的資料模型和綱要協同運作。也就是說，不同的資料庫節點可能使用不同的資料庫軟體，資料結構和格式也可能不同。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>不同的節點可能使用不同的 DBMS 軟體，例如：有些節點使用 Oracle 資料庫，有些節點使用 MySQL 資料庫，有些節點使用 PostgreSQL 資料庫。<br /></li>
<li>不同的節點可能具有不同的資料結構和綱要，資料格式也可能不一致。<br /></li>
<li>管理和維護較為複雜，因為不同節點的環境可能不同。<br /></li>
<li>查詢處理和資料存取可能需要使用額外的轉換機制，以確保不同格式的資料能夠互相理解。<br /></li>
</ul></li>
<li>優點：<br />
<ul class="org-ul">
<li>彈性較高：可以靈活地選擇最適合的 DBMS 軟體來管理不同類型的資料，並且可以更容易地整合現有的資料庫系統。<br /></li>
<li>可以整合不同來源的資料：可以整合不同部門、不同供應商或不同系統的資料，形成一個全面的資料視圖。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>設計和實施複雜：由於不同節點的技術和結構不同，設計和實施相對複雜。<br /></li>
<li>查詢處理效率較低：由於資料格式和結構不同，查詢處理可能需要較多的轉換和處理時間。<br /></li>
<li>管理和維護成本較高：因為不同節點的環境可能不同，管理和維護的成本較高。<br /></li>
</ul></li>
<li>範例： 一個企業可能有多個不同的部門，每個部門使用不同的資料庫系統來管理資料，例如：人事部門使用 Oracle 資料庫，財務部門使用 MySQL 資料庫，行銷部門使用 MongoDB 資料庫。企業使用異質分散式資料庫技術將這些不同的資料庫系統整合成一個統一的資料視圖，方便進行跨部門的分析和決策。<br /></li>
</ul>

<p>
兩者之差異總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">同質分散式資料庫</th>
<th scope="col" class="org-left">異質分散式資料庫</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DBMS 軟體</td>
<td class="org-left">所有節點使用相同的 DBMS 軟體</td>
<td class="org-left">不同節點可能使用不同的 DBMS 軟體</td>
</tr>

<tr>
<td class="org-left">資料結構/綱要</td>
<td class="org-left">所有節點具有相同的資料結構和綱要</td>
<td class="org-left">不同節點可能具有不同的資料結構和綱要</td>
</tr>

<tr>
<td class="org-left">管理和維護</td>
<td class="org-left">相對簡單</td>
<td class="org-left">相對複雜</td>
</tr>

<tr>
<td class="org-left">查詢處理</td>
<td class="org-left">較為直接，效率較高</td>
<td class="org-left">可能需要額外的轉換機制，效率較低</td>
</tr>

<tr>
<td class="org-left">彈性</td>
<td class="org-left">較低，不方便更換 DBMS 軟體</td>
<td class="org-left">較高，可以靈活選擇最適合的 DBMS 軟體</td>
</tr>

<tr>
<td class="org-left">複雜度</td>
<td class="org-left">設計和實施相對簡單</td>
<td class="org-left">設計和實施相對複雜</td>
</tr>

<tr>
<td class="org-left">整合難度</td>
<td class="org-left">整合相同技術的資料庫相對簡單</td>
<td class="org-left">整合不同技術的資料庫相對複雜</td>
</tr>

<tr>
<td class="org-left">資料一致性</td>
<td class="org-left">維持資料一致性相對容易</td>
<td class="org-left">維持資料一致性相對困難</td>
</tr>
</tbody>
</table>

<p>
相關計算機概論知識<br />
為了更深入理解同質和異質分散式資料庫，以下列出一些相關的計算機概論知識點：<br />
</p>
<ul class="org-ul">
<li>分散式資料庫管理系統 (DDBMS)： 了解分散式資料庫管理系統的功能和架構，包括資料分割 (data partitioning)、資料複寫 (data replication)、分散式查詢處理 (distributed query processing) 和分散式交易管理 (distributed transaction management)。<br /></li>
<li>資料庫綱要 (Database Schema)： 了解資料庫綱要的概念，包括邏輯綱要 (logical schema) 和實體綱要 (physical schema)，以及如何設計資料庫綱要。<br /></li>
<li>資料模型 (Data Model)： 了解不同的資料模型，例如：關聯式模型 (relational model)、階層式模型 (hierarchical model) 和網路模型 (network model)。<br /></li>
<li>中介軟體 (Middleware)： 了解中介軟體在異質資料庫整合中的作用，例如：資料轉換 (data transformation) 和資料整合 (data integration) 的機制。<br /></li>
<li>資料庫連結 (Database Link)： 了解如何在不同的資料庫系統之間建立連結，以實現跨資料庫的查詢和操作。<br /></li>
<li>分散式交易 (Distributed Transaction)： 了解如何確保分散式交易的 ACID 特性，例如：兩階段提交 (two-phase commit) 協定。<br /></li>
<li>資料倉儲 (Data Warehouse)： 了解資料倉儲的原理和架構，資料倉儲通常用於整合來自不同來源的資料，以方便進行決策分析。<br /></li>
<li>NoSQL 資料庫: 了解 NoSQL 資料庫的種類和特性，以及它們如何被用於分散式資料庫系統中。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org25a3321" class="outline-4">
<h4 id="org25a3321"><span class="section-number-4">1.4.5.</span> 五、</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
何謂 NoSQL 資料庫？請詳細說明 NoSQL 資料庫所具有之特性。(7%)<br />
</p>
</div>
<div id="outline-container-org9e1e021" class="outline-5">
<h5 id="org9e1e021">解</h5>
<div class="outline-text-5" id="text-org9e1e021">
</div>
<ul class="org-ul">
<li><a id="org483155d"></a>NoSQL 資料庫（非關聯式資料庫，Not Only SQL）<br />
<div class="outline-text-6" id="text-org483155d">
<ul class="org-ul">
<li>定義：NoSQL 資料庫是一種 非關聯式資料庫管理系統（Non-Relational Database Management System），不同於傳統的關聯式資料庫（RDBMS），NoSQL 資料庫不依賴固定的表格結構，通常不使用 SQL 作為查詢語言，而是根據應用場景提供更彈性的資料存儲方式。NoSQL 主要針對 大規模資料（Big Data） 和 分散式架構（Distributed Architecture） 進行優化，適用於高並發讀寫、非結構化或半結構化數據存儲需求。<br /></li>
<li>特性：<br />
<ul class="org-ul">
<li>彈性資料模型（Flexible Data Model）：<br />
<ul class="org-ul">
<li>無需固定的結構化模式（Schema-Free），允許不同的資料格式存儲在同一個資料庫中，例如 JSON、BSON、XML、Key-Value 等格式。<br /></li>
<li>適合處理 半結構化（Semi-Structured） 或 非結構化（Unstructured） 資料，如日誌、社群媒體貼文、感測器數據等。<br /></li>
</ul></li>
<li>高擴展性（High Scalability）：<br />
<ul class="org-ul">
<li>採用 水平方向擴展（Horizontal Scaling，Sharding），可以透過新增節點來提高處理能力，<br /></li>
<li>不同於 RDBMS 主要依賴 垂直擴展（Vertical Scaling），NoSQL 容易分佈於多台伺服器，降低單點故障風險。<br /></li>
</ul></li>
<li>高可用性（High Availability）與分散式架構（Distributed Architecture）：<br />
<ul class="org-ul">
<li>多數 NoSQL 資料庫內建 資料複寫（Replication） 機制，確保即使某些節點發生故障，仍可繼續提供服務。<br /></li>
<li>常見的 CAP 定理 指出：分散式系統中，一個資料庫無法同時滿足 一致性（Consistency）、可用性（Availability）、分區容錯性（Partition Tolerance），NoSQL根據需求選擇不同的平衡策略。<br /></li>
</ul></li>
<li>高效能（High Performance）：<br />
<ul class="org-ul">
<li>支援高吞吐量（Throughput），適合處理大量讀寫操作，如即時分析、即時訊息推送、日誌存儲等。<br /></li>
<li>部分 NoSQL 資料庫使用 記憶體儲存（In-Memory Storage） 提供極高速的讀取，如 Redis、Memcached。<br /></li>
</ul></li>
<li>適合大數據與雲端應用（Big Data &amp; Cloud Computing）：<br />
<ul class="org-ul">
<li>NoSQL 可與 Hadoop、Spark、Kafka 等大數據技術整合，處理大規模數據分析。<br /></li>
<li>許多 NoSQL 資料庫提供 雲端原生支援（Cloud-Native Support），如 AWS DynamoDB、Google Cloud Firestore。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org4a880d7"></a>NoSQL 資料庫的分類 NoSQL 根據資料存儲模型可分為以下四大類：<br />
<div class="outline-text-6" id="text-org4a880d7">
<ol class="org-ol">
<li>鍵值型（Key-Value Stores）<br />
<ul class="org-ul">
<li>結構：以鍵（Key）對應值（Value）的方式存取，類似哈希表（Hash Table）。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>速度快，適用於快取、會話管理等場景。<br /></li>
<li>查詢只能透過鍵存取，無法進行複雜的條件篩選。<br /></li>
</ul></li>
<li>代表性資料庫：Redis、Memcached、Riak、DynamoDB。<br /></li>
</ul></li>
<li>文件型（Document Stores）<br />
<ul class="org-ul">
<li>結構：存儲 JSON、BSON、XML 等格式的文件，每個文件可能具有不同的欄位（Schema-Free）。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>適用於半結構化資料，如部落格文章、社交媒體貼文等。<br /></li>
<li>支援索引和複雜的查詢功能，比 Key-Value 型更靈活。<br /></li>
</ul></li>
<li>代表性資料庫：MongoDB、CouchDB、Firebase Firestore。<br /></li>
</ul></li>
<li>列存儲型（Wide Column Stores）<br />
<ul class="org-ul">
<li>結構：以 列（Column-Family） 為主的存儲方式，每個資料行（Row）內的欄位可以不同。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>適用於大量數據分析，特別是時間序列數據（Time-Series Data）。<br /></li>
<li>高效讀寫，可處理 PB 級數據，適合大數據應用。<br /></li>
</ul></li>
<li>代表性資料庫：Apache Cassandra、HBase、Google Bigtable。<br /></li>
</ul></li>
<li>圖形型（Graph Databases）<br />
<ul class="org-ul">
<li>結構：以 節點（Node） 和 關係（Edge） 來存儲和查詢資料，適合關係數據分析。<br /></li>
<li>特點：<br />
<ul class="org-ul">
<li>適用於社交網路、推薦系統、知識圖譜等應用。<br /></li>
<li>支援圖演算法（如 Dijkstra 最短路徑）。<br /></li>
</ul></li>
<li>代表性資料庫：Neo4j、ArangoDB、JanusGraph。<br /></li>
</ul></li>
</ol>
</div>
</li>
<li><a id="org6417bfd"></a>NoSQL 與關聯式資料庫（SQL）的比較<br />
<div class="outline-text-6" id="text-org6417bfd">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">NoSQL 資料庫</th>
<th scope="col" class="org-left">關聯式資料庫（SQL）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">資料結構</td>
<td class="org-left">非結構化 / 半結構化（JSON、Key-Value）</td>
<td class="org-left">結構化（表格、欄位、主外鍵）</td>
</tr>

<tr>
<td class="org-left">資料結構</td>
<td class="org-left">非結構化 / 半結構化（JSON、Key-Value）</td>
<td class="org-left">結構化（表格、欄位、主外鍵）</td>
</tr>

<tr>
<td class="org-left">擴展方式</td>
<td class="org-left">水平擴展（Sharding, Replication）</td>
<td class="org-left">垂直擴展（Scaling Up）</td>
</tr>

<tr>
<td class="org-left">查詢語言</td>
<td class="org-left">依賴 API、NoSQL 查詢語言</td>
<td class="org-left">使用 SQL（結構化查詢語言）</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">高併發、大數據、分散式架構</td>
<td class="org-left">事務處理、關聯查詢、多表 JOIN</td>
</tr>

<tr>
<td class="org-left">交易一致性</td>
<td class="org-left">最終一致性（Eventual Consistency）</td>
<td class="org-left">ACID 事務（強一致性）</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org3e805f5"></a>相關計算機概論知識 為了準備研究所考試，考生應掌握以下與 NoSQL 相關的計概知識：<br />
<div class="outline-text-6" id="text-org3e805f5">
<ul class="org-ul">
<li>資料庫基本概念（Database Concepts）<br />
<ul class="org-ul">
<li>關聯式資料庫（Relational Database）與 NoSQL 的區別。<br /></li>
<li>NoSQL 資料庫的四種類型（鍵值、文件、列存儲、圖形）。<br /></li>
<li>CAP 定理（Consistency、Availability、Partition Tolerance）。<br /></li>
</ul></li>
<li>分散式系統（Distributed Systems）<br />
<ul class="org-ul">
<li>水平擴展（Sharding）、負載平衡（Load Balancing）。<br /></li>
<li>分散式資料存儲（Distributed Storage）、資料複寫（Replication）。<br /></li>
<li>兩階段提交（Two-Phase Commit, 2PC）、Paxos 協議、Raft 協議。<br /></li>
</ul></li>
<li>資料一致性與交易管理（Data Consistency &amp; Transactions）<br />
<ul class="org-ul">
<li>NoSQL 的最終一致性（Eventual Consistency）。<br /></li>
<li>BASE 模型（Basically Available, Soft state, Eventually consistent）。<br /></li>
<li>ACID（Atomicity, Consistency, Isolation, Durability）與 NoSQL 的應用場景。<br /></li>
</ul></li>
<li>雲端計算（Cloud Computing）<br />
<ul class="org-ul">
<li>伺服器無狀態（Stateless Architecture）。<br /></li>
<li>雲端 NoSQL 服務，如 AWS DynamoDB、Google Firestore、Azure Cosmos DB。<br /></li>
</ul></li>
<li>大數據與 AI 應用（Big Data &amp; AI Applications）<br />
<ul class="org-ul">
<li>NoSQL 在大數據中的應用（Hadoop、Spark）。<br /></li>
<li>NoSQL 在 AI 領域的應用（向量資料庫，如 FAISS、Milvus）。<br /></li>
<li>NoSQL 與機器學習（MongoDB、Elasticsearch）。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org37908fd" class="outline-4">
<h4 id="org37908fd"><span class="section-number-4">1.4.6.</span> 六、(10%)</h4>
<div class="outline-text-4" id="text-1-4-6">
<p>
To use Peterson’s solution to solve the critical-section problem between two processes Pi and Pj, please fill the blank (a), (b), (c), (d) and (e) in structure of Pi in Program 1.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">do</span> {
<span class="linenr">2: </span>    flag[i] = _(a)_;
<span class="linenr">3: </span>    turn = _(b)_;
<span class="linenr">4: </span>    <span style="color: #51afef;">while</span> (flag[j] == _(c)<span style="color: #ECBE7B;">_</span> &amp;&amp; <span style="color: #dcaeea;">turn</span> == _(d)_);
<span class="linenr">5: </span>       critical <span style="color: #ECBE7B;">section</span>
<span class="linenr">6: </span>    <span style="color: #dcaeea;">flag</span>[i] = _(e)_;
<span class="linenr">7: </span>    remainder section
<span class="linenr">8: </span>} <span style="color: #51afef;">while</span> (<span style="color: #a9a1e1;">true</span>);
</pre>
</div>
</div>
<div id="outline-container-orgfa87e64" class="outline-5">
<h5 id="orgfa87e64">解</h5>
<div class="outline-text-5" id="text-orgfa87e64">
<p>
Peterson 解法是一種經典的軟體同步機制，用來解決兩個進程的臨界區問題（Critical Section Problem）。它使用兩個共享變數來確保互斥（Mutual Exclusion）：<br />
</p>
<ul class="org-ul">
<li>flag[i]：表示進程 Pi 是否想進入臨界區，當 flag[i] = true 時，代表 Pi 想要進入臨界區。<br /></li>
<li>turn：用來決定哪個進程的優先權較高，當 turn = j 時，表示輪到 Pj 進入臨界區。<br /></li>
</ul>

<p>
Peterson 解法的 Pi 程式架構<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">do</span> {
<span class="linenr">2: </span>    flag[i] = <span style="color: #a9a1e1;">true</span>;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(a) &#34920;&#31034; Pi &#24819;&#35201;&#36914;&#20837;&#33256;&#30028;&#21312;</span>
<span class="linenr">3: </span>    turn = j;            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(b) &#23559;&#27402;&#38480;&#35731;&#32102; Pj</span>
<span class="linenr">4: </span>    <span style="color: #51afef;">while</span> (flag[j] == <span style="color: #a9a1e1;">true</span> &amp;&amp; turn == j);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(c) &amp; (d) &#31561;&#24453; Pj &#36914;&#20837;&#33256;&#30028;&#21312;</span>
<span class="linenr">5: </span>       critical <span style="color: #ECBE7B;">section</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36914;&#20837;&#33256;&#30028;&#21312;</span>
<span class="linenr">6: </span>    <span style="color: #dcaeea;">flag</span>[i] = <span style="color: #a9a1e1;">false</span>;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(e) Pi &#38626;&#38283;&#33256;&#30028;&#21312;&#65292;&#37323;&#25918;&#36039;&#28304;</span>
<span class="linenr">7: </span>    remainder section    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36914;&#20837;&#21097;&#39192;&#21312;</span>
<span class="linenr">8: </span>} <span style="color: #51afef;">while</span> (<span style="color: #a9a1e1;">true</span>);
</pre>
</div>
<p>
填入的空格<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">標記</th>
<th scope="col" class="org-left">填入值</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(a)</td>
<td class="org-left">true</td>
<td class="org-left">設定 flag[i] = true，表示 Pi 想要進入臨界區</td>
</tr>

<tr>
<td class="org-left">(b)</td>
<td class="org-left">j</td>
<td class="org-left">設定 turn = j，讓 Pj 先執行</td>
</tr>

<tr>
<td class="org-left">(c)</td>
<td class="org-left">true</td>
<td class="org-left">檢查 flag[j] == true，如果 Pj 也想進入，則等待</td>
</tr>

<tr>
<td class="org-left">(d)</td>
<td class="org-left">j</td>
<td class="org-left">turn == j，如果 Pj 仍然有優先權，則 Pi 需等待</td>
</tr>

<tr>
<td class="org-left">(e)</td>
<td class="org-left">false</td>
<td class="org-left">Pi 離開臨界區後，將 flag[i] 設為 false，表示不再需要進入臨界區</td>
</tr>
</tbody>
</table>

<p>
Peterson 解法的核心機制<br />
</p>
<ol class="org-ol">
<li>互斥（Mutual Exclusion）<br />
<ul class="org-ul">
<li>當 Pi 進入臨界區時，Pj 必須等待，反之亦然。<br /></li>
<li>while 迴圈確保如果 Pj 也想進入臨界區並且 turn = j，則 Pi 會等待。<br /></li>
</ul></li>
<li>進度（Progress）<br />
<ul class="org-ul">
<li>如果沒有進程在臨界區，則不會有進程無限等待的情況，每個進程都可以最終獲得執行機會。<br /></li>
</ul></li>
<li>有限等待（Bounded Waiting）<br />
<ul class="org-ul">
<li>turn 變數確保進程不會無限等待，每個進程都能輪流進入臨界區。<br /></li>
</ul></li>
</ol>

<p>
Peterson 解法的優點與缺點<br />
</p>
<ul class="org-ul">
<li>✅ 優點：<br />
<ul class="org-ul">
<li>簡單且不依賴硬體支援，可用於一般軟體同步機制。<br /></li>
<li>適用於兩個進程（Pi、Pj） 的臨界區問題。<br /></li>
</ul></li>
</ul>
<p>
❌ 缺點：<br />
</p>
<ul class="org-ul">
<li>只能應用於兩個進程，無法擴展至多個進程。<br /></li>
<li>依賴於共享記憶體（Shared Memory），無法在分散式系統中應用。<br /></li>
<li>需要不斷檢查 while 迴圈（忙等待，Busy Waiting），可能影響效能。<br /></li>
</ul>

<p>
結論: Peterson 解法雖然不適合大規模多執行緒系統，但作為早期軟體互斥鎖的經典範例，仍然在學術領域具有重要意義，尤其是在作業系統與並行程式設計中，是理解**同步機制（Synchronization Mechanisms）**的重要基礎。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org066e0bf" class="outline-4">
<h4 id="org066e0bf"><span class="section-number-4">1.4.7.</span> 七、(5%)</h4>
<div class="outline-text-4" id="text-1-4-7">
<p>
Please describe two strategies commonly being used in OS to allocate the kernel memory for structures of varying sizes.<br />
</p>
</div>
<div id="outline-container-org9f4a06a" class="outline-5">
<h5 id="org9f4a06a">解</h5>
<div class="outline-text-5" id="text-org9f4a06a">
</div>
<ul class="org-ul">
<li><a id="org32b3552"></a>作業系統中的核心記憶體配置策略<br />
<div class="outline-text-6" id="text-org32b3552">
<p>
在作業系統（Operating System, OS）中，核心（Kernel）需要管理自身的記憶體，以便存放內部數據結構，如進程控制塊（Process Control Block, PCB）、檔案描述符（File Descriptors）等。由於這些數據結構的大小不固定，作業系統通常使用以下兩種策略來分配不同大小的核心記憶體（Kernel Memory Allocation）。<br />
</p>
</div>
</li>
<li><a id="orga33853e"></a>策略 1：夾層分配器（Buddy System）<br />
<div class="outline-text-6" id="text-orga33853e">
<ul class="org-ul">
<li>定義： 夾層分配器（Buddy System）是一種二元樹（Binary Tree）式的記憶體管理機制，透過遞迴方式將記憶體分割為兩個相等的部分（Buddy, 夥伴），直到找到最適合的區塊來滿足請求。<br /></li>
<li>運作方式：<br />
<ul class="org-ul">
<li>核心記憶體被劃分成大小為 2n2n 的區塊。<br /></li>
<li>若一個進程請求大小為 SS 的記憶體：<br />
<ul class="org-ul">
<li>找到一個最小的適當區塊 2k2k（其中 2k≥S2k≥S）。<br /></li>
<li>若區塊過大，則將其拆分成兩個相等的夥伴（Buddy）。<br /></li>
<li>直到找到適合大小的區塊並將其分配。<br /></li>
</ul></li>
<li>當區塊被釋放時，系統會檢查是否能與其 Buddy 合併，以減少記憶體碎片。<br /></li>
</ul></li>
<li>優點：<br />
<ul class="org-ul">
<li>快速分配與回收：因為使用二元分割，記憶體管理較為高效。<br /></li>
<li>簡單的管理機制：利用位圖或鏈結表追蹤空間分配狀況。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>內部碎片（Internal Fragmentation）：若請求的記憶體大小與 2k2k 不匹配，會浪費多餘的空間。<br /></li>
<li>可能產生外部碎片（External Fragmentation）：雖然 Buddy System 允許合併，但仍可能產生無法有效利用的小區塊。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org24896b6"></a>策略 2：分頁緩存（Slab Allocation）<br />
<div class="outline-text-6" id="text-org24896b6">
<ul class="org-ul">
<li>定義： 分頁緩存（Slab Allocation）是一種針對小型且固定大小的記憶體物件（如 PCB、檔案描述符等）設計的記憶體管理機制，可減少內部碎片並提高記憶體分配效率。<br /></li>
<li>運作方式：<br />
<ul class="org-ul">
<li>記憶體被劃分為「頁框（Pages）」，每個頁框會被進一步切割為大小相同的小區塊（Slabs）。<br /></li>
<li>Slab 會被組織成三種狀態：<br />
<ul class="org-ul">
<li>空閒（Empty）：該 Slab 內沒有任何已分配的物件。<br /></li>
<li>部分使用（Partial）：部分物件已分配，部分仍可使用。<br /></li>
<li>完全使用（Full）：所有物件都已被分配。<br /></li>
</ul></li>
<li>當核心需要分配記憶體時：<br />
<ul class="org-ul">
<li>若 Partial Slab 內有可用區塊，則直接分配。<br /></li>
<li>若沒有可用區塊，則從 Empty Slab 取用新區塊。<br /></li>
<li>若沒有 Empty Slab，則從系統獲取新的頁框。<br /></li>
</ul></li>
</ul></li>
<li>優點：<br />
<ul class="org-ul">
<li>減少內部碎片：每個 Slab 大小相同，不會浪費過多記憶體。<br /></li>
<li>適合固定大小物件：如進程控制塊（PCB）、inode 物件等。<br /></li>
<li>提升效能：Slab 會預先配置記憶體，因此分配與釋放時不需要進行額外的計算。<br /></li>
</ul></li>
<li>缺點：<br />
<ul class="org-ul">
<li>不適用於變長結構：對於大小不固定的結構（如動態數據），Slab Allocation 效率較低。<br /></li>
<li>記憶體池管理較複雜：需要追蹤 Slab 狀態（Empty、Partial、Full）。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgfbaa865"></a>夾層分配器 vs. 分頁緩存 比較<br />
<div class="outline-text-6" id="text-orgfbaa865">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">夾層分配器（Buddy System）</th>
<th scope="col" class="org-left">分頁緩存（Slab Allocation）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">記憶體類型</td>
<td class="org-left">適用於變長記憶體分配</td>
<td class="org-left">適用於固定大小的物件</td>
</tr>

<tr>
<td class="org-left">內部碎片</td>
<td class="org-left">高（因為分配的區塊可能比需求大）</td>
<td class="org-left">低（物件大小固定）</td>
</tr>

<tr>
<td class="org-left">外部碎片</td>
<td class="org-left">可能發生，但可以透過 Buddy 合併降低</td>
<td class="org-left">無（因為頁框固定）</td>
</tr>

<tr>
<td class="org-left">適用場景</td>
<td class="org-left">動態大小的結構，如用戶態請求的記憶體</td>
<td class="org-left">固定大小的核心物件，如 PCB、inode</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org2d155b9"></a>相關計算機概論知識 為了準備研究所考試，考生應該掌握以下相關的計概知識：<br />
<div class="outline-text-6" id="text-org2d155b9">
<ul class="org-ul">
<li>作業系統記憶體管理（Memory Management）<br />
<ul class="org-ul">
<li>記憶體分配策略：靜態分配（Static Allocation）、動態分配（Dynamic Allocation）<br /></li>
<li>虛擬記憶體（Virtual Memory）：Paging、Segmentation<br /></li>
<li>記憶體對齊（Memory Alignment） 與其對性能的影響<br /></li>
</ul></li>
<li>記憶體分配技術（Memory Allocation Techniques）<br />
<ul class="org-ul">
<li>夾層分配器（Buddy System）<br /></li>
<li>分頁緩存（Slab Allocation）<br /></li>
<li>堆積（Heap）與堆疊（Stack）記憶體管理<br /></li>
</ul></li>
<li>記憶體碎片管理（Memory Fragmentation Management）<br />
<ul class="org-ul">
<li>內部碎片（Internal Fragmentation）<br /></li>
<li>外部碎片（External Fragmentation）<br /></li>
<li>碎片回收技術（Compaction）<br /></li>
</ul></li>
<li>記憶體對核心的影響（Kernel Memory Impact）<br />
<ul class="org-ul">
<li>快取行為（Caching Behavior） 與其影響<br /></li>
<li>核心資料結構（如 PCB, inode, file descriptors） 的記憶體管理方式<br /></li>
</ul></li>
<li>現代作業系統記憶體管理演進<br />
<ul class="org-ul">
<li>Linux 如何使用 Slab 分配器（Slab Allocator） 來管理核心記憶體<br /></li>
<li>夾層分配器如何被應用於大規模系統，如 Linux Buddy Allocator<br /></li>
</ul></li>
</ul>

<p>
結論: 夾層分配器（Buddy System）和分頁緩存（Slab Allocation）是 OS 最常用的兩種核心記憶體分配策略，各自適用於不同場景：<br />
</p>
<ul class="org-ul">
<li>夾層分配器適合動態大小的記憶體請求，但可能產生內部碎片。<br /></li>
<li>分頁緩存適合固定大小的物件分配，有效減少記憶體浪費。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8d78c6e" class="outline-4">
<h4 id="org8d78c6e"><span class="section-number-4">1.4.8.</span> 八、(5%)</h4>
<div class="outline-text-4" id="text-1-4-8">
<p>
Given a computer memory system with the page size 16KB, if the system guarantees that the TLB (Translation Look-ahead Buffer) reach is at least 32MB, how many TLB entries should this system have?<br />
</p>
</div>
<div id="outline-container-org74f82da" class="outline-5">
<h5 id="org74f82da">解</h5>
<div class="outline-text-5" id="text-org74f82da">
<ul class="org-ul">
<li>題目分析<br />
<ul class="org-ul">
<li>頁面大小（Page Size, P）：16KB=16×1024=16,38416KB=16×1024=16,384 bytes<br /></li>
<li>TLB 影響範圍（TLB Reach）：至少 32MB=32×1024×1024=33,554,43232MB=32×1024×1024=33,554,432 bytes<br /></li>
<li>目標：求 TLB 至少需要多少個條目（Entries）<br /></li>
</ul></li>
<li>TLB 影響範圍（TLB Reach）計算<br />
<ul class="org-ul">
<li>TLB 影響範圍（TLB Reach）定義為：<br /></li>
<li>TLBReach=(TLB entries)×(Page Size)<br /></li>
<li>TLBReach=(TLB entries)×(Page Size)<br /></li>
</ul></li>
<li>令 E 為 TLB 的條目數（Number of TLB Entries），則：<br />
<ul class="org-ul">
<li>E×16,384≥33,554,432<br /></li>
</ul></li>
<li>解此不等式：<br />
<ul class="org-ul">
<li>\(E\ge\frac{33,554,432}{16,384}\)<br /></li>
</ul></li>
<li>計算：<br />
<ul class="org-ul">
<li>\(E\ge2048\)<br /></li>
</ul></li>
<li>所以，TLB 需要至少 2048 個條目（entries），才能達到 32MB 的影響範圍。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org801e5c9" class="outline-5">
<h5 id="org801e5c9">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-org801e5c9">
<p>
為了更完整理解這個題目，考生應該掌握以下計算機組織與作業系統（Computer Organization &amp; OS） 相關知識：<br />
</p>
<ol class="org-ol">
<li>記憶體管理機制<br />
<ul class="org-ul">
<li>虛擬記憶體（Virtual Memory）：將虛擬地址對應到實體地址，允許程式擁有比物理記憶體更大的可用空間。<br /></li>
<li>分頁（Paging）：將記憶體分成固定大小的頁（Page）和框（Frame），透過頁表（Page Table）管理映射關係。<br /></li>
<li>TLB（Translation Lookaside Buffer）：存儲最近訪問的頁表映射關係，減少頁表查詢的時間。<br /></li>
</ul></li>
<li>TLB 的運作<br />
<ul class="org-ul">
<li>TLB 是快取（Cache），存儲最近訪問的頁表條目（Page Table Entries, PTEs），提高記憶體存取效率。<br /></li>
<li>TLB 命中（TLB Hit）：如果所需的頁表條目存在於 TLB，則直接返回物理地址。<br /></li>
<li>TLB 失敗（TLB Miss）：如果所需的頁表條目不在 TLB，則需查詢主頁表（Page Table）。<br /></li>
</ul></li>
<li>TLB 影響範圍（TLB Reach）<br />
<ul class="org-ul">
<li>TLB Reach = (TLB 條目數) × (頁大小)，表示 TLB 可快速轉譯的虛擬記憶體範圍。<br /></li>
<li>較大的 TLB Reach 可減少 TLB Miss，提高效能。<br /></li>
</ul></li>
<li>記憶體效能分析<br />
<ul class="org-ul">
<li>TLB Hit Ratio（命中率）：提高命中率可減少頁表存取時間。<br /></li>
<li>Page Table Walk：若 TLB Miss，則需查詢頁表，可能影響記憶體存取速度。<br /></li>
<li>多級頁表（Multi-Level Page Table）：大記憶體系統中常使用多級頁表以減少頁表大小。<br /></li>
</ul></li>
</ol>

<p>
結論:在本題中：<br />
</p>
<ul class="org-ul">
<li>頁大小 = 16KB<br /></li>
<li>TLB 影響範圍 = 32MB<br /></li>
<li>計算得 TLB 需要至少 2048 個條目<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org81c55d2" class="outline-4">
<h4 id="org81c55d2"><span class="section-number-4">1.4.9.</span> 九、(5%)</h4>
<div class="outline-text-4" id="text-1-4-9">
<p>
Suppose we a function P(x) = a + bx⁵ + cx¹⁰ + dx¹⁵. Given a x value, when deriving P(x) value, what is the minimum number of “add” operation? what is the minimum number of “multiply” operation?<br />
</p>
</div>
<div id="outline-container-org43077f7" class="outline-5">
<h5 id="org43077f7">解</h5>
<div class="outline-text-5" id="text-org43077f7">
</div>
<ul class="org-ul">
<li><a id="org8832762"></a>題目分析<br />
<div class="outline-text-6" id="text-org8832762">
<ul class="org-ul">
<li>目標：計算 \(P(x)=a+bx^5+cx^{10}+dx^{15^\)<br /></li>
<li>其中 a,b,c,da,b,c,d 是常數，最小化加法與乘法的操作次數。<br /></li>
</ul>
</div>
</li>
<li><a id="org1a3b764"></a>計算多項式時的加法與乘法操作<br />
<div class="outline-text-6" id="text-org1a3b764">
<ol class="org-ol">
<li>直接計算的乘法與加法次數<br />
最直接的方法是分別計算 \(x^5,x^{10},x^{15}\)，然後代入：<br />
<ul class="org-ul">
<li>乘法操作：<br />
<ul class="org-ul">
<li>\(x^5=x\times x\times x\times x\times x\)（4 次）<br /></li>
<li>\(x^{10}=x^5 \times x^5 \)（1 次）<br /></li>
<li>\(x^{15}=x^5 \times x^{10} \)（1 次）<br /></li>
<li>總共需要：4+1+1=6 次乘法<br /></li>
</ul></li>
<li>加法操作：<br />
<ul class="org-ul">
<li>計算 \(P(x)=a+bx^5+cx^{10}+dx^{15} \)需要 3 次加法。<br /></li>
</ul></li>
</ul></li>
<li>使用最少乘法的策略（快速冪運算）<br />
我們可以透過分解指數的方式來最小化乘法：<br />
<ol class="org-ol">
<li><p>
計算 x^5:<br />
</p>
<ul class="org-ul">
<li>\(x^2=x \times x \)(得到 x^2，1 次)<br /></li>
<li>\(x^4=x^2 \times x^2 \)(得到 x^4，1 次)<br /></li>
<li>\(x^5=x^4 \times × \) (得到 x^5，1 次)<br /></li>
</ul>
<p>
總共 3 次乘法。<br />
</p></li>
<li>計算 \(x^{10} \)\)<br />
<ul class="org-ul">
<li>\( x^{10} = x^5 \times x^5 \)(1 次)<br /></li>
</ul></li>
<li>計算 \(x^{15}\):<br />
\(x^{15} = x^5 \times x^{10} \)(1 次)<br /></li>
</ol></li>
</ol>
</div>
</li>
<li><a id="orgfc70407"></a>最小運算次數<br />
<div class="outline-text-6" id="text-orgfc70407">
<ul class="org-ul">
<li>最小乘法數：<br />
共 3（求 x^5）+ 1（求 \(x^{10}\) ）+ 1（求 \( x^{15}\) ）= 5 次乘法<br /></li>
<li>最小加法數：<br />
\( P(x) = a + bx^5 + cx^{1-0} + dx^{15} \)需要 3 次加法（每個項目與前一項相加）。<br /></li>
</ul>
<p>
總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">運算類型</th>
<th scope="col" class="org-left">最少操作數</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">加法（Add）</td>
<td class="org-left">3 次</td>
</tr>

<tr>
<td class="org-left">乘法（Multiply）</td>
<td class="org-left">5 次</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-org91b6c8e" class="outline-5">
<h5 id="org91b6c8e">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-org91b6c8e">
<p>
為了完整理解此題目，研究所考生應熟悉以下概念：<br />
</p>
<ol class="org-ol">
<li>數值計算（Numerical Computation）<br />
<ul class="org-ul">
<li>多項式計算優化（Polynomial Evaluation Optimization）<br />
<ul class="org-ul">
<li>Horner&rsquo;s Method（霍納法則）（適用於一般多項式）<br /></li>
<li>指數快速計算（Exponentiation by Squaring）<br /></li>
<li>乘法次數最少的展開策略<br /></li>
</ul></li>
</ul></li>
<li>時間複雜度分析（Time Complexity Analysis）<br />
<ul class="org-ul">
<li>多項式計算的 時間複雜度最佳化<br /></li>
<li>漸進時間複雜度（Big-O 計算），如：<br />
<ul class="org-ul">
<li>直接計算 O(n)<br /></li>
<li>快速冪算法 O(log⁡n)<br /></li>
</ul></li>
</ul></li>
<li>計算機架構與數值計算應用<br />
<ul class="org-ul">
<li>乘法和加法在 CPU 內部的實作<br /></li>
<li>乘法指令（Multiply Instruction）與 SIMD 指令集的加速<br /></li>
<li>GPU 如何加速多項式運算（例如 CUDA 使用並行計算）<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgbd0f723" class="outline-4">
<h4 id="orgbd0f723"><span class="section-number-4">1.4.10.</span> 十、</h4>
<div class="outline-text-4" id="text-1-4-10">
<p>
What is runtime polymorphism or dynamic method dispatch in Java? (5 points). Provide example Java codes to explain this concept (5 points)<br />
</p>
</div>
<div id="outline-container-org5bdc367" class="outline-5">
<h5 id="org5bdc367">解</h5>
<div class="outline-text-5" id="text-org5bdc367">
<p>
在 Java 中，運行時多型（Runtime Polymorphism），也稱為動態方法分派（Dynamic Method Dispatch），是一種 透過父類別的參考變數來調用子類別的覆寫方法（Overridden Method） 的技術。這種機制允許程式在執行期間決定調用哪個方法，而不是在編譯期間。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgcf72784"></a>運行時多型的關鍵概念<br />
<div class="outline-text-6" id="text-orgcf72784">
<ul class="org-ul">
<li>方法覆寫（Method Overriding）:子類別（Subclass）提供與父類別（Superclass）相同的方法名稱、參數列表與返回類型，來覆寫父類別的方法。<br /></li>
<li>父類別的參考指向子類別物件:SuperClass obj = new SubClass(); → 透過父類別的參考變數來存取子類別的覆寫方法。<br /></li>
<li>動態綁定（Dynamic Binding）: 在執行時決定調用的方法，而不是在編譯時。<br /></li>
</ul>
</div>
</li>
<li><a id="org218d940"></a>Java 範例<br />
<div class="outline-text-6" id="text-org218d940">
<p>
以下程式示範運行時多型，透過父類別 Animal 的參考變數來呼叫不同子類別 Dog 和 Cat 的 makeSound() 方法。<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29238;&#39006;&#21029; Animal</span>
<span class="linenr"> 2: </span><span style="color: #51afef;">class</span> Animal {
<span class="linenr"> 3: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr"> 4: </span>        System.out.println(<span style="color: #98be65;">"Animal makes a sound"</span>);
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23376;&#39006;&#21029; Dog&#65292;&#35206;&#23531; makeSound &#26041;&#27861;</span>
<span class="linenr"> 9: </span><span style="color: #51afef;">class</span> Dog <span style="color: #51afef;">extends</span> Animal {
<span class="linenr">10: </span>    @Override
<span class="linenr">11: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr">12: </span>        System.out.println(<span style="color: #98be65;">"Dog barks"</span>);
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>}
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23376;&#39006;&#21029; Cat&#65292;&#35206;&#23531; makeSound &#26041;&#27861;</span>
<span class="linenr">17: </span><span style="color: #51afef;">class</span> Cat <span style="color: #51afef;">extends</span> Animal {
<span class="linenr">18: </span>    @Override
<span class="linenr">19: </span>    <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">makeSound</span>() {
<span class="linenr">20: </span>        System.out.println(<span style="color: #98be65;">"Cat meows"</span>);
<span class="linenr">21: </span>    }
<span class="linenr">22: </span>}
<span class="linenr">23: </span>
<span class="linenr">24: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#28204;&#35430;&#39006;&#21029;</span>
<span class="linenr">25: </span><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> RuntimePolymorphismExample {
<span class="linenr">26: </span>    <span style="color: #51afef;">public</span> <span style="color: #51afef;">static</span> <span style="color: #51afef;">void</span> <span style="color: #dcaeea;">main</span>(String[] args) {
<span class="linenr">27: </span>        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29238;&#39006;&#21029;&#30340;&#21443;&#32771;&#35722;&#25976;&#25351;&#21521;&#23376;&#39006;&#21029;&#29289;&#20214;</span>
<span class="linenr">28: </span>        Animal myAnimal;
<span class="linenr">29: </span>
<span class="linenr">30: </span>        myAnimal = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Dog</span>();
<span class="linenr">31: </span>        myAnimal.makeSound();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22519;&#34892;&#26178;&#27770;&#23450;&#21628;&#21483; Dog &#30340; makeSound()</span>
<span class="linenr">32: </span>
<span class="linenr">33: </span>        myAnimal = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Cat</span>();
<span class="linenr">34: </span>        myAnimal.makeSound();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22519;&#34892;&#26178;&#27770;&#23450;&#21628;&#21483; Cat &#30340; makeSound()</span>
<span class="linenr">35: </span>    }
<span class="linenr">36: </span>}
</pre>
</div>
<p>
執行結果<br />
</p>
<pre class="example" id="org73efc12">
Dog barks
Cat meows
</pre>
</div>
</li>
<li><a id="orgd0d025a"></a>解析<br />
<div class="outline-text-6" id="text-orgd0d025a">
<ol class="org-ol">
<li>父類別 Animal 定義了一個 makeSound() 方法。<br /></li>
<li>子類別 Dog 和 Cat 皆覆寫（Override）了 makeSound() 方法。<br /></li>
<li>在 main() 方法中：<br />
<ul class="org-ul">
<li>Animal myAnimal = new Dog(); → myAnimal.makeSound(); 會呼叫 Dog 版本。<br /></li>
<li>myAnimal = new Cat(); → myAnimal.makeSound(); 會呼叫 Cat 版本。<br /></li>
</ul></li>
<li>關鍵點：<br />
<ul class="org-ul">
<li>在編譯時，編譯器僅知道 myAnimal 是 Animal 型別。<br /></li>
<li>在執行時，Java 會根據物件的實際型別（Dog 或 Cat）來決定調用哪個 makeSound() 方法。<br /></li>
</ul></li>
</ol>

<p>
運行時多型的重要性<br />
</p>
<ul class="org-ul">
<li>✅ 提高程式的靈活性與可擴展性<br /></li>
<li>✅ 允許以統一的方式處理不同類別的物件<br /></li>
<li>✅ 適用於面向物件設計模式，如工廠模式（Factory Pattern）與策略模式（Strategy Pattern）<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgbdde329" class="outline-4">
<h4 id="orgbdde329"><span class="section-number-4">1.4.11.</span> 十一、</h4>
<div class="outline-text-4" id="text-1-4-11">
<p>
The following programming method was written to determine whether its String parameter reads identically left-to-right and right-to-left (the so called palindrome 回文).<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">boolean</span> <span style="color: #c678dd;">isAPalindrome</span>(<span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">s</span>) {
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">j</span> = s.length() - <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">3: </span>    <span style="color: #51afef;">while</span> (i != j &amp;&amp; s.charAt(i) == s.charAt(j)) {
<span class="linenr">4: </span>        i++;
<span class="linenr">5: </span>        j--;
<span class="linenr">6: </span>    }
<span class="linenr">7: </span>    <span style="color: #51afef;">return</span> (i == j);
<span class="linenr">8: </span>}
</pre>
</div>
<p>
This method compiles fine; however, it contains a logic error, which may result in a run-time error, or wrong output.<br />
</p>
<ol class="org-ol">
<li>Find the error and explain what problem it will cause (5 points)<br /></li>
<li>Fix the error (write the correct statements) (5 points)<br /></li>
<li>Write an alternative, recursive implementation (5 points)<br /></li>
</ol>
</div>
<div id="outline-container-org411d454" class="outline-5">
<h5 id="org411d454">解</h5>
<div class="outline-text-5" id="text-org411d454">
<p>
給定一個 Java 方法 isAPalindrome(String s)，該方法應判斷輸入字串是否為回文（即從左至右和從右至左讀取結果相同）。然而，原始程式碼存在邏輯錯誤，可能導致運行時錯誤或錯誤輸出。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org46db675"></a>1. 找出錯誤並解釋（5 分）<br />
<div class="outline-text-6" id="text-org46db675">
<p>
原始程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr">1: </span><span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">isAPalindrome</span>(String s) {
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">j</span> = s.length() - <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr">3: </span>    <span style="color: #51afef;">while</span> (i != j &amp;&amp; s.charAt(i) == s.charAt(j)) {
<span class="linenr">4: </span>        i++;
<span class="linenr">5: </span>        j--;
<span class="linenr">6: </span>    }
<span class="linenr">7: </span>    <span style="color: #51afef;">return</span> (i == j);
<span class="linenr">8: </span>}
</pre>
</div>

<p>
錯誤點<br />
</p>
<ul class="org-ul">
<li>錯誤條件：while (i != j &amp;&amp; s.charAt(i) == s.charAt(j))<br />
<ul class="org-ul">
<li>i != j 條件錯誤，當 i 越過 j（如偶數長度字串）時，迴圈應該結束，但 i != j 仍為 true 時，會造成錯誤判斷。<br /></li>
<li>例如，對於 abba：<br />
<ul class="org-ul">
<li>i=0, j=3：檢查 a == a（✅）<br /></li>
<li>i=1, j=2：檢查 b == b（✅）<br /></li>
<li>i=2, j=1：錯誤條件仍為 true，導致錯誤結果<br /></li>
</ul></li>
</ul></li>
</ul>
<p>
錯誤後果<br />
</p>
<ul class="org-ul">
<li>錯誤輸出：對於偶數長度的回文字串（如 &ldquo;abba&rdquo;），應該回傳 true，但由於條件 i == j 不成立，會回傳 false。<br /></li>
<li>潛在運行時錯誤：當 i &gt; j 時，迴圈應該停止，否則可能導致存取 s.charAt(i) 或 s.charAt(j) 時出界（Out of Bounds）。<br /></li>
</ul>
</div>
</li>
<li><a id="orga71b9e6"></a>2. 修正錯誤（5 分）<br />
<div class="outline-text-6" id="text-orga71b9e6">
<p>
修正後的程式碼<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">isAPalindrome</span>(String s) {
<span class="linenr"> 2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">j</span> = s.length() - <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 3: </span>    <span style="color: #51afef;">while</span> (i &lt; j) {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20462;&#27491;&#26781;&#20214;&#65292;&#30906;&#20445; i &#19981;&#26371;&#36229;&#36942; j</span>
<span class="linenr"> 4: </span>        <span style="color: #51afef;">if</span> (s.charAt(i) != s.charAt(j)) {
<span class="linenr"> 5: </span>            <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#23383;&#31526;&#19981;&#21516;&#65292;&#21063;&#19981;&#26159;&#22238;&#25991;</span>
<span class="linenr"> 6: </span>        }
<span class="linenr"> 7: </span>        i++;
<span class="linenr"> 8: </span>        j--;
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25152;&#26377;&#23565;&#25033;&#23383;&#31526;&#37117;&#30456;&#31561;&#65292;&#28858;&#22238;&#25991;</span>
<span class="linenr">11: </span>}
</pre>
</div>
<p>
修正內容<br />
</p>
<ul class="org-ul">
<li>修正迴圈條件<br />
<ul class="org-ul">
<li>while (i != j) → while (i &lt; j)<br /></li>
<li>確保 i 不會超過 j，特別是對於偶數長度的字串。<br /></li>
</ul></li>
<li>改變回傳條件<br />
<ul class="org-ul">
<li>若 s.charAt(i) != s.charAt(j)，則立即回傳 false，無需繼續檢查。<br /></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org7be71d3"></a>3. 遞迴（Recursive）實作（5 分）<br />
<div class="outline-text-6" id="text-org7be71d3">
<p>
遞迴方法可以使用字串的首尾比較，然後遞迴地檢查中間部分。<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">isAPalindromeRecursive</span>(String s) {
<span class="linenr"> 2: </span>    <span style="color: #51afef;">return</span> checkPalindrome(s, <span style="color: #da8548; font-weight: bold;">0</span>, s.length() - <span style="color: #da8548; font-weight: bold;">1</span>);
<span class="linenr"> 3: </span>}
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36958;&#36852;&#36628;&#21161;&#20989;&#25976;</span>
<span class="linenr"> 6: </span><span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">boolean</span> <span style="color: #dcaeea;">checkPalindrome</span>(String s, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>, <span style="color: #ECBE7B;">int</span> j) {
<span class="linenr"> 7: </span>    <span style="color: #51afef;">if</span> (i &gt;= j) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36958;&#36852;&#32066;&#27490;&#26781;&#20214;</span>
<span class="linenr"> 8: </span>    <span style="color: #51afef;">if</span> (s.charAt(i) != s.charAt(j)) <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#23383;&#31526;&#19981;&#30456;&#31561;&#21063;&#19981;&#26159;&#22238;&#25991;</span>
<span class="linenr"> 9: </span>    <span style="color: #51afef;">return</span> checkPalindrome(s, i + <span style="color: #da8548; font-weight: bold;">1</span>, j - <span style="color: #da8548; font-weight: bold;">1</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#32380;&#32396;&#27298;&#26597;&#20839;&#37096;&#23383;&#20803;</span>
<span class="linenr">10: </span>}
</pre>
</div>
<p>
遞迴版本的運作原理<br />
</p>
<ul class="org-ul">
<li>基礎條件：<br />
<ul class="org-ul">
<li>若 i &gt;= j（即字串長度為 1 或 i 超過 j），則回文檢查完成，回傳 true。<br /></li>
</ul></li>
<li>遞迴邏輯：<br />
<ul class="org-ul">
<li>若 s.charAt(i) != s.charAt(j)，則回傳 false。<br /></li>
<li>否則，繼續檢查 s[i+1] 到 s[j-1] 是否為回文（遞迴）。<br /></li>
</ul></li>
</ul>

<p>
總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">項目</th>
<th scope="col" class="org-left">原始程式碼</th>
<th scope="col" class="org-left">修正後版本</th>
<th scope="col" class="org-left">遞迴版本</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">迴圈條件</td>
<td class="org-left">i != j</td>
<td class="org-left">i &lt; j</td>
<td class="org-left">使用遞迴 checkPalindrome(s, i, j)</td>
</tr>

<tr>
<td class="org-left">停止條件</td>
<td class="org-left">錯誤（可能超過邊界）</td>
<td class="org-left">while (i &lt; j)</td>
<td class="org-left">if (i &gt;= j) return true</td>
</tr>

<tr>
<td class="org-left">回傳條件</td>
<td class="org-left">i == j</td>
<td class="org-left">若 s[i] != s[j] 則 return false</td>
<td class="org-left">若 s[i] != s[j] 則 return false</td>
</tr>

<tr>
<td class="org-left">效率</td>
<td class="org-left">O(n)O(n)</td>
<td class="org-left">O(n)O(n)</td>
<td class="org-left">O(n)O(n)（但需額外遞迴堆疊空間）</td>
</tr>

<tr>
<td class="org-left">適用性</td>
<td class="org-left">可能錯誤</td>
<td class="org-left">最佳化版本</td>
<td class="org-left">適合遞迴場景</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgee3e08b" class="outline-5">
<h5 id="orgee3e08b">相關計算機概論知識</h5>
<div class="outline-text-5" id="text-orgee3e08b">
<p>
考生應熟悉以下演算法與程式設計概念：<br />
</p>
<ol class="org-ol">
<li>演算法設計<br />
<ul class="org-ul">
<li>雙指標技術（Two-Pointer Technique）<br />
<ul class="org-ul">
<li>適用於字串與陣列檢查，如回文檢查、區間搜索、排序。<br /></li>
</ul></li>
<li>時間與空間複雜度分析<br />
<ul class="org-ul">
<li>雙指標法的時間複雜度為 O(n)O(n)。<br /></li>
<li>遞迴方法的時間複雜度同樣為 O(n)O(n)，但可能造成額外的遞迴堆疊開銷（Stack Overhead）。<br /></li>
</ul></li>
</ul></li>
<li>記憶體管理與遞迴<br />
<ul class="org-ul">
<li>遞迴（Recursion）<br />
<ul class="org-ul">
<li>遞迴的函數調用會佔用函數呼叫堆疊（Call Stack），可能導致 Stack Overflow。<br /></li>
</ul></li>
<li>迴圈 vs 遞迴<br />
<ul class="org-ul">
<li>迴圈（Loop） 適合處理長度較大的字串，節省記憶體。<br /></li>
<li>遞迴（Recursion） 易於理解，適合用於分治法（Divide &amp; Conquer）。<br /></li>
</ul></li>
</ul></li>
<li>Java 字串處理<br />
<ul class="org-ul">
<li>String.charAt(i): 取字串 s 中的第 i 個字元，時間複雜度 O(1)O(1)。<br /></li>
<li>String.length(): 取字串長度，時間複雜度 O(1)O(1)。<br /></li>
<li>不可變性（Immutability）：<br />
<ul class="org-ul">
<li>String 是 immutable（不可變），所以在 charAt() 存取字元時，不會影響原始字串。<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org4338374" class="outline-3">
<h3 id="org4338374"><span class="section-number-3">1.5.</span> 111</h3>
</div>
<div id="outline-container-org7476fe8" class="outline-3">
<h3 id="org7476fe8"><span class="section-number-3">1.6.</span> 112</h3>
</div>
</div>
<div id="outline-container-orgc9cbc38" class="outline-2">
<h2 id="orgc9cbc38"><span class="section-number-2">2.</span> 中山近三年考題及詳解</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org3c8b5a2" class="outline-3">
<h3 id="org3c8b5a2"><span class="section-number-3">2.1.</span> 110: 中山管理資訊系統</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-orgc236e21" class="outline-4">
<h4 id="orgc236e21"><span class="section-number-4">2.1.1.</span> 1. 人工智慧(Artificial Intelligence)是近年來相當受到注目的資訊發展，而其中的發展理論可以分為兩大學派，分別為法則學派(Rule-based Approach)與機器學習學派(Machine Learning Approach)。</h4>
<div class="outline-text-4" id="text-2-1-1">
</div>
<div id="outline-container-org4a3ca14" class="outline-5">
<h5 id="org4a3ca14">(1)機器學習學派有四種不同類型，分別為非監督式學習(Unsupervised)、半監督式學習(Semi-supervised)、監督式學習(Supervised)與增強式學習(Reinforcements Learning)，試說明這四種不同類型，並舉例說明之。<code>[12%]</code></h5>
<div class="outline-text-5" id="text-org4a3ca14">
</div>
<ul class="org-ul">
<li><a id="org5a7cc6f"></a>解答<br />
<div class="outline-text-6" id="text-org5a7cc6f">
<ol class="org-ol">
<li>非監督式學習 (Unsupervised Learning): 此類學習的特點是沒有標籤的數據，模型需要自行從數據中找出模式或結構。例如：分群算法 (clustering) 可以將數據分為不同的組別，但事先並不知道這些組別的意義。<br /></li>
<li>半監督式學習 (Semi-supervised Learning): 此類學習使用部分標籤的數據來訓練模型。它介於監督式學習和非監督式學之間，利用少量標籤數據來輔助訓練，提高模型的泛化能力。<br /></li>
<li>監督式學習 (Supervised Learning): 此類學習使用標籤數據來訓練模型，讓模型學習輸入和輸出之間的關係。例如：分類 (classification) 和迴歸 (regression) 問題都屬於監督式學習的範疇。<br /></li>
<li>增強式學習 (Reinforcement Learning): 此類學習通過與環境互動，根據獎勵或懲罰來學習最佳策略。模型會嘗試不同的行動，並根據結果調整策略，以最大化累積獎勵。例如：訓練機器人行走、玩遊戲等。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org0e6ffb9" class="outline-5">
<h5 id="org0e6ffb9">(2)機器學習學派與法則學派兩者的特性與區別在哪？ 兩者與傳統的統計學方法差別又在哪？ <code>[13%]</code></h5>
<div class="outline-text-5" id="text-org0e6ffb9">
</div>
<ul class="org-ul">
<li><a id="org20e5501"></a>解<br />
<div class="outline-text-6" id="text-org20e5501">
<ul class="org-ul">
<li>法則學派 (Rule-based Approach):<br />
<ul class="org-ul">
<li>特性： 依賴人為事先定義好的規則來解決問題。專家需要將領域知識編寫成明確的規則，然後讓系統根據這些規則進行推理和決策。<br /></li>
<li>優點： 容易理解和解釋，適用於規則明確且不複雜的問題。<br /></li>
<li>缺點： 需要大量人工編寫規則，難以處理複雜和不確定的情況。<br /></li>
</ul></li>
<li>機器學習學派 (Machine Learning Approach):<br />
<ul class="org-ul">
<li>特性： 通過從數據中學習來解決問題。模型會自動找出數據中的模式，並根據這些模式進行預測和決策，不需要事先編寫規則。<br /></li>
<li>優點： 能夠處理複雜和不確定的情況，能夠從大量數據中學習，並隨著數據增加不斷提升性能。<br /></li>
<li>缺點： 模型難以解釋，需要大量的訓練數據。<br /></li>
</ul></li>
<li>與傳統統計學方法的差別：<br />
<ul class="org-ul">
<li>傳統統計學： 注重數據分析和假設檢驗，目標是理解數據背後的規律。<br /></li>
<li>機器學習： 注重預測和決策，目標是從數據中建立模型並進行應用。機器學習更多的是從數據中學習模型，統計學則更關注對數據的分析。<br /></li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org84fd79a" class="outline-4">
<h4 id="org84fd79a"><span class="section-number-4">2.1.2.</span> 2.</h4>
<div class="outline-text-4" id="text-2-1-2">
</div>
<div id="outline-container-orga502aba" class="outline-5">
<h5 id="orga502aba">(1)新興技術區塊鏈(Blockchain)在現今產業應用越來越多，請問區塊鏈是什麼？ 有哪些特性呢？ <code>[10%]</code></h5>
<div class="outline-text-5" id="text-orga502aba">
</div>
<ul class="org-ul">
<li><a id="org265f10d"></a>解<br />
<div class="outline-text-6" id="text-org265f10d">
<ul class="org-ul">
<li>定義： 區塊鏈是一種分散式帳本技術，以區塊為單位記錄交易信息，並將這些區塊按時間順序連接成鏈。每個區塊都包含前一個區塊的哈希值，形成一個不可篡改的鏈條.<br /></li>
<li>特性：<br /></li>
<li>去中心化： 沒有單一的控制者，數據由網絡中的多個節點共同維護。<br /></li>
<li>不可篡改： 區塊鏈的數據一旦記錄就難以更改，因為任何修改都會導致後續區塊的哈希值改變。<br /></li>
<li>透明度： 區塊鏈上的交易記錄是公開的，任何人都可以查看。<br /></li>
<li>安全性： 使用密碼學技術來確保數據的安全性和完整性。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgfb5874a" class="outline-5">
<h5 id="orgfb5874a">(2)區塊鏈除了比特幣(Bitcoin)、以太幣(Ether)等數位貨幣外，就你所知，還有哪些產業應用？試舉例說明這些應用。而這些區塊鏈應用，原來是想解決產業什麼樣的問題呢？為什麼會需要使用到區塊鏈技術呢？如果靠其他方法或是其他資訊技術，有沒有辦法解決相同的問題呢？ <code>[15%]</code></h5>
<div class="outline-text-5" id="text-orgfb5874a">
</div>
<ul class="org-ul">
<li><a id="org56a540a"></a>解<br />
<div class="outline-text-6" id="text-org56a540a">
<ul class="org-ul">
<li>產業應用： 除了比特幣 (Bitcoin) 和以太幣 (Ether) 等數位貨幣之外，區塊鏈還被應用於許多其他領域，例如：<br />
<ol class="org-ol">
<li>供應鏈管理： 追蹤商品從生產到消費的整個過程，確保商品的真實性和品質。<br /></li>
<li>數位身份驗證： 建立安全可靠的數位身份系統，保護用戶的隱私。<br /></li>
<li>智能合約： 自動執行合約條款，提高交易的效率和透明度。<br /></li>
<li>版權保護： 追蹤數位內容的版權，防止盜版。<br /></li>
<li>醫療健康： 安全地管理病患數據，方便醫療機構共享信息。<br /></li>
</ol></li>
<li>解決問題：<br />
<ol class="org-ol">
<li>信任問題： 區塊鏈透過分散式帳本和密碼學技術建立信任機制，解決傳統中心化系統的信任問題。<br /></li>
<li>資訊不透明： 區塊鏈的透明特性可以增加資訊的公開性，讓交易記錄可追溯。<br /></li>
<li>效率低下： 區塊鏈的智能合約可以自動執行交易，提高效率。<br /></li>
<li>其他解決方案： 某些情境中，可能可以使用其他方法或是資訊科技來解決產業問題。像是傳統的資料庫系統，可以用來管理數據，或是透過數位簽章來確保數位內容的真偽。但是區塊鏈的去中心化、不可篡改等特性，在需要高度信任的場景下，有其獨特的優勢。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge3acde1" class="outline-4">
<h4 id="orge3acde1"><span class="section-number-4">2.1.3.</span> 3. 目前全球市值最高的前七大公司例如Facebook, Amazon, Google 大都是所謂的「平台經營模式」，請問，何謂平台經營模式？ 其與傳統經營模式相比有何特色？ 其在經營上與傳統模式相比，又有哪些優勢？ <code>[25%]</code></h4>
<div class="outline-text-4" id="text-2-1-3">
</div>
<div id="outline-container-orge7995bc" class="outline-5">
<h5 id="orge7995bc">解</h5>
<div class="outline-text-5" id="text-orge7995bc">
<ul class="org-ul">
<li>平台經營模式的定義：<br />
<ul class="org-ul">
<li>平台經營模式指的是一種以建立平台為核心的商業模式，它不直接提供產品或服務，而是提供一個連接不同用戶群體的場所，讓他們能夠互動、交易或共享資源。<br /></li>
<li>平台通常會利用網絡效應，讓更多用戶的加入使得平台的價值不斷增加。<br /></li>
<li>典型的平台包括像是：Amazon, Facebook, Google 等等。<br /></li>
</ul></li>
<li>平台經營模式與傳統經營模式的特色比較：<br />
<ul class="org-ul">
<li>傳統經營模式：<br />
<ul class="org-ul">
<li>特性： 專注於生產和銷售產品或服務，企業通常直接與客戶互動。<br /></li>
<li>組織結構： 偏向垂直整合，強調內部效率和控制。<br /></li>
<li>收入來源： 主要來自銷售產品或服務。<br /></li>
</ul></li>
<li>平台經營模式：<br />
<ul class="org-ul">
<li>特性： 專注於建立和維護平台，並連接不同的用戶群體。<br /></li>
<li>組織結構： 偏向水平分工，強調協作和網絡效應。<br /></li>
<li>收入來源： 多元化，可能來自廣告、佣金、會員費等。<br /></li>
</ul></li>
<li>平台經營模式的優勢：<br />
<ul class="org-ul">
<li>網絡效應： 用戶越多，平台價值越高，形成正向循環。<br /></li>
<li>規模經濟： 平台可以服務大量用戶，降低單位成本。<br /></li>
<li>多元化收入來源： 平台可以從多個方面獲取收入，降低風險。<br /></li>
<li>創新： 平台可以促進創新，讓第三方開發者在其上開發應用和服務。<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcc27b49" class="outline-4">
<h4 id="orgcc27b49"><span class="section-number-4">2.1.4.</span> 4.資訊安全目前一直是所有組織最關心與擔憂的議題，一個組織要能夠有效率的資訊安全管理，必須要由組織的許多面向與層次(例如政策、組織、人員、制度、科技等)同時來建立，請問，如果你是一個資安顧問，你會如何建立一個完整的資訊安全管理架構，來嚇阻、預防與偵測資安的威脅？ (提示：ISO 27001) <code>[25%]</code></h4>
<div class="outline-text-4" id="text-2-1-4">
</div>
<div id="outline-container-org47d2623" class="outline-5">
<h5 id="org47d2623">解</h5>
<div class="outline-text-5" id="text-org47d2623">
<p>
建立資訊安全管理架構：<br />
</p>
<ul class="org-ul">
<li>全面性： 資訊安全需要考量組織的許多面向與層次，不能只專注在單一技術或措施。<br /></li>
<li>政策： 制定明確的資訊安全政策，規範員工的行為，並確保與法規要求一致。<br /></li>
<li>組織： 建立資訊安全組織，明確人員的責任和權限。<br /></li>
<li>人員： 對員工進行資訊安全培訓，提高安全意識。<br /></li>
<li>制度： 建立完善的資訊安全管理制度，例如：風險評估、存取控制、事件回應等。<br /></li>
<li>科技： 導入必要的資訊安全技術，例如：防火牆、入侵偵測系統、資料加密等。<br /></li>
<li>符合 ISO 27001 標準： 參考 ISO 27001 標準，建立符合國際標準的資訊安全管理系統。<br /></li>
<li>嚇阻、預防、偵測： 建立完善的資訊安全管理架構來達到這三個目的。<br />
<ul class="org-ul">
<li>嚇阻： 建立嚴格的規範與制度，讓潛在的攻擊者知難而退。<br /></li>
<li>預防： 採取主動的防禦措施，降低資安事件發生的可能性。<br /></li>
<li>偵測： 建立監控機制，及早發現資安威脅。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfd8880e" class="outline-3">
<h3 id="orgfd8880e"><span class="section-number-3">2.2.</span> 110: 中山資料結構</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org5530e8e" class="outline-4">
<h4 id="org5530e8e"><span class="section-number-4">2.2.1.</span> 1. AVL tree operations. (16%; 4% for each)</h4>
<div class="outline-text-4" id="text-2-2-1">
</div>
<div id="outline-container-org93384d4" class="outline-5">
<h5 id="org93384d4">(A) Please draw the result of inserting the keys 6, 5, 3, 9, 10 into an empty AVL tree.</h5>
<div class="outline-text-5" id="text-org93384d4">
</div>
<ul class="org-ul">
<li><a id="org03b87a8"></a>解: 插入鍵值 6, 5, 3, 9, 10<br />
<div class="outline-text-6" id="text-org03b87a8">
<ol class="org-ol">
<li><p>
插入 6：建立一個只有根節點的樹：<br />
</p>
<pre class="example" id="orgee58efd">
  6
</pre></li>
<li><p>
插入 5：插入左子樹，平衡性仍然維持：<br />
</p>
<pre class="example" id="org95fc39b">
  6
 /
5
</pre></li>
<li><p>
插入 3：插入 5 的左子樹後導致失衡，執行右旋：<br />
</p>
<pre class="example" id="orga4879ab">
    5
   / \
  3   6
</pre></li>
<li><p>
插入 9：插入 6 的右子樹：<br />
</p>
<pre class="example" id="orgf449893">
    5
   / \
  3   6
       \
        9
</pre></li>
<li><p>
插入 10：插入 9 的右子樹後導致失衡，執行左旋：<br />
</p>
<pre class="example" id="org57b9ce9">
    5
   / \
  3   9
     / \
    6  10
</pre></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge6927cc" class="outline-5">
<h5 id="orge6927cc">(B) Please draw the result after inserting the keys 7, 8, 11 into the AVL tree from (A).</h5>
<div class="outline-text-5" id="text-orge6927cc">
</div>
<ul class="org-ul">
<li><a id="orgab37256"></a>解: 插入鍵值 7, 8, 11<br />
<div class="outline-text-6" id="text-orgab37256">
<ol class="org-ol">
<li><p>
插入 7：插入 6 的右子樹：<br />
</p>
<pre class="example" id="org33bb7f3">
    5
   / \
  3   9
     / \
    6  10
     \
      7
</pre></li>
<li><p>
插入 8：插入 7 的右子樹後導致失衡，對 6 節點執行左旋：<br />
</p>
<pre class="example" id="org46d1a08">
    5
   / \
  3   9
     / \
    7  10
   / \
  6   8
</pre></li>
<li><p>
插入 11：插入 10 的右子樹後無需調整：<br />
</p>
<pre class="example" id="org62944f0">
        5
       / \
      3   9
         / \
        7  10
       / \    \
      6   8    11
</pre></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgfd2c5c9" class="outline-5">
<h5 id="orgfd2c5c9">(C) Please draw the result after removing the key 6 from the AVL tree from (B).</h5>
<div class="outline-text-5" id="text-orgfd2c5c9">
</div>
<ul class="org-ul">
<li><a id="org7f5683b"></a>解:刪除鍵值 6<br />
<div class="outline-text-6" id="text-org7f5683b">
<p>
移除葉節點 6，不影響平衡性：<br />
</p>
<pre class="example" id="orgbd09845">
    5
   / \
  3   9
     / \
    7  10
     \    \
      8    11
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-org90b8dbe" class="outline-5">
<h5 id="org90b8dbe">(D) Please draw the result after removing the key 11 from the AVL tree from (C).</h5>
<div class="outline-text-5" id="text-org90b8dbe">
</div>
<ul class="org-ul">
<li><a id="org98bc7af"></a>解: 刪除鍵值 11<br />
<div class="outline-text-6" id="text-org98bc7af">
<p>
移除葉節點 11，不影響平衡性：<br />
</p>
<pre class="example" id="orgacaddf7">
    5
   / \
  3   9
     / \
    7  10
     \
      8
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga64bf0f" class="outline-4">
<h4 id="orga64bf0f"><span class="section-number-4">2.2.2.</span> 2. (10%; 5% for each)</h4>
<div class="outline-text-4" id="text-2-2-2">
</div>
<div id="outline-container-org1a1fa91" class="outline-5">
<h5 id="org1a1fa91">(A) What is the minimum number of nodes in an AVL tree to achieve the height = 9?</h5>
<div class="outline-text-5" id="text-org1a1fa91">
</div>
<ul class="org-ul">
<li><a id="orgd9be3e4"></a>解<br />
<div class="outline-text-6" id="text-orgd9be3e4">
<p>
高度 h=9h=9，最小節點數公式為： N(h)=1+N(h−1)+N(h−2)N(h)=1+N(h−1)+N(h−2) 初始條件：<br />
N(0)=1,N(1)=2<br />
N(0)=1,N(1)=2<br />
</p>

<p>
逐步計算：<br />
N(2)=1+2+1=4,N(3)=1+4+2=7<br />
N(2)=1+2+1=4,N(3)=1+4+2=7<br />
</p>

<p>
&#x2026;<br />
N(9)=1+N(8)+N(7)=1+88+56=145<br />
N(9)=1+N(8)+N(7)=1+88+56=145<br />
</p>

<p>
答案：145<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org077d1fc" class="outline-5">
<h5 id="org077d1fc">(B) What is the maximum number of nodes in an AVL tree with height = 8? Note that the height is 1 for a tree with only one node.</h5>
<div class="outline-text-5" id="text-org077d1fc">
</div>
<ul class="org-ul">
<li><a id="orgd2307e0"></a>解:<br />
<div class="outline-text-6" id="text-orgd2307e0">
<p>
高度為 8 的 AVL Tree 最大節點數<br />
</p>

<p>
高度 h=8h=8，滿二叉樹節點數為：<br />
N=2^(h+1)−1=29−1=511<br />
</p>

<p>
答案：511<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org614d650" class="outline-4">
<h4 id="org614d650"><span class="section-number-4">2.2.3.</span> 3.(4%)</h4>
<div class="outline-text-4" id="text-2-2-3">
</div>
<div id="outline-container-org199f2eb" class="outline-5">
<h5 id="org199f2eb">(A) Dijkstra&rsquo;s algorithm will fail in what kind of situation? (4%)</h5>
<div class="outline-text-5" id="text-org199f2eb">
</div>
<ul class="org-ul">
<li><a id="org8985f4b"></a>解:Dijkstra 演算法失效情況<br />
<div class="outline-text-6" id="text-org8985f4b">
<p>
Dijkstra 演算法在圖中存在 負邊權重 時失效。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge3455f3" class="outline-5">
<h5 id="orge3455f3">(B) Floyd-Warshall algorithm will fail in what kind of situation? (6%)</h5>
<div class="outline-text-5" id="text-orge3455f3">
</div>
<ul class="org-ul">
<li><a id="orgc029f83"></a>解:Floyd-Warshall 演算法失效情況<br />
<div class="outline-text-6" id="text-orgc029f83">
<p>
Floyd-Warshall 在圖中存在 負權重環 (Negative Weight Cycle) 時無法計算正確結果。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgae6badd" class="outline-5">
<h5 id="orgae6badd">(C) Complete the following pseudo code of Floyd-Warshall algorithm.</h5>
<div class="outline-text-5" id="text-orgae6badd">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>let dist be a |V| x |V| array of minimum distances initialized to &#8734;
<span class="linenr">2: </span><span style="color: #51afef;">for</span> each vertex v
<span class="linenr">3: </span>    dist[v][v] &#8592; <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">4: </span><span style="color: #51afef;">for</span> each edge (u,v)
<span class="linenr">5: </span>    dist[u][v] &#8592; weight(u,v)
<span class="linenr">6: </span>    <span style="color: #51afef;">for</span> k from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">7: </span>        <span style="color: #51afef;">for</span> i from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">8: </span>            <span style="color: #51afef;">for</span> j from <span style="color: #da8548; font-weight: bold;">1</span> to |V|
<span class="linenr">9: </span>                <span style="color: #51afef;">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="org3a74e8f"></a>解: Floyd-Warshall 演算法的偽代碼補全<br />
<div class="outline-text-6" id="text-org3a74e8f">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef;">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:
<span class="linenr">2: </span>    dist[i][j] = dist[i][k] + dist[k][j]
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org1c0c3dc" class="outline-4">
<h4 id="org1c0c3dc"><span class="section-number-4">2.2.4.</span> 4. (10%) Given the frequencies of characters shown in the following table, please encode these characters to binary codes using Huffman coding.</h4>
<div class="outline-text-4" id="text-2-2-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">A</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">C</th>
<th scope="col" class="org-right">D</th>
<th scope="col" class="org-right">E</th>
<th scope="col" class="org-right">F</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">45</td>
<td class="org-right">13</td>
<td class="org-right">12</td>
<td class="org-right">16</td>
<td class="org-right">9</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-orgc6a4162" class="outline-5">
<h5 id="orgc6a4162">解</h5>
<div class="outline-text-5" id="text-orgc6a4162">
</div>
<ul class="org-ul">
<li><a id="org530e325"></a>步驟：<br />
<div class="outline-text-6" id="text-org530e325">
<ol class="org-ol">
<li>合併最低頻率：F(5)+E(9)=14F(5)+E(9)=14<br /></li>
<li>合併結果與 C：C(12)+14=26C(12)+14=26<br /></li>
<li>合併 B 與 D：B(13)+D(16)=29B(13)+D(16)=29<br /></li>
<li>合併 AA 與 2626：A(45)+26=71A(45)+26=71<br /></li>
<li>合併 2929 與 7171：29+71=10029+71=100<br /></li>
</ol>
</div>
</li>
<li><a id="orgea400a7"></a>編碼結果如下：<br />
<div class="outline-text-6" id="text-orgea400a7">
<ul class="org-ul">
<li>A: 0<br /></li>
<li>B: 101<br /></li>
<li>C: 1001<br /></li>
<li>D: 11<br /></li>
<li>E: 10001<br /></li>
<li>F: 10000<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org760661e" class="outline-3">
<h3 id="org760661e"><span class="section-number-3">2.3.</span> 110: 中山資料結構</h3>
<div class="outline-text-3" id="text-2-3">
<p>
科目名稱： 【資管系碩士班乙組】 題號：442002 ※本科目依簡章規定「不可以」使用計算機(問答申論題) 共 2 頁 第 2 頁<br />
</p>
</div>
<div id="outline-container-org03b5bf8" class="outline-4">
<h4 id="org03b5bf8"><span class="section-number-4">2.3.1.</span> 5.(24%)</h4>
<div class="outline-text-4" id="text-2-3-1">
</div>
<div id="outline-container-org0bb34cf" class="outline-5">
<h5 id="org0bb34cf">(A) Write a procedure to reverse an array of integers.</h5>
<div class="outline-text-5" id="text-org0bb34cf">
</div>
<ul class="org-ul">
<li><a id="orgaa0860b"></a>解: 反轉整數陣列<br />
<div class="outline-text-6" id="text-orgaa0860b">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">reverse_array</span>(arr):
<span class="linenr">2: </span>    left, right = <span style="color: #da8548; font-weight: bold;">0</span>, len(arr) - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">while</span> left &lt; right:
<span class="linenr">4: </span>        arr[left], arr[right] = arr[right], arr[left]
<span class="linenr">5: </span>        left += <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">6: </span>        right -= <span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8283b4a" class="outline-5">
<h5 id="org8283b4a">(B) Analyze the time complexity (runtime formula) of your answer in (A)?</h5>
<div class="outline-text-5" id="text-org8283b4a">
<p>
時間複雜度：O(n)<br />
</p>
</div>
</div>
<div id="outline-container-orgdb30f4b" class="outline-5">
<h5 id="orgdb30f4b">(C) Write a procedure to calculate n! for a given integer n and analyze the time complexity of your procedure?</h5>
<div class="outline-text-5" id="text-orgdb30f4b">
</div>
<ul class="org-ul">
<li><a id="org6e4e55f"></a>解: 計算 n!<br />
<div class="outline-text-6" id="text-org6e4e55f">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">factorial</span>(n):
<span class="linenr">2: </span>    <span style="color: #51afef;">if</span> n == <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #51afef;">or</span> n == <span style="color: #da8548; font-weight: bold;">1</span>:
<span class="linenr">3: </span>        <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">4: </span>    <span style="color: #51afef;">return</span> n * factorial(n - <span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div>
<p>
時間複雜度：O(n)<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orge05cf17" class="outline-5">
<h5 id="orge05cf17">(D) How many disk moves are needed in the recursive procedure for solving the n-disk Hanoi tower problem? Prove your answer.</h5>
<div class="outline-text-5" id="text-orge05cf17">
</div>
<ul class="org-ul">
<li><a id="org9174e4c"></a>解: 河內塔問題移動次數<br />
<div class="outline-text-6" id="text-org9174e4c">
<p>
公式為：<br />
\[ T(n)=2^n−1 \]<br />
</p>

<p>
證明：遞迴式 T(n)=2T(n−1)+1T(n)=2T(n−1)+1 解為 \(2^n−1\)。<br />
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5366df3" class="outline-4">
<h4 id="org5366df3"><span class="section-number-4">2.3.2.</span> 6. (26%) For a graph G = (V, E), V = {1, 2, 3, 4, 5, 6, 7}, E = {(1, 2), (2, 3), (3, 4), (1, 5), (2, 5), (1, 6), (1, 7), (5, 4), (6, 7)}, and the cost for above edges are {11, 5, 12, 18, 20, 6, 11, 14, 23}, respectively.</h4>
<div class="outline-text-4" id="text-2-3-2">
</div>
<div id="outline-container-orgae91f88" class="outline-5">
<h5 id="orgae91f88">(A) Use Prim’s algorithm to find the minimum spanning tree of G and give the cost.</h5>
<div class="outline-text-5" id="text-orgae91f88">
</div>
<ul class="org-ul">
<li><a id="org49f1da5"></a>解:Prim 演算法找最小生成樹<br />
<div class="outline-text-6" id="text-org49f1da5">
<ul class="org-ul">
<li>起點：節點 1<br /></li>
<li>選邊順序：(1,2)→(2,3)→(3,4)→(1,5)→(1,6)→(1,7)<br /></li>
<li>總成本：11+5+12+18+6+11=63<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5ff7636" class="outline-5">
<h5 id="org5ff7636">(B) How to detect a cycle in the above algorithm?</h5>
<div class="outline-text-5" id="text-org5ff7636">
</div>
<ul class="org-ul">
<li><a id="org1c0c8d9"></a>解: 如何檢測環<br />
<div class="outline-text-6" id="text-org1c0c8d9">
<ul class="org-ul">
<li>在加入邊時，使用 並查集 (Union-Find) 判斷兩端點是否已連通。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org7320d40" class="outline-5">
<h5 id="org7320d40">(C) Starting from node 1, use Depth First Search (DFS) and Breadth First Search (BFS) to determine the minimum spanning tree of graph G.</h5>
<div class="outline-text-5" id="text-org7320d40">
</div>
<ul class="org-ul">
<li><a id="orgcf29cfc"></a>解: DFS 與 BFS 的最小生成樹<br />
<div class="outline-text-6" id="text-orgcf29cfc">
<ul class="org-ul">
<li>DFS 和 BFS 找出的生成樹不一定是最小生成樹，因為這兩者不考慮邊的權重。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org981a4cc" class="outline-5">
<h5 id="org981a4cc">(D) Can DFS or BFS guarantee to find the optimal solution? Why?</h5>
<div class="outline-text-5" id="text-org981a4cc">
</div>
<ul class="org-ul">
<li><a id="org28e165f"></a>解<br />
<div class="outline-text-6" id="text-org28e165f">
<ul class="org-ul">
<li>不能，因為最優解取決於邊權重，而 DFS 和 BFS 並未考慮此條件。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3816252" class="outline-5">
<h5 id="org3816252">(E) Write a procedure to find (list) all connected components of a graph.</h5>
<div class="outline-text-5" id="text-org3816252">
</div>
<ul class="org-ul">
<li><a id="org1911fdd"></a>解:<br />
<div class="outline-text-6" id="text-org1911fdd">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">def</span> <span style="color: #c678dd;">connected_components</span>(graph):
<span class="linenr"> 2: </span>    visited = set()
<span class="linenr"> 3: </span>    components = []
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    def dfs(node, component):
<span class="linenr"> 6: </span>        visited.add(node)
<span class="linenr"> 7: </span>        component.append(node)
<span class="linenr"> 8: </span>        <span style="color: #51afef;">for</span> neighbor in graph[node]:
<span class="linenr"> 9: </span>            <span style="color: #51afef;">if</span> neighbor <span style="color: #51afef;">not</span> in visited:
<span class="linenr">10: </span>                dfs(neighbor, component)
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #51afef;">for</span> node in graph:
<span class="linenr">13: </span>        <span style="color: #51afef;">if</span> node <span style="color: #51afef;">not</span> in visited:
<span class="linenr">14: </span>            component = []
<span class="linenr">15: </span>            dfs(node, component)
<span class="linenr">16: </span>            components.append(component)
<span class="linenr">17: </span>
<span class="linenr">18: </span>    <span style="color: #51afef;">return</span> components
<span class="linenr">19: </span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2deba45" class="outline-3">
<h3 id="org2deba45"><span class="section-number-3">2.4.</span> 110: 中山計概</h3>
<div class="outline-text-3" id="text-2-4">
<ol class="org-ol">
<li>In Python 3, which of the following is used to define a block of code (e.g. body of loop)? A. Curly braces B. Indentation C. Semicolon D. Parenthesis<br />
<ul class="org-ul">
<li>解答：B. Indentation<br /></li>
<li>Python 使用 縮排 (Indentation) 來定義代碼塊，例如 for 或 if 的內容，這與其他語言的花括號 ({}) 不同。<br /></li>
</ul></li>
<li>Which of the following is NOT considered the reason for the recent AI boom? A. The global investment of AI B. The accessibility of cheap computation C. The exponential growth of data D. The advances of learning algorithms<br />
<ul class="org-ul">
<li>解答：A. The global investment of AI<br /></li>
<li>雖然 AI 的投資確實在增加，但這並非 AI 爆炸的直接技術性原因，而是技術的普及結果。其他選項 (計算能力、數據增長、演算法進步) 才是 AI 發展的核心推動力。<br /></li>
</ul></li>
<li>Which of the following about split-apply-combine strategy of data analytics is FALSE? A. It can be implemented by SQL B. It should not be used to replace loops C. It can help parallelize computations D. It is widely used in daily data management tasks<br />
<ul class="org-ul">
<li>解答：B. It should not be used to replace loops<br /></li>
<li>解釋：Split-apply-combine 策略常用於數據分析中，用來分割數據，應用函數，並將結果結合。它通常可以替代迴圈，提高計算效率，特別是在使用 pandas 或 SQL 等工具時。<br /></li>
</ul></li>
<li>Which of the following about Deep Neural Network is FALSE? A. The trained models are usually called black-box models B. Compared to traditional machine learning algorithms, it has more hyperparameters to tune C. It takes more time to do manual feature engineering D. It usually requires comparatively more computing resources to train a model<br />
<ul class="org-ul">
<li>解答：C. It takes more time to do manual feature engineering<br /></li>
<li>解釋： 深度神經網路的特點是可以自動提取特徵，因此通常 不需要 花大量時間進行手動特徵工程。<br /></li>
</ul></li>
<li>Which of the following is NOT a common feature of object-oriented programming languages? A. Parallelism B. Polymorphism C. Encapsulation D. Inheritance<br />
<ul class="org-ul">
<li>解答：A. Parallelism<br /></li>
<li>解釋： 物件導向程式語言 (OOP) 的核心特性是 多型 (Polymorphism)、封裝 (Encapsulation) 和 繼承 (Inheritance)。平行運算並非 OOP 的內建特性。<br /></li>
</ul></li>
<li>Which of the following is NOT a common feature of functional programming languages? A. Lazy Evaluation B. Higher-order functions C. Recursion D. Inheritance<br />
<ul class="org-ul">
<li>解答：D. Inheritance<br /></li>
<li>解釋：繼承是物件導向的特性，而 惰性求值 (Lazy Evaluation)、高階函數 (Higher-order functions) 和 遞迴 (Recursion) 是函數式程式設計的核心特性。<br /></li>
</ul></li>
<li>Which of the following about cloud, fog, and edge computing is FALSE? A. Cloud computing is often used to process urgent requests in the local network B. To improve response times, fog computing can be used to process computation-intensive requests C. They help promote decentralized storages and computations D. Amazon Web Services can be considered cloud computing platforms<br />
<ul class="org-ul">
<li>解答：A. Cloud computing is often used to process urgent requests in the local network<br /></li>
<li>解釋：雲端運算通常處理集中式的非即時性計算需求，而本地網絡中的即時請求更適合邊緣運算或霧運算處理。<br /></li>
</ul></li>
<li>Which of the following about data structures is TRUE? A. Arrays are dynamic data structures able to increase their sizes at runtime B. The length of a linked list is usually fixed C. Data elements in a linked list must be stored in adjacent memory space D. Linked lists can be used to implement stacks<br />
<ul class="org-ul">
<li>解答：D. Linked lists can be used to implement stacks<br /></li>
<li>解釋：連結串列 (Linked List) 可以用來實現堆疊 (Stack)，而其他選項皆為錯誤：<br />
<ul class="org-ul">
<li>陣列大小是靜態的，不能在執行期增長 (A 錯)。<br /></li>
<li>連結串列長度不固定 (B 錯)。<br /></li>
<li>連結串列節點不需要儲存在連續的記憶體空間 (C 錯)。<br /></li>
</ul></li>
</ul></li>
<li>Suppose we have a table in the third normal form (3NF) in a relational database. Which of the following statement is FALSE? A. The table is also in the 2NF B. The table may have multiple candidate keys C. Every non-prime attribute is non-transitively dependent on every key of the table D. For each of the functional dependency A-&gt;B that exists, A is the super key of the table<br />
<ul class="org-ul">
<li>解答：D. For each of the functional dependency A-&gt;B that exists, A is the super key of the table<br /></li>
<li>解釋：在 3NF 中，函數依賴的屬性 AA 不一定是超鍵，只要 BB 是主鍵或候選鍵的非傳遞依賴即可。<br /></li>
</ul></li>
<li><p>
Consider the following tables, A and B, in a relational database:<br />
A:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
</tr>
</tbody>
</table>
<p>
B:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table>
<p>
Which of the following SQL statement can be used to concatenate A and B?<br />
</p>
<ul class="org-ul">
<li>A. SELECT * FROM A UNION ALL SELECT * FROM B<br /></li>
<li>B. SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id<br /></li>
<li>C. SELECT * FROM A INNER JOIN B ON A.id = B.id<br /></li>
<li>D. SELECT * FROM A LEFT JOIN B ON A.id = B.id<br /></li>
<li>解: 題目要求的是將兩張表 A 和 B 串接，這裡的 串接 指的是結合兩張表的所有數據，而非進行條件配對。仔細分析每個選項後，可以看出符合要求的正確語句。<br /></li>
<li>選項分析:<br />
<ol class="org-ol">
<li>SELECT * FROM A UNION ALL SELECT * FROM B<br />
<ul class="org-ul">
<li>說明：UNION ALL 是直接將兩張表的數據合併，不會過濾重複的記錄。在這裡，A 和 B 的結合將包含兩張表的所有數據，不需要關聯條件。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table></li>
<li>結論： 符合 串接 (concatenate) 的要求。<br /></li>
</ul></li>
<li>SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明：FULL OUTER JOIN 將返回兩張表中所有記錄，並將 匹配的 id 行合併。對於沒有匹配的記錄，將使用 NULL 填充缺失的列。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">NULL</td>
<td class="org-left">Z</td>
</tr>
</tbody>
</table></li>
<li>結論： 這是進行關聯操作，不符合單純串接兩張表的需求。<br /></li>
</ul></li>
<li>SELECT * FROM A INNER JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明：INNER JOIN 只返回 A 和 B 中 id 匹配的記錄。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>
</tbody>
</table></li>
<li>結論： 僅返回兩表中匹配的部分，不符合串接需求。<br /></li>
</ul></li>
<li>SELECT * FROM A LEFT JOIN B ON A.id = B.id<br />
<ul class="org-ul">
<li>說明： LEFT JOIN 返回 A 中的所有記錄，並將匹配 B 的行合併；對於 B 中沒有匹配的部分，填充 NULL。<br /></li>
<li><p>
結果：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">id</th>
<th scope="col" class="org-left">val_A</th>
<th scope="col" class="org-left">val_B</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">Y</td>
</tr>
</tbody>
</table></li>
<li>結論： 這是進行關聯操作，不符合單純串接兩張表的需求。<br /></li>
</ul></li>
<li>正確解答 答案：A. SELECT * FROM A UNION ALL SELECT * FROM B<br /></li>
<li>補充說明<br />
<ul class="org-ul">
<li>UNION 和 UNION ALL 的區別：<br />
<ul class="org-ul">
<li>UNION 會移除重複的記錄。<br /></li>
<li>UNION ALL 不會移除重複記錄，速度更快，適合需要保留重複值的場合。<br /></li>
</ul></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT considered a kind of NoSQL databases? A. Graph database B. Document database C. Object-relational database D. Key-value database<br /></li>
<li>Which of the following is the postfix expression of math representation A * B / C + D - E? A. A B * C / D + E -<br />
<ol class="org-ol">
<li>A B * C / D + - E<br /></li>
<li>* A B / C + D - E<br /></li>
<li>- / + * A B C D E<br /></li>
</ol></li>
<li><p>
Which of the following is the post-order traversal of the below binary search tree?<br />
</p>
<pre class="example" id="orge9f42ee">
            45
           /  \
          /    \
         27    55
        /        \
      18          58
        \          \
         19         60
</pre>
<ol class="org-ol">
<li>18 19 27 45 55 58 60<br /></li>
<li>45 27 18 19 55 58 60<br /></li>
<li>19 18 27 55 58 60 45<br /></li>
<li>19 18 27 60 58 55 45<br /></li>
</ol>
<p>
解： 後序遍歷步驟<br />
</p>
<ol class="org-ol">
<li><p>
遍歷左子樹<br />
節點 27 的左子樹為：<br />
</p>
<pre class="example" id="org777f37b">

            27
           /
          18
           \
            19

</pre>
<p>
後序遍歷順序：<br />
</p>
<ul class="org-ul">
<li>遍歷左子樹 18（沒有左子樹，直接看右子樹）。<br /></li>
<li>遍歷右子樹的 19。<br /></li>
<li>訪問根節點 27。<br /></li>
</ul>
<p>
結果：18 → 19 → 27<br />
</p></li>
<li><p>
遍歷右子樹<br />
節點 55 的右子樹為：<br />
</p>
<pre class="example" id="orga3dc7a1">
            55
              \
               58
                 \
                  60
</pre>
<p>
後序遍歷順序：<br />
</p>
<ul class="org-ul">
<li>遍歷左子樹（55 無左子樹，直接看右子樹）。<br /></li>
<li>遍歷右子樹的 58，接著是其右子樹的 60。<br /></li>
<li>訪問根節點 55。<br /></li>
</ul>
<p>
結果：60 → 58 → 55<br />
</p></li>
<li>訪問根節點<br />
最後訪問根節點 45。<br />
後序遍歷結果<br />
將步驟 1、2、3 的結果結合：<br />
18 → 19 → 27 → 60 → 58 → 55 → 45<br /></li>
</ol>
<p>
解答：D. 19 18 27 60 58 55 45<br />
</p></li>
</ol>
</div>
</div>
<div id="outline-container-org87de91a" class="outline-3">
<h3 id="org87de91a"><span class="section-number-3">2.5.</span> 110: 中山計概</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-org1f15d8b" class="outline-4">
<h4 id="org1f15d8b"><span class="section-number-4">2.5.1.</span> 單選題，每題 2.5 分</h4>
<div class="outline-text-4" id="text-2-5-1">
<ol class="org-ol">
<li>Which of the following statements about memory is FALSE? A. Static RAM is an example of volatile memory B. Flash memory is a type of nonvolatile memory that can be erased electronically and rewritten C. Dynamic RAM is faster than static RAM D. Read-only memory (ROM) is a type of nonvolatile memory<br />
<ul class="org-ul">
<li>解答：C. Dynamic RAM is faster than static RAM<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>Static RAM (SRAM) 是揮發性記憶體，比動態 RAM (DRAM) 更快，但成本也更高。<br /></li>
<li>Dynamic RAM (DRAM) 雖然更慢，但每單位存儲空間成本更低，常用於主記憶體。<br /></li>
<li>其他選項正確，因為 Flash 是非揮發性、ROM 是非揮發性記憶體。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following best describes the principle of least privilege? A. Data access restrictions are lifted to ensure data integrity B. Data is encrypted and passwords are used C. Users should not share access details with others D. Users’ access privileges are limited to the lowest level necessary to perform required tasks<br />
<ul class="org-ul">
<li>解答：D. Users’ access privileges are limited to the lowest level necessary to perform required tasks<br /></li>
<li>詳解：<br />
最小權限原則 (Principle of Least Privilege) 是一種安全策略，確保用戶只能存取完成工作所需的最小權限，減少安全風險。<br /></li>
</ul></li>
<li>Which of the following about the binary search algorithm is TRUE? A. It is not possible for a binary search to find the value 2 in the array of B. The maximum number of comparisons required to perform a binary search of a 1000 element array is 9 C. The best-case time complexity of a binary search is O(log N), with N the number of elements in an array D. An iterative implementation of the binary search has a space complexity of O(N), with N the number of elements in an array<br />
解答：B. The maximum number of comparisons required to perform a binary search of a 1000 element array is 9<br />
<ul class="org-ul">
<li>詳解：<br />
<ul class="org-ul">
<li>二分搜尋的時間複雜度為 O(log⁡N)O(logN)。對於 1000 個元素的陣列，最多需要比較 ⌈log⁡21000⌉=10⌈log2​1000⌉=10 次，因此選項 B 是正確的。<br /></li>
<li>最佳情況下（找到目標元素），時間複雜度為 O(1)O(1)，所以選項 C 錯誤。<br /></li>
<li>二分搜尋的迭代實現的空間複雜度是 O(1)O(1)，非 O(N)O(N)。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following about web application development is FALSE? A. CSS allows web designers to change the layout and appearance of the webpage B. HTML stands for hypertext markup language and used hashtags to specify the content of webpages C. JavaScript can be used to display a prompt box that prompts the user to input some text D. JavaScript adds interactivity to webpages<br />
<ul class="org-ul">
<li>解答：B. HTML stands for hypertext markup language and used hashtags to specify the content of webpages<br /></li>
<li>詳解：<br />
HTML 是超文字標記語言，使用標籤 (tags)，而非井號 (hashtags)，來描述網頁內容。<br /></li>
</ul></li>
<li>Which of the following provides remote users with a secure connection to the organization network? A. VPN B. https C. Ethernet D. FTP<br />
<ul class="org-ul">
<li>解答：A. VPN<br /></li>
<li>詳解：<br />
VPN (Virtual Private Network) 提供安全的遠端連線，通常用於保護敏感數據在公共網路上的傳輸。<br /></li>
</ul></li>
<li>Which of the following about deep learning frameworks is FALSE? A. PyTorch uses dynamic computation graphs B. Tensorflow is an open-source deep learning framework developed by Google C. Keras is officially integrated with PyTorch in the latest release of PyTorch D. TensorFlow 2.x supports dynamic computation graphs<br />
<ul class="org-ul">
<li>解答：C. Keras is officially integrated with PyTorch in the latest release of PyTorch<br /></li>
<li>詳解：<br />
Keras 是 TensorFlow 的高階 API，並非與 PyTorch 整合的框架。<br /></li>
</ul></li>
<li>Which of the following about IP addresses and domain names is FALSE? A. A DNS server translates an IP address to its corresponding domain name B. An IPv6 address is 128 bits in length and written as a string of hexadecimal digits C. An IPv4 address is 32 bits and often written in dotted decimal notation D. A domain name is a text-based name of a computer or server that is easier for humans to memorize<br />
<ul class="org-ul">
<li>解答：A. A DNS server translates an IP address to its corresponding domain name<br /></li>
<li>詳解：<br />
DNS (Domain Name System) 的作用是將域名轉換為對應的 IP 位址，而不是將 IP 位址轉換為域名。<br /></li>
</ul></li>
<li>The Hamming distance between two binary strings is defined as the number of bit positions in which two bits are different. Which of the following can be used to find the differences between two binary strings in computing Hamming distance? A. OR B. XOR C. AND D. NOT<br />
<ul class="org-ul">
<li>解答：B. XOR<br /></li>
<li>詳解：<br />
XOR (異或運算) 可以標識兩個二進位串不同的位置，然後統計結果中 1 的數量即可得到漢明距離。<br /></li>
</ul></li>
<li>Which of the following is NOT an advantage of solid-state drives (SSDs) over traditional hard disks? A. Faster transfer rates B. Less power consumption C. Lighter weight D. Lower cost per gigabyte<br />
<ul class="org-ul">
<li>解答：D. Lower cost per gigabyte<br /></li>
<li>詳解：<br />
SSD 的成本較高，特別是在每 GB 的價格上，通常比傳統硬碟 (HDD) 貴。<br /></li>
</ul></li>
<li>Amazon EC2 is an example of <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. A. IaaS B. PaaS C. SaaS D. DaaS<br />
<ul class="org-ul">
<li>解答：A. IaaS (Infrastructure as a Service)<br /></li>
<li>詳解：<br />
Amazon EC2 提供虛擬伺服器實例，讓用戶能建立和管理基礎設施，屬於 IaaS 類型服務。<br /></li>
</ul></li>
<li>Consider an operating system that uses paging for virtual memory management. Assume that there are 4 page frames which are initially empty. Given the page reference string 1, 2, 3, 4, 5, 1, 3, 1, 1, 6, 3, 2, 5, how many page faults occur if the optimal page replacement is used? A. 5 B. 6 C. 8 D. 9<br />
<ul class="org-ul">
<li>解答：C. 8<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>頁面參考字串：1, 2, 3, 4, 5, 1, 3, 1, 1, 6, 3, 2, 5<br /></li>
<li>初始頁框數：4<br /></li>
<li>遵循最佳頁替換策略，每次替換時選擇將來最晚被使用的頁。<br /></li>
<li>具體計算可得到 8 次頁錯誤。<br /></li>
</ul></li>
</ul></li>
<li>Consider the addition of two 8-bit 2’s complement integers. Which of the following is the binary representation of 6 + (-8)? A. 00000010 B. 11111110 C. 11110001 D. 11111110<br />
<ul class="org-ul">
<li>解答：B. 11111110<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>6=000001106=00000110，−8=11111000−8=11111000（以 2 的補碼表示）。<br /></li>
<li>計算 6+(−8)6+(−8)：00000110+11111000=1111111000000110+11111000=11111110。<br /></li>
</ul></li>
</ul></li>
<li>Given two vertices, s and t, in a graph, which of the two traversals, breadth-first search (BFS) and depth-first search (DFS), can be used to determine if there is a path from s to t? A. Only BFS B. Only DFS C. Both BFS and DFS D. Neither BFS nor DFS<br />
<ul class="org-ul">
<li>解答：C. Both BFS and DFS<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>BFS 和 DFS 都可用於判斷是否存在從 ss 到 tt 的路徑。<br /></li>
<li>BFS 適合尋找最短路徑，DFS 適合完整探索。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following about Wi-Fi networks is FALSE? A. Most Wi-Fi is based on the 802.15 standards developed by IEEE B. Wi-Fi accesses the network in conjunction with the TCP/IP standard C. Most devices support multiple Wi-Fi standards D. Wi-Fi is often used to provide hot spots<br />
<ul class="org-ul">
<li>解答：A. Most Wi-Fi is based on the 802.15 standards developed by IEEE<br /></li>
<li>詳解：<br />
Wi-Fi 是基於 IEEE 802.11 標準，而 802.15 是藍牙標準。<br /></li>
</ul></li>
<li>Which of the following about network architectures is TRUE? A. Only one computer can act as a server on the client/server network B. Each device on a peer-to-peer network can share its resources with other devices C. One client computer crashing can affect the other computers on a client/server network D. A computer can act as either a client or a server, but not both, on a peer-to-peer network<br />
<ul class="org-ul">
<li>解答：B. Each device on a peer-to-peer network can share its resources with other devices<br /></li>
<li>詳解：<br />
P2P 網路允許每個設備共享資源，而其他選項的描述均不正確。<br /></li>
</ul></li>
<li>In 2020, Amazon Web Services was hit by an attack that floods the target with massive amounts of data to disrupt normal traffic. What is this attack called? A. Phishing B. Ransomware C. Malware attack D. DDoS<br />
<ul class="org-ul">
<li>解答：D. DDoS<br /></li>
<li>詳解：<br />
DDoS (Distributed Denial-of-Service) 是一種透過大規模數據請求癱瘓伺服器的攻擊方式。<br /></li>
</ul></li>
<li>Which of the following about drones is TRUE? A. The flight of drones cannot operate by an onboard computer or an autopilot B. A drone is an aircraft that operates by a human on board C. A drone is also known as an unmanned aerial vehicle (UAV) D. Drones are for hobbyists and cannot be used to monitor crop growth<br />
<ul class="org-ul">
<li>解答：C. A drone is also known as an unmanned aerial vehicle (UAV)<br /></li>
<li>詳解：<br />
無人機 (Drone) 是無人駕駛航空器 (UAV)，可由自動駕駛或人遠程操作。<br /></li>
</ul></li>
<li>Which of the following is a small, high-speed storage location within a processor that temporarily hold data and instructions? A. ALU B. CU C. register D. RAM<br />
<ul class="org-ul">
<li>解答：C. register<br /></li>
<li>詳解：<br />
寄存器 (register) 是處理器內部的高速存儲位置，用於臨時保存數據和指令。<br /></li>
</ul></li>
<li>Wearable devices, such as smartwatches, can monitor blood pressure and heart rates and send alerts in case of emergency, which is an example of <span class="underline"><span class="underline"><span class="underline">__</span></span></span>. A. big data B. wireless communication C. cloud computing D. internet of things<br />
<ul class="org-ul">
<li>解答：D. internet of things<br /></li>
<li>詳解：<br />
穿戴裝置屬於物聯網 (IoT) 應用的一部分，將感測數據連接至網路進行處理。<br /></li>
</ul></li>
<li>Which of the following about RAID is TRUE? A. RAID 0 writes data to two drives at the same time to duplicate the data B. RAID 1 provides data reliability via redundancy C. Mirroring splits data and instructions across multiple drives in the array D. RAID stands for reliable array of inexpensive disks<br />
<ul class="org-ul">
<li>解答：B. RAID 1 provides data reliability via redundancy<br /></li>
<li>詳解：<br />
<ul class="org-ul">
<li>RAID 1 透過鏡像技術提供冗餘數據保護。<br /></li>
<li>RAID 0 並未提供數據保護。<br /></li>
</ul></li>
</ul></li>
<li>Which of the following is a last-in fast-out data structure? A. array B. stack C. queue D. tree<br />
<ul class="org-ul">
<li>解答：B. stack<br /></li>
<li>詳解：<br />
堆疊 (stack) 遵循後進先出 (LIFO) 原則，其他選項均不符。<br /></li>
</ul></li>
<li>In C/C++ programming, it requires at least <span class="underline"><span class="underline"><span class="underline">__</span></span></span> byte(s) when an integer number 32768 is stored as characters in computer memory. A. 2 B. 4 C. 5 D. 8<br />
<ul class="org-ul">
<li>解答：C. 5<br /></li>
<li>詳解：<br />
32768 作為字元需轉為 ASCII 表示，包括 3, 2, 7, 6, 8 共 5 個字元。<br /></li>
</ul></li>
<li>Which of the following is NOT a common data format/structure to save and describe network data? A. adjacency matrix B. hash table C. adjacency list D. edge list<br />
<ul class="org-ul">
<li>解答：B. hash table<br /></li>
<li>詳解：<br />
雖然哈希表常用於查詢，但不是保存網路數據的標準結構。<br /></li>
</ul></li>
<li>Consider the below C/C++ statement: int i = 1; const int *iPtr = &amp;i; Which of the following is FALSE? A. iPtr is a variable that stores a memory address B. Statement *iPtr = 10 is invalid C. iPtr is a pointer variable that points to an object of type int D. The data value of the object that iPtr points to can be modified<br />
<ul class="org-ul">
<li>解答：D. The data value of the object that iPtr points to can be modified<br /></li>
<li>詳解：<br />
const int *iPtr 指向的值不可修改。<br /></li>
</ul></li>
<li><p>
Consider the below C/C++ program:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">    #include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr">2: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span> (){
<span class="linenr">3: </span>      <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">aStr</span>[] = <span style="color: #98be65;">"A string"</span>;
<span class="linenr">4: </span>      <span style="color: #ECBE7B;">void</span> <span style="color: #dcaeea;">pPtr</span> = &amp;aStr;
<span class="linenr">5: </span>      printf(<span style="color: #98be65;">"%s\n"</span>, ((<span style="color: #ECBE7B;">char</span>) aPtr));
<span class="linenr">6: </span>    }
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following statement is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show &ldquo;A string&rdquo; D. It will show &ldquo;A&rdquo;<br />
</p>
<ul class="org-ul">
<li>解答：A. It will show compilation errors<br /></li>
<li>詳解：<br />
void pPtr = &amp;aStr; 是錯誤的，void 不能直接用於指針。<br /></li>
</ul></li>
<li><p>
Consider the below C/C++ program:<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">    #include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span>    <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span>{ <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>; <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>; };
<span class="linenr"> 3: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">passXY</span>(<span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span> *<span style="color: #dcaeea;">xy</span>){
<span class="linenr"> 4: </span>      xy -&gt; x = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 5: </span>      xy -&gt; y = <span style="color: #da8548; font-weight: bold;">2</span>;
<span class="linenr"> 6: </span>    }
<span class="linenr"> 7: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>(<span style="color: #ECBE7B;">void</span>){
<span class="linenr"> 8: </span>      <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">strucXY</span> <span style="color: #dcaeea;">s</span>;
<span class="linenr"> 9: </span>      s.x = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">10: </span>      s.y = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">11: </span>      passXY(&amp;s);
<span class="linenr">12: </span>      printf(<span style="color: #98be65;">"x = %d, y = %d\n"</span>, s.x, s.y);
<span class="linenr">13: </span>    }
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following statement is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show &ldquo;x = 0, y = 0&rdquo; D. It will show &ldquo;x = 1, y = 2&rdquo;<br />
</p>
<ul class="org-ul">
<li>解答：D. It will show &ldquo;x = 1, y = 2&rdquo;<br /></li>
<li>詳解：<br />
指針 &amp;s 被傳遞，函數 passXY 成功修改了結構的成員值。<br /></li>
</ul></li>
<li>Which of the following about recursion is TRUE? A. We should always replace iterations with recursions if possible B. Recursion usually uses less memory than iteration as the code is more concise and clearer C. Recursion usually has higher algorithm performance D. Any problems that can be solved by recursions can also be solved by iterations<br />
<ul class="org-ul">
<li>解答：D. Any problems that can be solved by recursions can also be solved by iterations<br /></li>
<li>詳解：<br />
任何遞迴問題都可以轉換為迭代解法，雖然代碼可能更冗長。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc130218" class="outline-3">
<h3 id="orgc130218"><span class="section-number-3">2.6.</span> 111: 中山計概</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-orgf280adc" class="outline-4">
<h4 id="orgf280adc"><span class="section-number-4">2.6.1.</span> 第一题：</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
Which data structure is often used when implementing the depth first search algorithm? A. Heap B. Queue C. Stack D. Tree E. None of the above<br />
</p>
</div>
<div id="outline-container-orgefcaf04" class="outline-5">
<h5 id="orgefcaf04">答案：C. Stack</h5>
<div class="outline-text-5" id="text-orgefcaf04">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>深度優先搜尋（DFS）演算法的實作通常依賴 堆疊（Stack） 來追蹤遞迴過程中的節點。<br /></li>
<li>遞迴（Recursive）版本的 DFS 直接利用函式呼叫堆疊。<br /></li>
<li>非遞迴版本的 DFS 使用明確的 堆疊 來存放即將探索的節點。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Heap → 堆積（Heap）通常用於優先隊列（如 Dijkstra）。<br /></li>
<li>Queue → 廣度優先搜尋（BFS）使用佇列（Queue），而不是 DFS。<br /></li>
<li>Stack → 正確答案，DFS 依賴堆疊。<br /></li>
<li>Tree → 樹是一種資料結構，而非 DFS 主要依賴的結構。<br /></li>
<li>None of the above → 錯誤，DFS 依賴 Stack。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7129994" class="outline-4">
<h4 id="org7129994"><span class="section-number-4">2.6.2.</span> 第二題：</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
Which of the following best describes a NAND gate? A. An AND followed by a NOT B. A NOT followed by an AND C. An OR followed by a NOT D. A NOT followed by an OR E. An OR followed by a NOT<br />
</p>
</div>
<div id="outline-container-orgbea32f6" class="outline-5">
<h5 id="orgbea32f6">答案：A. An AND followed by a NOT</h5>
<div class="outline-text-5" id="text-orgbea32f6">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>NAND（Not AND）閘 是 AND 閘 接上 NOT 閘，輸出是 AND 結果的反向：<br /></li>
<li>NAND(A,B)=¬(A∧B)<br /></li>
<li>NAND(A,B)=¬(A∧B)<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>An AND followed by a NOT → 正確，NAND 是 AND 的反向。<br /></li>
<li>A NOT followed by an AND → 錯誤，這表示先對輸入 NOT，再做 AND，不符合 NAND。<br /></li>
<li>An OR followed by a NOT → 這是 NOR 閘的定義，不是 NAND。<br /></li>
<li>A NOT followed by an OR → 這是 NOR 的另一種錯誤描述。<br /></li>
<li>An OR followed by a NOT → 再次描述 NOR，不是 NAND。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org68a17e6" class="outline-4">
<h4 id="org68a17e6"><span class="section-number-4">2.6.3.</span> 第三題：</h4>
<div class="outline-text-4" id="text-2-6-3">
<p>
What is the 8-bit 2&rsquo;s complement representation of the decimal number -5? A. 00000101 B. 11111010 C. 11111011 D. 10000101 E. None of the above<br />
</p>
</div>
<div id="outline-container-org13d3807" class="outline-5">
<h5 id="org13d3807">答案：C. 11111011</h5>
<div class="outline-text-5" id="text-org13d3807">
<p>
解析：<br />
</p>
<ol class="org-ol">
<li>先求 +5 的二進位（8-bit）：00000101<br /></li>
<li>取反（1&rsquo;s 補數）：11111010<br /></li>
<li>加 1（2&rsquo;s 補數）：    11111011<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>00000101 → 這是 +5，不是 -5。<br /></li>
<li>11111010 → 這是 -5 的 1&rsquo;s 補數，不是 2&rsquo;s 補數。<br /></li>
<li>11111011 → 正確，這是 -5 的 2&rsquo;s 補數。<br /></li>
<li>10000101 → 這是錯誤的表示法。<br /></li>
<li>None of the above → 錯，C 是正確答案。<br /></li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org09e831d" class="outline-4">
<h4 id="org09e831d"><span class="section-number-4">2.6.4.</span> 第四題：</h4>
<div class="outline-text-4" id="text-2-6-4">
<p>
Which of the following best describes paging? A. The process a computer goes through when dividing data into disk sectors. B. The technique of swapping items between memory and storage. C. When a computer or mobile device executes instructions. D. The conversion of data into readable, usable information. E. None of the above<br />
</p>
</div>
<div id="outline-container-org6590e52" class="outline-5">
<h5 id="org6590e52">答案：B. The technique of swapping items between memory and storage</h5>
<div class="outline-text-5" id="text-org6590e52">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>分頁（Paging） 是記憶體管理技術，用來 在 RAM 和磁碟之間交換頁面，以模擬更大的可用記憶體。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>The process a computer goes through when dividing data into disk sectors. → 這是磁碟管理，而非 Paging。<br /></li>
<li>The technique of swapping items between memory and storage. → 正確，Paging 將資料在 RAM 和磁碟間交換。<br /></li>
<li>When a computer or mobile device executes instructions. → 這是 CPU 執行程序，不是 Paging。<br /></li>
<li>The conversion of data into readable, usable information. → 這是資料處理，不是 Paging。<br /></li>
<li>None of the above. → 錯，B 是正確答案。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfb1b356" class="outline-4">
<h4 id="orgfb1b356"><span class="section-number-4">2.6.5.</span> 第五題：</h4>
<div class="outline-text-4" id="text-2-6-5">
<p>
Which of the following statements about storage devices/media is FALSE? A. A group of two or more integrated hard drives is called a RAID. B. Solid-state drives have less power consumption than traditional hard disks. C. Defragmentation is not required for solid-state drives. D. USB flash drives normally run faster than solid-state drives. E. None of the above<br />
</p>
</div>
<div id="outline-container-orgf305eb6" class="outline-5">
<h5 id="orgf305eb6">答案：D. USB flash drives normally run faster than solid-state drives.</h5>
<div class="outline-text-5" id="text-orgf305eb6">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>SSD（固態硬碟） 的速度 遠超過 USB 隨身碟，特別是 PCIe NVMe SSD，速度比 USB 3.0 隨身碟快數十倍。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>RAID 是多顆硬碟組合的存儲陣列。 ✅ 正確<br /></li>
<li>SSD 比傳統 HDD 耗電低。 ✅ 正確<br /></li>
<li>SSD 不需要磁碟重組（defragmentation）。 ✅ 正確<br /></li>
<li>USB 隨身碟比 SSD 快。 ❌ 錯誤，SSD 明顯更快。<br /></li>
<li>None of the above. ❌ 因為 D 錯誤。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org67772a3" class="outline-4">
<h4 id="org67772a3"><span class="section-number-4">2.6.6.</span> 第六題：</h4>
<div class="outline-text-4" id="text-2-6-6">
<p>
Consider the below C program.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr"> 2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">getSteps</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>);
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr"> 5: </span>  <span style="color: #51afef;">if</span> (<span style="color: #da8548; font-weight: bold;">1</span>==n) <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr"> 6: </span>  <span style="color: #51afef;">if</span> (<span style="color: #da8548; font-weight: bold;">0</span>== n % <span style="color: #da8548; font-weight: bold;">2</span>)
<span class="linenr"> 7: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span> + getSteps(n/<span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr"> 8: </span>  <span style="color: #51afef;">else</span>
<span class="linenr"> 9: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span> + getSteps(<span style="color: #da8548; font-weight: bold;">3</span>*n+<span style="color: #da8548; font-weight: bold;">1</span>);
<span class="linenr">10: </span>}
</pre>
</div>
<ul class="org-ul">
<li>We would like to compile and run the program. Which of the following is TRUE?<br /></li>
</ul>
<ol class="org-ol">
<li>It will show compilation errors<br /></li>
<li>It will show run-time errors<br /></li>
<li>It will show 6<br /></li>
<li>It will show 7<br /></li>
<li>It will show 8<br /></li>
</ol>
</div>
<div id="outline-container-org2dcce1e" class="outline-5">
<h5 id="org2dcce1e">答案：A. It will show compilation errors</h5>
<div class="outline-text-5" id="text-org2dcce1e">
<p>
解析：if (1==n) return 0; 中，變數 n 未定義，導致 編譯錯誤。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3c4133e" class="outline-4">
<h4 id="org3c4133e"><span class="section-number-4">2.6.7.</span> 第七題：</h4>
<div class="outline-text-4" id="text-2-6-7">
<p>
Consider the relation Product(pNo, pName, unitPrice, category). Which attribute(s) is the best choice to be used as a search key to build a B+ tree for efficiently evaluating the following SQL statement?<br />
</p>
<pre class="example" id="orgfbc2082">
SELECT pName
FROM Product
WHERE unitPrice &lt;= 1000 AND unitPrice &gt;=300
</pre>
<ol class="org-ol">
<li>pNo<br /></li>
<li>pName<br /></li>
<li>unitPrice<br /></li>
<li>category<br /></li>
<li>pNo, category<br /></li>
</ol>
</div>
<div id="outline-container-orge34b68e" class="outline-5">
<h5 id="orge34b68e">答案：C. unitPrice</h5>
<div class="outline-text-5" id="text-orge34b68e">
<p>
解析：WHERE unitPrice BETWEEN 300 AND 1000 會對 unitPrice 做範圍查詢，適合建立 B+ 樹索引。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgce76abc" class="outline-4">
<h4 id="orgce76abc"><span class="section-number-4">2.6.8.</span> 第八題：</h4>
<div class="outline-text-4" id="text-2-6-8">
<p>
What is the time complexity of the binary search algorithm? Assume the number of elements in the array is N. A. O(1) B. O(N) C. O(logN) D. O(NlogN) E. (NlogN)<br />
</p>
</div>
<div id="outline-container-org454d93c" class="outline-5">
<h5 id="org454d93c">答案：C. O(logN)</h5>
<div class="outline-text-5" id="text-org454d93c">
<p>
解析：二元搜尋每次 將搜尋範圍減半，時間複雜度是 O(logN)。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8b40648" class="outline-4">
<h4 id="org8b40648"><span class="section-number-4">2.6.9.</span> 第九題：</h4>
<div class="outline-text-4" id="text-2-6-9">
<p>
Consider the following C code.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;stdio.h&gt;</span>
<span class="linenr">2: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">3: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">array</span>[] = {<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>};
<span class="linenr">4: </span>    printf(<span style="color: #98be65;">"%d"</span>, array[<span style="color: #da8548; font-weight: bold;">1</span>]);
<span class="linenr">5: </span>}
</pre>
</div>
<p>
We would like to compile and run the program. Which of the following is TRUE? A. It will show compilation errors B. It will show run-time errors C. It will show 1 D. It will show 4 E. It will show some junk value<br />
</p>
</div>
<div id="outline-container-org4f2683b" class="outline-5">
<h5 id="org4f2683b">答案：1.</h5>
<div class="outline-text-5" id="text-org4f2683b">
<ul class="org-ul">
<li>它會輸出 3，但 3 不在選項內，應該是 C（但錯誤）<br /></li>
<li>array[1] 取值為 3。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org30ffcb0" class="outline-4">
<h4 id="org30ffcb0"><span class="section-number-4">2.6.10.</span> 第十題：</h4>
<div class="outline-text-4" id="text-2-6-10">
<p>
Which of the following about operating systems is TRUE? A. An operating system is an application software that manages the computer hardware and provides an interface between the hardware and the user. B. Microsoft Windows is an open-source software. C. Android is a Windows-like operating system. D. IOS is an operating system for Mac computers. E. None of the above<br />
</p>
</div>
<div id="outline-container-orgb36d56d" class="outline-5">
<h5 id="orgb36d56d">答案：E. None of the above</h5>
<div class="outline-text-5" id="text-orgb36d56d">
<p>
解析：<br />
</p>
<ol class="org-ol">
<li>錯：作業系統是系統軟體，不是應用軟體。<br /></li>
<li>錯：Windows 不是開源軟體。<br /></li>
<li>錯：Android 和 Windows 不同，基於 Linux。<br /></li>
<li>錯：iOS 是行動裝置的 OS，Mac 使用 macOS。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org02e39cc" class="outline-4">
<h4 id="org02e39cc"><span class="section-number-4">2.6.11.</span> 第十一題：</h4>
<div class="outline-text-4" id="text-2-6-11">
<p>
With the even parity and ASCII code, which of the following is correct? A. 01101011 B. 00011011 C. 00100101 D. 10111010 E. None of the above<br />
</p>
</div>
<div id="outline-container-orgd2ca6e1" class="outline-5">
<h5 id="orgd2ca6e1">答案：E. None of the above</h5>
<div class="outline-text-5" id="text-orgd2ca6e1">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>ASCII 字元為 7 位元，加上 偶數（even）奇偶校驗位 應該為 8 位元。<br /></li>
<li>偶數奇偶校驗（Even Parity）要求 1 的個數為偶數。<br /></li>
<li>檢查每個選項，沒有滿足此條件的，因此正確答案為 E. None of the above。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org65fb7e2" class="outline-4">
<h4 id="org65fb7e2"><span class="section-number-4">2.6.12.</span> 第十二題：</h4>
<div class="outline-text-4" id="text-2-6-12">
<p>
What is the network number of the IP address 140.117.17.200 with the subnet mask 255.255.255.224? A. 140.117.17.0 B. 140.117.17.128 C. 140.117.17.192 D. 140.117.17.224 E. 140.117.17.240<br />
</p>
</div>
<div id="outline-container-orgc74a7d7" class="outline-5">
<h5 id="orgc74a7d7">答案：C. 140.117.17.192</h5>
<div class="outline-text-5" id="text-orgc74a7d7">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>子網掩碼 255.255.255.224（/27）表示 前 27 位為網路位址。<br /></li>
<li>每個子網的大小為 2^(32-27) = 32 個 IP。<br /></li>
<li>140.117.17.200 落在 140.117.17.192 到 140.117.17.223 之間，因此網路 ID 是 140.117.17.192。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8fc5bfc" class="outline-4">
<h4 id="org8fc5bfc"><span class="section-number-4">2.6.13.</span> 第十三題：</h4>
<div class="outline-text-4" id="text-2-6-13">
<p>
What is the height of a complete binary tree with 8192 nodes?  A. 8192 B. 4096 C. 12 D. 13 E. 14<br />
</p>
</div>
<div id="outline-container-orgf193bb4" class="outline-5">
<h5 id="orgf193bb4">答案：D. 13</h5>
<div class="outline-text-5" id="text-orgf193bb4">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>完全二元樹的高度 h 計算方式： \( 2^{h+1} + 1 >= 8192 \)<br /></li>
<li>反解得：h=log⁡2(8192+1)−1≈13<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org97a0283" class="outline-4">
<h4 id="org97a0283"><span class="section-number-4">2.6.14.</span> 第十四題：</h4>
<div class="outline-text-4" id="text-2-6-14">
<p>
What postfix expression does the expression tree below represent?<br />
</p>
<pre class="example" id="org69ea8a0">
      +
    /   \
  +      -
 /  \   /  \
a    b c    d
</pre>
<ol class="org-ol">
<li>a+b*c-d<br /></li>
<li>(a+b)*(c-d)<br /></li>
<li>ab+cd-*<br /></li>
<li>ab+c*d-*<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgb9a9c74" class="outline-5">
<h5 id="orgb9a9c74">答案：C. ab+cd-*</h5>
<div class="outline-text-5" id="text-orgb9a9c74">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>遍歷方式：<br />
<ul class="org-ul">
<li>後序（Postfix）順序： 左 -&gt; 右 -&gt; 根<br /></li>
<li>(a + b) * (c - d) → ab+cd-*<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org77741e0" class="outline-4">
<h4 id="org77741e0"><span class="section-number-4">2.6.15.</span> 第十五題：</h4>
<div class="outline-text-4" id="text-2-6-15">
<p>
The IPv6 specification uses addresses to identify hosts that consist of: A. 16 bits B. 32 bits C. 64 bits D. 128 bits E. 256 bits<br />
</p>
</div>
<div id="outline-container-org53183bc" class="outline-5">
<h5 id="org53183bc">答案：D. 128 bits</h5>
<div class="outline-text-5" id="text-org53183bc">
<ul class="org-ul">
<li>解析： IPv6 位址長度為 128 位元，而 IPv4 是 32 位元。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org60812d8" class="outline-4">
<h4 id="org60812d8"><span class="section-number-4">2.6.16.</span> 第十六題：</h4>
<div class="outline-text-4" id="text-2-6-16">
<pre class="example" id="org2a4dbec">
      A
    /  \
   B    C
       /  \
      D    E
</pre>
<p>
Which of the following is an in-order traversal of the above tree? A. ABCDE B. ABDCE C. BACDE D. EDBCA E. BADCE<br />
</p>
</div>
<div id="outline-container-orge8e94b4" class="outline-5">
<h5 id="orge8e94b4">答案：E. BADCE</h5>
<div class="outline-text-5" id="text-orge8e94b4">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>中序遍歷順序： 左 -&gt; 根 -&gt; 右<br /></li>
<li>結果： B → A → D → C → E<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4918b37" class="outline-4">
<h4 id="org4918b37"><span class="section-number-4">2.6.17.</span> 第十七題：</h4>
<div class="outline-text-4" id="text-2-6-17">
<p>
What is reinforcement learning? A. A kind of e-learning reinforced by classmates B. An educational technology to improve the learning performance C. A machine learning method based on maximizing the reward D. An unsupervised machine learning algorithm E. None of the above<br />
</p>
</div>
<div id="outline-container-orga5d236f" class="outline-5">
<h5 id="orga5d236f">答案：C. A machine learning method based on maximizing the reward</h5>
<div class="outline-text-5" id="text-orga5d236f">
<p>
解析：強化學習 透過獎勵機制（Reward）來學習最佳策略。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org04b6d54" class="outline-4">
<h4 id="org04b6d54"><span class="section-number-4">2.6.18.</span> 第十八題：</h4>
<div class="outline-text-4" id="text-2-6-18">
<p>
Which of the following technique is for using in local area network?<br />
</p>
<ol class="org-ol">
<li>Long-Term Evolution<br /></li>
<li>Ultra-Wide Band<br /></li>
<li>5G<br /></li>
<li>Bluetooth<br /></li>
<li>Ethernet<br /></li>
</ol>
</div>
<div id="outline-container-orge74061c" class="outline-5">
<h5 id="orge74061c">答案：E. Ethernet</h5>
<div class="outline-text-5" id="text-orge74061c">
<p>
解析： 區域網路（LAN） 主要使用 Ethernet（乙太網路），而 LTE、5G 屬於行動網路技術。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgdfa2ac8" class="outline-4">
<h4 id="orgdfa2ac8"><span class="section-number-4">2.6.19.</span> 第十九題：</h4>
<div class="outline-text-4" id="text-2-6-19">
<p>
Which of the following instruction level parallelism mechanisms highly depends on the compiler optimization but requires only a simple hardware?<br />
</p>
<ol class="org-ol">
<li>Out-of-order execution<br /></li>
<li>Branch prediction<br /></li>
<li>Superscalar<br /></li>
<li>Pipelining<br /></li>
<li>VLIW<br /></li>
</ol>
</div>
<div id="outline-container-org78f96af" class="outline-5">
<h5 id="org78f96af">答案：E. VLIW（Very Long Instruction Word）</h5>
<div class="outline-text-5" id="text-org78f96af">
<p>
解析：VLIW 需要編譯器來決定指令並行性，而不依賴複雜硬體。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org87097ac" class="outline-4">
<h4 id="org87097ac"><span class="section-number-4">2.6.20.</span> 第二十題：</h4>
<div class="outline-text-4" id="text-2-6-20">
<p>
Which of the following operating systems is not a Unix-like system?<br />
</p>
<ol class="org-ol">
<li>FreeBSD<br /></li>
<li>Linux<br /></li>
<li>Solaris<br /></li>
<li>macOS<br /></li>
<li>DOS<br /></li>
</ol>
</div>
<div id="outline-container-org2202218" class="outline-5">
<h5 id="org2202218">答案：E. DOS</h5>
<div class="outline-text-5" id="text-org2202218">
<p>
解析： DOS（Disk Operating System） 是舊式作業系統，不是 Unix-like。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb1b4c64" class="outline-4">
<h4 id="orgb1b4c64"><span class="section-number-4">2.6.21.</span> 第二十一題：</h4>
<div class="outline-text-4" id="text-2-6-21">
<p>
(複選) Which of the following are main components of a CPU?<br />
</p>
<ol class="org-ol">
<li>Arithmetic Logic Unit<br /></li>
<li>Codec<br /></li>
<li>Registers<br /></li>
<li>Control Unit<br /></li>
<li>USB Controller<br /></li>
</ol>
</div>
<div id="outline-container-org7c3e7ae" class="outline-5">
<h5 id="org7c3e7ae">答案：A. Arithmetic Logic Unit, C. Registers, D. Control Unit</h5>
<div class="outline-text-5" id="text-org7c3e7ae">
<p>
解析：  ALU（算術邏輯單元）、控制單元（CU）、暫存器（Registers） 是 CPU 核心部分。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1987673" class="outline-4">
<h4 id="org1987673"><span class="section-number-4">2.6.22.</span> 第二十二題：</h4>
<div class="outline-text-4" id="text-2-6-22">
<p>
(複選) Which of the following principles are associated with object-oriented programming?<br />
</p>
<ol class="org-ol">
<li>Opcode mnemonics<br /></li>
<li>Inheritance<br /></li>
<li>Encapsulation<br /></li>
<li>Polymorphism<br /></li>
<li>Abstraction<br /></li>
</ol>
</div>
<div id="outline-container-org088747a" class="outline-5">
<h5 id="org088747a">答案：B. Inheritance, C. Encapsulation, D. Polymorphism, E. Abstraction</h5>
<div class="outline-text-5" id="text-org088747a">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>物件導向的四大原則：<br />
<ul class="org-ul">
<li>封裝（Encapsulation）<br /></li>
<li>繼承（Inheritance）<br /></li>
<li>多型（Polymorphism）<br /></li>
<li>抽象（Abstraction）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0b50754" class="outline-4">
<h4 id="org0b50754"><span class="section-number-4">2.6.23.</span> 第二十三題：</h4>
<div class="outline-text-4" id="text-2-6-23">
<p>
(複選) Which of the following encryption methods are symmetric-key algorithms?<br />
</p>
<ol class="org-ol">
<li>AES<br /></li>
<li>RSA<br /></li>
<li>3DES<br /></li>
<li>DES<br /></li>
<li>ChaCha20<br /></li>
</ol>
</div>
<div id="outline-container-org665ecf4" class="outline-5">
<h5 id="org665ecf4">答案：A. AES, C. 3DES, D. DES, E. ChaCha20</h5>
<div class="outline-text-5" id="text-org665ecf4">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>對稱加密（Symmetric-key encryption） 使用相同金鑰來加密/解密。<br /></li>
<li>非對稱加密（Asymmetric encryption）（如 RSA）使用公私鑰。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7efcbcf" class="outline-4">
<h4 id="org7efcbcf"><span class="section-number-4">2.6.24.</span> 第二十四題：</h4>
<div class="outline-text-4" id="text-2-6-24">
<p>
(複選) Wi-Fi 6E can run on which of the following frequency spectrums?<br />
</p>
<ol class="org-ol">
<li>2.4 GHz<br /></li>
<li>3.5 GHz<br /></li>
<li>5 GHz<br /></li>
<li>6 GHz<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org79b45c1" class="outline-5">
<h5 id="org79b45c1">答案：A. 2.4 GHz, C. 5 GHz, D. 6 GHz</h5>
<div class="outline-text-5" id="text-org79b45c1">
<p>
解析： Wi-Fi 6E 支援 2.4 GHz、5 GHz、6 GHz。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd5ba63f" class="outline-4">
<h4 id="orgd5ba63f"><span class="section-number-4">2.6.25.</span> 第二十五題：</h4>
<div class="outline-text-4" id="text-2-6-25">
<p>
(複選)Which of the following descriptions for blockchain technology is correct?<br />
</p>
<ol class="org-ol">
<li>Using daily chain topology<br /></li>
<li>A decentralization mechanism<br /></li>
<li>Proof of work is popularly used<br /></li>
<li>Using cryptographic hash algorithms<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org3c9d31f" class="outline-5">
<h5 id="org3c9d31f">答案：B. A decentralization mechanism, C. Proof of work is popularly used, D. Using cryptographic hash algorithms</h5>
<div class="outline-text-5" id="text-org3c9d31f">
<p>
解析：<br />
</p>
<ul class="org-ul">
<li>區塊鏈的特性<br />
<ul class="org-ul">
<li>去中心化（Decentralization）<br /></li>
<li>工作量證明（PoW）<br /></li>
<li>加密雜湊演算法（Hashing）<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org07d2df8" class="outline-4">
<h4 id="org07d2df8"><span class="section-number-4">2.6.26.</span> 第二十六題：</h4>
<div class="outline-text-4" id="text-2-6-26">
<p>
(複選)Which of the following about recursion is TRUE?<br />
</p>
<ol class="org-ol">
<li>recursive function is a function that calls itself.<br /></li>
<li>When a problem can be solved either recursively or iteratively, the recursive version usually incurs extra computational overheads.<br /></li>
<li>One must not use for-loops in a recursive function<br /></li>
<li>When a base case is never reached in a recursive function, it results in stack overflow.<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-org9f8b46b" class="outline-5">
<h5 id="org9f8b46b">答案：A. recursive function is a function that calls itself, B. When a problem can be solved either recursively or iteratively, the recursive version usually incurs extra computational overheads, D. When a base case is never reached in a recursive function, it results in stack overflow</h5>
<div class="outline-text-5" id="text-org9f8b46b">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>遞迴函數會呼叫自己，且 無基底條件 會導致 堆疊溢位（Stack Overflow）。<br /></li>
<li>遞迴通常會 增加額外計算開銷。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org06c9f97" class="outline-4">
<h4 id="org06c9f97"><span class="section-number-4">2.6.27.</span> 第二十七題：</h4>
<div class="outline-text-4" id="text-2-6-27">
<p>
(複選)Consider the relation T(A1, A2, A3, A4, A5, A6, A7) and the following functional  dependencies:<br />
</p>
<pre class="example" id="orga5ab265">
A1 -&gt; A3
A2 -&gt; A4
A4 -&gt; A5
{A1, A2} -&gt; {A6, A7}
A6 -&gt; A1
A7 -&gt; A2
</pre>
<p>
Which of the following statements is TRUE?<br />
</p>
<ol class="org-ol">
<li>{A1, A3} is a key.<br /></li>
<li>{A3, A6, A7} is a key.<br /></li>
<li>{A1, A4, A7} is a key.<br /></li>
<li>{A2, A6} is a key.<br /></li>
<li>{A1, A2} is a key.<br /></li>
</ol>
</div>
<div id="outline-container-orgcbdc003" class="outline-5">
<h5 id="orgcbdc003">答案：E. {A1, A2} is a key</h5>
<div class="outline-text-5" id="text-orgcbdc003">
<ul class="org-ul">
<li>解析：{A1, A2} 可以唯一標識所有屬性，因此是候選鍵（Candidate Key）。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgdafebe8" class="outline-4">
<h4 id="orgdafebe8"><span class="section-number-4">2.6.28.</span> 第二十八題：</h4>
<div class="outline-text-4" id="text-2-6-28">
<p>
(複選)Which of the following about deep learning is TRUE?<br />
</p>
<ol class="org-ol">
<li>Convolutional neural networks (CNNs) are commonly used to process images.<br /></li>
<li>Recurrent neural networks (RNNs) can be used to process sequential data.<br /></li>
<li>Deep learning is loosely inspired by the human brain.<br /></li>
<li>The “deep” in deep learning refers to the number of nodes.<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgfadd292" class="outline-5">
<h5 id="orgfadd292">答案：A. Convolutional neural networks (CNNs) are commonly used to process images, B. Recurrent neural networks (RNNs) can be used to process sequential data, C. Deep learning is loosely inspired by the human brain</h5>
<div class="outline-text-5" id="text-orgfadd292">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>CNN 處理影像<br /></li>
<li>RNN 處理序列數據<br /></li>
<li>深度學習受神經網路啟發<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3c849e5" class="outline-4">
<h4 id="org3c849e5"><span class="section-number-4">2.6.29.</span> 第二十九題：</h4>
<div class="outline-text-4" id="text-2-6-29">
<p>
(複選)Which of the following storage are non-volatile?<br />
</p>
<ol class="org-ol">
<li>SDRAM<br /></li>
<li>DRAM<br /></li>
<li>ROM<br /></li>
<li>Flash memory<br /></li>
<li>Static RAM<br /></li>
</ol>
</div>
<div id="outline-container-org54ace22" class="outline-5">
<h5 id="org54ace22">答案：C. ROM, D. Flash memory</h5>
<div class="outline-text-5" id="text-org54ace22">
<p>
解析：ROM（唯讀記憶體） 和 快閃記憶體（Flash Memory） 不會斷電遺失資料。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga6ac72a" class="outline-4">
<h4 id="orga6ac72a"><span class="section-number-4">2.6.30.</span> 第三十題：</h4>
<div class="outline-text-4" id="text-2-6-30">
<p>
(複選)Which of the following about the relational database is TRUE?<br />
</p>
<ol class="org-ol">
<li>If a relation is in BCNF, it also satisfies 3NF.<br /></li>
<li>A relation may have multiple candidate keys.<br /></li>
<li>A key is a minimal set of attributes that can uniquely identify tuples in a relation.<br /></li>
<li>A foreign key is also a superkey.<br /></li>
<li>If a relation is in 2NF, it also satisfies 3NF.<br /></li>
</ol>
</div>
<div id="outline-container-org86712fc" class="outline-5">
<h5 id="org86712fc">答案：A. If a relation is in BCNF, it also satisfies 3NF, B. A relation may have multiple candidate keys, C. A key is a minimal set of attributes that can uniquely identify tuples in a relation</h5>
<div class="outline-text-5" id="text-org86712fc">
<ul class="org-ul">
<li>解析：<br />
<ul class="org-ul">
<li>BCNF（巴斯-柯德正規形） 是 3NF 的加強版，因此滿足 3NF。<br /></li>
<li>關係可有多個候選鍵，但僅有一個主鍵。<br /></li>
<li>鍵（Key）必須是最小的唯一標識屬性組。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org9754d20" class="outline-3">
<h3 id="org9754d20"><span class="section-number-3">2.7.</span> 111: 管理資訊系統</h3>
<div class="outline-text-3" id="text-2-7">
</div>
<div id="outline-container-org70b362d" class="outline-4">
<h4 id="org70b362d"><span class="section-number-4">2.7.1.</span> 一、金融科技是近年相當熱門的議題，請回答下列問題：</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
1、何謂金融科技？(5%)<br />
   金融科技（Financial Technology, FinTech）是指 運用新興科技（如人工智慧、大數據、區塊鏈、雲端運算）來優化金融服務與產品，提升金融交易效率、降低成本，並創造新的商業模式。<br />
2、金融科技的應用可以分成哪幾大類？(10%)<br />
   金融科技的應用可分為以下幾大類：<br />
</p>
<ul class="org-ul">
<li>數位支付（Digital Payment）<br /></li>
<li>借貸與融資（Lending &amp; Crowdfunding）<br /></li>
<li>數位銀行（Digital Banking）<br /></li>
<li>財務管理與投資（Wealth Management &amp; Robo-Advisors）<br /></li>
<li>保險科技（InsurTech）<br /></li>
<li>區塊鏈與加密貨幣（Blockchain &amp; Cryptocurrency）<br /></li>
<li>監管科技（RegTech, Regulatory Technology）<br /></li>
</ul>
<p>
3、請為上述每類舉一例說明之 (5%)。<br />
</p>
<ul class="org-ul">
<li>數位支付 → Apple Pay：使用 NFC 技術進行行動支付。<br /></li>
<li>借貸與融資 → Kiva：提供 P2P（點對點）小額借貸。<br /></li>
<li>數位銀行 → Revolut：純網銀，提供無實體卡的金融服務。<br /></li>
<li>財務管理 → Betterment：AI 自動投資管理平台。<br /></li>
<li>保險科技 → Lemonade：利用 AI 進行保險核保與賠付。<br /></li>
<li>區塊鏈與加密貨幣 → Bitcoin：全球第一種去中心化加密貨幣。<br /></li>
<li>監管科技 → Onfido：透過 AI 進行身份驗證，防止金融詐欺。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgf3eafc1" class="outline-4">
<h4 id="orgf3eafc1"><span class="section-number-4">2.7.2.</span> 二、 近來NFT吸引到許多產業界的關注，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
1、請問何謂NFT？(5%)<br />
   NFT（Non-Fungible Token，非同質化代幣）是一種基於 區塊鏈技術 的數位資產，每個 NFT 具有唯一性、不可互換性，用於代表數位藝術品、收藏品、虛擬資產等。<br />
2、請試舉三種可能的NFT產業應用 (5%)<br />
</p>
<ol class="org-ol">
<li>數位藝術（Digital Art）：Beeple 的 NFT 作品《Everydays: The First 5000 Days》曾拍賣 6900 萬美元。<br /></li>
<li>遊戲資產（Gaming Assets）：Axie Infinity 允許玩家買賣 NFT 寵物。<br /></li>
<li>音樂版權（Music Rights）：音樂家可以透過 NFT 直接出售版權，減少中間商剝削。<br /></li>
</ol>
<p>
3、請說明NFT與一般的區塊鏈應用有何異同？(5%)。<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">NFT</th>
<th scope="col" class="org-left">一般區塊鏈應用（如加密貨幣）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">性質</td>
<td class="org-left">唯一、不可互換</td>
<td class="org-left">可互換（如 Bitcoin, Ethereum）</td>
</tr>

<tr>
<td class="org-left">技術標準</td>
<td class="org-left">ERC-721, ERC-1155</td>
<td class="org-left">E  RC-20, BEP-20</td>
</tr>

<tr>
<td class="org-left">應用場景</td>
<td class="org-left">藝術、遊戲、收藏品</td>
<td class="org-left">貨幣、支付、DeFi</td>
</tr>

<tr>
<td class="org-left">價值來源</td>
<td class="org-left">稀缺性、收藏價值</td>
<td class="org-left">供需市場決定</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org5b7778a" class="outline-4">
<h4 id="org5b7778a"><span class="section-number-4">2.7.3.</span> 三、近來元宇宙出現在各個媒體中，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
1、何謂元宇宙？(5%)<br />
   元宇宙（Metaverse）是一個 虛擬與現實融合的數位世界，透過 VR、AR、區塊鏈 等技術，讓使用者能夠進行社交、工作、娛樂等活動。<br />
2、請問可應用到的技術有哪些？(10%)<br />
</p>
<ul class="org-ul">
<li>虛擬實境（VR）<br /></li>
<li>擴增實境（AR）<br /></li>
<li>區塊鏈（Blockchain）<br /></li>
<li>人工智慧（AI）<br /></li>
<li>雲端運算（Cloud Computing）<br /></li>
<li>數位孿生（Digital Twin）<br /></li>
</ul>
<p>
3、舉出元宇宙可能的三種應用 (5%)。<br />
</p>
<ol class="org-ol">
<li>虛擬會議（如 Meta Horizon Workrooms）<br /></li>
<li>數位房地產（如 Decentraland）<br /></li>
<li>虛擬演唱會（如 Travis Scott 在 Fortnite 的虛擬音樂會）<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgf808a2f" class="outline-4">
<h4 id="orgf808a2f"><span class="section-number-4">2.7.4.</span> 四、隱私悖論近年來常被提出討論，請回答下列相關問題。</h4>
<div class="outline-text-4" id="text-2-7-4">
<p>
1、請說明何為隱私悖論？(5%)<br />
   隱私悖論 指的是 人們雖然擔心個資安全，但仍願意在網路上提供個資以換取便利。<br />
2、並舉出兩種情境來說明 (5%)<br />
</p>
<ol class="org-ol">
<li>社群媒體：用戶擔心個資外洩，但仍願意在 Facebook、Instagram 分享個人資訊。<br /></li>
<li>行動支付：使用者擔憂隱私問題，但仍使用 Google Pay、Apple Pay 綁定信用卡。<br /></li>
</ol>
<p>
3、另外請提出至少可能的三種悖論成因 (5%)。<br />
</p>
<ol class="org-ol">
<li>資訊不對稱：使用者不清楚個資的真正用途。<br /></li>
<li>行為習慣：人們習慣免費服務，願意提供個資換取便利。<br /></li>
<li>決策疲勞：隱私設定過於複雜，導致用戶選擇「接受所有條款」。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org1d40eeb" class="outline-4">
<h4 id="org1d40eeb"><span class="section-number-4">2.7.5.</span> 五、近來臉書的推薦演算法飽受質疑，請回答下列問題。</h4>
<div class="outline-text-4" id="text-2-7-5">
<p>
1、請問一般推薦系統演算法，主要可分為哪幾類？(10%)<br />
</p>
<ol class="org-ol">
<li>協同過濾（Collaborative Filtering）<br /></li>
<li>內容導向推薦（Content-Based Filtering）<br /></li>
<li>混合式推薦（Hybrid Recommendation）<br /></li>
</ol>
<p>
2、承上，請為每類提出一種代表性的演算法？(5%)<br />
</p>
<ol class="org-ol">
<li>協同過濾 → KNN（K-Nearest Neighbors）<br /></li>
<li>內容導向推薦 → TF-IDF（Term Frequency-Inverse Document Frequency）<br /></li>
<li>混合式推薦 → Netflix 使用的混合推薦系統<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org81d23ff" class="outline-4">
<h4 id="org81d23ff"><span class="section-number-4">2.7.6.</span> 六、共享平台以補助金或津貼的方式進行擴張，例如滴滴出行補貼計程車以及消費者，以增加市場佔有率。</h4>
<div class="outline-text-4" id="text-2-7-6">
<p>
1、請以波特的五力模式分析平台需具備什麼特質才適合以補貼方式進行市場擴張？(10%)<br />
   波特五力模型分析（10%）<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">五力</th>
<th scope="col" class="org-left">適用補貼的條件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">供應商議價力</td>
<td class="org-left">供應商（司機）較多，議價力較低，適合補貼吸引司機。</td>
</tr>

<tr>
<td class="org-left">買方議價力</td>
<td class="org-left">消費者對價格敏感，補貼可吸引新用戶。</td>
</tr>

<tr>
<td class="org-left">市場競爭</td>
<td class="org-left">競爭激烈時，補貼可提高市占率。</td>
</tr>

<tr>
<td class="org-left">替代品威脅</td>
<td class="org-left">若市場有強替代品（如計程車），補貼可降低用戶轉移風險。</td>
</tr>

<tr>
<td class="org-left">新進者威脅</td>
<td class="org-left">補貼可提高市場門檻，阻止新競爭者加入。</td>
</tr>
</tbody>
</table>
<p>
2、若以上述原則判斷，請問滴滴出行適合採取補貼模式嗎？(5%)<br />
   適合，因為滴滴出行市場競爭激烈（Uber 競爭），且用戶對價格敏感，補貼可提高黏著度。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org1262198" class="outline-3">
<h3 id="org1262198"><span class="section-number-3">2.8.</span> 111: 資料結構：</h3>
<div class="outline-text-3" id="text-2-8">
</div>
<div id="outline-container-orgf45f453" class="outline-4">
<h4 id="orgf45f453"><span class="section-number-4">2.8.1.</span> 第一題：</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
A heap is an implementation of a (3%)<br />
</p>
<ol class="org-ol">
<li>stack<br /></li>
<li>priority queue<br /></li>
<li>linked list<br /></li>
<li>cyclic graph<br /></li>
</ol>
</div>
<div id="outline-container-orga808464" class="outline-5">
<h5 id="orga808464">答案：B. Priority Queue（優先佇列）</h5>
<div class="outline-text-5" id="text-orga808464">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Heap（堆積） 是一種 樹狀結構（通常是二元堆積，Binary Heap），主要應用於 優先佇列（Priority Queue） 的實作。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Stack（堆疊） → 錯誤，堆疊通常使用陣列或連結串列實作，不使用 Heap。<br /></li>
<li>Priority Queue（優先佇列） → 正確，Heap 主要用於實作優先佇列，如 min-heap 和 max-heap。<br /></li>
<li>Linked List（鏈結串列） → 錯誤，鏈結串列不是用 Heap 來實作。<br /></li>
<li>Cyclic Graph（循環圖） → 錯誤，Heap 與圖無關。<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfd2ed25" class="outline-4">
<h4 id="orgfd2ed25"><span class="section-number-4">2.8.2.</span> 第二題：</h4>
<div class="outline-text-4" id="text-2-8-2">
<p>
Which of the following data structure is not based on a binary tree? (3%)<br />
</p>
<ol class="org-ol">
<li>Min Heap<br /></li>
<li>Red Black Tree<br /></li>
<li>AVL Tree<br /></li>
<li>Stack<br /></li>
</ol>
</div>
<div id="outline-container-orgade61a0" class="outline-5">
<h5 id="orgade61a0">答案：D. Stack（堆疊）</h5>
<div class="outline-text-5" id="text-orgade61a0">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>二元樹結構的資料結構：<br />
<ul class="org-ul">
<li>Min Heap（最小堆積） → 基於二元樹（通常是完全二元樹）。<br /></li>
<li>Red-Black Tree（紅黑樹） → 基於自平衡二元搜尋樹（BST）。<br /></li>
<li>AVL Tree（AVL 樹） → 基於自平衡二元搜尋樹。<br /></li>
</ul></li>
<li>非二元樹結構：<br />
<ul class="org-ul">
<li>Stack（堆疊） 是 線性結構（LIFO, Last In First Out），通常使用陣列或鏈結串列來實作，不是基於二元樹。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5d6d135" class="outline-4">
<h4 id="org5d6d135"><span class="section-number-4">2.8.3.</span> 第三題：</h4>
<div class="outline-text-4" id="text-2-8-3">
<p>
What is the breadth-first search order for the following tree? (4%)<br />
</p>
<pre class="example" id="orge018ef5">
              28
            /    \
          /        \
        15         58
       /  \        /
      9    20     46
     / \     \   /  \
    7   11   23 38  51
</pre>
<ol class="org-ol">
<li>28 15 58 9 20 46 7 11 23 38 51<br /></li>
<li>28 15 9 7 11 20 23 58 46 38 51<br /></li>
<li>7 9 11 15 20 23 28 38 46 51 58<br /></li>
<li>7 11 23 38 51 9 20 46 15 58 28<br /></li>
</ol>
<p>
答案：A. 28 15 58 9 20 46 7 11 23 38 51<br />
解析<br />
</p>
<ul class="org-ul">
<li>廣度優先搜尋（BFS） 遵循 層級遍歷（Level Order Traversal），即從 根節點開始，逐層遍歷每一層的節點。<br /></li>
</ul>
<p>
BFS 遍歷順序：<br />
</p>
<ul class="org-ul">
<li>層 1（根節點） → 28<br /></li>
<li>層 2 → 15 58<br /></li>
<li>層 3 → 9 20 46<br /></li>
<li>層 4 → 7 11 23 38 51<br /></li>
</ul>
<p>
所以，BFS 結果為： 28 15 58 9 20 46 7 11 23 38 51<br />
選項分析：<br />
</p>
<ol class="org-ol">
<li>28 15 58 9 20 46 7 11 23 38 51 ✅ 正確<br /></li>
<li>28 15 9 7 11 20 23 58 46 38 51 ❌ 錯誤，58 應該在 20 之後<br /></li>
<li>7 9 11 15 20 23 28 38 46 51 58 ❌ 這是中序（In-order）遍歷，不是 BFS<br /></li>
<li>7 11 23 38 51 9 20 46 15 58 28 ❌ 這是後序（Post-order）遍歷，不是 BFS<br /></li>
</ol>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>Heap 是 Priority Queue（優先佇列）的實作。<br /></li>
<li>Stack（堆疊）不是基於二元樹的資料結構。<br /></li>
<li>BFS（廣度優先搜尋）遍歷順序為：28 15 58 9 20 46 7 11 23 38 51。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org93f23c8" class="outline-4">
<h4 id="org93f23c8"><span class="section-number-4">2.8.4.</span> 第四題：</h4>
<div class="outline-text-4" id="text-2-8-4">
<p>
What is the time complexity of the following code? (4%)<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>, <span style="color: #dcaeea;">j</span>, <span style="color: #dcaeea;">sum</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span><span style="color: #51afef;">for</span>(i=<span style="color: #da8548; font-weight: bold;">0</span>; i&lt;n; i++){
<span class="linenr">3: </span>    <span style="color: #51afef;">for</span>(j = <span style="color: #da8548; font-weight: bold;">0</span>; j&lt;n; j++){
<span class="linenr">4: </span>        <span style="color: #51afef;">for</span>(k = <span style="color: #da8548; font-weight: bold;">0</span>; k &lt; i; k++){
<span class="linenr">5: </span>             sum++;
<span class="linenr">6: </span>        }
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>}
</pre>
</div>
<ol class="org-ol">
<li>O(1)<br /></li>
<li>O(n)<br /></li>
<li>O(n^2)<br /></li>
<li>O(n^3)<br /></li>
</ol>
</div>
<div id="outline-container-org453a423" class="outline-5">
<h5 id="org453a423">答案：C. O(n^2)</h5>
<div class="outline-text-5" id="text-org453a423">
<p>
解析<br />
程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>, <span style="color: #dcaeea;">j</span>, <span style="color: #dcaeea;">sum</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span><span style="color: #51afef;">for</span>(i = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++) {       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22806;&#23652;&#36852;&#22280;&#22519;&#34892; n &#27425;</span>
<span class="linenr">3: </span>    <span style="color: #51afef;">for</span>(j = <span style="color: #da8548; font-weight: bold;">0</span>; j &lt; n; j++) {   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#20108;&#23652;&#36852;&#22280;&#22519;&#34892; n &#27425;</span>
<span class="linenr">4: </span>        <span style="color: #51afef;">for</span>(k = <span style="color: #da8548; font-weight: bold;">0</span>; k &lt; i; k++) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#19977;&#23652;&#36852;&#22280;&#22519;&#34892; i &#27425;</span>
<span class="linenr">5: </span>            sum++;
<span class="linenr">6: </span>        }
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>}
</pre>
</div>
<p>
分析各層迴圈次數：<br />
</p>
<ul class="org-ul">
<li>外層迴圈（變數 i）執行 n 次。<br /></li>
<li>中層迴圈（變數 j）執行 n 次。<br /></li>
<li>內層迴圈（變數 k）執行 i 次。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3299489" class="outline-4">
<h4 id="org3299489"><span class="section-number-4">2.8.5.</span> 第五題：</h4>
<div class="outline-text-4" id="text-2-8-5">
<p>
A binary search tree is generated in order with the following numbers: 3, 7, 1, 2, 5, 6, 10, 17, 4. How many nodes are in the right subtree? (4%)<br />
</p>
<ol class="org-ol">
<li>6<br /></li>
<li>1<br /></li>
<li>3<br /></li>
<li>5<br /></li>
</ol>
</div>
<div id="outline-container-org7c9f7c0" class="outline-5">
<h5 id="org7c9f7c0">答案：C. 3</h5>
<div class="outline-text-5" id="text-org7c9f7c0">
<p>
解析<br />
依序插入數字到二元搜尋樹（BST）：<br />
</p>
<ol class="org-ol">
<li>3 為根節點。<br /></li>
<li>7 插入右子樹。<br /></li>
<li>1 插入左子樹。<br /></li>
<li>2 插入 1 的右子樹。<br /></li>
<li>5 插入 7 的左子樹。<br /></li>
<li>6 插入 5 的右子樹。<br /></li>
<li>10 插入 7 的右子樹。<br /></li>
<li>17 插入 10 的右子樹。<br /></li>
<li>4 插入 5 的左子樹。<br /></li>
</ol>
<p>
右子樹的節點數量（從 7 開始）：<br />
</p>
<ul class="org-ul">
<li>7<br /></li>
<li>10<br /></li>
<li>17<br /></li>
</ul>
<p>
共 3 個節點，答案為 C. 3。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf4b7f97" class="outline-4">
<h4 id="orgf4b7f97"><span class="section-number-4">2.8.6.</span> 第六題：</h4>
<div class="outline-text-4" id="text-2-8-6">
<p>
What is the answer to the following postfix expression? (4%) 912*+62/-<br />
</p>
<ol class="org-ol">
<li>10<br /></li>
<li>30<br /></li>
<li>-1<br /></li>
<li>-15<br /></li>
</ol>
</div>
<div id="outline-container-org27d2078" class="outline-5">
<h5 id="org27d2078">答案：C. -1</h5>
<div class="outline-text-5" id="text-org27d2078">
<p>
解析<br />
後序表示法 912*+62/- 計算步驟：<br />
</p>
<ul class="org-ul">
<li>乘法 1 * 2 = 2 → 9 2 + 2 / -<br /></li>
<li>加法 9 + 2 = 11 → 11 6 2 / -<br /></li>
<li>除法 6 / 2 = 3 → 11 3 -<br /></li>
<li>減法 11 - 3 = 8 → 8<br /></li>
</ul>
<p>
答案應該是 C. -1，但運算結果應該是 8，可能題目有誤。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7053904" class="outline-4">
<h4 id="org7053904"><span class="section-number-4">2.8.7.</span> 第七題：</h4>
<div class="outline-text-4" id="text-2-8-7">
<p>
What is the sum of edge weights of the minimal spanning tree of the following graph? (4%)<br />
</p>

<div id="org6678f5f" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_10-59-10.png" alt="2025-01-29_10-59-10.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org2784b62">
圖形表示如下：節點1、2、3、4、5、6、7，邊及權重如下：1-2(2)，1-3(6)，1-7(2)，2-3(4)，2-5(2)，3-4(4)，3-6(10)，4-5(2)，4-6(4)，4-7(2)。
</pre>
<ol class="org-ol">
<li>14<br /></li>
<li>16<br /></li>
<li>18<br /></li>
<li>10<br /></li>
</ol>
</div>
<div id="outline-container-org633038d" class="outline-5">
<h5 id="org633038d">答案：B. 16</h5>
<div class="outline-text-5" id="text-org633038d">
<p>
解析<br />
使用 Kruskal 或 Prim 演算法 建立最小生成樹（MST）：<br />
</p>
<pre class="example" id="org02678d5">
圖中節點：1、2、3、4、5、6、7
邊及權重：
1-2(2), 1-3(6), 1-7(2), 2-3(4), 2-5(2),
3-4(4), 3-6(10), 4-5(2), 4-6(4), 4-7(2)
</pre>
<p>
按權重由小到大排序：<br />
</p>
<ol class="org-ol">
<li>1-2（2）<br /></li>
<li>1-7（2）<br /></li>
<li>2-5（2）<br /></li>
<li>4-5（2）<br /></li>
<li>4-7（2）<br /></li>
<li>2-3（4）<br /></li>
<li>3-4（4）<br /></li>
<li>4-6（4）<br /></li>
<li>1-3（6）<br /></li>
<li>3-6（10）<br /></li>
</ol>
<p>
建立最小生成樹（MST）：<br />
</p>
<ol class="org-ol">
<li>1-2（2）<br /></li>
<li>1-7（2）<br /></li>
<li>2-5（2）<br /></li>
<li>4-5（2）<br /></li>
<li>4-7（2）<br /></li>
<li>2-3（4）<br /></li>
<li>4-6（4）<br /></li>
</ol>
<p>
總權重：2+2+2+2+2+4+4=16<br />
</p>

<p>
答案為 B. 16。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7e06002" class="outline-4">
<h4 id="org7e06002"><span class="section-number-4">2.8.8.</span> 第八題：</h4>
<div class="outline-text-4" id="text-2-8-8">
<p>
In a complete graph of n vertices, how many edges are there? (4%)<br />
</p>
<ol class="org-ol">
<li>n^2<br /></li>
<li>n(n-1)/2<br /></li>
<li>n<br /></li>
<li>2n<br /></li>
</ol>
</div>
<div id="outline-container-orgc5a2e3f" class="outline-5">
<h5 id="orgc5a2e3f">答案：B. \( \frac{n(n-1)}{2} \)</h5>
<div class="outline-text-5" id="text-orgc5a2e3f">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>完全圖（Complete Graph）KnKn​ 是指 每個頂點與其他所有頂點都有邊相連。<br /></li>
<li>公式：<br /></li>
<li>邊數= \( \frac{n(n-1)}{2} \)<br /></li>
<li>因為 每兩個頂點之間都有一條邊，但 無重複計數（無向圖）。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>n2n2 ❌ 錯誤，這是錯誤的關係式。<br /></li>
<li>n(n−1)/2n(n−1)/2 ✅ 正確<br /></li>
<li>nn ❌ 錯誤，這是錯誤的關係式。<br /></li>
<li>2n2n ❌ 錯誤，邊數不會是 2n2n。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org1ce17cf" class="outline-4">
<h4 id="org1ce17cf"><span class="section-number-4">2.8.9.</span> 第九題：</h4>
<div class="outline-text-4" id="text-2-8-9">
<p>
What is the height of 12345 nodes in an AVL tree? (4%) A. 6172 B. 1 C. 13 D. 14<br />
</p>
</div>
<div id="outline-container-org9122ce4" class="outline-5">
<h5 id="org9122ce4">答案：C. 13</h5>
<div class="outline-text-5" id="text-org9122ce4">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>AVL 樹的最小高度 hh 滿足公式： N(h)=N(h−1)+N(h−2)+1<br /></li>
<li>其中 N(h)N(h) 表示具有 最少節點數量的 AVL 樹 的高度為 hh。<br /></li>
<li>已知 AVL 樹的高度增長類似於費氏數列（Fibonacci sequence），所以：N(h)≈1.44^h<br /></li>
<li>解方程式： 1.44^h=12345<br /></li>
<li>取對數：h=log⁡1.44(12345)≈13<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>6172 ❌ 錯誤，明顯太大<br /></li>
<li>1 ❌ 錯誤，AVL 樹只有 1 個節點時高度才是 1<br /></li>
<li>13 ✅ 正確<br /></li>
<li>14 ❌ 錯誤，12345 個節點的 AVL 樹高度大約是 13 而不是 14<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org441b49d" class="outline-4">
<h4 id="org441b49d"><span class="section-number-4">2.8.10.</span> 第十題：</h4>
<div class="outline-text-4" id="text-2-8-10">
<p>
For the following tree, what is the 5th node we visit if we perform a pre-order traversal? (4%)<br />
</p>

<div id="org615fe0e" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_11-18-16.png" alt="2025-01-29_11-18-16.png" width="500" /><br />
</p>
</div>
<pre class="example" id="orgfd1b8c3">
圖形表示如下：根節點為30，左子節點為17，右子節點為52。17的左子節點為14，右子節點為20。52的左子節點為47，右子節點為53。14的左子節點為8，右子節點為15。20的左子節點為19，右子節點為21。47的左子節點為40，右子節點為49。40的右子節點為39。
</pre>
<ol class="org-ol">
<li>20<br /></li>
<li>21<br /></li>
<li>39<br /></li>
<li>15<br /></li>
</ol>
</div>
<div id="outline-container-org325b0b4" class="outline-5">
<h5 id="org325b0b4">解析</h5>
<div class="outline-text-5" id="text-org325b0b4">
<p>
前序遍歷（Pre-order Traversal）順序：<br />
</p>
<ol class="org-ol">
<li>根節點<br /></li>
<li>左子樹<br /></li>
<li>右子樹<br /></li>
</ol>
<p>
前序遍歷順序（Pre-order Traversal）：<br />
</p>
<ol class="org-ol">
<li>30（根）<br /></li>
<li>17（左子樹）<br /></li>
<li>14（左子樹）<br /></li>
<li>8（左子樹）<br /></li>
<li>15（右子樹）→ 第 5 個節點<br /></li>
</ol>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>20 ❌ 錯誤，第 6 個節點<br /></li>
<li>21 ❌ 錯誤，還沒訪問到<br /></li>
<li>39 ❌ 錯誤，後面才會訪問<br /></li>
<li>15 ✅ 正確，第 5 個訪問的節點<br /></li>
</ol>
<p>
總結<br />
</p>
<ol class="org-ol">
<li>完全圖的邊數：n(n−1)/2n(n−1)/2<br /></li>
<li>AVL 樹（12345 個節點）的高度：13<br /></li>
<li>前序遍歷第 5 個訪問的節點：15<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org64f06be" class="outline-4">
<h4 id="org64f06be"><span class="section-number-4">2.8.11.</span> 第十一題：</h4>
<div class="outline-text-4" id="text-2-8-11">
<p>
For the tree in question 10, what is the 10th node we visit if we perform an in-order traversal? (4%)<br />
</p>
<ol class="org-ol">
<li>49<br /></li>
<li>40<br /></li>
<li>47<br /></li>
<li>53<br /></li>
</ol>
</div>
<div id="outline-container-org2cbd4ea" class="outline-5">
<h5 id="org2cbd4ea">答案：C. 47</h5>
<div class="outline-text-5" id="text-org2cbd4ea">
<p>
解析: 中序遍歷（In-order Traversal）順序：<br />
</p>
<ol class="org-ol">
<li>左子樹<br /></li>
<li>根節點<br /></li>
<li>右子樹<br /></li>
</ol>
<p>
中序遍歷順序（從最左邊開始遍歷）：<br />
</p>
<ol class="org-ol">
<li>8<br /></li>
<li>14<br /></li>
<li>15<br /></li>
<li>17<br /></li>
<li>19<br /></li>
<li>20<br /></li>
<li>21<br /></li>
<li>30<br /></li>
<li>39<br /></li>
<li>47 （第 10 個節點）<br /></li>
</ol>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>49 ❌ 錯誤，第 12 個節點<br /></li>
<li>40 ❌ 錯誤，第 11 個節點<br /></li>
<li>47 ✅ 正確，第 10 個節點<br /></li>
<li>53 ❌ 錯誤，第 13 個節點<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org036dd1b" class="outline-4">
<h4 id="org036dd1b"><span class="section-number-4">2.8.12.</span> 第十二題：</h4>
<div class="outline-text-4" id="text-2-8-12">
<p>
If the following numbers &ldquo;7&rdquo;, &ldquo;3&rdquo;, &ldquo;2&rdquo;, &ldquo;5&rdquo; are inserted into a queue, what would be their order for removal? (4%)<br />
</p>
<ol class="org-ol">
<li>7325<br /></li>
<li>5237<br /></li>
<li>7352<br /></li>
<li>None of the above<br /></li>
</ol>
</div>
<div id="outline-container-orge6813db" class="outline-5">
<h5 id="orge6813db">答案：A. 7325</h5>
<div class="outline-text-5" id="text-orge6813db">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>FIFO（First In, First Out） 規則：<br />
<ol class="org-ol">
<li>插入 7（隊列：7）<br /></li>
<li>插入 3（隊列：7 3）<br /></li>
<li>插入 2（隊列：7 3 2）<br /></li>
<li>插入 5（隊列：7 3 2 5）<br /></li>
</ol></li>
<li>移除順序： 7 3 2 5<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>7325 ✅ 正確<br /></li>
<li>5237 ❌ 錯誤，不符合 FIFO<br /></li>
<li>7352 ❌ 錯誤，不符合 FIFO<br /></li>
<li>None of the above ❌ 錯誤，因為 A 是正確的<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc71008e" class="outline-4">
<h4 id="orgc71008e"><span class="section-number-4">2.8.13.</span> 第十三題：</h4>
<div class="outline-text-4" id="text-2-8-13">
<p>
Which vertex is NOT a cut vertex in the following graph? (4%)<br />
</p>

<div id="org9c039a0" class="figure">
<p><img src="images/林北的考前猜題/2025-01-29_11-19-47.png" alt="2025-01-29_11-19-47.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org16fc576">
圖形表示如下：節點A、B、C、D、E、F、G，邊如下：A-B，B-C，B-D，C-E，D-F，E-G。
</pre>
<ol class="org-ol">
<li>B<br /></li>
<li>E<br /></li>
<li>G<br /></li>
<li>A<br /></li>
</ol>
</div>
<div id="outline-container-org19fe92f" class="outline-5">
<h5 id="org19fe92f">答案：C. G</h5>
<div class="outline-text-5" id="text-org19fe92f">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>割點（Cut Vertex）：如果刪除該頂點會導致圖變成兩個或更多的連通部分，則該頂點是割點。<br /></li>
<li>給定圖：<br /></li>
</ul>
<pre class="example" id="org25507bd">
  A -- B -- C
       |    |
       D    E
       |    |
       F    G

</pre>
<ul class="org-ul">
<li>A 是割點（移除後 A 和 B 分開）<br /></li>
<li>B 是割點（移除後 A 和 C 分開）<br /></li>
<li>C 是割點（移除後 B 和 E 分開）<br /></li>
<li>D 是割點（移除後 B 和 F 分開）<br /></li>
<li>E 是割點（移除後 C 和 G 分開）<br /></li>
<li>F 不是割點（因為 D 仍然連接其他部分）<br /></li>
<li>G 不是割點（因為移除後不會影響圖的連通性）<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>B ❌ 錯誤，B 是割點<br /></li>
<li>E ❌ 錯誤，E 是割點<br /></li>
<li>G ✅ 正確，G 不是割點<br /></li>
<li>A ❌ 錯誤，A 是割點<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org59a388e" class="outline-4">
<h4 id="org59a388e"><span class="section-number-4">2.8.14.</span> 第十四題：</h4>
<div class="outline-text-4" id="text-2-8-14">
<p>
In the implementation of quick sort, we divide the problem on the base of pivot element and: (3%)<br />
</p>
<ol class="org-ol">
<li>there is explicit combine process to conquer the solution<br /></li>
<li>no work is needed to combine the sub-arrays, the array is already sorted<br /></li>
<li>merge the subarrays<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-orgb43b358" class="outline-5">
<h5 id="orgb43b358">答案：B. no work is needed to combine the sub-arrays, the array is already sorted</h5>
<div class="outline-text-5" id="text-orgb43b358">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>快速排序（Quick Sort） 透過 選擇基準（pivot），並將數列劃分為 小於基準 和 大於基準 兩部分。<br /></li>
<li>不同於合併排序（Merge Sort），快速排序 不需要額外的合併步驟，因為遞迴執行完後陣列已經排序。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>there is explicit combine process to conquer the solution ❌ 錯誤，沒有明確的合併步驟<br /></li>
<li>no work is needed to combine the sub-arrays, the array is already sorted ✅ 正確<br /></li>
<li>merge the subarrays ❌ 錯誤，這描述的是合併排序（Merge Sort）<br /></li>
<li>none of the above ❌ 錯誤，B 是正確的<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org413f49b" class="outline-4">
<h4 id="org413f49b"><span class="section-number-4">2.8.15.</span> 第十五題：</h4>
<div class="outline-text-4" id="text-2-8-15">
<p>
Which of the following is not return optimal solution? (3%)<br />
</p>
<ol class="org-ol">
<li>dynamic programming<br /></li>
<li>backtracking<br /></li>
<li>branch and bound<br /></li>
<li>greedy method<br /></li>
</ol>
</div>
<div id="outline-container-org9c119dc" class="outline-5">
<h5 id="org9c119dc">答案：D. Greedy Method（貪婪法）</h5>
<div class="outline-text-5" id="text-org9c119dc">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>最佳解（Optimal Solution）：<br />
<ol class="org-ol">
<li>動態規劃（Dynamic Programming） ✅ 返回最佳解<br /></li>
<li>回溯法（Backtracking） ✅ 尋找所有可能解，一般能找到最佳解<br /></li>
<li>分支界限法（Branch and Bound） ✅ 尋找最佳解<br /></li>
<li>貪婪法（Greedy Algorithm） ❌ 不一定能找到最佳解<br /></li>
</ol></li>
<li>貪婪法問題：<br />
<ul class="org-ul">
<li>有時選擇當下最佳解，但整體結果不是最佳解，例如：<br />
<ul class="org-ul">
<li>最短路徑問題（Dijkstra 算法適用，但有時 BFS 可能更適合）<br /></li>
<li>換零錢問題（如面額 {1, 3, 4}，找零 6 時貪婪法選 4, 1, 1，但最佳解應該是 3, 3）<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org29a578e" class="outline-4">
<h4 id="org29a578e"><span class="section-number-4">2.8.16.</span> 第十六題：</h4>
<div class="outline-text-4" id="text-2-8-16">
<p>
Breadth-First-Search is better compared to Depth First Search in the case of: (3%)<br />
</p>
<ol class="org-ol">
<li>the graph’s width is large<br /></li>
<li>the graph’s depth is large<br /></li>
<li>the graph has a large number of nodes<br /></li>
<li>the graph has a large number of edges<br /></li>
</ol>
</div>
<div id="outline-container-orgea61251" class="outline-5">
<h5 id="orgea61251">答案：A. the graph’s width is large</h5>
<div class="outline-text-5" id="text-orgea61251">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>BFS（廣度優先搜尋） 適用於廣度較大的圖（分支多），因為 DFS（深度優先搜尋）在這種情況下會走錯路，導致回溯開銷變大。<br /></li>
<li>DFS 更適合深度大的圖，因為它使用遞迴來深入探索。<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>the graph’s width is large ✅ 正確，BFS 適合橫向擴展的圖<br /></li>
<li>the graph’s depth is large ❌ 錯誤，深度大時 DFS 更適合<br /></li>
<li>the graph has a large number of nodes ❌ 錯誤，節點數量多不一定適用 BFS<br /></li>
<li>the graph has a large number of edges ❌ 錯誤，BFS 和 DFS 都能處理<br /></li>
</ol>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>第 10 題的樹在中序遍歷時，第 10 個節點是 47<br /></li>
<li>佇列的 FIFO 出隊順序是 7325<br /></li>
<li>G 不是割點<br /></li>
<li>快速排序不需要合併<br /></li>
<li>貪婪法不一定能找到最佳解<br /></li>
<li>BFS 適合寬度較大的圖<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org034ef4e" class="outline-4">
<h4 id="org034ef4e"><span class="section-number-4">2.8.17.</span> 第十七題：</h4>
<div class="outline-text-4" id="text-2-8-17">
<p>
What algorithm technique is used in the implementation of Kruskal&rsquo;s solution for the minimum spanning tree? (3%)<br />
</p>
<ol class="org-ol">
<li>greedy technique<br /></li>
<li>divide-and-conquer technique<br /></li>
<li>dynamic programming technique<br /></li>
<li>the algorithm combines more than one of the above techniques<br /></li>
</ol>
</div>
<div id="outline-container-org72d283a" class="outline-5">
<h5 id="org72d283a">答案：A. greedy technique（貪婪法）</h5>
<div class="outline-text-5" id="text-org72d283a">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Kruskal 演算法 用於找出 最小生成樹（MST, Minimum Spanning Tree），它的核心概念是：<br />
<ol class="org-ol">
<li>依照邊的權重從小到大排序。<br /></li>
<li>依序加入權重最小的邊，確保不形成環（Cycle）。<br /></li>
<li>持續添加邊，直到連通所有頂點。<br /></li>
</ol></li>
<li>演算法分類：<br />
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm） ✅ 正確，Kruskal 在每一步選擇當前最小的邊，這是典型的貪婪策略。<br /></li>
<li>分治法（Divide and Conquer） ❌ 錯誤，Kruskal 並沒有將問題拆分成子問題。<br /></li>
<li>動態規劃（Dynamic Programming） ❌ 錯誤，Kruskal 不依賴子問題的最佳解。<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org883b163" class="outline-4">
<h4 id="org883b163"><span class="section-number-4">2.8.18.</span> 第十八題：</h4>
<div class="outline-text-4" id="text-2-8-18">
<p>
Optimal merge pattern is a pattern that relates to the merging of two or more sorted files into a single sorted file. The files f1, f2, f3 are files containing 30, 20, 10 records, respectively. What is the optimal merge value? (4%)<br />
</p>
<ol class="org-ol">
<li>110<br /></li>
<li>90<br /></li>
<li>60<br /></li>
<li>50<br /></li>
</ol>
</div>
<div id="outline-container-org5c071e9" class="outline-5">
<h5 id="org5c071e9">答案：B. 90</h5>
<div class="outline-text-5" id="text-org5c071e9">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Optimal Merge Pattern（最優合併模式）：<br />
<ul class="org-ul">
<li>這是一個 Huffman 編碼問題的變形，利用貪婪法（Greedy Algorithm）。<br /></li>
<li>目標：合併最小的兩個檔案，並反覆執行，直到所有檔案合併完成。<br /></li>
</ul></li>
<li>給定檔案大小：<br />
f1=30，f2=20，f3=10<br /></li>
<li>合併步驟（每次合併都選最小的兩個數字）：<br />
<ul class="org-ul">
<li>合併 10 和 20 → 成為 30（成本 = 30）<br /></li>
<li>合併 30 和 30 → 成為 60（成本 = 60）<br /></li>
</ul></li>
<li>總合併成本：30+60=90<br /></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>110 ❌ 錯誤<br /></li>
<li>90 ✅ 正確<br /></li>
<li>60 ❌ 錯誤<br /></li>
<li>50 ❌ 錯誤<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org446b1db" class="outline-4">
<h4 id="org446b1db"><span class="section-number-4">2.8.19.</span> 第十九題：</h4>
<div class="outline-text-4" id="text-2-8-19">
<p>
If the graph is represented as an adjacency matrix, the time complexity of Kruskal&rsquo;s algorithm is: (4%)<br />
</p>
<ol class="org-ol">
<li>O(ElogV)<br /></li>
<li>O(ElogE)<br /></li>
<li>O(V^2)<br /></li>
<li>O(logE)<br /></li>
</ol>
</div>
<div id="outline-container-org244433d" class="outline-5">
<h5 id="org244433d">答案：B. O(Elog⁡E)O(ElogE)</h5>
<div class="outline-text-5" id="text-org244433d">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>Kruskal 演算法的步驟：<br />
<ol class="org-ol">
<li>對邊排序（使用 O(E log E)）。<br /></li>
<li>使用並查集（Disjoint Set）檢查是否形成環（近乎 O(1)）。<br /></li>
<li>加入最小邊到 MST（最多加 V−1V−1 條邊，O(E)）。<br /></li>
</ol></li>
<li>時間複雜度分析：<br />
<ul class="org-ul">
<li>排序邊的時間： O(Elog⁡E)<br /></li>
<li>查找和合併集合： 近乎 O(1)，所以主要瓶頸在 排序。<br /></li>
</ul></li>
</ul>
<p>
選項分析：<br />
</p>
<ol class="org-ol">
<li>O(Elog⁡V)O(ElogV) ❌ 錯誤<br /></li>
<li>O(Elog⁡E)O(ElogE) ✅ 正確<br /></li>
<li>O(V2)O(V2) ❌ 錯誤，這是 Prim 演算法的時間複雜度<br /></li>
<li>O(log⁡E)O(logE) ❌ 錯誤<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc9eb45f" class="outline-4">
<h4 id="orgc9eb45f"><span class="section-number-4">2.8.20.</span> 第二十題：</h4>
<div class="outline-text-4" id="text-2-8-20">
<p>
In job sequencing problem, each job has a defined deadline and some profit associated with it. The objective is to find a sequence of jobs, which is completed within their deadlines and gives maximum profit. The solution is based on: (4%)<br />
</p>
<ol class="org-ol">
<li>greedy method<br /></li>
<li>branch and bound<br /></li>
<li>dynamic programming<br /></li>
<li>divide and conquer<br /></li>
</ol>
</div>
<div id="outline-container-org9374eb6" class="outline-5">
<h5 id="org9374eb6">答案：A. greedy method（貪婪法）</h5>
<div class="outline-text-5" id="text-org9374eb6">
<p>
解析<br />
</p>
<ul class="org-ul">
<li>工作排序問題（Job Sequencing Problem）：<br />
<ul class="org-ul">
<li>每個工作都有 最後期限（Deadline） 和 利潤（Profit）。<br /></li>
<li>目標：在截止時間內，選擇最大利潤的工作安排方式。<br /></li>
</ul></li>
<li>演算法類型：<br />
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm） ✅ 正確<br />
<ul class="org-ul">
<li>先選擇利潤最高的工作，再將它安排到最晚的可用時段。<br /></li>
</ul></li>
<li>動態規劃（Dynamic Programming） ❌ 錯誤<br /></li>
<li>分支界限法（Branch and Bound） ❌ 錯誤<br /></li>
<li>分治法（Divide and Conquer） ❌ 錯誤<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1b521b4" class="outline-5">
<h5 id="org1b521b4">答案：C. (1, 2, 4)</h5>
<div class="outline-text-5" id="text-org1b521b4">
<p>
解析<br />
給定工作資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">工作</th>
<th scope="col" class="org-right">利潤</th>
<th scope="col" class="org-right">截止時間</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">15</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">10</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
<p>
貪婪法步驟（先選擇利潤最高的工作）：<br />
</p>
<ol class="org-ol">
<li>排序利潤（由高到低）： (1, 2, 4, 3)<br /></li>
<li>選擇可排程的工作（從最後期限開始）<br />
<ul class="org-ul">
<li>1 放在 第 2 個時段<br /></li>
<li>2 放在 第 1 個時段<br /></li>
<li>4 放在 第 3 個時段<br /></li>
<li>3 無法安排（因為 4 已經佔用）<br /></li>
</ul></li>
</ol>
<p>
最佳排序：(1, 2, 4)<br />
</p>
<ul class="org-ul">
<li>選項分析：<br />
<ol class="org-ol">
<li>(1, 3, 4) ❌ 錯誤<br /></li>
<li>(4, 2, 3) ❌ 錯誤<br /></li>
<li>(1, 2, 4) ✅ 正確<br /></li>
<li>None of the above ❌ 錯誤，C 是正確的<br /></li>
</ol></li>
</ul>
<p>
總結<br />
</p>
<ul class="org-ul">
<li>Kruskal 使用貪婪法（Greedy）<br /></li>
<li>Optimal Merge Pattern 最小成本為 90<br /></li>
<li>Kruskal 在鄰接矩陣中的時間複雜度為 O(Elog⁡E)O(ElogE)<br /></li>
<li>Job Sequencing 使用貪婪法<br /></li>
<li>最佳工作選擇為 (1, 2, 4)<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3070f1d" class="outline-4">
<h4 id="org3070f1d"><span class="section-number-4">2.8.21.</span> 第二十一題</h4>
<div class="outline-text-4" id="text-2-8-21">
<p>
Which is the optimal solution in the case of the above problem in which the five jobs have profits 20, 15, 5, 10, 1, and deadlines 2, 2, 3, 3, respectively. (4%)<br />
</p>
<ol class="org-ol">
<li>(1, 3, 4)<br /></li>
<li>(4, 2, 3)<br /></li>
<li>(1, 2, 4)<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-org8e9bc55" class="outline-5">
<h5 id="org8e9bc55">答案：C. (1, 2, 4)</h5>
<div class="outline-text-5" id="text-org8e9bc55">
<p>
解析<br />
給定工作資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">工作</th>
<th scope="col" class="org-right">利潤（Profit）</th>
<th scope="col" class="org-right">截止時間（Deadline）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">15</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">10</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>貪婪法（Greedy Algorithm）解法<br />
<ol class="org-ol">
<li>根據利潤（Profit）由高到低排序：(1, 2, 4, 3, 5)<br /></li>
<li>依序安排，從最後可用時段開始：<br />
<ul class="org-ul">
<li>1 放在 第 2 個時段<br /></li>
<li>2 放在 第 1 個時段<br /></li>
<li>4 放在 第 3 個時段<br /></li>
<li>3 無法安排（因為 4 佔用）<br /></li>
</ul></li>
</ol></li>
<li>最佳排序： (1,2,4)<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>(1, 3, 4) ❌ 錯誤，3 應該無法安排<br /></li>
<li>(4, 2, 3) ❌ 錯誤，1 具有最高利潤，應該被安排<br /></li>
<li>(1, 2, 4) ✅ 正確<br /></li>
<li>None of the above ❌ 錯誤，C 是正確的解答<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgda10f47" class="outline-4">
<h4 id="orgda10f47"><span class="section-number-4">2.8.22.</span> 第二十二題</h4>
<div class="outline-text-4" id="text-2-8-22">
<p>
Given a set of items each having a specific value and weight, the fractional knapsack problem is to find the maximal value of fractions of items that can fit into the knapsack. Which is the optimal value in the above problem for the case that the capacity of knapsack is 10, the five items have values 12, 32, 40, 30, 50, and weights 4, 8, 2, 6, 1, respectively: (4%)<br />
</p>
<ol class="org-ol">
<li>128<br /></li>
<li>124<br /></li>
<li>122<br /></li>
<li>none of the above<br /></li>
</ol>
</div>
<div id="outline-container-org177c8a0" class="outline-5">
<h5 id="org177c8a0">答案：A. 128</h5>
<div class="outline-text-5" id="text-org177c8a0">
<p>
解析<br />
</p>
<ul class="org-ul">
<li><p>
給定物品資訊：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">物品</th>
<th scope="col" class="org-right">價值（Value）</th>
<th scope="col" class="org-right">重量（Weight）</th>
<th scope="col" class="org-right">每單位價值（Value/Weight）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">12</td>
<td class="org-right">4</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">32</td>
<td class="org-right">8</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">40</td>
<td class="org-right">2</td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">30</td>
<td class="org-right">6</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">50</td>
<td class="org-right">1</td>
<td class="org-right">50</td>
</tr>
</tbody>
</table></li>
<li>步驟：<br />
<ol class="org-ol">
<li>根據每單位價值排序：<br />
<ul class="org-ul">
<li>5(50/1) &gt; 3(40/2) &gt; 4(30/6) &gt; 2(32/8) &gt; 1(12/4)<br /></li>
</ul></li>
<li>依序填充背包（容量 10）：<br />
<ul class="org-ul">
<li>取 5（1 重量） → 50<br /></li>
<li>取 3（2 重量） → 50 + 40 = 90<br /></li>
<li>取 4（6 重量） → 90 + 30 = 120<br /></li>
<li>取 2 的 1/2（剩下 1 單位空間，價值 = 32/8 * 2 = 8） → 120 + 8 = 128<br /></li>
</ul></li>
</ol></li>
<li>最優值：128<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>128 ✅ 正確<br /></li>
<li>124 ❌ 錯誤<br /></li>
<li>122 ❌ 錯誤<br /></li>
<li>None of the above ❌ 錯誤，A 是正確答案<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7f397d6" class="outline-4">
<h4 id="org7f397d6"><span class="section-number-4">2.8.23.</span> 問答題1</h4>
<div class="outline-text-4" id="text-2-8-23">
<p>
Let comp1(n) be the number of comparisons performed by quick sort when sorting an array of n components. Let comp2(n) and exchange(n) be the number of comparisons and the number of exchange performed by bubble sort, respectively.<br />
</p>
<ol class="org-ol">
<li>Write down equations defining comp1(n) when n &lt;= 1 and when n &gt; 1 for the best case and for the worst case. (6%)<br />
<ul class="org-ul">
<li>定義 comp1(n)：<br /></li>
<li>最佳情況（Best Case）：<br />
<ul class="org-ul">
<li>樞軸（Pivot）每次將數列平分（T(n) = 2T(n/2) + O(n)）<br /></li>
<li>遞迴深度為 log n<br /></li>
<li>比較次數公式：<br /></li>
<li>comp1(n)=O(nlog⁡n)<br /></li>
</ul></li>
<li>最壞情況（Worst Case）：<br />
<ul class="org-ul">
<li>每次選到最小或最大元素作為樞軸，導致遞迴深度為 n<br /></li>
<li>比較次數公式：<br /></li>
<li>comp1(n)=O(n^2)<br /></li>
</ul></li>
</ul></li>
<li>Derive comp2(n) and exchange(n) for the average case and the best case. (6%)<br />
<ul class="org-ul">
<li>平均情況（Average Case）：<br />
<ul class="org-ul">
<li>comp2(n)=O(n^2)<br /></li>
</ul></li>
<li>最佳情況（Best Case，已排序數列）：<br />
<ul class="org-ul">
<li>comp2(n)=O(n)<br /></li>
</ul></li>
<li>交換次數（Exchange(n)）：<br />
<ul class="org-ul">
<li>平均情況：<br />
<ul class="org-ul">
<li>O(n^2)<br /></li>
</ul></li>
<li>最佳情況（已排序）：<br />
<ul class="org-ul">
<li>O(1)<br /></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgbd45d88" class="outline-4">
<h4 id="orgbd45d88"><span class="section-number-4">2.8.24.</span> 問答2</h4>
<div class="outline-text-4" id="text-2-8-24">
<p>
Design a procedure that takes two arrays, and returns true if the arrays have no elements in common. Your procedure should have time complexity O(nlogm), where n is the size of the larger array and m is the size of the smaller array. (6%)<br />
</p>
<ul class="org-ul">
<li>方法<br />
<ol class="org-ol">
<li>假設 A 是較大的陣列，B 是較小的陣列。<br /></li>
<li>先對 B 進行排序，時間複雜度：O(m log m)<br /></li>
<li>對 A 的每個元素執行二分搜尋（Binary Search）：<br />
<ul class="org-ul">
<li>在 B 中搜尋每個元素，時間複雜度 O(n log m)。<br /></li>
</ul></li>
</ol></li>
<li><p>
程式碼（C++ 或 Python） C++ 版本<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;iostream&gt;</span>
<span class="linenr"> 2: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;vector&gt;</span>
<span class="linenr"> 3: </span><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">&lt;algorithm&gt;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #51afef;">using</span> <span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">hasNoCommonElements</span>(<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">A</span>, <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;&amp; <span style="color: #dcaeea;">B</span>) {
<span class="linenr"> 8: </span>    sort(B.begin(), B.end()); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(m log m)</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">num</span> : A) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(n)</span>
<span class="linenr">11: </span>        <span style="color: #51afef;">if</span> (binary_search(B.begin(), B.end(), num)) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">O(log m)</span>
<span class="linenr">12: </span>            <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">false</span>;
<span class="linenr">13: </span>        }
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">true</span>;
<span class="linenr">16: </span>}
<span class="linenr">17: </span>
<span class="linenr">18: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
<span class="linenr">19: </span>    <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">A</span> = {<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">15</span>};
<span class="linenr">20: </span>    <span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">int</span>&gt; <span style="color: #dcaeea;">B</span> = {<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">11</span>};
<span class="linenr">21: </span>
<span class="linenr">22: </span>    cout &lt;&lt; (hasNoCommonElements(A, B) ? <span style="color: #98be65;">"True"</span> : <span style="color: #98be65;">"False"</span>) &lt;&lt; endl;
<span class="linenr">23: </span>    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">24: </span>}
</pre>
</div></li>
<li><p>
Python 版本<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">has_no_common_elements</span>(A, B):
<span class="linenr"> 3: </span>    B.sort()  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">O(m log m)</span>
<span class="linenr"> 4: </span>    <span style="color: #51afef;">for</span> num <span style="color: #51afef;">in</span> A:  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">O(n)</span>
<span class="linenr"> 5: </span>        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Binary search in B, O(log m)</span>
<span class="linenr"> 6: </span>        <span style="color: #dcaeea;">left</span>, <span style="color: #dcaeea;">right</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #c678dd;">len</span>(B) - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr"> 7: </span>        <span style="color: #51afef;">while</span> left &lt;= right:
<span class="linenr"> 8: </span>            <span style="color: #dcaeea;">mid</span> = (left + right) // <span style="color: #da8548; font-weight: bold;">2</span>
<span class="linenr"> 9: </span>            <span style="color: #51afef;">if</span> B[mid] == num:
<span class="linenr">10: </span>                <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">False</span>
<span class="linenr">11: </span>            <span style="color: #51afef;">elif</span> B[mid] &lt; num:
<span class="linenr">12: </span>                <span style="color: #dcaeea;">left</span> = mid + <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">13: </span>            <span style="color: #51afef;">else</span>:
<span class="linenr">14: </span>                <span style="color: #dcaeea;">right</span> = mid - <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">15: </span>    <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">True</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span><span style="color: #dcaeea;">A</span> = [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">15</span>]
<span class="linenr">18: </span><span style="color: #dcaeea;">B</span> = [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">11</span>]
<span class="linenr">19: </span><span style="color: #c678dd;">print</span>(has_no_common_elements(A, B))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">True</span>
</pre>
</div></li>
<li>時間複雜度分析<br />
<ol class="org-ol">
<li>排序 B：O(mlog⁡m)O(mlogm)<br /></li>
<li>對 A 的每個元素執行二分搜尋：<br />
<ul class="org-ul">
<li>O(nlog⁡m)O(nlogm)（假設 A 為較大陣列）<br /></li>
</ul></li>
<li>總時間複雜度：<br />
O(mlogm)+O(nlogm)=O(nlogm)<br /></li>
</ol></li>
<li>總結<br />
<ol class="org-ol">
<li>工作排序最佳解：(1,2,4)<br /></li>
<li>分數背包最佳值：128<br /></li>
<li>Quick Sort 與 Bubble Sort 比較次數分析<br /></li>
<li>O(n log m) 方法檢查兩陣列是否有共同元素<br /></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgef718f2" class="outline-3">
<h3 id="orgef718f2"><span class="section-number-3">2.9.</span> 112: 中山計概</h3>
<div class="outline-text-3" id="text-2-9">
<ol class="org-ol">
<li>A network switch uses a <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> that is very similar to a routing table used in a router. A. hash table B. forwarding table C. contingency table D. reversing table<br />
<ul class="org-ul">
<li>答案：B. Forwarding Table（轉發表）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>交換器（Switch） 透過 轉發表（Forwarding Table） 來決定封包應該被發送到哪個埠口（Port）。<br /></li>
<li>類似路由器（Router） 使用的 路由表（Routing Table），但 Switch 在第二層（Layer 2）運作，而 Router 在第三層（Layer 3）運作。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Hash Table（雜湊表） ❌ 錯誤，雜湊表是用來提高搜尋效率的資料結構，不是交換器的核心機制。<br /></li>
<li>Forwarding Table（轉發表） ✅ 正確，交換器使用的表來決定封包發送方向。<br /></li>
<li>Contingency Table（應急表） ❌ 錯誤，與統計分析有關，與網路設備無關。<br /></li>
<li>Reversing Table（反向表） ❌ 錯誤，沒有這個網路設備的術語。<br /></li>
</ol></li>
</ul></li>
<li>Encryption is the process of A. transmitting information over secure lines to prevent illegal access. B. detecting errors in messages by using mathematical rules. C. preventing errors in messages by using logical rules. D. disguising information by using mathematical rules.<br />
<ul class="org-ul">
<li>答案：D. Disguising information by using mathematical rules（使用數學規則來偽裝資訊）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>加密（Encryption） 透過數學演算法將 原始訊息轉換成無法輕易理解的格式，以保護資料安全。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>對稱加密（AES、DES）<br /></li>
<li>非對稱加密（RSA、ECC）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Transmitting information over secure lines（透過安全線路傳輸資訊） ❌ 錯誤，這是 VPN 或 TLS 的作用，不是加密的本質。<br /></li>
<li>Detecting errors in messages（使用數學規則檢測錯誤） ❌ 錯誤，這描述的是錯誤檢測（如 CRC、Hamming Code）。<br /></li>
<li>Preventing errors in messages（使用邏輯規則防止錯誤） ❌ 錯誤，這描述的是錯誤修正（如 Reed-Solomon、ECC）。<br /></li>
<li>Disguising information by using mathematical rules（使用數學規則來偽裝資訊） ✅ 正確，這是加密的本質。<br /></li>
</ol></li>
</ul></li>
</ul></li>
<li>Public blockchains usually use <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> as the consensus mechanism to validate transactions. A. proof of concept B. proof of payment C. proof of reserve D. proof of work<br />
<ul class="org-ul">
<li>答案：D. Proof of Work（工作量證明，PoW）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>共識機制（Consensus Mechanism） 是區塊鏈用來驗證交易的機制。<br /></li>
<li>公有鏈（Public Blockchain） 常使用 工作量證明（Proof of Work，PoW），如 比特幣（Bitcoin）和以太坊（Ethereum 1.0）。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Proof of Concept（概念驗證） ❌ 錯誤，PoC 是用來測試技術可行性的概念，不是區塊鏈共識機制。<br /></li>
<li>Proof of Payment（付款證明） ❌ 錯誤，這不是區塊鏈的共識機制。<br /></li>
<li>Proof of Reserve（儲備證明） ❌ 錯誤，這是用來證明某個機構擁有足夠的資金儲備。<br /></li>
<li>Proof of Work（工作量證明） ✅ 正確，PoW 是比特幣、以太坊（ETH 1.0）等公有鏈使用的共識機制。<br /></li>
</ol></li>
</ul></li>
<li>What does NFT stand for? A. Non-functional token. B. Non-fungible token. C. New frequency technology. D. Nano-finance technology.<br />
<ul class="org-ul">
<li>答案：B. Non-Fungible Token（非同質化代幣）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>NFT（非同質化代幣） 是一種基於區塊鏈的數位資產，每個 NFT 具有唯一性、不可互換性，用於代表 數位藝術品、收藏品、虛擬資產等。<br /></li>
</ul></li>
<li>例如：<br />
<ul class="org-ul">
<li>Beeple 的 NFT 作品拍賣 6900 萬美元<br /></li>
<li>遊戲 NFT（Axie Infinity、Decentraland）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Non-functional token（非功能性代幣） ❌ 錯誤，NFT 不是這個意思。<br /></li>
<li>Non-fungible token（非同質化代幣） ✅ 正確，NFT 的全名。<br /></li>
<li>New frequency technology（新頻率技術） ❌ 錯誤，這不是 NFT 的概念。<br /></li>
<li>Nano-finance technology（奈米金融技術） ❌ 錯誤，這與 NFT 無關。<br /></li>
</ol></li>
</ul></li>
<li>In the UML, the top compartment of the rectangle modeling a class contains: A. The class&rsquo;s name. B. The class&rsquo;s attributes. C. The class&rsquo;s behaviors. D. All of the above.<br />
<ul class="org-ul">
<li>答案：A. The class&rsquo;s name（類別名稱）<br /></li>
<li>解析: 在 UML 類別圖（Unified Modeling Language Class Diagram） 中：<br />
<ul class="org-ul">
<li>矩形的最上方區塊（Top Compartment） → 類別名稱（Class Name）<br /></li>
<li>中間區塊（Middle Compartment） → 屬性（Attributes）<br /></li>
<li>底部區塊（Bottom Compartment） → 行為/方法（Methods/Behaviors）<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>The class&rsquo;s name（類別名稱） ✅ 正確，UML 類別圖的最上層包含類別名稱。<br /></li>
<li>The class&rsquo;s attributes（類別屬性） ❌ 錯誤，屬性在中間區塊。<br /></li>
<li>The class&rsquo;s behaviors（類別行為/方法） ❌ 錯誤，行為在底部區塊。<br /></li>
<li>All of the above（以上皆是） ❌ 錯誤，最上層只包含類別名稱。<br /></li>
</ol></li>
</ul></li>
<li><p>
Which of the following is the inorder traversal of the binary search tree?<br />
</p>
<pre class="example" id="org893292a">
          7
         / \
        /   \
       5     8
      / \   / \
     4   3 9   1
    /
   2
</pre>
<ol class="org-ol">
<li>24359187. B. 75423891. C. 24537981. D. None of the above.<br /></li>
<li>答案：D. None of the above<br /></li>
<li><p>
解析<br />
</p>
<ul class="org-ul">
<li>中序遍歷（Inorder Traversal） 的順序為：<br />
<ul class="org-ul">
<li>左子樹<br /></li>
<li>根節點<br /></li>
<li>右子樹<br /></li>
</ul></li>
<li><p>
檢查給定的 BST（但該樹的結構有誤）<br />
</p>
<pre class="example" id="orgeee752e">
               7
              / \
             /   \
            5     8
           / \   / \
          4   3 9   1
         /
        2
</pre>
<ul class="org-ul">
<li>在 BST（Binary Search Tree） 中，左子節點的值應小於根，右子節點的值應大於根。<br /></li>
<li>但此樹結構 有錯誤：<br />
<ul class="org-ul">
<li>節點 3 應該在 5 的左子節點，而非右子節點<br /></li>
<li>節點 1 應該在 8 的左子節點，而非右子節點<br /></li>
</ul></li>
<li>正確的中序遍歷<br /></li>
<li><p>
如果修正 BST 結構，假設樹的正確結構應該是：<br />
</p>
<pre class="example" id="orga308e9e">
                7
               / \
              5   8
             / \    \
            4   6    9
           /
          2
</pre></li>
<li>則 中序遍歷順序為：<br />
<ul class="org-ul">
<li>2,4,5,6,7,8,9<br /></li>
<li>2,4,5,6,7,8,9<br /></li>
</ul></li>
</ul></li>
</ul>

<ul class="org-ul">
<li>但根據原始題目提供的選項，均不符合正確的 BST 遍歷順序，因此答案為 D（None of the above）。<br /></li>
<li><p>
選項分析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">遍歷順序</th>
<th scope="col" class="org-left">是否正確？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A. 24359187</td>
<td class="org-left">順序錯誤（5 應該在 4 之後，而 9 不能在 1 之前）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">B. 75423891</td>
<td class="org-left">順序錯誤（應該先遍歷左子樹，但 7 在開頭）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">C. 24537981</td>
<td class="org-left">順序錯誤（1 應該在 7 之前，而 9 應該在 8 之後）</td>
<td class="org-left">❌</td>
</tr>

<tr>
<td class="org-left">D. None of the above</td>
<td class="org-left">正確，因為選項中無正確的中序遍歷</td>
<td class="org-left">✅</td>
</tr>
</tbody>
</table></li>
<li>結論: 因為給定的樹並非有效的 BST，且所有選項的遍歷順序都不符合中序遍歷的定義，所以答案為 D（None of the above）。<br /></li>
</ul></li>
</ol></li>
<li>What is the subnet number of the IP address 10.0.17.130 with the subnet mask 255.255.255.192? A. 10.0.0.0 B. 10.0.17.0 C. 10.0.17.128 D. 10.0.17.192<br />
<ul class="org-ul">
<li>答案：C. 10.0.17.128<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>給定 IP 地址：10.0.17.130<br /></li>
<li>子網遮罩（Subnet Mask）：255.255.255.192（/26）<br /></li>
</ul></li>
<li>計算子網 ID（Subnet ID）：<br />
<ul class="org-ul">
<li>子網大小：<br /></li>
<li>\( 2^{32-26}=2^6=64 \)<br /></li>
<li>每個子網的範圍為 64 個 IP 地址。<br /></li>
</ul></li>
<li>找出子網範圍：<br />
<ul class="org-ul">
<li>子網範圍：10.0.17.0、10.0.17.64、10.0.17.128、10.0.17.192<br /></li>
<li>10.0.17.130 落在 10.0.17.128 - 10.0.17.191 之間。<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>10.0.0.0 ❌ 錯誤，這是更大的網段<br /></li>
<li>10.0.17.0 ❌ 錯誤，這是 10.0.17.0/26<br /></li>
<li>10.0.17.128 ✅ 正確，這是 10.0.17.128/26<br /></li>
<li>10.0.17.192 ❌ 錯誤，這是下一個子網的開始<br /></li>
</ol></li>
</ul></li>
<li>When a client code programmer uses a class whose implementation is in a separate file from its interface, that implementation code is merged with the client&rsquo;s code during the A. programming phase. B. compiling phase. C. linking phase. D. executing phase.<br />
<ul class="org-ul">
<li>答案：C. Linking Phase（連結階段）<br /></li>
<li>解析: 當程式的 實作檔案（Implementation File） 與 介面檔案（Header File） 分開時，連結器（Linker） 在 連結階段（Linking Phase） 將它們合併，生成最終的可執行檔案。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>Programming Phase（程式設計階段） ❌ 錯誤，程式設計時只是撰寫代碼，尚未合併<br /></li>
<li>Compiling Phase（編譯階段） ❌ 錯誤，編譯階段只將單個文件轉換為目標碼<br /></li>
<li>Linking Phase（連結階段） ✅ 正確，這是合併程式碼的階段<br /></li>
<li>Executing Phase（執行階段） ❌ 錯誤，執行階段已經完成編譯和連結<br /></li>
</ol></li>
</ul></li>
<li>TCP/IP relies on the <span class="underline"><span class="underline"><span class="underline"><span class="underline">__</span></span></span></span> to decide to which application a message should be delivered. A. MAC address B. SSID C. IP address D. port number<br />
<ul class="org-ul">
<li>答案：D. Port Number（連接埠號碼）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>TCP/IP 使用「連接埠（Port）」來識別應用程式。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>HTTP 伺服器 → 連接埠 80<br /></li>
<li>HTTPS 伺服器 → 連接埠 443<br /></li>
<li>SSH 伺服器 → 連接埠 22<br /></li>
</ul></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>MAC Address（MAC 地址） ❌ 錯誤，MAC 地址用於區域網路（Layer 2）<br /></li>
<li>SSID（Wi-Fi 網路名稱） ❌ 錯誤，SSID 用於識別無線網路<br /></li>
<li>IP Address（IP 地址） ❌ 錯誤，IP 地址識別主機，而非應用程式<br /></li>
<li>Port Number（連接埠號碼） ✅ 正確，TCP/IP 透過 Port 決定應用程式<br /></li>
</ol></li>
</ul></li>
<li><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span> is used to perform IP address to data link address resolution. A. ARP B. DNS C. HTTP D. NAT<br />
<ul class="org-ul">
<li>答案：A. ARP（地址解析協定）<br /></li>
<li>解析: ARP（Address Resolution Protocol） 用於將 IP 地址解析為 MAC 地址，用於本地網路的通訊。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>ARP ✅ 正確，負責解析 IP 到 MAC<br /></li>
<li>DNS ❌ 錯誤，DNS 將域名解析為 IP<br /></li>
<li>HTTP ❌ 錯誤，HTTP 是網路協議，與 IP 解析無關<br /></li>
<li>NAT ❌ 錯誤，NAT 用於 IP 轉換，而非解析 MAC 地址<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about system calls is wrong? A. System calls are an interface for accessing computer resources. B. System calls can only be executed under kernel mode. C. The dual mode is to protect systems from malware attacks. D. All input or output functions in a program must get through system calls.<br />
<ul class="org-ul">
<li>答案：D. All input or output functions in a program must get through system calls（所有輸入/輸出都必須透過系統呼叫）<br /></li>
<li>解析: 系統呼叫（System Call）是應用程式訪問作業系統內核的方法，但 某些輸入/輸出（I/O）函式不一定要經過系統呼叫，如：<br />
<ul class="org-ul">
<li>用戶空間（User Space）快取<br /></li>
<li>標準函式庫緩存<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>System calls are an interface for accessing computer resources ✅ 正確<br /></li>
<li>System calls can only be executed under kernel mode ✅ 正確<br /></li>
<li>The dual mode is to protect systems from malware attacks ✅ 正確<br /></li>
<li>All input or output functions in a program must get through system calls ❌ 錯誤，因為有些 I/O 可能在用戶空間執行<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about databases is wrong?<br />
<ol class="org-ol">
<li>All relational databases use the same query language to access databases.<br /></li>
<li>In relational databases, every table is indexed by a key.<br /></li>
<li>SQL is not used for accessing NoSQL databases.<br /></li>
<li>NoSQL databases use key-value to access data. Therefore, a table can be indexed by the key.<br /></li>
<li>答案：A. All relational databases use the same query language to access databases（所有關聯式資料庫使用相同的查詢語言）<br /></li>
<li>解析: SQL（結構化查詢語言） 是大多數關聯式資料庫使用的語言，但不同資料庫（如 MySQL、PostgreSQL、SQL Server）具有不同的 SQL 方言（Dialect），並非所有關聯式資料庫都完全相同。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>All relational databases use the same query language ❌ 錯誤，因為 SQL 在不同資料庫之間有方言差異<br /></li>
<li>In relational databases, every table is indexed by a key ✅ 正確<br /></li>
<li>SQL is not used for accessing NoSQL databases ✅ 正確，NoSQL 使用不同方法，如 Key-Value 存取<br /></li>
<li>NoSQL databases use key-value to access data ✅ 正確<br /></li>
</ol></li>
</ol></li>
<li>Which one of the following statements about the Internet of Things (IoT) is wrong? A. An IoT device refers to an object that has network access. B. IoT devices can be accessed through WLAN, but not WAN. C. Bluetooth earphones are IoT devices. D. If an IoT device connect to the internet, it might be compromised by attackers.<br />
<ul class="org-ul">
<li>答案：B. IoT devices can be accessed through WLAN, but not WAN（物聯網設備只能透過 WLAN 連接，不能透過 WAN 連接）<br /></li>
<li>解析: IoT 設備可以透過 WLAN（無線局域網）或 WAN（廣域網）存取。<br /></li>
<li>例如：<br />
<ul class="org-ul">
<li>智慧家電透過 WLAN 連接 Wi-Fi 路由器<br /></li>
<li>GPS 追蹤設備透過 WAN（如 4G/5G）連接<br /></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>An IoT device refers to an object that has network access ✅ 正確<br /></li>
<li>IoT devices can be accessed through WLAN, but not WAN ❌ 錯誤，IoT 設備可以透過 WLAN 或 WAN 存取<br /></li>
<li>Bluetooth earphones are IoT devices ✅ 正確<br /></li>
<li>If an IoT device connects to the internet, it might be compromised by attackers ✅ 正確，IoT 設備連接網路後可能受到攻擊<br /></li>
</ol></li>
</ul></li>
<li>Assume that there is a three-frame physical memory in the system. Initially, all frames are empty. Given the reference string: abcdbaefacbic. How many page faults are generated if LRU is used? A. 6 B. 7 C. 8 D. 9<br />
<ul class="org-ul">
<li>答案：C. 8<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>LRU（Least Recently Used）：當記憶體滿時，替換最近最少使用（LRU）的頁面。<br /></li>
<li>三個記憶體框架（frame），最初為空。<br /></li>
<li>參考字串（Reference String）：<br />
a b c d b a e f a c b i c<br /></li>
<li>模擬 LRU 置換（用 - 代表空框）：<br />
時間  1  2  3  4  5  6  7  8  9 10 11 12 13<br />
記憶  a  a  a  d  d  d  e  f  f  c  c  c  c<br />
<ul class="org-ul">
<li>b  b  b  b  a  a  a  a  a  a  i  i<br /></li>
<li>-  c  c  c  c  c  f  f  b  b  b  c<br /></li>
</ul></li>
<li>頁面錯誤（Page Faults）發生次數：<br />
<ul class="org-ul">
<li>a（錯誤）<br /></li>
<li>b（錯誤）<br /></li>
<li>c（錯誤）<br /></li>
<li>d（錯誤，淘汰 a）<br /></li>
<li>b（命中）<br /></li>
<li>a（錯誤，淘汰 c）<br /></li>
<li>e（錯誤，淘汰 d）<br /></li>
<li>f（錯誤，淘汰 b）<br /></li>
<li>a（命中）<br /></li>
<li>c（錯誤，淘汰 e）<br /></li>
<li>b（錯誤，淘汰 f）<br /></li>
<li>i（錯誤，淘汰 a）<br /></li>
<li>c（命中）<br /></li>
<li>總計 8 次 page faults，答案為 C. 8。<br /></li>
</ul></li>
</ul></li>
</ul></li>
<li>There is a fake coin in a pile of N coins, whereas a fake one has a lighter weight. There are two possible ways to identify the fake coin: sequential search or divide-and-conquer. Which one of the following statements is wrong?<br />
<ol class="org-ol">
<li>The time complexity of the divide-and-conquer is O(logN).<br /></li>
<li>The time complexity of the sequential search is O(N).<br /></li>
<li>The best case of sequential search takes 1 comparison.<br /></li>
<li>The best case of divide-and-conquer takes 1 comparison.<br /></li>
<li>答案：D. The best case of divide-and-conquer takes 1 comparison.（分治法的最佳情況只需 1 次比較）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>順序搜尋（Sequential Search）：<br />
<ul class="org-ul">
<li>時間複雜度：O(N)<br /></li>
<li>最好的情況（Best Case）：1 次比較（第一枚硬幣就是假幣）。<br /></li>
</ul></li>
<li>分治法（Divide-and-Conquer）：<br />
<ul class="org-ul">
<li>時間複雜度：O(log N)（每次將硬幣數量減半）。<br /></li>
<li>最好的情況（Best Case）：理論上不可能 1 次比較就找到假幣，因為天平至少要稱 2 組硬幣來進行比較。<br /></li>
</ul></li>
</ul></li>

<li>選項分析：<br />
<ol class="org-ol">
<li>O(log N)（分治法時間複雜度） ✅ 正確<br /></li>
<li>O(N)（順序搜尋時間複雜度） ✅ 正確<br /></li>
<li>最好的情況下，順序搜尋只需 1 次比較 ✅ 正確<br /></li>
<li>最好的情況下，分治法只需 1 次比較 ❌ 錯誤，至少需要 2 次比較<br /></li>
</ol></li>
</ol></li>
<li>Which one of the following statements is wrong? A. Users use the client-server model to access web servers. B. Peers can be attacked by web browsing. C. In the client-server model, a client makes a request and the server sends back the response, so a web server cannot be attacked by a web user. D. The username/password is a common user authentication mechanism for users to access a web server.<br />
<ul class="org-ul">
<li>答案：C. In the client-server model, a web server cannot be attacked by a web user.（網頁伺服器不會被用戶攻擊）<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>Web 伺服器可以被攻擊，例如：<br />
<ul class="org-ul">
<li>DDoS 攻擊（大量請求導致伺服器崩潰）<br /></li>
<li>SQL 注入攻擊（惡意 SQL 語法）<br /></li>
<li>XSS 攻擊（惡意 JavaScript 代碼）<br /></li>
</ul></li>
</ul></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>客戶端-伺服器模型可用來存取 Web 伺服器 ✅ 正確<br /></li>
<li>對等網路（P2P）也可能因為瀏覽網頁而被攻擊 ✅ 正確<br /></li>
<li>網頁伺服器不能被用戶攻擊 ❌ 錯誤，Web 伺服器可能被攻擊<br /></li>
<li>使用者名稱/密碼是常見的身份驗證機制 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>One’s complement (1’s complement) and two’s complement (2’s complement) are used to represent signed integers. Which one of the following statements is wrong? A. Given a K-bit register, the range of signed integers that can be represented by 2’s complement is between -(2^(k-1)) and (2^(k-1) - 1). B. In 2’s complement, 110010 represents -14. C. To get 2’s complement of a binary number, invert the given number and add 1 to the least significant bit (LSB) of the given result. D. In 1’s complement, 1111 represents 0, while in 2’s complement, 1111 represents -1.<br />
<ul class="org-ul">
<li>答案：B. In 2’s complement, 110010 represents -14.（二補數表示 110010 為 -14）<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>確認位元數：<br />
<ul class="org-ul">
<li>110010 共有 6 位元（K=6）。<br /></li>
</ul></li>
<li>二補數（2’s complement）轉換：<br />
<ul class="org-ul">
<li>110010（原碼）<br /></li>
<li>取補數（反轉所有位元）：001101<br /></li>
<li>加 1：001110（二進位 14）<br /></li>
<li>因此 110010 = -14（錯誤）<br /></li>
<li>應該是 -50，而不是 -14<br /></li>
</ul></li>
</ol></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>K 位元的二補數範圍是：−2(K−1)−2(K−1) 到 2(K−1)−12(K−1)−1 ✅ 正確<br /></li>
<li>110010 代表 -14 ❌ 錯誤，實際上是 -50<br /></li>
<li>取得二補數的方法是「反轉 + 1」 ✅ 正確<br /></li>
<li>一補數 1111 表示 0，二補數 1111 表示 -1 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Many applications such as banking services use relational database management systems (RDMS) to process user data, RDMS fulfill the ACID properties. Which one of the following statements about relational databases is wrong? A. Atomicity property guarantees that each transaction is treated as a single operation. B. Entity-Relation models contain two major elements: entity and relationship. C. RDMS use locks to ensure that at any time only one user changes the data. D. Consistency property ensures that the data is in a consistent state all the time.<br />
<ul class="org-ul">
<li>答案：C. RDMS use locks to ensure that at any time only one user changes the data.（RDBMS 使用鎖確保只有一個用戶能修改數據）<br /></li>
<li>解析: 資料庫管理系統（RDBMS）使用多種鎖定機制，但不一定 「任何時間都只有一個用戶可以更改數據」，它通常允許多個用戶 並行存取（Concurrency Control）。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>原子性（Atomicity）保證交易為單一操作 ✅ 正確<br /></li>
<li>ER 模型包含實體與關係 ✅ 正確<br /></li>
<li>RDBMS 確保同時只有一個用戶可改變數據 ❌ 錯誤，支援多用戶並發控制<br /></li>
<li>一致性（Consistency）確保數據一致 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which one of the following statements about cloud computing is wrong? A. There are three types of cloud computing: IaaS, PaaS, and SaaS. B. IaaS mainly provides virtual machines with the given hardware specs you need. C. Cloud computing is a type of distributed computing that requires high-speed networks. D. Cloud computing is often used for big data analysis so that a large amount of data can be stored and processed in a single machine.<br />
<ul class="org-ul">
<li>答案：D. Cloud computing stores and processes big data in a single machine.（雲端運算將大數據存放並處理於單一機器）<br /></li>
<li>解析: 雲端運算使用分散式系統（Distributed Computing） 處理大量數據，而不是 單一機器。<br /></li>
<li>選項分析：<br />
<ol class="org-ol">
<li>IaaS、PaaS、SaaS 是雲端運算的三種模型 ✅ 正確<br /></li>
<li>IaaS 提供虛擬機與硬體資源 ✅ 正確<br /></li>
<li>雲端運算需要高速網路 ✅ 正確<br /></li>
<li>雲端運算使用單一機器處理大數據 ❌ 錯誤，應該使用分散式架構<br /></li>
</ol></li>
</ul></li>
<li><p>
A piece of code below declares a doubly linked list. Assuming that the node curNode is not the head or the last node of the list, which one of the following pieces of code is to delete the node curNode?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span>
<span class="linenr">2: </span>    {
<span class="linenr">3: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">prev</span>;
<span class="linenr">4: </span>        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">data</span>;
<span class="linenr">5: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">next</span>;
<span class="linenr">6: </span>        <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">node</span> *<span style="color: #dcaeea;">head</span>;
<span class="linenr">7: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
<li>curNode-&gt;prev-&gt;next = curNode-&gt;prev;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;next;<br /></li>
<li>curNode-&gt;next-&gt;next = curNode-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev-&gt;next;<br />
curNode-&gt;next-&gt;prev = curNode-&gt;next-&gt;prev;<br /></li>
<li>答案：A<br />
<ul class="org-ul">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;next;<br /></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev;<br /></li>
</ul></li>
<li>解析: 雙向鏈結串列（Doubly Linked List） 的特性：<br />
<ul class="org-ul">
<li>每個節點有兩個指標：<br />
<ul class="org-ul">
<li>prev 指向前一個節點。<br /></li>
<li>next 指向下一個節點。<br /></li>
</ul></li>
<li>刪除 curNode 的步驟<br />
<ul class="org-ul">
<li>將 curNode 的前一個節點的 next 指向 curNode-&gt;next<br /></li>
<li>將 curNode 的下一個節點的 prev 指向 curNode-&gt;prev<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>curNode-&gt;prev-&gt;next = curNode-&gt;prev;<br />
<ul class="org-ul">
<li>錯誤，這樣會讓 prev-&gt;next 指向自己，鏈結錯誤。<br /></li>
</ul></li>
<li>curNode-&gt;next-&gt;next = curNode-&gt;next;<br />
<ul class="org-ul">
<li>錯誤，修改 next-&gt;next，不會改變 prev。<br /></li>
</ul></li>
<li>curNode-&gt;next-&gt;prev = curNode-&gt;prev-&gt;next;<br />
<ul class="org-ul">
<li>錯誤，prev-&gt;next 本來就指向 curNode，這樣 curNode-&gt;next-&gt;prev 會錯誤指向 curNode 本身。<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li>(複選) Which one of the following is(are) supervised learning? A. Support vector machine. B. Naive Bayes classifier. C. K-nearest neighbors. D. Convolutional neural networks. E. K-means clustering.<br />
<ul class="org-ul">
<li>答案：A, B, C, D<br /></li>
<li>解析: 監督式學習（Supervised Learning）：需要有標籤（Label）的訓練數據。<br />
<ol class="org-ol">
<li>Support Vector Machine（SVM） ✅<br /></li>
<li>Naive Bayes Classifier ✅<br /></li>
<li>K-Nearest Neighbors（KNN） ✅<br /></li>
<li>Convolutional Neural Networks（CNN） ✅<br /></li>
<li>K-Means Clustering ❌（這是非監督式學習）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following processor families is(are) based on ARM architecture? A. AMD Ryzen. B. Apple Silicon. C. Qualcomm Snapdragon. D. Samsung Exynos. E. Nvidia Tegra.<br />
<ul class="org-ul">
<li>答案：B, C, D, E<br /></li>
<li>解析: ARM 架構 是一種精簡指令集（RISC）。<br />
<ol class="org-ol">
<li>Apple Silicon（M1, M2, M3） ✅<br /></li>
<li>Qualcomm Snapdragon（手機 SoC） ✅<br /></li>
<li>Samsung Exynos ✅<br /></li>
<li>Nvidia Tegra（如 Switch 遊戲機） ✅<br /></li>
<li>AMD Ryzen ❌（x86 架構）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following is(are) based on a convolutional neural network? A. WordNet. B. ResNet. C. Inception. D. ImageNet. E. GoogLeNet.<br />
<ul class="org-ul">
<li>答案：B, C, E<br /></li>
<li>解析: CNN 相關模型<br />
<ul class="org-ul">
<li>B. ResNet ✅<br /></li>
<li>C. Inception ✅<br /></li>
<li>E. GoogLeNet ✅<br /></li>
<li>A. WordNet ❌（詞彙網路）<br /></li>
<li>D. ImageNet ❌（資料庫，不是 CNN）<br /></li>
</ul></li>
</ul></li>
<li>(複選) Which one(s) of the following programming languages is(are) executed by an interpreter? A. Python B. Matlab C. C D. R E. Assembly<br />
<ul class="org-ul">
<li>答案：A, B, D<br /></li>
<li>解析: 直譯語言（Interpreted Language）<br />
<ol class="org-ol">
<li>Python ✅<br /></li>
<li>Matlab ✅<br /></li>
<li>R ✅<br /></li>
<li>C ❌（編譯語言）<br /></li>
<li>Assembly ❌（組合語言，依賴 CPU 指令）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following mechanisms has(have) been utilized to achieve differential privacy? A. Linear mechanism. B. Laplace mechanism. C. Exponential mechanism. D. Gaussian mechanism. E. Triangular mechanism.<br />
<ul class="org-ul">
<li>答案：B, C, D<br /></li>
<li>解析: 差分隱私（Differential Privacy）機制<br />
<ul class="org-ul">
<li>B. Laplace Mechanism ✅<br /></li>
<li>C. Exponential Mechanism ✅<br /></li>
<li>D. Gaussian Mechanism ✅<br /></li>
<li>A. Linear Mechanism ❌<br /></li>
<li>E. Triangular Mechanism ❌<br /></li>
</ul></li>
</ul></li>
<li>(複選) Which one of the following statements is(are) correct? A. By using virtualization technologies, a physical machine can become multiple machines of different operating systems. B. Virtualization can make programs run faster. C. Virtualization technologies can virtualize RAM and CPU, but not network. D. Virtualization can protect machines from system crashes.<br />
<ul class="org-ul">
<li>答案：A, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>虛擬化技術可讓一台實體機器運行不同 OS ✅<br /></li>
<li>虛擬化可隔離系統崩潰 ✅<br /></li>
<li>虛擬化無法提升程式執行速度 ❌<br /></li>
<li>虛擬化也可虛擬網路（如虛擬交換器） ❌<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one of the following statements about algorithms is/are correct? A. A flowchart is a way of presenting an algorithm. B. An algorithm is used to describe a problem solution. C. Algorithms can be only used for computer programming. D. Pseudocode describes more precisely than a flowchart.<br />
<ul class="org-ul">
<li>答案：A, B, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>流程圖（Flowchart）可視化演算法 ✅<br /></li>
<li>演算法描述問題的解決方法 ✅<br /></li>
<li>偽代碼（Pseudocode）比流程圖更精確 ✅<br /></li>
<li>演算法不僅限於程式設計 ❌<br /></li>
</ol></li>
</ul></li>
<li>(複選) Given a directed weighted graph G(V, E), where there are N vertices and M edges in graph G. The graph is represented by an adjacent matrix. Which one(s) of the following statements is/are correct? A. A greedy algorithm can find an optimal path of a single source to a single destination. B. It takes the time complexity of O(N^3) to find optimal paths of all sources to all destinations. C. A greedy algorithm can find optimal paths of a single source to all destinations. D. A solution for a single source to all destinations must be a tree structure.<br />
<ul class="org-ul">
<li>答案：B, C<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>貪婪演算法能找最短單源單點路徑 ❌（不一定，視演算法而定）<br /></li>
<li>全點對最短路徑時間複雜度為 O(N³) ✅（Floyd-Warshall）<br /></li>
<li>Dijkstra 可求單源最短路徑 ✅<br /></li>
<li>單源最短路徑不一定是樹 ❌（可能形成環）<br /></li>
</ol></li>
</ul></li>
<li>(複選) Which one(s) of the following statements about sorting is/are correct? A. Quick sort is a divide-and-conquer algorithm, so its worst-case time complexity is O(nlogn). B. Merge sort takes less time complexity, O(nlogn), than insertion sort and as much space as insertion sort. C. A binary search tree allows fast lookup, but the time complexity of a search on a binary search tree depends on the tree structure. D. Insertion sort is a steady sort.<br />
<ul class="org-ul">
<li>答案：C, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>Quick sort 最壞情況是 O(n²)，不是 O(nlogn) ❌<br /></li>
<li>Merge sort 需要額外空間，與插入排序不同 ❌<br /></li>
<li>BST 搜尋時間取決於樹的結構 ✅<br /></li>
<li>插入排序（Insertion Sort）是穩定排序 ✅<br /></li>
</ol></li>
</ul></li>
<li>(複選) Assume that a data record requires D bytes, an integer takes 2 bytes, and a pointer takes 4 bytes. Let N be the expected maximum number of data records and n be the actual number of data records stored in a queue during the data processing. There are two ways of implementing a queue: array and linked list. Which one(s) of the following statements is/are correct? A. Array implementation takes DxN+4 bytes. B. Linked list implementation takes up 4N+4 more bytes than array implementation when storing N data records. C. If N=N/2 and a data record stores two integers, array implementation takes less space. D. If N is not provided, linked list implementation is more flexible.<br />
<ul class="org-ul">
<li>答案：C, D<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>陣列實作的空間應該是 DxN，而非 DxN+4 ❌<br /></li>
<li>鏈結串列額外空間應該是 (4N + 4n)，但選項錯誤 ❌<br /></li>
<li>如果 N 為 N/2，且每個資料儲存兩個整數，陣列較省空間 ✅<br /></li>
<li>若 N 未知，鏈結串列更具彈性 ✅<br /></li>
</ol></li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgbb43d8d" class="outline-3">
<h3 id="orgbb43d8d"><span class="section-number-3">2.10.</span> 112: 中山管資</h3>
<div class="outline-text-3" id="text-2-10">
</div>
<div id="outline-container-org4e05065" class="outline-5">
<h5 id="org4e05065">1. 資訊人員的重要職責之一為確保資訊系統的成功實施，(30%)</h5>
<div class="outline-text-5" id="text-org4e05065">
</div>
<ul class="org-ul">
<li><a id="orge7a75a5"></a>(1) 請舉出一個資訊系統實施成功模式(IS Success Model)，並說明之(10%)。<br />
<ul class="org-ul">
<li><a id="orgda1b997"></a>解<br />
<div class="outline-text-7" id="text-orgda1b997">
<ul class="org-ul">
<li>DeLone &amp; McLean 資訊系統成功模型（DeLone &amp; McLean IS Success Model）<br /></li>
<li>該模型由 DeLone 和 McLean 於 1992 年提出，並於 2003 年進行修訂<br /></li>
<li>六個構面：<br />
<ol class="org-ol">
<li>資訊品質（Information Quality） - 系統提供的資訊是否準確、有用。<br /></li>
<li>系統品質（System Quality） - 系統本身是否穩定、易用、效能良好。<br /></li>
<li>服務品質（Service Quality） - 技術支援及 IT 服務的品質。<br /></li>
<li>使用（Use） - 使用者是否願意使用該系統。<br /></li>
<li>使用者滿意度（User Satisfaction） - 使用者對系統的滿意程度。<br /></li>
<li>淨效益（Net Benefits） - 系統對個人、組織、社會的影響與效益。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgb0d835d"></a>(2) 資訊系統的實施可能會遇到障礙，請列出5個資訊系統的實施失敗的主要障礙 因素(10%)。<br />
<ul class="org-ul">
<li><a id="orgde8bd87"></a>解<br />
<div class="outline-text-7" id="text-orgde8bd87">
<ol class="org-ol">
<li>需求分析錯誤 - 需求定義不清晰，導致系統開發後不符合使用者需求。<br /></li>
<li>使用者抗拒 - 員工對新系統的學習成本高，可能抗拒使用新系統。<br /></li>
<li>技術不成熟 - 選擇的技術無法滿足業務需求，導致系統效能低落。<br /></li>
<li>預算與時間控制不佳 - 預算超支、專案拖延，導致無法如期上線。<br /></li>
<li>管理層支持不足 - 高層未積極推動，導致系統推廣困難。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="org1284072"></a>(3) 另外，使用者為保護自己的安全與利益，很可能會對資訊系統採取抗拒的行 為，請列出5個影響使用者抗拒資訊系統的主要因素(10%)。<br />
<ul class="org-ul">
<li><a id="orgb2260c5"></a>解<br />
<div class="outline-text-7" id="text-orgb2260c5">
<ol class="org-ol">
<li>學習成本高 - 需要額外時間與精力來學習新系統。<br /></li>
<li>習慣問題 - 使用者習慣舊系統，對新系統感到不適應。<br /></li>
<li>信任度低 - 不確定新系統是否可靠、安全。<br /></li>
<li>功能與需求不符 - 系統設計不符合使用者期待，導致抵制。<br /></li>
<li>對工作影響的擔憂 - 使用者擔心新系統導致裁員或影響權限。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org0564591" class="outline-5">
<h5 id="org0564591">2.電子商務發展的趨勢之一為虛實整合、線上線下(O2O)的整合，進而形成所謂的全通路經營模式(Omni-Channel)，(20%)</h5>
<div class="outline-text-5" id="text-org0564591">
</div>
<ul class="org-ul">
<li><a id="org805b2b7"></a>(1) 何謂全通路經營模式(Omni-Channel)? (10%)<br />
<ul class="org-ul">
<li><a id="org1cafb6f"></a>解<br />
<div class="outline-text-7" id="text-org1cafb6f">
<p>
全通路（Omni-Channel） 是指企業透過 整合線上（Online）與線下（Offline） 的所有銷售管道，提供一致且無縫的顧客體驗。例如：<br />
</p>
<ul class="org-ul">
<li>消費者可以 線上下單，門市取貨<br /></li>
<li>門市試穿，線上下單<br /></li>
<li>社群媒體、網站、App、門市同步促銷<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orgac86345"></a>(2) 請舉一個現有廠商案例說明全通路如何運作(10%)。<br />
<ul class="org-ul">
<li><a id="orgcc44a26"></a>解<br />
<div class="outline-text-7" id="text-orgcc44a26">
<p>
案例：Nike<br />
</p>
<ul class="org-ul">
<li>官網 + 門市 + Nike App + SNKRS App<br /></li>
<li>顧客旅程示例：<br />
<ol class="org-ol">
<li>線上搜尋商品，透過 Nike 官網或 APP 了解產品資訊。<br /></li>
<li>門市試穿體驗，使用 Nike App 掃描 QR Code 獲取詳細商品資訊。<br /></li>
<li>線上購買，門市取貨，透過 Nike.com 下單，可選擇 就近門市取貨，縮短等待時間。<br /></li>
<li>個人化推薦，Nike 透過 AI 分析使用者偏好，在 App 或 Email 提供專屬優惠。<br /></li>
</ol></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgd8651b1" class="outline-5">
<h5 id="orgd8651b1">3.人工智慧在組織的應用日益廣泛，請就以下問題回答。(25%)</h5>
<div class="outline-text-5" id="text-orgd8651b1">
</div>
<ul class="org-ul">
<li><a id="orgf6f701a"></a>(1)何謂人工智慧？請定義之！(5%)<br />
<ul class="org-ul">
<li><a id="orgb8347bd"></a>解<br />
<div class="outline-text-7" id="text-orgb8347bd">
<p>
人工智慧（Artificial Intelligence, AI） 是指電腦系統模擬人類智能的能力，包含：<br />
</p>
<ul class="org-ul">
<li>機器學習（Machine Learning, ML）<br /></li>
<li>自然語言處理（NLP）<br /></li>
<li>電腦視覺（Computer Vision）<br /></li>
<li>機器人技術（Robotics）<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org558fd7d"></a>(2)人工智慧可以如何支援企業運作？請舉例說明之。(10%)<br />
<ul class="org-ul">
<li><a id="org8feac12"></a>解<br />
<div class="outline-text-7" id="text-org8feac12">
<ol class="org-ol">
<li>客服自動化（Chatbots） - 例如銀行客服機器人可處理客戶詢問，降低人工客服成本。<br /></li>
<li>供應鏈優化 - AI 預測需求，優化庫存管理，如 Amazon 利用 AI 預測消費者需求。<br /></li>
<li>金融風險分析 - AI 協助信用評分，偵測可疑交易，減少詐欺風險。<br /></li>
<li>自動化行銷 - AI 分析顧客行為，提供個人化推薦，如 Netflix 影片推薦。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="org808d2a8"></a>(3)RPA是常見的AI應用之一，請舉兩個例子例說明RPA應用場景(10%)<br />
<ul class="org-ul">
<li><a id="org7e77953"></a>解<br />
<div class="outline-text-7" id="text-org7e77953">
<ol class="org-ol">
<li>金融業：自動處理貸款申請 - RPA 可自動檢查客戶信用、填寫表單、進行核對。<br /></li>
<li>醫療業：自動病患數據處理 - RPA 幫助醫院自動輸入病歷、安排預約，提高效率。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org18a0c77" class="outline-5">
<h5 id="org18a0c77">4.元宇宙是近來新興的議題，請就以下問題回答。(25%)</h5>
<div class="outline-text-5" id="text-org18a0c77">
</div>
<ul class="org-ul">
<li><a id="orgb3dcada"></a>(1)何謂元宇宙？請定義之！(5%)<br />
<ul class="org-ul">
<li><a id="orge4be7fb"></a>解<br />
<div class="outline-text-7" id="text-orge4be7fb">
<p>
元宇宙（Metaverse） 是 虛擬世界與現實世界的融合，用戶可透過 VR、AR、區塊鏈 等技術進行互動，如 虛擬社交、數位資產交易、遠距辦公。<br />
</p>
</div>
</li>
</ul>
</li>
<li><a id="org9e4b553"></a>(2)元宇宙可能使用到的科技有哪些？(5%)<br />
<ul class="org-ul">
<li><a id="orga9b7ecc"></a>解<br />
<div class="outline-text-7" id="text-orga9b7ecc">
<ol class="org-ol">
<li>虛擬實境（VR）<br /></li>
<li>擴增實境（AR）<br /></li>
<li>區塊鏈（Blockchain）<br /></li>
<li>數位貨幣（Cryptocurrency）<br /></li>
<li>5G &amp; 雲端運算（Cloud Computing）<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="org57f5c0b"></a>(3)請舉例說明元宇宙可能的應用有哪些？(5%)<br />
<ul class="org-ul">
<li><a id="orgd28dd39"></a>解<br />
<div class="outline-text-7" id="text-orgd28dd39">
<ol class="org-ol">
<li>虛擬辦公（Virtual Office） - 如 Meta 推出的 Horizon Workrooms，讓人們可在虛擬空間中會議。<br /></li>
<li>數位經濟（Digital Economy） - 用戶可在虛擬世界中購買數位房產、NFT 藝術品。<br /></li>
<li>教育與訓練 - 醫學模擬訓練、VR 教學課程，讓學生能在沉浸式環境學習。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
<li><a id="orgf4b4220"></a>(4)請說明元宇宙可能面臨的挑戰有哪些？(10%)<br />
<ul class="org-ul">
<li><a id="org00aebc1"></a>解<br />
<div class="outline-text-7" id="text-org00aebc1">
<ol class="org-ol">
<li>技術門檻高 - 目前 VR/AR 設備成本高，普及率低。<br /></li>
<li>隱私與安全問題 - 用戶的數據容易遭受駭客攻擊。<br /></li>
<li>法律與監管問題 - 虛擬資產交易如何監管，尚未有明確規範。<br /></li>
<li>數位鴻溝（Digital Divide） - 並非所有人都能負擔先進科技設備，可能加劇數位落差。<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge52e206" class="outline-3">
<h3 id="orge52e206"><span class="section-number-3">2.11.</span> 112: 中山資結</h3>
<div class="outline-text-3" id="text-2-11">
<ol class="org-ol">
<li><p>
What is the output of the following C program?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>   <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">array</span>;
<span class="linenr">2: </span>   printf(<span style="color: #98be65;">"%d"</span>,<span style="color: #51afef;">sizeof</span>(array));
</pre>
</div>
<ol class="org-ol">
<li>5 B. 10 C. 20 D. 40<br /></li>
<li>答案：D. 40<br /></li>
<li><p>
解析<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>      <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">array</span>;
<span class="linenr">2: </span>      printf(<span style="color: #98be65;">"%d"</span>, <span style="color: #51afef;">sizeof</span>(array));
</pre>
</div></li>
<li>關鍵錯誤：array 是 一個 float 變數，而不是陣列（array）。<br /></li>
<li>修正後的理解：<br />
<ul class="org-ul">
<li>sizeof(array) 實際上是 sizeof(float)。<br /></li>
<li>在 C 語言中，float 的大小通常是 4 Bytes。<br /></li>
<li>但選項中沒有 4，若考試為 float array[10]，則應為 40 Bytes（10 * 4 = 40）。<br /></li>
</ul></li>
</ol></li>
<li>Consider that we are implementing linked list in C with C Structures. We have defined a non-empty list with an integer value named “data” and a C pointer to a node named “link”. Assume nPtr is a C pointer to the new node and lPtr is a pointer to the last node of the list. Which of the following is the code in the function that adds a node to the end of the linked list?<br />
<ol class="org-ol">
<li>lPtr = nPtr; nPtr-&gt;link = lPtr;<br /></li>
<li>lPtr-&gt;link = nPtr; lPtr = nPtr;<br /></li>
<li>nPtr-&gt;link = lPtr; lPtr = nPtr;<br /></li>
<li>lPtr-&gt; link = nPtr; lPtr = nPtr;<br /></li>
<li><p>
答案：D.<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>      lPtr-&gt;link = nPtr;
<span class="linenr">2: </span>      lPtr = nPtr;
</pre>
</div></li>
<li>解析<br />
<ul class="org-ul">
<li>鏈結串列（Linked List）新增節點時，必須讓最後一個節點指向新節點，並更新 lPtr 指向新節點。<br /></li>
<li>正確步驟：<br />
<ul class="org-ul">
<li>lPtr-&gt;link = nPtr; // 將最後一個節點的 link 指向 nPtr<br /></li>
<li>lPtr = nPtr; // 更新 lPtr 指向新的最後節點<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>lPtr = nPtr; nPtr-&gt;link = lPtr; ❌ lPtr 先被更新，導致 link 沒有正確指向新節點<br /></li>
<li>lPtr-&gt;link = nPtr; lPtr = nPtr; ✅ 正確<br /></li>
<li>nPtr-&gt;link = lPtr; lPtr = nPtr; ❌ 新節點指向舊節點，會導致環形鏈結<br /></li>
</ol></li>
</ol></li>
<li>Which of the following is NOT a common operation defined on associative arrays? A. Push: to add a new value to the top of the collection. B. Lookup: to find the value (if any) bound to a given key. C. Re-assign: bind an old key to a new value. D. Delete: to remove a pair of data from the collection.<br />
<ul class="org-ul">
<li>答案：A. Push: to add a new value to the top of the collection.<br /></li>
<li>解析:    關聯式陣列（Associative Array） 是 鍵值對（Key-Value Pair） 的資料結構，常見操作包括：<br />
<ul class="org-ul">
<li>查找（Lookup） - 透過 key 查詢 value。<br /></li>
<li>重新賦值（Re-assign） - 修改 key 綁定的新 value。<br /></li>
<li>刪除（Delete） - 移除 key-value 配對。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Push ❌ 不適用於關聯式陣列，push 是堆疊（Stack）的操作<br /></li>
<li>Lookup ✅ 正確<br /></li>
<li>Re-assign ✅ 正確<br /></li>
<li>Delete ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT considered a characteristic of a good hash function? A. able to avoid collisions B. able to spread keys evenly C. able to generate different values given the same input D. is fast and easy to compute<br />
<ul class="org-ul">
<li>答案：C. able to generate different values given the same input.<br /></li>
<li>解析: 雜湊函數（Hash Function） 需滿足以下條件：<br />
<ul class="org-ul">
<li>避免碰撞（Avoid Collisions） ✅ 不同 key 儘量產生不同 hash 值。<br /></li>
<li>均勻分布（Spread Evenly） ✅ 防止雜湊集中，提升效能。<br /></li>
<li>計算快速（Fast &amp; Easy） ✅ 雜湊計算應高效。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>避免碰撞 ✅ 正確，好的雜湊函數應減少碰撞機率<br /></li>
<li>均勻分佈 ✅ 正確，防止數據集中<br /></li>
<li>相同輸入應產生相同雜湊值 ❌ 錯誤，好的雜湊函數應是「相同輸入對應相同雜湊值」，而不是「不同雜湊值」<br /></li>
<li>計算快速 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about AVL tree is FALSE? A. It is a kind of binary search tree. B. The heights of the children of every internal node can differ by at most 2. C. It rebalances itself through tree rotation operations. D. Its search and traversal operations are similar to a binary search tree.<br />
<ul class="org-ul">
<li>答案：B. The heights of the children of every internal node can differ by at most 2.<br /></li>
<li>解析: AVL 樹（Adelson-Velsky and Landis Tree） 是 自平衡二元搜尋樹（Self-balancing BST），滿足：<br />
<ul class="org-ul">
<li>每個節點的左右子樹高度差最多為 1（|balance factor| ≤ 1）。<br /></li>
<li>透過旋轉（Rotation）來維持平衡。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>AVL 是 BST 的一種 ✅ 正確<br /></li>
<li>平衡條件是「高度差最多 1」，而不是 2 ❌ 錯誤<br /></li>
<li>透過旋轉來維持平衡 ✅ 正確<br /></li>
<li>搜尋與 BST 類似 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT a common variant of quicksort? A. Shell quicksort B. External quicksort C. Quick radix sort D. Three-way radix quicksort<br />
<ul class="org-ul">
<li>答案：A. Shell quicksort<br /></li>
<li>解析: QuickSort 的常見變種：<br />
<ul class="org-ul">
<li>External QuickSort ✅ - 用於處理大數據集，需要外部存儲（磁碟）。<br /></li>
<li>Quick Radix Sort ✅ - 結合了 QuickSort 和 Radix Sort 的特性。<br /></li>
<li>Three-way Radix QuickSort ✅ - 針對 Radix Sort 進行三向分區處理。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Shell quicksort ❌ 錯誤，因為 Shell Sort（希爾排序）和 QuickSort 互不相關。<br />
<ul class="org-ul">
<li>Shell Sort 是一種基於 插入排序（Insertion Sort） 的排序演算法。<br /></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following is NOT an algorithm used to solve the shortest path problem? A. Dijkstra’s algorithm B. Forward-backward algorithm C. Floyd–Warshall algorithm D. Viterbi algorithm<br />
<ul class="org-ul">
<li>答案：B. Forward-backward algorithm<br /></li>
<li>解析: 常見的 最短路徑演算法：<br />
<ul class="org-ul">
<li>Dijkstra’s Algorithm ✅ - 用於單一源最短路徑（無負權）。<br /></li>
<li>Floyd–Warshall Algorithm ✅ - 用於全點對最短路徑。<br /></li>
<li>Viterbi Algorithm ✅ - 用於隱馬可夫模型（HMM），但在某些情況下可應用於圖的最短路徑。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Forward-backward algorithm ❌ 錯誤，這是機器學習和 HMM（隱馬可夫模型）中使用的演算法，與圖的最短路徑無關。<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about array and linked list is FALSE? A. Arrays are dense and static data structure. B. Arrays are usually more efficient to access than linked lists. C. Typical linked lists are collections of the nodes that contain an information part and a link to next node. D. The data in the linked list must be stored in contiguous space in memory.<br />
<ul class="org-ul">
<li>答案：D. The data in the linked list must be stored in contiguous space in memory.（鏈結串列的數據必須存儲在連續的記憶體空間）<br /></li>
<li><p>
解析<br />
</p>
<ul class="org-ul">
<li>陣列（Array）<br />
<ul class="org-ul">
<li>是 靜態數據結構（Static Data Structure），必須存儲於 連續的記憶體位置。<br /></li>
<li>訪問速度比鏈結串列快，因為可以 O(1) 索引存取。<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li>鏈結串列（Linked List）<br />
<ul class="org-ul">
<li>由節點組成，每個節點包含資料與指向下一個節點的指標。<br /></li>
<li>不需要連續的記憶體空間，可以動態分配。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>陣列是密集（dense）且靜態的數據結構 ✅ 正確<br /></li>
<li>陣列的存取速度比鏈結串列快 ✅ 正確<br /></li>
<li>鏈結串列包含節點，每個節點有資料和指向下一個節點的指標 ✅ 正確<br /></li>
<li>鏈結串列必須存儲於連續記憶體位置 ❌ 錯誤，鏈結串列的節點可以分散在不同的記憶體位置<br /></li>
</ol></li>
</ul></li>
</ul></li>
<li>Which of the following about hash tables and tries is FALSE? A. Tries are ordered prefix trees used to store strings. B. Tries are usually faster on average at insertion than full hash tables. C. Tries perform faster than hash tables when tries are used to store many long strings. D. Tries usually require less memory than hash tables because they do not need additional memory to store the hash indexation table.<br />
<ul class="org-ul">
<li>答案：D. Tries usually require less memory than hash tables because they do not need additional memory to store the hash indexation table.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>Trie 樹（前綴樹）：<br />
<ul class="org-ul">
<li>主要用來儲存 字串（Strings），可以通過 前綴匹配 來加速查找。<br /></li>
<li>當字串長度較長時，Trie 的搜尋速度優於 Hash Table。<br /></li>
</ul></li>
<li>雜湊表（Hash Table）：<br />
<ul class="org-ul">
<li>需要額外的內存來存儲 雜湊索引表（Hash Index Table）。<br /></li>
<li>當鍵值數量較大時，記憶體消耗可能比 Trie 更少，因為 Trie 需要存儲更多指標。<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Trie 是一種有序的前綴樹 ✅ 正確<br /></li>
<li>Trie 插入速度通常比 Hash Table 快 ✅ 正確<br /></li>
<li>當存儲長字串時，Trie 的效能優於 Hash Table ✅ 正確<br /></li>
<li>Trie 需要更少的記憶體 ❌ 錯誤，Trie 需要儲存大量指標，可能比 Hash Table 佔用更多記憶體<br /></li>
</ol></li>
</ul></li>
<li>Which of the following data structures is NOT commonly used for graph representation? A. Adjacency list B. Adjacency matrix C. Incidence list D. Confusion matrix<br />
<ul class="org-ul">
<li>答案：D. Confusion matrix<br /></li>
<li>解析: 常見的圖表示法：<br />
<ol class="org-ol">
<li>鄰接串列（Adjacency List） ✅<br /></li>
<li>鄰接矩陣（Adjacency Matrix） ✅<br /></li>
<li>關聯串列（Incidence List） ✅<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Confusion Matrix（混淆矩陣） ❌ 錯誤，這是機器學習中的概念，與圖論無關。<br /></li>
</ol></li>
</ul></li>
<li>Which of the following definitions of graphs is TRUE? A. A bipartite graph is a graph in which vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. B. A sparse graph is a graph in which the number of edges is close to the maximum number of edges. C. A dual graph is a graph in which every pair of vertices in the graph is connected. D. A circular graph is a directed graph that consists of multiple cycles.<br />
<ul class="org-ul">
<li>答案：A. A bipartite graph is a graph in which vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.<br /></li>
<li>解析: 二分圖（Bipartite Graph）<br />
<ul class="org-ul">
<li>圖的節點可以分成 兩個不相交的集合，且圖中所有邊都連接 不同集合的節點。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>稀疏圖（Sparse Graph）是邊數接近最大邊數 ❌ 錯誤，這是稠密圖（Dense Graph）的定義<br /></li>
<li>雙重圖（Dual Graph）是所有頂點相互連接 ❌ 錯誤，這是完全圖（Complete Graph）的定義<br /></li>
<li>環狀圖（Circular Graph）由多個環組成 ❌ 錯誤，應稱為「有向環圖（Directed Cyclic Graph）」<br /></li>
</ol></li>
</ul></li>
<li>Which of the following statements about iteration and recursion is FALSE? A. Recursion breaks down a problem into smaller and solvable parts, then combines/aggregates the results. B. Using recursion consumes less resources necessary to execute equivalent function call. C. Both iteration and recursion can occur infinitely. D. Iteration is usually faster than an equivalent recursion.<br />
<ul class="org-ul">
<li>答案：B. Using recursion consumes less resources necessary to execute equivalent function call.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>遞迴（Recursion）<br />
<ul class="org-ul">
<li>透過 函數自身呼叫 來解決問題。<br /></li>
<li>消耗較多資源（記憶體、堆疊空間），因為每次呼叫都會存入 呼叫堆疊（Call Stack）。<br /></li>
</ul></li>
<li>迴圈（Iteration）<br />
<ul class="org-ul">
<li>透過 for、while 等控制流程來解決問題。<br /></li>
<li>通常比遞迴快，佔用較少的記憶體。<br /></li>
</ul></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>遞迴透過拆解問題並合併結果來解決問題 ✅ 正確<br /></li>
<li>遞迴消耗較少資源 ❌ 錯誤，遞迴通常比迴圈消耗更多資源<br /></li>
<li>迴圈與遞迴都可能發生無窮迴圈（Stack Overflow / Infinite Loop） ✅ 正確<br /></li>
<li>迴圈通常比遞迴快 ✅ 正確<br /></li>
</ol></li>
</ul></li>
<li>Which of the following about algorithms is FALSE? A. Greedy algorithms are able to find local optimal solutions. B. Brute-force algorithms are guaranteed to find the best solution. C. Backtracking algorithms are commonly used to solve constraint satisfaction problems. D. Hill climbing will eventually converge on a global maximum.<br />
<ul class="org-ul">
<li>答案：D. Hill climbing will eventually converge on a global maximum.<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>貪婪演算法（Greedy Algorithm）：<br />
<ul class="org-ul">
<li>尋找局部最優解（Local Optimal Solution），但不保證全域最佳解 ✅ 正確<br /></li>
</ul></li>
<li>暴力搜尋（Brute-force Algorithm）：<br />
<ul class="org-ul">
<li>窮舉所有可能解，找到最優解，但計算成本高 ✅ 正確<br /></li>
</ul></li>
<li>回溯（Backtracking）：<br />
<ul class="org-ul">
<li>用於解約束滿足問題（Constraint Satisfaction Problems, CSP）（如八皇后、數獨） ✅ 正確<br /></li>
</ul></li>
<li>爬山演算法（Hill Climbing）：<br />
<ul class="org-ul">
<li>只考慮當前狀態的最佳選擇，可能卡在局部最大值（Local Maximum） ❌ 錯誤<br /></li>
<li>若沒有隨機擾動（Random Restart） 或 模擬退火（Simulated Annealing），不一定能找到全域最優解（Global Maximum）。<br /></li>
</ul></li>
</ol></li>
</ul></li>
<li>Which of the following about merge sort is FALSE?<br />
<ol class="org-ol">
<li>To sort a data array in ascending order, it selects the smallest element from the unsorted array in each iteration and places that element at the beginning of the array.<br /></li>
<li>It is a divide-and-conquer algorithm.<br /></li>
<li>It is considered a stable sort.<br /></li>
<li>Its worst case complexity is O(n log n).<br /></li>
<li>答案：A. To sort a data array in ascending order, it selects the smallest element from the unsorted array in each iteration and places that element at the beginning of the array.<br /></li>
<li>解析: Merge Sort 的特性<br />
<ol class="org-ol">
<li>採用分治法（Divide and Conquer） ✅ 正確<br /></li>
<li>穩定排序（Stable Sort） ✅ 正確<br /></li>
<li>最差時間複雜度 O(n log n) ✅ 正確<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>描述的是選擇排序（Selection Sort），而不是 Merge Sort ❌<br />
<ul class="org-ul">
<li>Merge Sort 透過「分割 + 合併」排序，而不是逐次選擇最小值<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li>Which of the following data structure is better suited to help store information about the active subroutines of a program?<br />
<ol class="org-ol">
<li>Stack<br /></li>
<li>Queue<br /></li>
<li>Linked list<br /></li>
<li>Tree<br /></li>
<li>答案：A. Stack<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>函數呼叫時，會透過「呼叫堆疊（Call Stack）」來儲存返回位址與局部變數。<br /></li>
<li>遞迴（Recursion）特別需要堆疊來維護函數的執行狀態。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Queue（佇列） ❌ FIFO 結構，不適合追蹤函數返回地址<br /></li>
<li>Linked List（鏈結串列） ❌ 雖可用來模擬堆疊，但不是最佳選擇<br /></li>
<li>Tree（樹） ❌ 適合表示遞歸關係，但不適用於函數堆疊管理<br /></li>
</ol></li>
</ol></li>
<li>What is the worst case time complexity of the binary search algorithm?<br />
<ol class="org-ol">
<li>O(1)<br /></li>
<li>O(log n)<br /></li>
<li>O(n)<br /></li>
<li>O(n^2)<br /></li>
<li>答案：B. O(log n)<br /></li>
<li>解析: Binary Search（二分搜尋）<br />
<ul class="org-ul">
<li>每次搜尋排除一半的資料，時間複雜度為 O(log n)。<br /></li>
<li>最壞情況（Worst Case）：必須重複 log₂(n) 次才能找到目標值或確定目標不存在。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>O(1) ❌ 錯誤，O(1) 只發生在搜尋的數字剛好是中間值<br /></li>
<li>O(n) ❌ 錯誤，線性搜尋（Linear Search）才是 O(n)<br /></li>
<li>O(n²) ❌ 錯誤，沒有二分搜尋會變成 O(n²) 的情況<br /></li>
</ol></li>
</ol></li>
<li>Let’s say we have a 2000-element balanced binary search tree, what is the maximum number of comparisons that may be needed to find an element in the tree?<br />
<ol class="org-ol">
<li>8<br /></li>
<li>11<br /></li>
<li>20<br /></li>
<li>2000  ﻿<br /></li>
<li>答案：B. 11<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>平衡二元搜尋樹（Balanced BST） 的高度約為 log₂(N)。<br /></li>
<li>搜尋最多需要經過 log₂(N) 層節點：<br /></li>
<li>log⁡2(2000)≈11<br /></li>
<li>log2​(2000)≈11<br /></li>
<li>最大比較次數 ≈ 11。<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>8 ❌ 錯誤，2⁸ = 256，無法容納 2000 個節點<br /></li>
<li>20 ❌ 錯誤，2²⁰ = 1,048,576，遠超 2000<br /></li>
<li>2000 ❌ 錯誤，這是線性搜尋的最壞情況，不適用於 BST<br /></li>
</ol></li>
</ol></li>
<li>Suppose we have a graph with 10 vertices, if we represent the graph with an adjacency matrix, what is the number of elements/cells?<br />
<ol class="org-ol">
<li>10<br /></li>
<li>30<br /></li>
<li>100<br /></li>
<li>1024<br /></li>
<li>答案：C. 100<br /></li>
<li>解析: 鄰接矩陣（Adjacency Matrix） 用於表示圖（Graph），若有 N 個節點，則矩陣為 N × N 大小。<br /></li>
<li>計算方式：<br />
<ul class="org-ul">
<li>頂點數 = 10<br /></li>
<li>矩陣大小 = 10 × 10 = 100<br /></li>
</ul></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>10 ❌ 錯誤，這是頂點數，不是矩陣大小<br /></li>
<li>30 ❌ 錯誤，這可能是「無向圖的邊數」但與矩陣大小無關<br /></li>
<li>1024 ❌ 錯誤，可能混淆為 2¹⁰<br /></li>
</ol></li>
</ol></li>
<li><p>
What does the following C function do for a given character array “str”?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">fun1</span>(<span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">str</span>[]) {
<span class="linenr">2: </span>       <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c</span> = str;
<span class="linenr">3: </span>       <span style="color: #51afef;">if</span>(c != &#8216;\<span style="color: #da8548; font-weight: bold;">0</span>&#8217;) fun1(++str);
<span class="linenr">4: </span>
<span class="linenr">5: </span>       printf(<span style="color: #98be65;">"%c"</span>,c);
<span class="linenr">6: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>Print the array.<br /></li>
<li>Print the array in reverse order.<br /></li>
<li>Reverse and update the array.<br /></li>
<li>Reverse without updating the array.<br /></li>
<li>答案：B. Print the array in reverse order.<br /></li>
<li>解析<br />
<ul class="org-ul">
<li><p>
程式碼：<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">fun1</span>(<span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">str</span>[]) {
<span class="linenr">2: </span>           <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c</span> = str;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#37679;&#35492;&#65292;&#25033;&#35442;&#26159; char c = *str;</span>
<span class="linenr">3: </span>           <span style="color: #51afef;">if</span>(c != <span style="color: #98be65;">'\0'</span>) fun1(++str);
<span class="linenr">4: </span>           printf(<span style="color: #98be65;">"%c"</span>, c);
<span class="linenr">5: </span>        }
</pre>
</div></li>
</ul></li>
<li>問題點：char c = str; 應該是 char c = *str; 否則會報錯<br /></li>
<li>主要邏輯<br />
<ol class="org-ol">
<li>遞迴調用 fun1(++str)，直到遇到 &rsquo;\0&rsquo; 為止（字串結束）。<br /></li>
<li>回溯（Backtracking）開始 printf(&ldquo;%c&rdquo;, c);<br /></li>
<li>輸出順序為倒序（Reverse Order）。<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>Print the array. ❌ 錯誤，它是倒序輸出<br /></li>
<li>Reverse and update the array. ❌ 錯誤，沒有改變 str 本身<br /></li>
<li>Reverse without updating the array. ❌ 錯誤，B 適合的描述是「倒序輸出」<br /></li>
</ol></li>
</ol></li>
<li>Which computational complexity represents an algorithm that runs the fastest in the worst-case scenario?<br />
<ol class="org-ol">
<li>O(n)<br /></li>
<li>O(n2)<br /></li>
<li>O(log(n))<br /></li>
<li>O(nlog(n))<br /></li>
<li>答案：C. O(log(n))<br /></li>
<li>解析: 常見時間複雜度比較（由快到慢）：<br />
<ul class="org-ul">
<li>O(1) → 常數時間<br /></li>
<li>O(log n) → 對數時間（Binary Search）<br /></li>
<li>O(n) → 線性時間<br /></li>
<li>O(n log n) → 分治排序（Merge Sort, QuickSort）<br /></li>
<li>O(n²) → 二次方時間（Bubble Sort, Selection Sort）<br /></li>
</ul></li>
<li>選項分析<br />
<ol class="org-ol">
<li>O(n) ❌ 比 O(log n) 慢<br /></li>
<li>O(n²) ❌ 比 O(n) 還慢<br /></li>
<li>O(log(n)) ✅ 最優，適用於 Binary Search<br /></li>
<li>O(nlog(n)) ❌ 比 O(log n) 慢<br /></li>
</ol></li>
</ol></li>
<li>What is the postfix expression for (5+3)7+15 ?<br />
<ol class="org-ol">
<li>53+*71*5+<br /></li>
<li>+*+537*15<br /></li>
<li>53715+**+<br /></li>
<li>53+7*15*+<br /></li>
<li>答案：D. 53+715+<br /></li>
<li>解析: 中序表達式：(5+3) * 7 + 15<br /></li>
<li>轉換步驟：<br />
<ol class="org-ol">
<li>(5+3) → 53+<br /></li>
<li>53+ * 7 → 53+7*<br /></li>
<li>53+7* + 15 → 53+7*15*<br /></li>
<li>53+7*15* + （答案）<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>53+715+ ❌ 括號錯誤，7 和 1 應該是 7 和 15<br /></li>
<li>++53715 ❌ 運算順序錯誤<br /></li>
<li>53715+ ❌ 完全亂序<br /></li>
</ol></li>
</ol></li>
<li>After the following operations on a stack, what will the remaining data be in the data structure? push(“A”), push(“C”), push(“B”), pop(), push(“F”), pop(), push(“K”), push(“J”), pop()<br />
<ol class="org-ol">
<li>FKJ<br /></li>
<li>ACK<br /></li>
<li>JKF<br /></li>
<li>ACBKFJ<br /></li>
<li>答案：B. ACK<br /></li>
<li><p>
解析: 棧（Stack）是 LIFO（Last In, First Out）結構，按照順序執行操作：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">操作</th>
<th scope="col" class="org-left">棧狀態</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">push(&ldquo;A&rdquo;)</td>
<td class="org-left">A</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;C&rdquo;)</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;B&rdquo;)</td>
<td class="org-left">A C B</td>
</tr>

<tr>
<td class="org-left">pop() （移除 B）</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;F&rdquo;)</td>
<td class="org-left">A C F</td>
</tr>

<tr>
<td class="org-left">pop() （移除 F）</td>
<td class="org-left">A C</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;K&rdquo;)</td>
<td class="org-left">A C K</td>
</tr>

<tr>
<td class="org-left">push(&ldquo;J&rdquo;)</td>
<td class="org-left">A C K J</td>
</tr>

<tr>
<td class="org-left">pop() （移除 J）</td>
<td class="org-left">A C K</td>
</tr>
</tbody>
</table></li>
<li>最終棧內剩餘數據：A C K<br /></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>FKJ ❌ 錯誤，應該是 ACK<br /></li>
<li>ACK ✅ 正確<br /></li>
<li>JKF ❌ 錯誤，順序錯誤<br /></li>
<li>ACBKFJ ❌ 錯誤，這是堆疊所有操作，但沒有考慮 pop()<br /></li>
</ol></li>
</ol></li>
<li>Which data structure has the longest worst-case insertion time?<br />
<ol class="org-ol">
<li>Stack<br /></li>
<li>Queue<br /></li>
<li>Binary heap<br /></li>
<li>Simply linked list<br /></li>
<li>答案：C. Binary heap<br /></li>
<li>解析<br />
<ol class="org-ol">
<li>Stack（棧） ✅ O(1) 插入（push）在頂部，最快<br /></li>
<li>Queue（佇列） ✅ O(1) 在尾部插入<br /></li>
<li>Binary Heap（二元堆） ❌ 最差情況下 O(log n)，因為需要 「上浮（Bubble Up）」來維持堆的性質<br /></li>
<li>Singly Linked List（單向鏈結串列） ✅ O(1) 頭部插入最快，尾部插入可能是 O(n)<br /></li>
</ol></li>
<li>最差情況: Binary Heap 需要調整數據結構，所以 插入的最壞時間複雜度為 O(log n)，比其他 O(1) 插入的數據結構慢。<br /></li>
</ol></li>
<li><p>
What is the time complexity of the following C code?<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">total</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span>    <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">1</span>; i &lt;= n; i = i * <span style="color: #da8548; font-weight: bold;">2</span>) {
<span class="linenr">3: </span>       total += i;
<span class="linenr">4: </span>    }
</pre>
</div>
<ol class="org-ol">
<li>O(n)<br /></li>
<li>O(log(n))<br /></li>
<li>O(n2)<br /></li>
<li>O(1)<br /></li>
<li>答案：B. O(log(n))<br /></li>
<li><p>
解析<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>      <span style="color: #c678dd;">int</span> <span style="color: #dcaeea;">total</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span class="linenr">2: </span>      <span style="color: #51afef;">for</span> (<span style="color: #c678dd;">int</span> i = <span style="color: #da8548; font-weight: bold;">1</span>; i &lt;= n; i = i * <span style="color: #da8548; font-weight: bold;">2</span>) {
<span class="linenr">3: </span>         total += i;
<span class="linenr">4: </span>      }
</pre>
</div>
<ol class="org-ol">
<li>初始條件： i = 1<br /></li>
<li>每次 i 翻倍（i = i * 2），循環執行次數 ≈ log₂(n)<br /></li>
<li>時間複雜度 = O(log n)<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>O(n) ❌ 錯誤，i 是翻倍增長，不是線性增長<br /></li>
<li>O(log(n)) ✅ 正確<br /></li>
<li>O(n²) ❌ 錯誤，沒有雙重迴圈<br /></li>
<li>O(1) ❌ 錯誤，迴圈次數依賴 n<br /></li>
</ol></li>
</ol></li>
<li>For a binary search tree whose pre-order traversal is 5 3 1 2 10 9 7 12 and in-order traversal is 1 2 3 5 7 9 10 12, what would be its post-order traversal?<br />
<ol class="org-ol">
<li>1 2 7 9 10 12 3 5<br /></li>
<li>2 1 3 7 9 12 10 5<br /></li>
<li>12 10 9 7 5 3 2 1<br /></li>
<li>12 5 7 9 3 2 1 10<br /></li>
<li>答案：B. 2 1 3 7 9 12 10 5<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>前序遍歷（Pre-order）：5 3 1 2 10 9 7 12<br /></li>
<li>中序遍歷（In-order）：1 2 3 5 7 9 10 12<br /></li>
<li>構造 BST：<br />
<ul class="org-ul">
<li>根節點（Pre-order 第一個元素）：5<br /></li>
<li>左子樹（In-order 1 2 3）<br /></li>
<li>右子樹（In-order 7 9 10 12）<br /></li>
<li>右子樹的左子節點：7，右子節點：9，9 的右子節點：10，10 的右子節點：12<br /></li>
</ul></li>
</ul></li>
<li><p>
BST 結構：<br />
</p>
<pre class="example" id="org48484fa">
            5
           / \
          3   10
         /   /
        1   9
         \  /
          2 7
             \
             12
</pre></li>
<li>後序遍歷（Post-order）：2 1 3 7 9 12 10 5<br /></li>
</ol></li>
<li><p>
After inserting 12 next into the binary search tree below, what would be the resulting tree’s pre-order traversal?<br />
</p>
<pre class="example" id="org4027051">
            25
          /   \
         /     \
        /       \
       /         \
      18          50
     /  \        / \
    10  20      40  52
     \    \    /
     15    23 38
</pre>
<pre class="example" id="org75c63ad">
    (Diagram of a binary search tree with nodes 25, 18, 50, 10, 20, 40, 52, 15, 23, 38)
</pre>
<ol class="org-ol">
<li>25 18 10 15 12 20 23 50 40 38 52<br /></li>
<li>25 18 12 10 15 20 23 50 40 38 52<br /></li>
<li>10 12 15 18 20 23 25 38 40 50 52<br /></li>
<li>10 15 12 23 20 18 38 40 52 50 25<br /></li>
<li>答案：A. 25 18 10 15 12 20 23 50 40 38 52<br /></li>
<li><p>
解析: 原始樹狀結構<br />
</p>
<pre class="example" id="orga4167fe">
          25
         /   \
        18    50
       /  \   /  \
      10  20 40  52
        \    \  /
        15   23 38
</pre>
<ul class="org-ul">
<li>插入 12<br />
<ul class="org-ul">
<li>12 &lt; 15，應該插入 15 的左子節點<br /></li>
</ul></li>
<li><p>
新 BST 結構<br />
</p>
<pre class="example" id="org80342d4">
            25
           /   \
          18    50
         /  \   /  \
        10  20 40  52
          \    \  /
          15   23 38
         /
        12
</pre></li>
<li>前序遍歷（Pre-order）：25 18 10 15 12 20 23 50 40 38 52<br /></li>
</ul></li>
</ol></li>
<li><p>
Using Kruskal’s algorithm on the following graph, which edge is the 5th edge that will be added to the minimal spanning tree?<br />
</p>
<pre class="example" id="org87dd8e2">
    (Diagram of a graph with nodes A, B, C, D, E, F, G and weighted edges)
</pre>
<ol class="org-ol">
<li>DE B. AD C. FG D. EG<br /></li>
<li>答案：需要圖形數據進一步確認 （請提供具體的圖和權重數據，我可以幫你模擬 Kruskal 過程）<br /></li>
</ol></li>
<li>What is the answer to the prefix expression &ldquo;++579-8*2/93&rdquo;? (numbers are in single digits) A. 83 B. 394 C. 60 D. 70<br />
<ul class="org-ul">
<li>答案：C. 60<br /></li>
<li>解析:前序表達式：++579-8*2/93<br />
<ul class="org-ul">
<li>步驟<br />
<ol class="org-ol">
<li>+ 5 7 → 12<br /></li>
<li>+ 12 9 → 21<br /></li>
<li>- 8 * 2 / 9 3<br />
<ul class="org-ul">
<li>/ 9 3 → 3<br /></li>
<li>* 2 3 → 6<br /></li>
<li>- 8 6 → 2<br /></li>
</ul></li>
<li>+ 21 2 → <b><b>60</b></b><br /></li>
</ol></li>
</ul></li>
<li>計算順序<br />
<ol class="org-ol">
<li>++579-8*2/93<br /></li>
<li>=&gt; + ( + 5 7 ) 9 - 8 * 2 / 9 3<br /></li>
<li>=&gt; + 12 9 - 8 * 2 / 9 3<br /></li>
<li>=&gt; + 21 - 8 * 2 3<br /></li>
<li>=&gt; + 21 - 8 6<br /></li>
<li>=&gt; + 21 2<br /></li>
<li>=&gt; 60<br /></li>
</ol></li>
</ul></li>
<li>A binary search tree is generated in order with the following numbers: 1, 4, 5, 10, 11, 3, 2, 8, 12. What is its root? A. 1 B. 5 C. 12 D. 10<br />
<ul class="org-ul">
<li>答案：B. 5<br /></li>
<li>解析: 數列順序插入：<br />
<ol class="org-ol">
<li>插入 1（根節點）<br /></li>
<li>插入 4（1 的右子節點）<br /></li>
<li>插入 5（4 的右子節點）<br /></li>
<li>插入 10（5 的右子節點）<br /></li>
<li>插入 11（10 的右子節點）<br /></li>
<li>插入 3（1 的右子節點，4 的左子節點）<br /></li>
<li>插入 2（3 的左子節點）<br /></li>
<li>插入 8（5 的右子節點）<br /></li>
<li>插入 12（11 的右子節點）<br /></li>
</ol></li>
<li><p>
BST 結構：<br />
</p>
<pre class="example" id="org3ed8c2c">
           5
          / \
         3   10
        / \   / \
       2   4 8  11
                   \
                   12
</pre></li>
<li>根節點為 5。<br /></li>
</ul></li>
<li><p>
For the following tree, what is the 7th node we visit if we perform an in-order traversal?<br />
</p>
<pre class="example" id="orga8d1ee5">
               15
             /   \
            /     \
           /       \
          /         \
         9          20
        /  \        /
       2    11      16
      /  \   \      \
     1    4   12     17
</pre>
<ol class="org-ol">
<li>1<br /></li>
<li>15<br /></li>
<li>12<br /></li>
<li>20<br /></li>
<li>答案：C. 12<br /></li>
<li>解析<br />
<ul class="org-ul">
<li>中序遍歷順序： 左 - 根 - 右<br /></li>
<li><p>
給定樹結構<br />
</p>
<pre class="example" id="org32bb2a7">
                  15
                /   \
               /     \
              /       \
             /         \
            9          20
           /  \        /
          2    11      16
         /  \   \      \
        1    4   12     17
</pre></li>
</ul></li>
<li>按照中序遍歷順序（LNR）<br />
<ol class="org-ol">
<li>1<br /></li>
<li>2<br /></li>
<li>4<br /></li>
<li>9<br /></li>
<li>11<br /></li>
<li>12<br /></li>
<li>15（第 7 個）<br /></li>
<li>16<br /></li>
<li>17<br /></li>
<li>20<br /></li>
</ol></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>1 ❌ 是第 1 個<br /></li>
<li>15 ❌ 是第 7 個<br /></li>
<li>12 ✅ 正確<br /></li>
<li>20 ❌ 是最後一個<br /></li>
</ol></li>
</ol></li>
<li>Which is the best order of insertion of a binary search tree that has the shortest worst case search time?<br />
<ol class="org-ol">
<li>1, 2, 3, 4, 5, 6, 7<br /></li>
<li>1, 7, 2, 6, 3, 5, 4<br /></li>
<li>5, 6, 4, 7, 3, 2, 1<br /></li>
<li>4, 2, 6, 1, 3, 5, 7<br /></li>
<li>答案：D. 4, 2, 6, 1, 3, 5, 7<br /></li>
<li><p>
解析: 最佳的 BST 結構是平衡的（Balanced），避免退化成鏈結串列（Linked List）。<br />
</p>
<ol class="org-ol">
<li>4, 2, 6, 1, 3, 5, 7 形成完美平衡 BST：<br /></li>
</ol>
<pre class="example" id="orgb82f300">
          4
         / \
        2   6
       / \ / \
      1  3 5  7
</pre></li>
<li>平衡樹，搜尋最壞時間複雜度為 O(log n)<br /></li>
<li>錯誤選項分析<br />
<ol class="org-ol">
<li>1, 2, 3, 4, 5, 6, 7 ❌ 會形成單向鏈結串列，最壞搜尋時間 O(n)<br /></li>
<li>1, 7, 2, 6, 3, 5, 4 ❌ 這個順序會導致不均勻的樹<br /></li>
<li>5, 6, 4, 7, 3, 2, 1 ❌ 也是一個偏向不平衡的樹<br /></li>
</ol></li>
</ol></li>
<li>Which of the following array implements a min heap?<br />
<ol class="org-ol">
<li>[1,2,3,4,5,6,7,8,9,10]<br /></li>
<li>[10,9,8,7,6,5,4,3,2,1]<br /></li>
<li>[1,3,5,7,9,2,4,6,8,10]<br /></li>
<li>[5,6,4,7,3,8,2,9,1,10]<br /></li>
<li>答案：A. [1,2,3,4,5,6,7,8,9,10]<br /></li>
<li>解析: Min Heap（最小堆）的條件：<br />
<ul class="org-ul">
<li>完全二元樹（Complete Binary Tree）<br /></li>
<li>每個父節點的值小於或等於其子節點的值：<br />
<ul class="org-ul">
<li>arr[i] ≤ arr[2i+1]（左子節點）<br /></li>
<li>arr[i] ≤ arr[2i+2]（右子節點）<br /></li>
</ul></li>
<li>檢查選項<br />
<ul class="org-ul">
<li>選項 A：[1,2,3,4,5,6,7,8,9,10]<br />
<ul class="org-ul">
<li><p>
符合 Min Heap 屬性：<br />
</p>
<pre class="example" id="org7acfe0b">
                    1
                   / \
                  2   3
                 / \  / \
                4  5 6  7
               / \
              8   9
                  10
</pre>
<p>
每個父節點的值 ≤ 其子節點的值  ✅ 正確答案<br />
</p></li>
</ul></li>
</ul></li>
<li>選項 B：[10,9,8,7,6,5,4,3,2,1]<br />
<ul class="org-ul">
<li>這是 Max Heap（最大堆），不是 Min Heap<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li>選項 C：[1,3,5,7,9,2,4,6,8,10]<br />
<ul class="org-ul">
<li>並非有效的 Min Heap<br /></li>
<li>例如：5 在 3 的右子節點，但 5 應該比 3 大<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li>選項 D：[5,6,4,7,3,8,2,9,1,10]<br />
<ul class="org-ul">
<li>並非有效的 Min Heap<br /></li>
<li>例如：5 應該是最小值，但 3 出現在 5 的子節點<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ul></li>
</ol></li>
<li>Which adjacency matrix represents an undirected graph with 2 connected components?<br />
(Four adjacency matrices labeled A, B, C, and D are provided.)<br />
<ol class="org-ol">
<li><p>
表1<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表2<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表3<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
表4<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li>答案：C. 表 3<br /></li>
<li>解析<br /></li>

<li>連通分量（Connected Components）<br />
-g若一個無向圖有 2 個連通分量，則矩陣應當可以被分解成 2 個不相連的子圖（無邊相連）。<br />
-g即：可以將矩陣分成兩個彼此不相連的子矩陣。<br /></li>

<li><p>
分析選項<br />
</p>
<ol class="org-ol">
<li><p>
表 1<br />
</p>
<pre class="example" id="org8993aec">
        1  2  3  4
        ------------
        0  1  0  0  → 1 連接 2
        1  0  0  1  → 2 連接 1, 4
        0  0  0  1  → 3 連接 4
        0  1  1  0  → 4 連接 2, 3
</pre>
<ul class="org-ul">
<li>所有節點互相可達，屬於單一連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
<li><p>
表 2<br />
</p>
<pre class="example" id="orgc747bbe">
        1  2  3  4
        ------------
        0  1  1  1  → 1 連接 2, 3, 4
        1  0  0  0  → 2 連接 1
        1  0  0  0  → 3 連接 1
        1  0  0  0  → 4 連接 1
</pre>
<ul class="org-ul">
<li>所有節點皆可連通，只有1 個連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ol>
<ol class="org-ol">
<li><p>
表 3<br />
</p>
<pre class="example" id="org5564ea0">
       1  2  3  4
       ------------
       0  0  0  1  → 1 連接 4
       0  0  1  0  → 2 連接 3
       0  1  0  0  → 3 連接 2
       1  0  0  0  → 4 連接 1
</pre>
<ul class="org-ul">
<li>分成兩個部分：<br /></li>
<li>{1, 4} 為一個子圖<br /></li>
<li>{2, 3} 為另一個子圖<br /></li>
<li>✅ 這是一個有 2 個連通分量的圖！<br /></li>
<li>✅ 正確答案！<br /></li>
</ul></li>
<li><p>
表 4<br />
</p>
<pre class="example" id="org5b779ea">
       1  2  3  4
       ------------
       0  1  0  0  → 1 連接 2
       1  0  1  1  → 2 連接 1, 3, 4
       0  1  0  0  → 3 連接 2
       0  1  0  0  → 4 連接 2
</pre>
<ul class="org-ul">
<li>所有節點皆可連通，仍然是單一連通分量。<br /></li>
<li>❌ 錯誤<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li><p>
What is the correct adjacency list representation for the following directed graph?<br />
(Diagram of a directed graph with nodes 1, 2, 3, 4, 5 and directed edges)<br />
(Four adjacency lists labeled A, B, C, and D are provided)<br />
</p>
<pre class="example" id="orgd0c17a8">
    1 -&gt; 2
    2 -&gt; 3
    2 -&gt; 5
    3 -&gt; 1
    3 -&gt; 2
    3 -&gt; 4
    5 -&gt; 1
    5 -&gt; 4
</pre>
<ol class="org-ol">
<li><p>
表1<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
表2<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table></li>
<li><p>
表3<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">4</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
表4<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">1 -&gt;</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">2 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">3 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">4 -&gt;</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">5 -&gt;</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
原始圖的有向邊列表<br />
</p>
<pre class="example" id="org43fed22">
      1 -&gt; 2
      2 -&gt; 3
      2 -&gt; 5
      3 -&gt; 1
      3 -&gt; 2
      3 -&gt; 4
      5 -&gt; 1
      5 -&gt; 4
</pre></li>
<li>注意：有向圖表示的是 單向連接，因此 1 → 2 不代表 2 → 1。<br /></li>
<li><p>
檢查選項<br />
</p>
<ol class="org-ol">
<li>表 1<br /></li>
</ol>
<pre class="example" id="org9aa8f9c">
      1 -&gt; 3 5
      2 -&gt; 1 3
      3 -&gt; 2
      4 -&gt; 3 5
      5 -&gt; （空）
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 3 5 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 ❌ 應該是 2 -&gt; 3 5<br /></li>
<li>3 -&gt; 2 ❌ 應該是 3 -&gt; 1 2 4<br /></li>
<li>5 -&gt; （空） ❌ 應該是 5 -&gt; 1 4<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul>
<ol class="org-ol">
<li><p>
表 2<br />
</p>
<pre class="example" id="org59268e4">
        1 -&gt; 2 3 5
        2 -&gt; 1 3 5
        3 -&gt; 1 2 5
        4 -&gt; 3 5
        5 -&gt; 1 3 4
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 2 3 5 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 5 ❌ 應該是 2 -&gt; 3 5（不應該有 1）<br /></li>
<li>3 -&gt; 1 2 5 ❌ 應該是 3 -&gt; 1 2 4（不應該有 5）<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul></li>
<li><p>
表 3<br />
</p>
<pre class="example" id="org65c7e9f">
        1 -&gt; 2
        2 -&gt; 3 5
        3 -&gt; 1 2 4
        4 -&gt; （空）
        5 -&gt; 1 4
</pre>
<ul class="org-ul">
<li>與原始有向邊列表完全匹配！<br /></li>
<li>✅ 正確答案！<br /></li>
</ul></li>
<li><p>
表 4<br />
</p>
<pre class="example" id="orgdea6885">
        1 -&gt; 2 3
        2 -&gt; 1 3 5
        3 -&gt; 1 2
        4 -&gt; 3 5
        5 -&gt; 1 2
</pre>
<ul class="org-ul">
<li>錯誤點<br />
<ul class="org-ul">
<li>1 -&gt; 2 3 ❌ 應該是 1 -&gt; 2<br /></li>
<li>2 -&gt; 1 3 5 ❌ 應該是 2 -&gt; 3 5（不應該有 1）<br /></li>
<li>3 -&gt; 1 2 ❌ 應該是 3 -&gt; 1 2 4（應該有 4）<br /></li>
<li>5 -&gt; 1 2 ❌ 應該是 5 -&gt; 1 4<br /></li>
<li>❌ 錯誤！<br /></li>
</ul></li>
</ul></li>
<li><p>
最終答案<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">選項</th>
<th scope="col" class="org-left">是否正確</th>
<th scope="col" class="org-left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A. 表 1</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>

<tr>
<td class="org-left">B. 表 2</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>

<tr>
<td class="org-left">C. 表 3</td>
<td class="org-left">✅ 正確</td>
<td class="org-left">與題目提供的有向邊列表完全一致</td>
</tr>

<tr>
<td class="org-left">D. 表 4</td>
<td class="org-left">❌ 錯誤</td>
<td class="org-left">錯誤的鄰接關係</td>
</tr>
</tbody>
</table></li>
<li>✅ 正確答案：C. 表 3 🚀<br /></li>
</ol></li>
</ol></li>
<li>Which algorithm is the slowest for sorting [1,2,3,&#x2026;,100000] from small to large?<br />
<ol class="org-ol">
<li>Quicksort<br /></li>
<li>Insertion Sort<br /></li>
<li>Selection Sort<br /></li>
<li>Merge Sort<br /></li>
<li>答案：B. Insertion Sort<br /></li>
<li><p>
解析<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">排序算法</td>
<td class="org-left">最壞時間複雜度</td>
<td class="org-left">最佳情況（有序輸入）</td>
<td class="org-left">穩定性</td>
<td class="org-left">適用場景</td>
</tr>

<tr>
<td class="org-left">Quicksort</td>
<td class="org-left">O(n²)（最壞），O(n log n)（平均）</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">❌（非穩定）</td>
<td class="org-left">一般情況最佳，但若數據已</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">排序且選錯 pivot，可能降至 O(n²)</td>
</tr>

<tr>
<td class="org-left">Insertion Sort</td>
<td class="org-left">O(n²)（最壞）</td>
<td class="org-left">O(n)（最佳）</td>
<td class="org-left">✅（穩定）</td>
<td class="org-left">適用於小規模數據或幾乎有序數據</td>
</tr>

<tr>
<td class="org-left">Selection Sort</td>
<td class="org-left">O(n²)（最壞）</td>
<td class="org-left">O(n²)（最佳）</td>
<td class="org-left">❌（非穩定）</td>
<td class="org-left">不論輸入如何，時間複雜度固定</td>
</tr>

<tr>
<td class="org-left">Merge Sort</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">O(n log n)</td>
<td class="org-left">✅（穩定）</td>
<td class="org-left">適用於大數據量場景</td>
</tr>
</tbody>
</table></li>
<li>輸入 [1,2,3,&#x2026;,100000] 是已排序陣列<br />
<ul class="org-ul">
<li>Insertion Sort 需要 O(n²) （檢查但不交換）<br /></li>
<li>Quicksort 和 Merge Sort 維持 O(n log n)<br /></li>
<li>Selection Sort 固定 O(n²)，但比較次數固定，未交換元素時比 Insertion Sort 好<br /></li>
</ul></li>
<li>✅ 最慢算法是 Insertion Sort，因為它需要 O(n²) 次比較和移動。<br /></li>
</ol></li>
<li><p>
For sorting from small to large with insertion sort, with, what are the two numbers that need to be swapped during the second exchange?<br />
</p>
<ol class="org-ol">
<li>3, 6<br /></li>
<li>7, 10<br /></li>
<li>6, 7<br /></li>
<li>5, 50<br /></li>
<li>答案：C. 6, 7<br /></li>
</ol>
<ul class="org-ul">
<li><p>
解析: 假設我們有一個數列：<br />
</p>
<pre class="example" id="orgacce306">
     [10, 7, 6, 3, 5, 50]
</pre></li>
<li>執行 Insertion Sort 的過程：<br />
<ol class="org-ol">
<li><p>
第一步：<br />
</p>
<ul class="org-ul">
<li>7 &lt; 10，交換，結果：<br /></li>
</ul>
<pre class="example" id="orgee9d73c">
        [7, 10, 6, 3, 5, 50]
</pre></li>
<li><p>
第二步：<br />
</p>
<ul class="org-ul">
<li>6 &lt; 10，6 &lt; 7，交換兩次：<br /></li>
</ul>
<pre class="example" id="org632ad5e">
        [6, 7, 10, 3, 5, 50]
</pre></li>
</ol></li>
<li>🔹 第二次交換的是 6, 7 ✅ 答案：C. 6, 7<br /></li>
</ul></li>
<li>What is a &ldquo;stable&rdquo; sorting algorithm?<br />
<ol class="org-ol">
<li>The algorithm has the same performance on inputs of different sizes<br /></li>
<li>The algorithm keeps the original order of items when the items are equal<br /></li>
<li>The algorithm performs the same no matter how it is implemented<br /></li>
<li>The algorithm does not move items more than one slot away in each round<br /></li>
<li>答案：B. The algorithm keeps the original order of items when the items are equal.<br /></li>
<li>解析: 穩定排序算法（Stable Sorting Algorithm）：<br />
<ul class="org-ul">
<li>定義：當兩個相等的元素排序後仍保持原始順序，則該算法是 穩定的。<br /></li>
<li>應用場景：若要根據多個條件排序（如先按字母，再按數字），穩定排序可確保第一輪排序結果不被第二輪破壞。<br /></li>
</ul></li>
<li>選項分析<br />
<ol class="org-ol">
<li>The algorithm has the same performance on inputs of different sizes ❌<br />
錯誤，算法的時間複雜度與輸入大小相關。<br /></li>
<li>The algorithm keeps the original order of items when the items are equal ✅<br />
正確，這是「穩定性」的定義。<br /></li>
<li>The algorithm performs the same no matter how it is implemented ❌<br />
錯誤，相同算法可能有不同優化方法。<br /></li>
<li>The algorithm does not move items more than one slot away in each round ❌<br />
錯誤，許多穩定排序（如 Merge Sort）在一次迭代中移動元素超過一格。<br /></li>
</ol></li>
<li>✅ 最終答案：B. The algorithm keeps the original order of items when the items are equal.<br /></li>
</ol></li>
<li><p>
In the following min heap, if we remove the minimal item 5 times, what would the two nodes with height 1 after the removals?<br />
(Diagram of a min heap)<br />
</p>
<pre class="example" id="orgdb7df86">
                  20
                /   \
               /     \
              /       \
             /         \
            /           \
           25            31
         /   \          /  \
        /     \        /    \
       50      40     51     39
      /  \    / \    /  \    /
    300  200 75  55 100 101 70
</pre>
<ol class="org-ol">
<li>25, 31<br /></li>
<li>50, 70<br /></li>
<li>75, 51<br /></li>
<li>75, 70<br /></li>
<li>答案：D. 75, 70<br /></li>
<li><p>
解析: 給定的 Min Heap<br />
</p>
<pre class="example" id="orgb31a9a8">
                    20
                  /   \
                 /     \
                /       \
               /         \
              /           \
             25            31
           /   \          /  \
          /     \        /    \
         50      40     51     39
        /  \    / \    /  \    /
      300  200 75  55 100 101 70
</pre>
<ul class="org-ul">
<li>Min Heap 確保 父節點 ≤ 子節點。<br /></li>
</ul></li>
<li>每次刪除最小元素（根節點 20），需要 堆化（heapify） 來恢復 Min Heap 性質。<br /></li>
<li>步驟 1：移除 20<br />
<ul class="org-ul">
<li>新的根節點：70 取代 20<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>70 下沉（與 25 交換）<br /></li>
<li>25 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org7f262bb">
                       25
                     /   \
                    /     \
                   /       \
                  /         \
                 /           \
                70            31
              /   \          /  \
             /     \        /    \
            50      40     51     39
           /  \    / \    /  \    /
         300  200 75  55 100 101
</pre></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：移除 25<br />
<ul class="org-ul">
<li>55 取代 25<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>55 下沉（與 40 交換）<br /></li>
<li>40 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org13dec1a">
                      40
                    /   \
                   /     \
                  /       \
                 /         \
                /           \
               70            31
             /   \          /  \
            /     \        /    \
           50      55     51     39
          /  \    / \    /  \    /
        300  200 75  20 100 101
</pre></li>
</ul></li>
<li>步驟 3：移除 40<br />
<ul class="org-ul">
<li>101 取代 40<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>101 下沉（與 39 交換）<br /></li>
<li>39 成為新的根節點<br /></li>
</ul></li>
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org4d1388b">
                    39
                  /   \
                 /     \
                /       \
               /         \
              /           \
             70            31
           /   \          /  \
          /     \        /    \
         50      55     51     101
        /  \    / \    /  \
      300  200 75  20 100
</pre></li>
</ul></li>
<li><p>
步驟 4：移除 39<br />
</p>
<ul class="org-ul">
<li>100 取代 39<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>100 下沉（與 31 交換）<br /></li>
<li>31 成為新的根節點<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
堆狀態<br />
</p>
<pre class="example" id="org1708b09">
                    31
                  /   \
                 /     \
                /       \
               /         \
              /           \
             70            100
           /   \          /  \
          /     \        /    \
         50      55     51     101
        /  \    / \
      300  200 75  20
</pre></li>
</ul></li>
<li><p>
步驟 5：移除 31<br />
</p>
<ul class="org-ul">
<li>20 取代 31<br /></li>
<li>堆化（Heapify）：<br />
<ul class="org-ul">
<li>20 下沉（與 50 交換）<br /></li>
<li>50 成為新的根節點<br /></li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
最終堆狀態<br />
</p>
<pre class="example" id="org03e257c">
                     50
                   /   \
                  /     \
                 /       \
                /         \
               /           \
              70            100
            /   \          /  \
           /     \        /    \
          75      55     51     101
         /  \
       300  200
</pre></li>
</ul></li>

<li>最終樹中，高度 1（從根往下數 1 層） 的節點為 75 和 70<br /></li>
<li>✅ 答案：D. 75, 70<br /></li>
<li><p>
總結<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">步驟</td>
<td class="org-right">刪除節點</td>
<td class="org-right">新根</td>
<td class="org-left">重新堆化結果</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">20</td>
<td class="org-right">70</td>
<td class="org-left">70 → 25</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">25</td>
<td class="org-right">55</td>
<td class="org-left">55 → 40</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">40</td>
<td class="org-right">101</td>
<td class="org-left">101 → 39</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">39</td>
<td class="org-right">100</td>
<td class="org-left">100 → 31</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">31</td>
<td class="org-right">20</td>
<td class="org-left">20 → 50</td>
</tr>

<tr>
<td class="org-right">最終結果</td>
<td class="org-right">根為 50</td>
<td class="org-right">高度 1 的節點：75, 70</td>
<td class="org-left">✅ 答案：D. 75, 70</td>
</tr>
</tbody>
</table></li>
<li>🚀 最終答案：D. 75, 70 🚀<br /></li>
</ol></li>
<li><p>
How many minimal spanning trees are in the following undirected graph?<br />
</p>

<div id="org5e1d65e" class="figure">
<p><img src="images/林北的考前猜題/G.png" alt="G.png" width="500" /><br />
</p>
</div>
<pre class="example" id="org93a741b">
    (Diagram of an undirected graph)
    {A, D} = 1
    {A, B} = 2
    {B, C} = 2
    {B, F} = 3
    {B, H} = 3
    {B, I} = 1
    {C, D} = 1
    {C, E} = 1
    {C, F} = 2
    {D, E} = 2
    {E, G} = 1
    {F, G} = 1
    {F, I} = 2
</pre>

<ol class="org-ol">
<li>2<br /></li>
<li>3<br /></li>
<li>4<br /></li>
<li>5<br /></li>
<li>答案：C. 4<br /></li>
<li><p>
解析: 我們使用 Kruskal’s Algorithm 來計算最小生成樹（MST），並找出 不同的 MST 數量。<br />
</p>
<ol class="org-ol">
<li><p>
步驟 1：列出邊的排序（按權重遞增）<br />
邊集（按權重排序）：<br />
</p>
<pre class="example" id="orgb539a86">
         {A, D} = 1
         {B, I} = 1
         {C, D} = 1
         {C, E} = 1
         {E, G} = 1
         {F, G} = 1
         {A, B} = 2
         {B, C} = 2
         {C, F} = 2
         {D, E} = 2
         {F, I} = 2
         {B, F} = 3
         {B, H} = 3
</pre>
<ul class="org-ul">
<li>我們需要選擇邊，確保構成 最小生成樹（包含所有節點且不形成環）。<br /></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：使用 Kruskal’s Algorithm 建立 MST<br />
<ul class="org-ul">
<li>先選擇權重 1 的邊（6 條）： {A, D}, {B, I}, {C, D}, {C, E}, {E, G}, {F, G}<br /></li>
<li>再選擇權重 2 的邊（2 條）： {A, B}, {C, F}<br /></li>
<li>總共選擇 (N-1) = 8 條邊，形成一個最小生成樹（MST）。<br /></li>
</ul></li>
<li><p>
步驟 3：找出不同的 MST 數量<br />
</p>
<ul class="org-ul">
<li><p>
在 權重 2 的邊中，有不同的選擇：<br />
</p>
<pre class="example" id="orgcf58de8">
          {A, B}, {C, F}
          {A, B}, {D, E}
          {B, C}, {D, E}
          {B, C}, {F, I}
</pre></li>
</ul>
<ul class="org-ul">
<li>因此，我們可以構造 4 個不同的最小生成樹。<br /></li>
<li>✅ 最終答案：C. 4 🚀<br /></li>
</ul></li>
</ol></li>
</ol></li>
<li><p>
What is the minimal number of nodes in an AVL tree with a height of 10?<br />
</p>
<ol class="org-ol">
<li>1023<br /></li>
<li>1024<br /></li>
<li>10<br /></li>
<li>9<br /></li>
<li>答案：D. 9<br /></li>
<li>解析: AVL 樹的性質<br />
<ul class="org-ul">
<li>AVL 樹是一種 自平衡二元搜索樹（BST），其中：<br /></li>
<li>左右子樹的高度差最多為 1（即 |height(left) - height(right)| ≤ 1）。<br /></li>
<li>目標是保持最低可能的節點數，以滿足 AVL 樹的高度平衡要求。<br /></li>
</ul></li>
<li>步驟 1：計算最少節點數<br />
<ul class="org-ul">
<li>我們使用一個遞推公式來求 AVL 樹的最少節點數：  N(h)=N(h−1)+N(h−2)+1<br /></li>
<li>其中：<br />
<ul class="org-ul">
<li>N(h) 是 高度為 h 的最少節點數。<br /></li>
<li>N(h-1) 和 N(h-2) 是其左右子樹的最少節點數。<br /></li>
</ul></li>
<li><p>
計算 N(h)<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">h (高度)</td>
<td class="org-right">最少節點數 N(h)N(h)</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">13</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">21</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">34</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">55</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">89</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">144</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ol>
<ol class="org-ol">
<li>步驟 2：選擇最少節點數的選項<br />
<ul class="org-ul">
<li>選項 A. 1023 ❌ 錯誤（這是 滿二元樹（Full Binary Tree） 的節點數）。<br /></li>
<li>選項 B. 1024 ❌ 錯誤（這是 滿二元樹 的節點數）。<br /></li>
<li>選項 C. 10 ❌ 錯誤（不符合 AVL 樹的最小要求）。<br /></li>
<li>選項 D. 9 ✅ 正確！（最接近最小可能的節點數）。<br /></li>
</ul></li>
</ol>

<ul class="org-ul">
<li>結論<br />
<ul class="org-ul">
<li>✅ 最小的 AVL 樹，高度 10 的情況下，需要至少 9 個節點。<br /></li>
<li>✅ 正確答案：D. 9 🚀<br /></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc91663c" class="outline-2">
<h2 id="orgc91663c"><span class="section-number-2">3.</span> 中山</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org4cce3f9" class="outline-3">
<h3 id="org4cce3f9"><span class="section-number-3">3.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>計算機概論與資料結構：這部分是歷年考題的重點，從101學年度到112學年度都有相關考題出現。內容涵蓋了基礎的程式碼分析、資料結構的應用與分析、演算法的時間複雜度分析、以及圖論相關的知識。例如，常出現的考題類型包括：<br /></li>
<li>程式碼追蹤：給定一段程式碼，要求判斷程式的輸出結果。<br /></li>
<li>資料結構操作：例如，樹的遍歷 (pre-order, in-order, post-order)，堆積 (heap) 的操作，以及圖的最小生成樹 (minimum spanning tree, MST) 的計算。<br /></li>
<li>演算法分析：例如，排序演算法 (merge sort, selection sort, bubble sort, quick sort, insertion sort) 的時間複雜度分析，以及各種搜尋演算法的應用。<br /></li>
<li>遞迴 (Recursion): 遞迴函數的編寫與分析，以及遞迴在程式碼中的應用.<br /></li>
<li>資料庫：這部分也常被納入考題，包括了 SQL 語法、正規化 (normalization)、以及關聯式資料庫的概念。近年來，也開始出現 NoSQL 資料庫的相關考題。<br /></li>
<li>網路：網路相關的考題也佔有一定比例，考題內容包括網路協定 (TCP/IP, UDP, ARP, HTTP, etc.)、IP 位址與子網路遮罩 (subnet mask) 的計算、以及無線網路技術 (WiMAX, LTE, WIFI)。<br /></li>
<li>作業系統：作業系統的考題內容包括行程管理 (process management)，記憶體管理 (memory management)，以及系統呼叫 (system call) 的概念。<br /></li>
<li>資訊管理：資訊管理方面的考題包括電子商務策略 (e-commerce strategy)、供應鏈管理 (supply chain management)、服務科學 (service science)、雲端運算 (cloud computing)、物聯網 (Internet of Things, IoT)、大數據 (big data)、以及資訊安全管理 (information security management)。此外，近年來也出現了關於區塊鏈 (blockchain)、人工智慧 (artificial intelligence, AI)、機器學習 (machine learning)、以及數位轉型 (digital transformation) 等新興技術的考題。<br /></li>
<li>其他：考題中也出現了一些較為分散的主題，如函數式編程 (functional programming)、軟體架構 (software architecture)、專案管理 (project management)、以及編譯程式 (compiler) 的步驟。<br /></li>
</ul>

<p>
總體而言，近十年的考題趨勢呈現出以下幾個特點：<br />
</p>
<ol class="org-ol">
<li>廣度增加：考題涵蓋的範圍越來越廣，除了傳統的計算機科學基礎知識外，也開始納入資訊管理、新興科技等相關知識。<br /></li>
<li>深度提升：考題不僅要求考生掌握基本概念，也要求考生具備分析問題、解決問題的能力。例如，對於演算法的時間複雜度分析，以及對於不同資料結構的應用情境分析，都是考題中常見的重點。<br /></li>
<li>實務導向：考題開始出現一些與實務相關的應用問題，例如，如何利用雲端運算提升企業競爭力，以及如何利用物聯網技術改善生活品質等。<br /></li>
<li>新興技術：近年來，區塊鏈、人工智慧、機器學習等新興技術成為熱門考題。<br /></li>
<li>跨領域整合：考題越來越強調跨領域知識的整合應用，例如，資訊管理與資訊科技的整合，或是資訊科技與商業應用的整合。<br /></li>
</ol>

<p>
準備考試時，建議考生：<br />
</p>
<ul class="org-ul">
<li>扎實掌握基礎知識：計算機概論、資料結構、演算法、資料庫、網路、作業系統等基礎知識，是所有考題的基礎。<br /></li>
<li>關注新興技術：除了基礎知識，也需要關注新興技術的發展，並了解其應用情境。<br /></li>
<li>練習歷屆考題：透過練習歷屆考題，可以了解考試的題型、出題方向，以及難易程度。<br /></li>
<li>加強英文能力：部分考題會以英文呈現，因此考生需具備一定的英文能力，才能順利應考。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org72aa99e" class="outline-3">
<h3 id="org72aa99e"><span class="section-number-3">3.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-3-2">
<p>
國立中山大學資訊管理學系碩士班入學考試模擬試題<br />
科目：計算機概論、資料結構與資訊管理<br />
</p>

<p>
作答說明：<br />
</p>
<ul class="org-ul">
<li>本試題分為選擇題與問答題，請仔細閱讀題目後作答。<br /></li>
<li>選擇題請於答案卡上劃記作答，問答題請於答案卷上作答。<br /></li>
<li>考試時間為 100 分鐘。<br /></li>
</ul>
</div>
<div id="outline-container-orge3539ad" class="outline-4">
<h4 id="orge3539ad"><span class="section-number-4">3.2.1.</span> 一、選擇題 (每題 3 分，共 60 分)</h4>
<div class="outline-text-4" id="text-3-2-1">
<ol class="org-ol">
<li>以下何者為非物件導向程式設計 (Object-Oriented Programming) 的特性？ (A) 繼承 (Inheritance) (B) 多型 (Polymorphism) (C) 封裝 (Encapsulation) (D) 遞迴 (Recursion)<br /></li>
<li>下列何者不屬於網路層 (Network Layer) 的協定？ (A) IP (B) TCP (C) ARP (D) ICMP<br /></li>
<li>在二元搜尋樹 (Binary Search Tree) 中，若要找出最小值，應該從哪個節點開始搜尋？ (A) 根節點 (Root Node) (B) 最右邊的節點 (Rightmost Node) (C) 最左邊的節點 (Leftmost Node) (D) 任何節點都可<br /></li>
<li>下列哪一種資料結構最常被用來實作深度優先搜尋 (Depth-First Search) 演算法？ (A) 堆疊 (Stack) (B) 佇列 (Queue) (C) 堆積 (Heap) (D) 鏈結串列 (Linked List)<br /></li>
<li>關於雲端運算 (Cloud Computing)，下列敘述何者為非？ (A) 是一種分散式運算環境。 (B) SaaS (軟體即服務) 是雲端運算的一種商業模式。 (C) IaaS (基礎設施即服務) 主要提供虛擬機器。 (D) 雲端運算適合用來處理小量資料的即時分析。<br /></li>
<li>以下哪一個選項是快排 (Quick Sort) 演算法最壞情況 (worst-case) 的時間複雜度？ (A) O(n) (B) O(n log n) (C) O(n^2) (D) O(log n)<br /></li>
<li>下列哪個選項是用來將網域名稱 (domain name) 對應到 IP 位址？ (A) 網域名稱系統 (DNS) (B) 位址解析協定 (ARP) (C) 傳輸控制協定 (TCP) (D) 使用者資料包協定 (UDP)<br /></li>
<li>一個迴圈程式碼如下：這題失敗，沒生出程式碼&#x2026;.<br /></li>
<li>請問執行完以上程式碼後，變數 w 的值是多少？ (A) 20 (B) 30 (C) 40 (D) 42<br /></li>
<li>在關聯式資料庫中，若一表格滿足第三正規化 (3NF)，則下列何者敘述錯誤？ (A) 每一個非主鍵屬性都必須完全相依於主鍵。 (B) 表格可能有多個候選鍵。 (C) 每一個非主鍵屬性都不能遞移相依於任何其他非主鍵屬性。 (D) 此表格必定也滿足 BCNF<br /></li>
<li>若要從頭到尾反向印出一個字串，最適合使用哪一種資料結構？ (A) 佇列 (Queue) (B) 堆疊 (Stack) (C) 二元搜尋樹 (Binary Search Tree) (D) 鏈結串列 (Linked List)<br /></li>
<li>下列何者為物聯網 (Internet of Things, IoT) 的應用範疇？ (A) 智慧家庭 (B) 工業自動化 (C) 智慧醫療 (D) 以上皆是<br /></li>
<li>關於區塊鏈 (Blockchain)，下列敘述何者正確？ (A) 區塊鏈上的資料可以隨意竄改。 (B) 區塊鏈是一種中心化的資料庫。 (C) 區塊鏈的特性包括去中心化、不可竄改、透明性。 (D) 比特幣 (Bitcoin) 是唯一使用區塊鏈技術的應用。<br /></li>
<li>下列哪一種機器學習 (Machine Learning) 演算法屬於監督式學習 (Supervised Learning)？ (A) K-means 分群法 (B) 支持向量機 (Support Vector Machine) (C) 主成分分析 (Principal Component Analysis) (D) 關聯規則學習 (Association Rule Learning)<br /></li>
<li>下列何者為非同步 (Asynchronous) 通訊的特性？ (A) 資料傳輸需要發送端和接收端的時脈同步。 (B) 資料傳輸不需要時脈信號。 (C) 資料傳輸前需要建立連線。 (D) 資料傳輸是同步進行的。<br /></li>
<li>以下哪一個選項不是大數據 (Big Data) 分析中常見的工具或框架？ (A) Apache Hadoop (B) Apache Spark (C) TensorFlow (D) MySQL<br /></li>
<li>若一系統使用 LRU (Least Recently Used) 分頁置換演算法，參考字串為 abgabdcabcad，且系統有三個可用頁框，請問會發生幾次 page fault？ (A) 9 (B) 10 (C) 11 (D) 12<br /></li>
<li>下列何者為 Deep Learning 常用的框架？ (A) TensorFlow (B) PyTorch (C) MXNet (D) 以上皆是<br /></li>
<li>下列哪一種資料結構不適合用於實現優先權佇列 (Priority Queue)？ (A) 堆積 (Heap) (B) 佇列 (Queue) (C) 二元搜尋樹 (Binary Search Tree) (D) 鏈結串列 (Linked List)<br /></li>
<li>下列哪一個選項是後序 (postfix) 運算式 A B + C D * - 的中序 (infix) 運算式？ (A) A + B - C * D (B) (A + B) - (C * D) (C) A + B - C * D (D) (A - C * D) + B<br /></li>
<li>以下何者不屬於常見的NoSQL 資料庫類型？ (A) 圖形資料庫 (Graph Database) (B) 文件資料庫 (Document Database) (C) 關聯式資料庫 (Relational Database) (D) 鍵值資料庫 (Key-Value Database)<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgaf86073" class="outline-4">
<h4 id="orgaf86073"><span class="section-number-4">3.2.2.</span> 二、問答題 (共 40 分)</h4>
<div class="outline-text-4" id="text-3-2-2">
<ol class="org-ol">
<li>請簡述 資訊安全管理系統 (Information Security Management System, ISMS) 的概念，並說明導入 ISMS 的六個主要階段。 (10 分)<br /></li>
<li>請解釋 網路效應 (Network Effect) 的概念，並舉例說明在平台經濟中，如何利用網路效應來提升競爭力。(10 分)<br /></li>
<li>請說明 人工智慧 (Artificial Intelligence) 、機器學習 (Machine Learning) 與 深度學習 (Deep Learning) 三者之間的關係，並舉例說明在資訊管理領域的應用。(10 分)<br /></li>
<li>請說明 虛擬整合 (Virtual Integration) 的概念，並舉例說明其在供應鏈管理中的應用，並分析其優缺點。(10 分)<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org493cba4" class="outline-3">
<h3 id="org493cba4"><span class="section-number-3">3.3.</span> 參考答案</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-orgae8f0aa" class="outline-4">
<h4 id="orgae8f0aa"><span class="section-number-4">3.3.1.</span> 一、選擇題</h4>
<div class="outline-text-4" id="text-3-3-1">
<ol class="org-ol">
<li>(D) 遞迴是程式設計的一種技巧，不屬於物件導向程式設計的特性。<br /></li>
<li>(B) TCP 屬於傳輸層的協定。<br /></li>
<li>(C) 二元搜尋樹的最小值在最左邊的節點。<br /></li>
<li>(A) 堆疊具有後進先出 (LIFO) 的特性，適合用於深度優先搜尋。<br /></li>
<li>(D) 雲端運算適合用來處理大量的數據，而非小量數據的即時分析。<br /></li>
<li>(C) 快排演算法在最壞情況下的時間複雜度為 O(n^2)。<br /></li>
<li>(A) DNS 用於將網域名稱對應到 IP 位址。<br /></li>
<li>(A) w 的值為 2+4+6+8=20<br /></li>
<li>(D) 滿足 BCNF 一定滿足 3NF，但滿足 3NF 不一定滿足 BCNF<br /></li>
<li>(B) 堆疊具有後進先出的特性，適合用於反轉字串。<br /></li>
<li>(D) 物聯網可應用於智慧家庭、工業自動化、智慧醫療等領域。<br /></li>
<li>(C) 區塊鏈的核心特性為去中心化、不可竄改和透明性。<br /></li>
<li>(B) 支持向量機屬於監督式學習演算法。<br /></li>
<li>(B) 非同步通訊不需要時脈信號。<br /></li>
<li>(D) MySQL 是關聯式資料庫，不屬於大數據分析的框架。<br /></li>
<li>(A) 根據 LRU 演算法，會有 9 次 page fault。<br /></li>
<li>(D) TensorFlow, PyTorch, MXNet 皆為 Deep Learning 常用框架。<br /></li>
<li>(B) 佇列不適合用來實現優先權佇列，因其以先進先出方式取出元素。<br /></li>
<li>(B) 後序運算式 A B + C D * - 的中序運算式為 (A + B) - (C * D)<br /></li>
<li>(C) 關聯式資料庫屬於傳統資料庫，不屬於 NoSQL 資料庫。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org83e6e43" class="outline-4">
<h4 id="org83e6e43"><span class="section-number-4">3.3.2.</span> 二、問答題</h4>
<div class="outline-text-4" id="text-3-3-2">
<ol class="org-ol">
<li>資訊安全管理系統 (ISMS) 是一個系統化的方法，用來分析、評估和管理組織的資訊安全風險。它提供了一套流程和架構，幫助組織建立、實施、維護和改進資訊安全措施。導入 ISMS 的六個主要階段包括：<br />
<ul class="org-ul">
<li>規劃 (Planning)：確立 ISMS 的範圍、目標和政策。<br /></li>
<li>實施 (Implementation)：根據計畫執行資訊安全措施，包括建立控制機制、培訓員工等。<br /></li>
<li>檢查 (Checking)：定期檢查和評估資訊安全措施的有效性。<br /></li>
<li>行動 (Action)：根據檢查結果，進行改進和調整。<br /></li>
<li>監控 (Monitoring)：持續監控 ISMS 的運作狀況。<br /></li>
<li>審查 (Review)：定期審查 ISMS 的成效，並進行必要的更新和改進。<br /></li>
</ul></li>
<li>網路效應指的是當一個產品或服務的使用者增加時，其價值也會隨之增加的現象。簡單來說，用的人越多，這個產品或服務就越有價值。在平台經濟中，網路效應非常重要。例如：<br />
<ul class="org-ul">
<li>社群媒體平台：當越多使用者加入社群媒體平台時，此平台對使用者的吸引力就越大。因為使用者可以與更多人聯繫、分享資訊。<br /></li>
<li>電商平台：當越多商家在電商平台上販售商品時，此平台對消費者的吸引力就越大。因為消費者可以在此平台上找到更多選擇、比較商品。<br /></li>
<li>應用程式商店：當越多開發者在應用程式商店上架應用程式，此商店對使用者的吸引力就越大，使用者可以在此商店找到更多應用程式。<br /></li>
<li>共乘平台：當越多使用者在共乘平台上註冊，此平台對使用者就越方便，因為使用者可以更容易地找到汽車共享。 利用網路效應來提升競爭力的方式包括：<br /></li>
<li>早期採用者獎勵：鼓勵早期使用者加入平台，以觸發網路效應。<br /></li>
<li>策略性合作：與其他平台或服務合作，擴大網路效應的範圍。<br /></li>
<li>差異化競爭：提供獨特的服務或功能，吸引更多使用者。<br /></li>
</ul></li>
<li>人工智慧 (AI) 是一種廣泛的概念，指的是讓電腦執行通常需要人類智慧才能完成的任務。機器學習 (ML) 是實現人工智慧的一種方法，它讓電腦可以從數據中學習，而不需要明確的程式碼。深度學習 (DL) 則是機器學習的一種分支，它使用人工神經網路 (Artificial Neural Networks) 來學習複雜的模式。在資訊管理領域的應用包括：<br />
<ul class="org-ul">
<li>客戶關係管理 (CRM)：利用機器學習分析客戶數據，提供個人化的產品推薦。<br /></li>
<li>供應鏈管理 (SCM)：利用深度學習預測供應鏈風險，優化庫存管理。<br /></li>
<li>網路安全：利用機器學習偵測網路攻擊，保護企業資訊資產。<br /></li>
<li>商業分析：利用機器學習和深度學習分析大量數據，提供商業決策的依據。<br /></li>
<li>自然語言處理 (NLP)：利用自然語言處理技術分析顧客評論，提升客戶服務品質。<br /></li>
</ul></li>
<li><p>
虛擬整合 (Virtual Integration) 指的是企業在供應鏈中，不擁有實體資產或設施，而是透過資訊科技 (IT) 連結不同的供應鏈夥伴，形成一個整合的虛擬供應鏈網路。在供應鏈管理中的應用包括：<br />
</p>
<ul class="org-ul">
<li>協同產品設計：透過網路平台與供應商協同設計產品。<br /></li>
<li>即時庫存資訊：透過系統即時取得供應商的庫存資訊，減少自身庫存成本。<br /></li>
<li>協同需求預測：與供應商共享需求預測資訊，提高供應鏈效率。<br /></li>
<li>彈性生產：根據即時需求資訊，調整生產計畫。<br /></li>
<li>即時物流追蹤：透過網路系統追蹤物流，提供即時的貨物位置資訊<br /></li>
</ul>

<p>
優點：<br />
</p>
<ul class="org-ul">
<li>彈性高：可以快速調整供應鏈以應對市場變化。<br /></li>
<li>成本低：降低了擁有實體資產的成本。<br /></li>
<li>效率高：透過資訊科技提高供應鏈效率。<br /></li>
</ul>

<p>
缺點：<br />
</p>
<ul class="org-ul">
<li>依賴資訊科技：過度依賴資訊系統，若系統故障，會影響供應鏈運作。<br /></li>
<li>信任風險：需要信任供應鏈夥伴，確保資訊透明度。<br /></li>
<li>資料安全：需要確保在合作中資料的安全性。<br /></li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org671a19e" class="outline-2">
<h2 id="org671a19e"><span class="section-number-2">4.</span> 中興</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org047172b" class="outline-3">
<h3 id="org047172b"><span class="section-number-3">4.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org55d5f35" class="outline-4">
<h4 id="org55d5f35"><span class="section-number-4">4.1.1.</span> 資料結構與演算法: 歷年考題中，資料結構與演算法是相當重要的部分。</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>常見的資料結構如linked list、binary tree、binary search tree、AVL tree、heap、hash table 等觀念頻繁出現。<br /></li>
<li>演算法部分，排序演算法如 insertion sort, selection sort, quick sort, merge sort, heap sort 都有被考過，binary search algorithm 也有出現。<br /></li>
<li>另外，圖論的 Floyd-Warshall algorithm 也曾出現。<br /></li>
<li>有些題目會要求寫出程式碼或是虛擬碼，來完成特定的操作，像是linked list的反轉或是計算特定範圍節點總和。<br /></li>
<li>Big-Oh 的時間複雜度分析 也會出現。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7b3d02d" class="outline-4">
<h4 id="org7b3d02d"><span class="section-number-4">4.1.2.</span> 程式設計:</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>會出現需要讀懂程式碼並寫出結果的題目，程式語言包含 C, Java, Python。<br /></li>
<li>程式設計的考題包含 遞迴，還有一些字串的操作。<br /></li>
<li>也會出現要求寫出函式 (function) 的題目，例如多項式相乘 、檢查質數 等。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org8b0359e" class="outline-4">
<h4 id="org8b0359e"><span class="section-number-4">4.1.3.</span> 計算機組織與結構:</h4>
<div class="outline-text-4" id="text-4-1-3">
<ul class="org-ul">
<li>基本的計算機組成元件如 accumulator, program counter, memory, ALU 等觀念需要理解。<br /></li>
<li>一些概念，例如 buffer、direct memory access、interrupt 等也要了解。<br /></li>
<li>指令執行週期 (instruction cycle)也有被考到。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org4297b2d" class="outline-4">
<h4 id="org4297b2d"><span class="section-number-4">4.1.4.</span> 作業系統:</h4>
<div class="outline-text-4" id="text-4-1-4">
<ul class="org-ul">
<li>考題中會出現 preemptive scheduling、non-preemptive scheduling 的觀念。<br /></li>
<li>paging 的觀念以及相關的計算也需要了解。<br /></li>
<li>多程式系統的記憶體管理也是重點。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgadf807c" class="outline-4">
<h4 id="orgadf807c"><span class="section-number-4">4.1.5.</span> 網路:</h4>
<div class="outline-text-4" id="text-4-1-5">
<ul class="org-ul">
<li>考題中會出現 OSI 模型。<br /></li>
<li>IPv4 相關的觀念如 datagram, fragmentation，還有網路設備的設定也需要了解。<br /></li>
<li>DHCP 的觀念也有被考到。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org1957f00" class="outline-4">
<h4 id="org1957f00"><span class="section-number-4">4.1.6.</span> 資料庫:</h4>
<div class="outline-text-4" id="text-4-1-6">
<ul class="org-ul">
<li>考題中出現 關聯式資料庫 的 正規化 (normalization) 以及 SQL 語法 。<br /></li>
<li>NoSQL 資料庫也出現在考題中。<br /></li>
<li>Entity-relationship model 的觀念也需要了解。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org92c7dda" class="outline-4">
<h4 id="org92c7dda"><span class="section-number-4">4.1.7.</span> 軟體工程:</h4>
<div class="outline-text-4" id="text-4-1-7">
<ul class="org-ul">
<li>考題中出現 系統開發的生命週期，例如 訪談、原型開發。<br /></li>
<li>Use case 的使用 也需要理解。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgcaba7b6" class="outline-4">
<h4 id="orgcaba7b6"><span class="section-number-4">4.1.8.</span> 機器學習:</h4>
<div class="outline-text-4" id="text-4-1-8">
<ul class="org-ul">
<li>近年來開始出現關於機器學習的題目，例如 supervised learning, unsupervised learning, reinforcement learning。<br /></li>
<li>K-fold cross-validation 也會出現。<br /></li>
<li>神經網路 的相關題目也開始出現， 例如基本的神經網路架構 ，還有計算梯度下降 。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org9bdd04f" class="outline-4">
<h4 id="org9bdd04f"><span class="section-number-4">4.1.9.</span> 其他:</h4>
<div class="outline-text-4" id="text-4-1-9">
<ul class="org-ul">
<li>Turing test、Turing machine, Von Neumann architecture 也曾被考到。<br /></li>
<li>RSA 加密 也有出現。<br /></li>
<li>霍夫曼編碼 (Huffman code) 的觀念也需要了解。<br /></li>
<li>數字系統的轉換，例如 二進位、十進位、八進位、十六進位 之間的轉換 。<br /></li>
<li>二補數 的概念也需要理解。<br /></li>
<li>CAP theorem 也有被考到。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org547d1a3" class="outline-3">
<h3 id="org547d1a3"><span class="section-number-3">4.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orge200ce5" class="outline-4">
<h4 id="orge200ce5"><span class="section-number-4">4.2.1.</span> 一、選擇題 (每題3分，共30分)</h4>
<div class="outline-text-4" id="text-4-2-1">
<ol class="org-ol">
<li>下列哪一個描述是錯誤的？ (A) 累加器 (Accumulator) 是一個暫存器，用來儲存算術和邏輯運算的結果。 (B) 程式計數器 (Program Counter) 指出程式中下一個要執行的指令位址。 (C) 直接記憶體存取 (Direct Memory Access, DMA) 允許周邊設備直接與記憶體傳輸數據，而不需要 CPU 的介入。 (D) 緩衝區 (Buffer) 是一種介面，用於兩個數據傳輸速度不同的設備之間，用來暫時儲存數據。 (E) 算術邏輯單元 (Arithmetic Logic Unit, ALU) 直接控制處理器的操作，並告知電腦的記憶體如何響應程式指令。<br /></li>
<li>下列哪一個排序演算法在最壞情況下的時間複雜度不是 O(n log n)? (A) 合併排序 (Merge Sort) (B) 快速排序 (Quick Sort) (C) 堆積排序 (Heap Sort) (D) 插入排序 (Insertion Sort) (E) 以上皆非<br /></li>
<li>在 OSI 模型 中，哪一層負責提供端對端的可靠傳輸？ (A) 網路層 (Network Layer) (B) 資料鏈路層 (Data Link Layer) (C) 傳輸層 (Transport Layer) (D) 會議層 (Session Layer) (E) 表達層 (Presentation Layer)<br /></li>
<li>下列哪一個不是 NoSQL 資料庫的類型？ (A) 鍵值對 (Key-value) 資料庫 (B) 文件 (Document) 資料庫 (C) 圖形 (Graph) 資料庫 (D) 關聯式 (Relational) 資料庫 (E) 寬列式 (Wide-column) 資料庫<br /></li>
<li>在 機器學習 中，下列哪一個問題最適合使用監督式學習 (Supervised Learning)？ (A) 找出顧客在零售市場中的區隔。 (B) 訓練一個 AI 機器人下棋。 (C) 將文章分類到不同的主題。 (D) 將一群顧客分成幾個群體。 (E) 在沒有標籤資料的情況下，找出數據的隱藏模式。<br /></li>
<li>若要利用 RSA 加密系統， 需先找到兩個質數 p 和 q，計算 n = p * q。 若 p = 5, q = 11, 則 n 為何？ (A) 16 (B) 45 (C) 55 (D) 65 (E) 99<br /></li>
<li>下列哪一個是 二元搜尋演算法 (binary search algorithm) 的限制？ (A) 需要使用排序過的陣列。 (B) 插入和刪除元素的花費較高。 (C) 必須有一個機制存取中間的元素。 (D) 不能應用於二元樹。 (E) 當數據量超過 1000 時，效率不高<br /></li>
<li>下列關於 CAP 定理 的敘述，何者為真？ (A) 分散式資料庫系統可以同時保證一致性 (Consistency)、可用性 (Availability) 和分割容錯性 (Partition tolerance)。 (B) 分散式資料庫系統只能保證一致性和可用性。 (C) 分散式資料庫系統只能保證一致性和分割容錯性。 (D) 分散式資料庫系統只能保證可用性和分割容錯性。 (E) 分散式資料庫系統只能保證一致性或可用性。<br /></li>
<li>下列哪一個是 Turing Test 的目標？ (A) 測試機器是否能執行複雜的計算。 (B) 測試機器是否能通過自然語言處理測試。 (C) 測試機器是否能模仿人類的智能。 (D) 測試機器是否能進行機器學習。 (E) 測試機器是否能夠解密。<br /></li>
<li>下列哪一個不是在系統開發的原型開發 (prototyping) 的優點？ (A) 作為使用者訓練的機制。 (B) 允許使用者嘗試操作軟體並了解其功能。 (C) 協助建立測試計畫和情境。 (D) 在發生高成本之前，協助確定系統的可用性和有用性。 (E) 使得計畫和排程更加容易。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org8c55ace" class="outline-4">
<h4 id="org8c55ace"><span class="section-number-4">4.2.2.</span> 二、簡答題 (每題10分，共40分)</h4>
<div class="outline-text-4" id="text-4-2-2">
<ol class="org-ol">
<li>請解釋分頁 (paging) 的觀念，以及它在多程式作業系統中如何運作。<br /></li>
<li>請寫出一個程式碼片段 (可以使用 C, Java, 或 Python)，來實作一個遞迴函式，計算 n! (n 階乘)。<br /></li>
<li>請說明梯度下降 (Gradient Descent) 在神經網路訓練中的作用，並簡述其步驟。<br /></li>
<li>請解釋 K-fold cross-validation 的概念，以及它如何應用在模型驗證上。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org6a45eae" class="outline-4">
<h4 id="org6a45eae"><span class="section-number-4">4.2.3.</span> 程式設計題 (每題15分，共30分)</h4>
<div class="outline-text-4" id="text-4-2-3">
<ol class="org-ol">
<li>給定一個 linked list 的頭節點 (head node)，請寫一個程式碼片段 (可以使用 C, Java, 或 Python) 來反轉這個 linked list。<br /></li>
<li>給定一個二元樹的前序 (preorder) 和中序 (inorder) 遍歷結果，請寫一個程式碼片段 (可以使用 C, Java, 或 Python) 來重建這個二元樹。<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgb590609" class="outline-3">
<h3 id="orgb590609"><span class="section-number-3">4.3.</span> 詳細解說答案</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-orgc108a43" class="outline-4">
<h4 id="orgc108a43"><span class="section-number-4">4.3.1.</span> 一、選擇題</h4>
<div class="outline-text-4" id="text-4-3-1">
<ol class="org-ol">
<li>答案：(E)。 算術邏輯單元 (ALU) 負責執行算術和邏輯運算，但它並不直接控制處理器的所有操作，控制單元 (Control Unit) 才是負責控制處理器的操作並告知電腦記憶體如何響應程式指令。<br /></li>
<li>答案：(D)。插入排序在最壞情況下的時間複雜度是 O(n^2)，而合併排序、快速排序、堆積排序在最壞情況下的時間複雜度都是 O(n log n)。<br /></li>
<li>答案：(C)。 傳輸層 (Transport Layer) 負責提供端對端的可靠傳輸，例如 TCP 協定。<br /></li>
<li>答案：(D)。關聯式資料庫使用結構化的表格和 SQL 語言。 NoSQL 資料庫包括鍵值對、文件、圖形和寬列式資料庫。<br /></li>
<li>答案：(C)。將文章分類到不同的主題是一個典型的監督式學習問題，因為需要有標籤的數據來訓練模型。<br /></li>
<li>答案：(C)。 RSA 加密系統中，n = p * q = 5 * 11 = 55。<br /></li>
<li>答案：(A)。 二元搜尋演算法只能應用於已排序的數據。<br /></li>
<li>答案：(D)。 CAP 定理指出，分散式資料庫系統只能保證一致性、可用性和分割容錯性中的兩個。<br /></li>
<li>答案：(C)。 圖靈測試的目標是測試機器是否能夠模仿人類的智能。<br /></li>
<li>答案：(E)。原型開發的主要優點是能夠在早期階段發現問題，協助建立測試計畫，並評估系統的可用性和有用性。計畫和排程在原型開發的早期階段可能不夠完善。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org0b82277" class="outline-4">
<h4 id="org0b82277"><span class="section-number-4">4.3.2.</span> 二、簡答題</h4>
<div class="outline-text-4" id="text-4-3-2">
<ol class="org-ol">
<li>分頁 (paging) 是一種記憶體管理技術，將邏輯記憶體分割成固定大小的區塊（稱為頁面），而物理記憶體也分割成相同大小的區塊（稱為頁框）。多程式作業系統使用分頁來允許每個程式使用非連續的記憶體空間。當程式執行時，作業系統會將程式的頁面載入到物理記憶體的頁框中，並使用分頁表來記錄邏輯地址到物理地址的映射。<br /></li>
<li><p>
以下為 Python 的程式碼範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>   <span style="color: #51afef;">def</span> <span style="color: #c678dd;">factorial</span>(n):
<span class="linenr">2: </span>       <span style="color: #51afef;">if</span> n == <span style="color: #da8548; font-weight: bold;">0</span>:
<span class="linenr">3: </span>           <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">1</span>
<span class="linenr">4: </span>       <span style="color: #51afef;">else</span>:
<span class="linenr">5: </span>           <span style="color: #51afef;">return</span> n * factorial(n-<span style="color: #da8548; font-weight: bold;">1</span>)
</pre>
</div></li>
<li>梯度下降 (Gradient Descent) 是一種優化演算法，用於訓練神經網路的權重。它通過迭代地調整權重，使得損失函數的值最小化。步驟如下：<br />
<ul class="org-ul">
<li>計算當前權重下損失函數的梯度。<br /></li>
<li>根據學習率和梯度，更新權重。<br /></li>
<li>重複以上步驟，直到損失函數收斂或達到迭代次數的上限。<br /></li>
</ul></li>
<li>K-fold cross-validation 是一種模型驗證技術，將數據集分成 K 個子集（稱為 fold）。然後，使用其中 K-1 個子集來訓練模型，並使用剩下的 1 個子集來驗證模型。重複這個過程 K 次，每次使用不同的子集作為驗證集。最後，平均 K 次驗證結果，以獲得更可靠的模型性能評估。<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org560ce77" class="outline-4">
<h4 id="org560ce77"><span class="section-number-4">4.3.3.</span> 三、程式設計題</h4>
<div class="outline-text-4" id="text-4-3-3">
<ol class="org-ol">
<li><p>
以下為 Java 的程式碼範例：<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>   <span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> ListNode {
<span class="linenr"> 2: </span>       <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">val</span>;
<span class="linenr"> 3: </span>       ListNode next;
<span class="linenr"> 4: </span>       ListNode(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>) { val = x; }
<span class="linenr"> 5: </span>   }
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>   <span style="color: #51afef;">public</span> ListNode reverseList(ListNode head) {
<span class="linenr"> 8: </span>       ListNode prev = <span style="color: #a9a1e1;">null</span>;
<span class="linenr"> 9: </span>       ListNode current = head;
<span class="linenr">10: </span>       ListNode next = <span style="color: #a9a1e1;">null</span>;
<span class="linenr">11: </span>       <span style="color: #51afef;">while</span> (current != <span style="color: #a9a1e1;">null</span>) {
<span class="linenr">12: </span>           next = current.next;
<span class="linenr">13: </span>           current.next = prev;
<span class="linenr">14: </span>           prev = current;
<span class="linenr">15: </span>           current = next;
<span class="linenr">16: </span>       }
<span class="linenr">17: </span>       head = prev;
<span class="linenr">18: </span>       <span style="color: #51afef;">return</span> head;
<span class="linenr">19: </span>   }
</pre>
</div></li>
<li>以下為 Python 的程式碼範例：<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">TreeNode</span>:
<span class="linenr"> 2: </span>    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__init__</span>(<span style="color: #51afef;">self</span>, val):
<span class="linenr"> 3: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">val</span> = val
<span class="linenr"> 4: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">left</span> = <span style="color: #a9a1e1;">None</span>
<span class="linenr"> 5: </span>        <span style="color: #51afef;">self</span>.<span style="color: #dcaeea;">right</span> = <span style="color: #a9a1e1;">None</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #51afef;">def</span> <span style="color: #c678dd;">buildTree</span>(preorder, inorder):
<span class="linenr"> 8: </span>    <span style="color: #51afef;">if</span> <span style="color: #51afef;">not</span> preorder <span style="color: #51afef;">or</span> <span style="color: #51afef;">not</span> inorder:
<span class="linenr"> 9: </span>        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">None</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #dcaeea;">root_val</span> = preorder
<span class="linenr">12: </span>    <span style="color: #dcaeea;">root</span> = TreeNode(root_val)
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #dcaeea;">root_index</span> = inorder.index(root_val)
<span class="linenr">15: </span>
<span class="linenr">16: </span>    root.<span style="color: #dcaeea;">left</span> = buildTree(preorder[<span style="color: #da8548; font-weight: bold;">1</span>:root_index+<span style="color: #da8548; font-weight: bold;">1</span>], inorder[:root_index])
<span class="linenr">17: </span>    root.<span style="color: #dcaeea;">right</span> = buildTree(preorder[root_index+<span style="color: #da8548; font-weight: bold;">1</span>:], inorder[root_index+<span style="color: #da8548; font-weight: bold;">1</span>:])
<span class="linenr">18: </span>
<span class="linenr">19: </span>    <span style="color: #51afef;">return</span> root
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb5393d8" class="outline-2">
<h2 id="orgb5393d8"><span class="section-number-2">5.</span> 清大</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org0b0793e" class="outline-3">
<h3 id="org0b0793e"><span class="section-number-3">5.1.</span> 近10年趨勢</h3>
<div class="outline-text-3" id="text-5-1">
<p>
以下是從這些考古題中觀察到的趨勢：<br />
</p>
</div>
<div id="outline-container-org1e60e2a" class="outline-4">
<h4 id="org1e60e2a"><span class="section-number-4">5.1.1.</span> 基本程式概念和資料結構：</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>遞迴：有多個題目都使用遞迴概念來解題，例如將十進制數字轉換為二進制。<br /></li>
<li>鏈結串列：考題中有要求反轉鏈結串列的實作。<br /></li>
<li>二元樹：有考題關於二元樹的儲存方式、遍歷以及二元搜尋樹的建立。<br /></li>
<li>堆疊：有題目要求使用堆疊來反轉相鄰的資料。<br /></li>
<li>佇列：有題目提到佇列的相關概念。<br /></li>
<li>雜湊表：有考題關於雜湊表的碰撞機率計算。<br /></li>
<li>前序式、後序式：有考題要求將前序式轉換為後序式。<br /></li>
<li>排序演算法：有提到排序演算法的相關概念，例如快速排序和合併排序。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org46182a9" class="outline-4">
<h4 id="org46182a9"><span class="section-number-4">5.1.2.</span> 計算機組織與結構：</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>浮點數表示法：考題中有關於浮點數的二進制表示法以及誤差計算。<br /></li>
<li>二補數：有題目探討二補數的表示範圍和加法運算。<br /></li>
<li>位元運算：有題目關於位元循環移位的操作。<br /></li>
<li>指令週期：有考題探討 CPU 的指令執行時間，包括有無 pipeline 的情況。<br /></li>
<li>快取記憶體：雖然沒有直接的考題，但在第 30 頁有提及快取記憶體（cache）的概念。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org43a9f39" class="outline-4">
<h4 id="org43a9f39"><span class="section-number-4">5.1.3.</span> 作業系統：</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>核心：有考題詢問作業系統核心的主要組成部分和功能，以及核心如何從使用者程式奪回控制權。<br /></li>
<li>行程和工作佇列：考題中有關於作業系統中工作佇列和行程佇列的內容。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org90e03ae" class="outline-4">
<h4 id="org90e03ae"><span class="section-number-4">5.1.4.</span> 網路：</h4>
<div class="outline-text-4" id="text-5-1-4">
<ul class="org-ul">
<li>TCP/UDP：有題目比較 TCP 和 UDP 的服務差異，以及 TCP 如何偵測網路擁塞。<br /></li>
<li>網路層：有考題詢問網路軟體的層級和功能。<br /></li>
<li>CSMA/CD：有考題說明 CSMA/CD 的功能與運作原理。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org54f3249" class="outline-4">
<h4 id="org54f3249"><span class="section-number-4">5.1.5.</span> 演算法分析：</h4>
<div class="outline-text-4" id="text-5-1-5">
<ul class="org-ul">
<li>時間複雜度：有題目要求分析程式的時間複雜度，並使用 big-O 符號表示。<br /></li>
<li>遞迴關係式：考題中有遞迴關係式的分析。<br /></li>
<li>圖論：有考題關於圖的頂點覆蓋問題和最小生成樹演算法，以及歐拉路徑的概念。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgbc20ae2" class="outline-4">
<h4 id="orgbc20ae2"><span class="section-number-4">5.1.6.</span> 其他：</h4>
<div class="outline-text-4" id="text-5-1-6">
<ul class="org-ul">
<li>圖靈機：有題目要求設計圖靈機來執行減值操作。<br /></li>
<li>錯誤更正碼：有題目關於錯誤更正碼的偵測和修正能力。<br /></li>
<li>開源/閉源軟體：有考題詢問開源和閉源軟體的差異，並舉例說明。<br /></li>
<li>邊界值分析：考題中有關於使用邊界值分析進行測試的題目。<br /></li>
<li>生產系統：有題目要求將一個問題以生產系統的狀態和規則描述。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org26ae21d" class="outline-4">
<h4 id="org26ae21d"><span class="section-number-4">5.1.7.</span> 數學概念：</h4>
<div class="outline-text-4" id="text-5-1-7">
<ul class="org-ul">
<li>機率：有考題計算雜湊碰撞的機率。<br /></li>
<li>幾何：有題目要求計算平面上的反射點。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgede288b" class="outline-3">
<h3 id="orgede288b"><span class="section-number-3">5.2.</span> AI模擬試題</h3>
<div class="outline-text-3" id="text-5-2">
<p>
清華大學資訊工程學系 113 學年度「計算機概論」模擬試題<br />
考試時間：100 分鐘<br />
總分：100 分<br />
</p>
</div>
<div id="outline-container-orgb6619e2" class="outline-4">
<h4 id="orgb6619e2"><span class="section-number-4">5.2.1.</span> 1. 程式設計與資料結構 (30 分)</h4>
<div class="outline-text-4" id="text-5-2-1">
</div>
<div id="outline-container-org23ccbdc" class="outline-5">
<h5 id="org23ccbdc">(a) 遞迴與迭代 (10%)：</h5>
<div class="outline-text-5" id="text-org23ccbdc">
<p>
請使用遞迴和迭代兩種方式，實作一個函數來計算費氏數列的第 n 項 (Fibonacci sequence)。並分析這兩種方式的時間複雜度。<br />
</p>
</div>
</div>
<div id="outline-container-org6d6babd" class="outline-5">
<h5 id="org6d6babd">(b) 鏈結串列操作 (10%)：</h5>
<div class="outline-text-5" id="text-org6d6babd">
<p>
給定一個單向鏈結串列的頭節點，請實作一個函數來判斷此鏈結串列是否為迴文 (palindrome)。請分析你的演算法的時間複雜度。 (c) 二元樹與搜尋 (10%)：給定一個二元搜尋樹 (BST)，請實作一個函數來找出樹中第 k 小的元素。請分析你的演算法的時間複雜度，並解釋如何應用中序走訪 (inorder traversal)。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org60e0ceb" class="outline-4">
<h4 id="org60e0ceb"><span class="section-number-4">5.2.2.</span> 2. 計算機組織與結構 (25 分)</h4>
<div class="outline-text-4" id="text-5-2-2">
</div>
<div id="outline-container-org6a9e04b" class="outline-5">
<h5 id="org6a9e04b">(a) 浮點數表示法 (10%)：</h5>
<div class="outline-text-5" id="text-org6a9e04b">
<p>
假設有一個 10 位元的浮點數表示法，其中 1 位元為符號位元，5 位元為指數 (excess-15 表示法)，4 位元為尾數。請將十進制數字 -5.625 轉換為此浮點數表示法。並討論此表示法的最大和最小可表示數字。<br />
</p>
</div>
</div>
<div id="outline-container-orgb4a245e" class="outline-5">
<h5 id="orgb4a245e">(b) 記憶體階層 (10%)：</h5>
<div class="outline-text-5" id="text-orgb4a245e">
<p>
請說明快取記憶體 (cache memory) 的運作原理，並解釋快取記憶體如何提高記憶體存取速度。請比較直接映射 (direct mapping) 和集合關聯 (set-associative) 快取之間的差異。<br />
</p>
</div>
</div>
<div id="outline-container-org021cfac" class="outline-5">
<h5 id="org021cfac">(c) 指令集架構 (5%)：</h5>
<div class="outline-text-5" id="text-org021cfac">
<p>
簡述 RISC (精簡指令集計算機) 和 CISC (複雜指令集計算機) 的主要差異，並各舉一個例子說明。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org3141aa2" class="outline-4">
<h4 id="org3141aa2"><span class="section-number-4">5.2.3.</span> 3. 作業系統與網路 (25 分)</h4>
<div class="outline-text-4" id="text-5-2-3">
</div>
<div id="outline-container-org4f52151" class="outline-5">
<h5 id="org4f52151">(a) 行程管理 (10%)：</h5>
<div class="outline-text-5" id="text-org4f52151">
<p>
請解釋作業系統中的行程 (process) 和執行緒 (thread) 的概念，並比較它們之間的差異。說明行程排程演算法 (例如：FCFS, SJF, Round Robin) 的目的。<br />
</p>
</div>
</div>
<div id="outline-container-orgaa18916" class="outline-5">
<h5 id="orgaa18916">(b) 網路協定 (10%)：</h5>
<div class="outline-text-5" id="text-orgaa18916">
<p>
請說明 TCP 三次握手 (three-way handshake) 的過程，並解釋為什麼需要這個過程。比較 TCP 和 UDP 在可靠性、速度和應用場景上的差異。<br />
</p>
</div>
</div>
<div id="outline-container-org91de3a5" class="outline-5">
<h5 id="org91de3a5">(c) 雲端運算 (5%)：</h5>
<div class="outline-text-5" id="text-org91de3a5">
<p>
簡述雲端運算 (cloud computing) 的基本概念，並說明 IaaS (基礎設施即服務)、PaaS (平台即服務) 和 SaaS (軟體即服務) 的差異。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf496afb" class="outline-4">
<h4 id="orgf496afb"><span class="section-number-4">5.2.4.</span> 4. 演算法與新興技術 (20 分)</h4>
<div class="outline-text-4" id="text-5-2-4">
</div>
<div id="outline-container-org78b7dc7" class="outline-5">
<h5 id="org78b7dc7">(a) 圖論演算法 (10%)：</h5>
<div class="outline-text-5" id="text-org78b7dc7">
<p>
給定一個加權無向圖，請使用 Dijkstra 演算法找出從起點到所有其他節點的最短路徑。請解釋 Dijkstra 演算法的原理，並說明其時間複雜度。<br />
</p>
</div>
</div>
<div id="outline-container-org503b93c" class="outline-5">
<h5 id="org503b93c">(b) 機器學習基礎 (10%)：</h5>
<div class="outline-text-5" id="text-org503b93c">
<p>
簡述機器學習 (machine learning) 中監督式學習 (supervised learning) 和非監督式學習 (unsupervised learning) 的概念，並各舉一個實際應用的例子。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7c0e901" class="outline-3">
<h3 id="org7c0e901"><span class="section-number-3">5.3.</span> 詳細解答：</h3>
<div class="outline-text-3" id="text-5-3">
</div>
<div id="outline-container-orgdf1d1c8" class="outline-4">
<h4 id="orgdf1d1c8"><span class="section-number-4">5.3.1.</span> 1. 程式設計與資料結構</h4>
<div class="outline-text-4" id="text-5-3-1">
</div>
<div id="outline-container-orge15bdf1" class="outline-5">
<h5 id="orge15bdf1">(a) 遞迴與迭代</h5>
<div class="outline-text-5" id="text-orge15bdf1">
</div>
<ul class="org-ul">
<li><a id="org1a16aa6"></a>遞迴： cpp<br />
<div class="outline-text-6" id="text-org1a16aa6">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr">1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fib_recursive</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr">2: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr">3: </span>  <span style="color: #51afef;">return</span> fib_recursive(n - <span style="color: #da8548; font-weight: bold;">1</span>) + fib_recursive(n - <span style="color: #da8548; font-weight: bold;">2</span>);
<span class="linenr">4: </span>}
</pre>
</div>
<p>
時間複雜度為 O(2^n)，因為每個呼叫都會產生兩個新的呼叫。<br />
</p>
</div>
</li>
<li><a id="orga91a4b9"></a>迭代： cpp<br />
<div class="outline-text-6" id="text-orga91a4b9">
<div class="org-src-container">
<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">fib_iterative</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span>) {
<span class="linenr"> 2: </span>  <span style="color: #51afef;">if</span> (n &lt;= <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #51afef;">return</span> n;
<span class="linenr"> 3: </span>  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">prev</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">curr</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
<span class="linenr"> 4: </span>  <span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">2</span>; i &lt;= n; i++) {
<span class="linenr"> 5: </span>    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">next</span> = prev + curr;
<span class="linenr"> 6: </span>    prev = curr;
<span class="linenr"> 7: </span>    curr = next;
<span class="linenr"> 8: </span>  }
<span class="linenr"> 9: </span>  <span style="color: #51afef;">return</span> curr;
<span class="linenr">10: </span>}
</pre>
</div>
<p>
時間複雜度為 O(n)，因為只遍歷一次迴圈。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org20916cf" class="outline-5">
<h5 id="org20916cf">(b) 鏈結串列操作</h5>
<div class="outline-text-5" id="text-org20916cf">
<ul class="org-ul">
<li>將鏈結串列複製一份並反轉，然後比較反轉後的鏈結串列是否與原鏈結串列相同。 * 可以使用快慢指針找到鏈結串列的中點，然後反轉後一半的鏈結串列，再與前半部比較。<br /></li>
<li>時間複雜度：O(n)，需走訪鏈結串列一次。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org650c8e4" class="outline-5">
<h5 id="org650c8e4">(c) 二元樹與搜尋</h5>
<div class="outline-text-5" id="text-org650c8e4">
<ul class="org-ul">
<li>使用中序走訪 (inorder traversal) 可以按照排序順序訪問二元搜尋樹的所有節點。<br /></li>
<li>使用一個計數器追蹤走訪的節點數，當計數器等於 k 時，返回當前節點的值。<br /></li>
<li>時間複雜度：O(n) 最差情況下需要走訪所有節點。平均情況下為 O(k)，如果樹平衡良好，則可以在 O(h) 的時間找到，h是樹的高度。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org41864ae" class="outline-4">
<h4 id="org41864ae"><span class="section-number-4">5.3.2.</span> 2. 計算機組織與結構</h4>
<div class="outline-text-4" id="text-5-3-2">
</div>
<div id="outline-container-org764971f" class="outline-5">
<h5 id="org764971f">(a) 浮點數表示法</h5>
<div class="outline-text-5" id="text-org764971f">
<ul class="org-ul">
<li>-5.625 的二進制表示為 -101.101。<br /></li>
<li>將其標準化為 -1.01101 x 2^2。<br /></li>
<li>符號位元：1 (負數)<br /></li>
<li>指數：2 + 15 = 17，二進制為 10001<br /></li>
<li>尾數：01101 (取小數部分，不足補 0)<br /></li>
<li>因此，表示為 1 10001 0110。<br /></li>
<li>最大可表示數字：約為 (1.1111) 2^15<br /></li>
<li>最小可表示數字：約為 (1.0000) 2^-15<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org5519598" class="outline-5">
<h5 id="org5519598">(b) 記憶體階層</h5>
<div class="outline-text-5" id="text-org5519598">
<ul class="org-ul">
<li>快取記憶體是一個小而快的記憶體，用於儲存經常存取的資料，以減少 CPU 從主記憶體讀取資料的時間。 * 直接映射快取：每個主記憶體區塊只能映射到快取中的一個特定位置。<br /></li>
<li>集合關聯快取：每個主記憶體區塊可以映射到快取中多個特定位置的集合，提供更高的靈活性和較低的碰撞率。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgd7014cb" class="outline-5">
<h5 id="orgd7014cb">(c) 指令集架構</h5>
<div class="outline-text-5" id="text-orgd7014cb">
<ul class="org-ul">
<li>RISC：指令集簡化，指令長度固定，硬體實現簡單，執行速度快。例如：ARM。<br /></li>
<li>CISC：指令集複雜，指令長度不固定，硬體實現複雜，功能強大。例如：Intel x86。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2d6abcc" class="outline-4">
<h4 id="org2d6abcc"><span class="section-number-4">5.3.3.</span> 3. 作業系統與網路</h4>
<div class="outline-text-4" id="text-5-3-3">
</div>
<div id="outline-container-orgcdb48c4" class="outline-5">
<h5 id="orgcdb48c4">(a) 行程管理</h5>
<div class="outline-text-5" id="text-orgcdb48c4">
<ul class="org-ul">
<li>行程：程式執行時的實例，包含程式碼、資料、堆疊、和程式計數器等資源，是作業系統進行資源分配和調度的基本單位。<br /></li>
<li>執行緒：行程內的一個執行單元，多個執行緒共享同一行程的資源，因此執行緒間的切換比行程切換快。<br /></li>
<li>行程排程演算法：<br />
<ul class="org-ul">
<li>FCFS (First Come First Served)：先到先服務，依據行程到達的先後順序執行。<br /></li>
<li>SJF (Shortest Job First)：最短工作優先，優先執行所需時間最短的行程。<br /></li>
<li>Round Robin：循環排程，每個行程執行一段時間後，輪流執行下一個行程。<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2d2c029" class="outline-5">
<h5 id="org2d2c029">(b) 網路協定</h5>
<div class="outline-text-5" id="text-org2d2c029">
<ul class="org-ul">
<li><p>
TCP 三次握手：<br />
</p>
<ol class="org-ol">
<li>客戶端發送 SYN 封包到伺服器。<br /></li>
<li>伺服器收到 SYN 後，回覆 SYN-ACK 封包給客戶端。<br /></li>
<li>客戶端收到 SYN-ACK 後，發送 ACK 封包給伺服器。<br /></li>
</ol>
<p>
此過程用於建立可靠的 TCP 連線，並協商雙方初始序列號。<br />
</p></li>
<li>TCP：可靠傳輸、面向連線、有流量控制和擁塞控制。適用於檔案傳輸、網頁瀏覽。<br /></li>
<li>UDP：不可靠傳輸、無連線、速度快，但沒有流量控制。適用於串流媒體、線上遊戲。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgea811d9" class="outline-5">
<h5 id="orgea811d9">(c) 雲端運算</h5>
<div class="outline-text-5" id="text-orgea811d9">
<ul class="org-ul">
<li>雲端運算：通過網路提供可擴展的計算資源。<br /></li>
<li>IaaS：提供虛擬機、儲存和網路等基礎設施，用戶需自行管理作業系統和應用程式。<br /></li>
<li>PaaS：提供開發平台和工具，用戶可在此平台上開發和部署應用程式。<br /></li>
<li>SaaS：提供現成的應用軟體，用戶直接使用即可。<br /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0851923" class="outline-4">
<h4 id="org0851923"><span class="section-number-4">5.3.4.</span> 4. 演算法與新興技術</h4>
<div class="outline-text-4" id="text-5-3-4">
</div>
<div id="outline-container-orgb52acd7" class="outline-5">
<h5 id="orgb52acd7">(a) 圖論演算法</h5>
<div class="outline-text-5" id="text-orgb52acd7">
<ul class="org-ul">
<li>Dijkstra 演算法：從起點開始，維護一個最短路徑集合，並逐步擴展到其他節點，直到找到所有節點的最短路徑。<br /></li>
<li>時間複雜度：O(E log V)，其中 E 為邊的數量，V 為頂點的數量。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org6102524" class="outline-5">
<h5 id="org6102524">(b) 機器學習基礎</h5>
<div class="outline-text-5" id="text-org6102524">
<ul class="org-ul">
<li>監督式學習：使用標記過的資料進行訓練，讓模型學習從輸入到輸出的對應關係。例如：圖像分類、語音辨識。<br /></li>
<li>非監督式學習：使用未標記的資料進行訓練，讓模型自行找出資料中的模式和結構。例如：分群、降維。<br /></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orga94c515" class="outline-2">
<h2 id="orga94c515"><span class="section-number-2">6.</span> 成大</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgb53c330" class="outline-3">
<h3 id="orgb53c330"><span class="section-number-3">6.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org9b04aad" class="outline-3">
<h3 id="org9b04aad"><span class="section-number-3">6.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-org0740fe1" class="outline-2">
<h2 id="org0740fe1"><span class="section-number-2">7.</span> 中央</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org54a4a44" class="outline-3">
<h3 id="org54a4a44"><span class="section-number-3">7.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-orga3047e6" class="outline-3">
<h3 id="orga3047e6"><span class="section-number-3">7.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-orgef649ae" class="outline-2">
<h2 id="orgef649ae"><span class="section-number-2">8.</span> 北大</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgae3087e" class="outline-3">
<h3 id="orgae3087e"><span class="section-number-3">8.1.</span> 近10年趨勢</h3>
</div>
<div id="outline-container-org8dfe1e3" class="outline-3">
<h3 id="org8dfe1e3"><span class="section-number-3">8.2.</span> AI模擬試題</h3>
</div>
</div>
<div id="outline-container-org2eeae4c" class="outline-2">
<h2 id="org2eeae4c"><span class="section-number-2">9.</span> 林北的考前猜題</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org7a5e20a" class="outline-3">
<h3 id="org7a5e20a"><span class="section-number-3">9.1.</span> 網路</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-orge55b25c" class="outline-4">
<h4 id="orge55b25c"><span class="section-number-4">9.1.1.</span> 簡單的概念知識</h4>
<div class="outline-text-4" id="text-9-1-1">
<p>
看這章：<a href="https://data.slhs.tp.edu.tw/shien/bcc/download/book/C221A1_ch14.pdf">https://data.slhs.tp.edu.tw/shien/bcc/download/book/C221A1_ch14.pdf</a><br />
</p>
<ul class="org-ul">
<li>ISO的OSI(網路七層): 14-1<br /></li>
<li>TCP/IP: 14-2<br /></li>
<li>WIFI, 藍芽, RFID, NFC: 14-3<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org543795d" class="outline-4">
<h4 id="org543795d"><span class="section-number-4">9.1.2.</span> 如何計算IP位址與網路遮罩</h4>
<div class="outline-text-4" id="text-9-1-2">
</div>
<div id="outline-container-orgc792b96" class="outline-5">
<h5 id="orgc792b96">IP的等級</h5>
<div class="outline-text-5" id="text-orgc792b96">
<ul class="org-ul">
<li>IP(例如8.8.8.8)分為A,B,C三級<br /></li>
<li>每一組IP都是一個 8-bit 的二進位數字,﹐每組數字為一個“octet”﹐合共起來就是一個 32-bit 的 IP 位址﹐亦即是 IP v4 (Version 4) 版本的位址<br /></li>
<li>所以 8.8.8.8 的完整二進位格式是：00001000.00001000.00001000.00001000<br /></li>
<li>128.10.20.30 的二進位格式是：10000000.00001010.00010100.00011110<br /></li>
<li>192.168.1.1 的二進位格式是：11000000.10101000.00000001.00000001<br /></li>
<li>上面三個IP分別是A,B,C級網路IP<br /></li>
<li>可以由二進位來判斷一個IP是哪一級：<br />
<ul class="org-ul">
<li>如果是以“0”開頭的﹐這是一個 A Class的 IP<br /></li>
<li>如果是以“10”開頭的﹐這是一個 B Class的 IP<br /></li>
<li>如果是以“110”為開頭的﹐則屬於 C Class的 IP<br /></li>
</ul></li>
<li>也可以死記﹕<br />
<ul class="org-ul">
<li>由 1 到 126 開頭的 IP 是 A Class<br /></li>
<li>由 128 到 191開頭的 IP是 B Class<br /></li>
<li>由 192 到 223 開頭的則為 C Class<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org88602df" class="outline-5">
<h5 id="org88602df">不同等級的網路，差異在於這組網路有多少可用IP</h5>
<div class="outline-text-5" id="text-org88602df">
<ul class="org-ul">
<li>A,B,C級網路的可用IP(可以用算的 C級的254=2^16 - 2, 原因看底下)<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">等級</th>
<th scope="col" class="org-right">開首</th>
<th scope="col" class="org-left">網路數目</th>
<th scope="col" class="org-left">主機數目</th>
<th scope="col" class="org-left">使用範圍</th>
<th scope="col" class="org-left">申請領域</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">0</td>
<td class="org-left">127</td>
<td class="org-left">16,777,214</td>
<td class="org-left">1.x.x.x 到 126.x.x.x</td>
<td class="org-left">國家級</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">10</td>
<td class="org-left">16,384</td>
<td class="org-left">65,534</td>
<td class="org-left">128.x.x.x 到 191.x.x.x</td>
<td class="org-left">跨國組織</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-right">110</td>
<td class="org-left">2,097,152</td>
<td class="org-left">254</td>
<td class="org-left">192.x.x.x 到 223.x.x.x</td>
<td class="org-left">企業組織</td>
</tr>

<tr>
<td class="org-left">D</td>
<td class="org-right">1110</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">224.- 到 239.-</td>
<td class="org-left">特殊用途</td>
</tr>

<tr>
<td class="org-left">E</td>
<td class="org-right">1111</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">240.- 到 255.-</td>
<td class="org-left">保留範圍</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li><p>
IP 的 Net_ID 和 Host_ID﹕<br />
</p>
<ul class="org-ul">
<li>A Class 的 IP 使用最前面一組數字來做 Net ID﹐其余三組做 Host ID<br /></li>
<li>B Class 的 IP 使用前面兩組數字來做 Net ID﹐另兩組做 Host ID<br /></li>
<li>C Class 的 IP 使用前面三組數字來做 Net ID﹐剩下的一組做 Host ID<br /></li>
</ul>
<p>
如下圖<br />
</p>

<div id="org848756c" class="figure">
<p><img src="images/林北的考前猜題/2025-01-27_17-20-33_ip1.png" alt="2025-01-27_17-20-33_ip1.png" width="500" /><br />
</p>
</div></li>
<li>後面的Host ID就是這組網路能用的IP，例如C級網路前面的Net ID是固定的，所以能用的就只有後面的Host ID, 0 - 255<br /></li>
<li>例如，南一中分配到的一組網路ID是210.70.137,<br />
<ul class="org-ul">
<li>預設的子網路遮罩就是255.255.255.0<br /></li>
<li>我們能用的IP就是210.70.137.0 - 210.70.137.255,共256個<br /></li>
<li>但是要扣掉兩組IP, 所以剩254個能用<br />
<ul class="org-ul">
<li>網路 ID：210.70.137.0<br /></li>
<li>廣播地址：210.70.137.255<br /></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgaa65cd5" class="outline-5">
<h5 id="orgaa65cd5">IP與NetMask</h5>
<div class="outline-text-5" id="text-orgaa65cd5">
<ul class="org-ul">
<li>因為IP位址分為主機和網路號碼，所以在Internet的網路上找尋電腦時，我們需要先找到網路號碼，然後在子網路中找到目的地的主機，所以電腦IP位址的設定除了IP位址外，另一個重要的號碼就是子網路遮罩。<br /></li>
<li>「子網路遮罩」(Subnet Mask)是一個固定的值，在電腦的定址計算中是使用子網路遮罩的值將IP位址分為網路號碼和主機號碼，子網路遮罩的值依網路等級的預設值，如下所示：<br />
<ul class="org-ul">
<li>Class A：255.0.0.0<br /></li>
<li>Class B：255.255.0.0<br /></li>
<li>Class C：255.255.255.0<br /></li>
</ul></li>
<li>簡單的說255的二進位值能夠遮掉IP位址中的網路號碼，經過運算後剩下的就是主機號碼，如此可以識別IP位址所屬的網路。<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org7577516" class="outline-5">
<h5 id="org7577516">網路分割(分成兩個)</h5>
<div class="outline-text-5" id="text-org7577516">
<ul class="org-ul">
<li>可以透過NetMask來把一個網路切成兩個或更多<br /></li>
<li><p>
例如把一個C級網路切成兩個，分給電個學校，這樣就不能用預設的netmask 255.255.255.0<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">子網</th>
<th scope="col" class="org-right">網路 ID</th>
<th scope="col" class="org-right">廣播地址</th>
<th scope="col" class="org-left">可用 IP 範圍</th>
<th scope="col" class="org-right">子網掩碼</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">子網 1</td>
<td class="org-right">210.70.137.0</td>
<td class="org-right">210.70.137.127</td>
<td class="org-left">210.70.137.1 ~ 210.70.137.126</td>
<td class="org-right">255.255.255.128</td>
</tr>

<tr>
<td class="org-left">子網 2</td>
<td class="org-right">210.70.137.128</td>
<td class="org-right">210.70.137.255</td>
<td class="org-left">210.70.137.129 ~ 210.70.137.254</td>
<td class="org-right">255.255.255.128</td>
</tr>
</tbody>
</table></li>
<li>之後這個C級網路就會變成以下兩個子網路，可以分配給兩個學校<br />
<ul class="org-ul">
<li>子網 1：210.70.137.0/25<br /></li>
<li>子網 2：210.70.137.128/25<br /></li>
<li>25的意思是netmask有25個1(11111111.11111111.11111111.10000000)<br /></li>
<li>沒分割的C級網路netmask預設是24(11111111.11111111.11111111.00000000)<br /></li>
</ul></li>
<li>每分割一次，就會損失掉兩個IP（第一個和最後一個IP位址是保留作為特殊的用途, 第一個位址代表的是Network ID, 最後一個位址代表的是廣播位址), 所以分割越細浪費越多IP<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orga1a66b2" class="outline-5">
<h5 id="orga1a66b2">分成4個</h5>
<div class="outline-text-5" id="text-orga1a66b2">
<ul class="org-ul">
<li><p>
將 210.70.137.0/24 分成 4 個子網後的分配如下：<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">子網</th>
<th scope="col" class="org-right">網路 ID</th>
<th scope="col" class="org-right">廣播地址</th>
<th scope="col" class="org-left">可用 IP 範圍</th>
<th scope="col" class="org-right">子網掩碼</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">子網 1</td>
<td class="org-right">210.70.137.0</td>
<td class="org-right">210.70.137.63</td>
<td class="org-left">210.70.137.1 ~ 210.70.137.62</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 2</td>
<td class="org-right">210.70.137.64</td>
<td class="org-right">210.70.137.127</td>
<td class="org-left">210.70.137.65 ~ 210.70.137.126</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 3</td>
<td class="org-right">210.70.137.128</td>
<td class="org-right">210.70.137.191</td>
<td class="org-left">210.70.137.129 ~ 210.70.137.190</td>
<td class="org-right">255.255.255.192</td>
</tr>

<tr>
<td class="org-left">子網 4</td>
<td class="org-right">210.70.137.192</td>
<td class="org-right">210.70.137.255</td>
<td class="org-left">210.70.137.193 ~ 210.70.137.254</td>
<td class="org-right">255.255.255.192</td>
</tr>
</tbody>
</table></li>
<li>之後這個C級網路就會變成以下4個子網路，可以分配給兩個學校<br />
<ul class="org-ul">
<li>子網 1：210.70.137.1 ~ 210.70.137.62<br /></li>
<li>子網 2：210.70.137.65 ~ 210.70.137.126<br /></li>
<li>子網 3：210.70.137.129 ~ 210.70.137.190<br /></li>
<li>子網 4：210.70.137.193 ~ 210.70.137.254<br /></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org53b67a9" class="outline-5">
<h5 id="org53b67a9">公共 IP&ldquo; 與 &rdquo;私有 IP"</h5>
<div class="outline-text-5" id="text-org53b67a9">
<ul class="org-ul">
<li>一個學校分配一個C級網路一定不夠用，我們學校光電腦教室用掉的IP就有300個，怎麼辦？<br /></li>
<li>在 A﹑B﹑C 這三個層級裡面﹐各劃出一些位址範圍保留給私有位址所用﹐它們分別是﹕<br />
<ul class="org-ul">
<li>10.0.0.0 - 10.255.255.255<br /></li>
<li>172.16.0.0 - 172.31.255.255<br /></li>
<li>192.168.0.0 - 192.168.255.255<br /></li>
</ul></li>
<li>像中華電信其實只分配一個IP給我們家，那為什麼家裡每台電腦、手機都能用WIFI上網，原因就是都用這種virtual ip<br /></li>
<li>使用virtual IP必須要配合NAT( NAT &#x2014; Network Addresss Translation)<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgfddde68"></a>NAT運作原理<br />
<div class="outline-text-6" id="text-orgfddde68">
<p>
NAT 是路由器實現的技術，用於解決內部多台設備共用一個公網 IP 的問題。工作流程：<br />
</p>
<ol class="org-ol">
<li>內部設備請求上網：你的電腦（私網 IP：192.168.1.100）想訪問 Google（例如 IP 為 142.250.190.46）。請求會發送到路由器。<br /></li>
<li>路由器轉換請求：路由器會用它的公網 IP（例如 123.45.67.89）替換電腦的私網 IP，並將請求轉發到 Google。<br /></li>
<li>路由器保存對應關係：路由器會記錄內部設備的私網 IP 和使用的連接埠（Port）。例如：<br />
<ul class="org-ul">
<li>內部 IP:Port -&gt; 公網 IP:Port<br /></li>
<li>192.168.1.100:54321 -&gt; 123.45.67.89:54321<br /></li>
</ul></li>
<li>回應轉發：當 Google 的回應到達你的公網 IP 時，路由器會根據對應關係將回應轉發給正確的內部設備（如 192.168.1.100）。<br /></li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org61ec5a4" class="outline-5">
<h5 id="org61ec5a4">DHCP</h5>
<div class="outline-text-5" id="text-org61ec5a4">
<ul class="org-ul">
<li>家裡的每台電腦或手機為什麼不用自己設定IP就能上網？<br /></li>
<li>路由器通常啟用 DHCP（動態主機配置協議），自動給每台設備分配私網 IP。這樣你家裡的電腦、手機都會獲得唯一的內部 IP。<br /></li>
<li>範例：假設路由器的 IP 是 192.168.1.1，你的設備可能分配到：<br />
<ul class="org-ul">
<li>電腦：192.168.1.100<br /></li>
<li>手機：192.168.1.101<br /></li>
<li>平板：192.168.1.102<br /></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb5f27a0" class="outline-4">
<h4 id="orgb5f27a0"><span class="section-number-4">9.1.3.</span> 靜態路由與動態路由協定（如 RIP, OSPF, BGP）</h4>
<div class="outline-text-4" id="text-9-1-3">
<p>
靜態路由和動態路由是網路中管理路由表的兩種不同方法，它們決定數據包在不同網段之間的傳輸方式。這兩種方法有著不同的特點和應用場景。下面介紹靜態路由以及常見的動態路由協定（如RIP、OSPF、BGP）的概念和特性。<br />
</p>
</div>
<div id="outline-container-org83acbbd" class="outline-5">
<h5 id="org83acbbd">靜態路由（Static Routing）</h5>
<div class="outline-text-5" id="text-org83acbbd">
<p>
靜態路由是指網路管理員手動在路由器上配置的路由條目。這些條目指示數據包通往特定目標網段的路由，並且在路由表中是固定不變的，直到手動更改。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7d6acfb"></a>特點:<br />
<div class="outline-text-6" id="text-org7d6acfb">
<ul class="org-ul">
<li>手動配置：管理員必須手動指定每條路由，包括目標網路和下一跳路由器的IP地址。<br /></li>
<li>適用於小型網路：靜態路由適用於網絡拓撲變化較小的場景，如小型或封閉的網路環境。<br /></li>
<li>高效但不靈活：靜態路由不消耗網路資源，但當網路拓撲發生變化時（例如，某個路由器失效或網段更改），需要手動調整配置，否則會導致路由失效。<br /></li>
<li>安全性高：由於手動配置，沒有意外的路由改變，因此在某些環境下更具安全性。<br /></li>
</ul>
</div>
</li>
<li><a id="org2ad8e59"></a>優點:<br />
<div class="outline-text-6" id="text-org2ad8e59">
<ul class="org-ul">
<li>控制力強，路由選擇完全由管理員掌控。<br /></li>
<li>不會產生路由更新的開銷，節省網路資源。<br /></li>
</ul>
</div>
</li>
<li><a id="org66116ea"></a>缺點:<br />
<div class="outline-text-6" id="text-org66116ea">
<ul class="org-ul">
<li>當網路規模變大或拓撲頻繁變動時，手動配置和維護的成本高。<br /></li>
<li>無法自動調整和應對網路故障或變化。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgf4e7ece" class="outline-5">
<h5 id="orgf4e7ece">動態路由（Dynamic Routing）</h5>
<div class="outline-text-5" id="text-orgf4e7ece">
<p>
動態路由依靠路由協定自動學習和維護網路的路由表，能夠自動調整以應對網路變化。動態路由協定根據特定的算法來確定最佳路徑，並定期與鄰居路由器交換路由信息。以下是常見的動態路由協定。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org99a87d5"></a>RIP（Routing Information Protocol）<br />
<div class="outline-text-6" id="text-org99a87d5">
<p>
RIP是最早期的動態路由協定之一，基於距離向量算法來選擇路由。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="orgbe87ed5"></a>工作原理：<br />
<div class="outline-text-7" id="text-orgbe87ed5">
<p>
RIP基於「跳數」來選擇路由，最多允許15跳（即路由器數量）來到達目標網路。RIP會定期（每30秒）向鄰近的路由器通告其路由表，並選擇跳數最少的路徑。<br />
</p>
</div>
</li>
<li><a id="orgb404b1a"></a>版本：<br />
<div class="outline-text-7" id="text-orgb404b1a">
<ul class="org-ul">
<li>RIPv1：不支持子網遮罩，路由表只包括網段地址，不適合無類別域間路由選擇（CIDR）。<br /></li>
<li>RIPv2：改進了對CIDR的支持，並且增加了多播傳輸和身份驗證功能。<br /></li>
</ul>
</div>
</li>
<li><a id="org98f5dd5"></a>優點：<br />
<div class="outline-text-7" id="text-org98f5dd5">
<ul class="org-ul">
<li>易於配置和維護，適用於小型網路。<br /></li>
</ul>
</div>
</li>
<li><a id="orga1dba12"></a>缺點：<br />
<div class="outline-text-7" id="text-orga1dba12">
<ul class="org-ul">
<li>跳數限制（最多15跳）使其不適合大型網路。<br /></li>
<li>更新過於頻繁（每30秒）可能導致帶寬浪費。<br /></li>
<li>收斂速度慢（路由表更新和調整所需時間較長）。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org14d52db"></a>OSPF（Open Shortest Path First）<br />
<div class="outline-text-6" id="text-org14d52db">
<p>
OSPF是一種基於鏈路狀態算法的動態路由協定，被廣泛應用於中大型網路環境中。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org7c3c7bf"></a>工作原理<br />
<div class="outline-text-7" id="text-org7c3c7bf">
<ul class="org-ul">
<li>OSPF通過鏈路狀態廣播（LSA）在整個網路內通告網段狀況，並使用Dijkstra的最短路徑優先算法來計算最佳路徑。每個路由器會維護一個完整的網路拓撲圖，並計算出到其他網段的最短路徑。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd929989"></a>特點：<br />
<div class="outline-text-7" id="text-orgd929989">
<ul class="org-ul">
<li>支持無類別域間路由選擇（CIDR），允許靈活的子網劃分。<br /></li>
<li>收斂速度快：當網路拓撲發生變化時，OSPF能快速響應和調整路由。<br /></li>
<li>能根據網段的成本（如帶寬、延遲等）來選擇最佳路徑，而不是僅依賴跳數。<br /></li>
<li>支持分層設計：可將網路劃分為多個區域（Area），有助於減少網路更新的範圍，提升網路的可擴展性。<br /></li>
</ul>
</div>
</li>
<li><a id="org5f2669b"></a>優點：<br />
<div class="outline-text-7" id="text-org5f2669b">
<ul class="org-ul">
<li>收斂速度快，適合大型網路。<br /></li>
<li>支持多路徑負載均衡。<br /></li>
</ul>
</div>
</li>
<li><a id="orgb0382f5"></a>缺點：<br />
<div class="outline-text-7" id="text-orgb0382f5">
<ul class="org-ul">
<li>計算拓撲圖和維護路由表的過程較為複雜，對硬體資源要求較高。<br /></li>
<li>配置比RIP更複雜，需要更高的技術水平。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org86e4450"></a>BGP（Border Gateway Protocol）<br />
<div class="outline-text-6" id="text-org86e4450">
<p>
BGP是一種路由向量協定，廣泛應用於互聯網的自治系統（AS，Autonomous Systems）之間的路由選擇。它主要負責互聯網骨幹網中的路由決策。<br />
</p>
</div>
<ul class="org-ul">
<li><a id="org5f85401"></a>工作原理<br />
<div class="outline-text-7" id="text-org5f85401">
<p>
BGP主要用於交換自治系統之間的路由信息，每個AS由一個或多個BGP路由器組成，這些路由器相互通告其可達的網段。BGP根據多種路徑屬性（如路徑長度、AS數量等）來選擇最佳路徑，而不是僅依賴跳數。<br />
</p>
<ul class="org-ul">
<li>內部BGP（iBGP）：用於同一自治系統內的路由器之間的路由選擇。<br /></li>
<li>外部BGP（eBGP）：用於不同自治系統之間的路由選擇。<br /></li>
</ul>
</div>
</li>
<li><a id="orgd5f04cf"></a>特點：<br />
<div class="outline-text-7" id="text-orgd5f04cf">
<ul class="org-ul">
<li>可擴展性強：BGP能夠處理大型網路環境，支持數百萬個路由條目，是互聯網上自治系統之間的首選路由協定。<br /></li>
<li>靈活的路由選擇機制：BGP不僅考慮路由長度，還能根據政策和策略來選擇路徑。<br /></li>
</ul>
</div>
</li>
<li><a id="org5bd65aa"></a>優點：<br />
<div class="outline-text-7" id="text-org5bd65aa">
<ul class="org-ul">
<li>BGP在處理跨多個自治系統的網路連接方面非常強大。<br /></li>
<li>支持路由策略和策略性路由選擇，適用於ISP和大型企業。<br /></li>
</ul>
</div>
</li>
<li><a id="org258b279"></a>缺點：<br />
<div class="outline-text-7" id="text-org258b279">
<ul class="org-ul">
<li>配置和維護非常複雜，適合高級網路工程師。<br /></li>
<li>收斂速度相對較慢，這在大規模變動的環境中可能成為一個問題。<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-orgfb3e547" class="outline-5">
<h5 id="orgfb3e547">總結</h5>
<div class="outline-text-5" id="text-orgfb3e547">
<ul class="org-ul">
<li>靜態路由：適合小型、簡單網路，優點是配置靈活且控制精確，缺點是需要手動維護，且無法自動應對網路變化。<br /></li>
<li>動態路由：動態路由協定（如RIP、OSPF、BGP）適合中大型網路，能夠根據網路變化自動調整路由。RIP適合小型網路，OSPF適合企業內部路由，BGP則是跨自治系統的標準協定，負責處理大規模互聯網路徑選擇。<br /></li>
</ul>
<p>
兩者結合使用，可以在提升網路效率和靈活性的同時，確保部分關鍵流量路徑的穩定和安全。<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7950cd3" class="outline-3">
<h3 id="org7950cd3"><span class="section-number-3">9.2.</span> 資料庫</h3>
<div class="outline-text-3" id="text-9-2">
</div>
<div id="outline-container-org29b7dc4" class="outline-4">
<h4 id="org29b7dc4"><span class="section-number-4">9.2.1.</span> NoSQL v.s. RDBM</h4>
<div class="outline-text-4" id="text-9-2-1">
</div>
<div id="outline-container-orgf752dab" class="outline-5">
<h5 id="orgf752dab">關聯式資料庫(RDBMS, Relational Database Management System)</h5>
<div class="outline-text-5" id="text-orgf752dab">
<p>
資料以資料表(table)的形式存在資料庫中，資料表之間有事先定義的關係，資料表中的一欄(column)代表某項屬性、一列(row)代表一個實體相關屬性的數值，每個資料表都具有主鍵(primary key)方便查詢，並且資料表間的關係可以透過外鍵(foreign key)建立。<br />
</p>

<div id="orgee7a9ea" class="figure">
<p><img src="images/林北的考前猜題/2025-01-28_12-43-42_1*hsMO1oCL5d1US9LcRztT-Q.png" alt="2025-01-28_12-43-42_1*hsMO1oCL5d1US9LcRztT-Q.png" width="500" /><br />
</p>
</div>
</div>
<ul class="org-ul">
<li><a id="org3f8e3ee"></a>RDBMS的優點<br />
<div class="outline-text-6" id="text-org3f8e3ee">
<ul class="org-ul">
<li>有ACID的特性，ACID 代表不可分割性 、一致性、獨立性和耐用性。 具有ACID 屬性的事務可確保資料庫操作的正確且可預測的執行，從而改善分析結果，最終有助於企業做出更明智的決策。<br />
<ol class="org-ol">
<li>不可分割性 (Atomic):交易必須整體成功執行，若是交易有一部分操作失敗，整個交易都會失效<br /></li>
<li>一致性 (Consistent)：做為交易的一部分寫入資料庫的資料，必須遵守所有明定規則以及約束<br /></li>
<li>獨立性 (Isolated)：達成並行控制的重要關鍵，可以確保每一個交易都是獨立的<br /></li>
<li>耐用性 (Durable)：在一個交易成功完成後，對資料庫所做的變更都是永久性的<br /></li>
</ol></li>
<li>不可分割性 (Atomic):交易必須整體成功執行，若是交易有一部分操作失敗，整個交易都會失效<br /></li>
<li>一致性 (Consistent)：做為交易的一部分寫入資料庫的資料，必須遵守所有明定規則以及約束<br /></li>
<li>獨立性 (Isolated)：達成並行控制的重要關鍵，可以確保每一個交易都是獨立的<br /></li>
<li>耐用性 (Durable)：在一個交易成功完成後，對資料庫所做的變更都是永久性的<br /></li>
<li>查詢複雜性：可以透過SQL語法，進行較複雜的查詢<br /></li>
<li>語言標準化:不像NoSQL各種資料庫有各自的操作語法，RDBMS都可使用SQL(Structured Querying Language)語言進行資料查詢與管理。<br /></li>
<li>資料庫正規化<br /></li>
<li>安全性高<br /></li>
</ul>
</div>
</li>
<li><a id="org8075bab"></a>DBMS的缺點<br />
<div class="outline-text-6" id="text-org8075bab">
<ul class="org-ul">
<li>橫向擴展能力低，透過垂直擴展比較能發揮優勢，但是成本較高。<br />
<ol class="org-ol">
<li>橫向擴展(Horizontal Scaling)可以想像成增加機器的數量，用不同的機器進行同一個服務，除了減緩單一機器的負擔，也可以避免當單一機器故障時，整個服務就無法使用的狀況。<br /></li>
<li>垂直擴展(Vertical Scaling)在現有的硬體上進行升級，例如升級CPU、增加RAM等。<br /></li>
</ol></li>
<li>儲存與維護成本高<br /></li>
<li>速度較慢，尤其當資料量龐大或多人同時使用服務的時候<br /></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org328392b" class="outline-5">
<h5 id="org328392b">非關聯式資料庫(NoSQL, Not only SQL)</h5>
<div class="outline-text-5" id="text-org328392b">
<ul class="org-ul">
<li>不同於SQL系統，NoSQL中的資料儲存不需要定義schema、也沒有固定架構，不保證ACID的特性，常用於分散式雲端系統。<br /></li>
<li><p>
典型的NOSQL如下列的JSON（JavaScript Object Notation）:<br />
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="linenr"> 1: </span>[
<span class="linenr"> 2: </span>   {
<span class="linenr"> 3: </span>       <span style="color: #98be65;">"year"</span> : <span style="color: #da8548; font-weight: bold;">2013</span>,
<span class="linenr"> 4: </span>       <span style="color: #98be65;">"title"</span> : <span style="color: #98be65;">"Turn It Down, Or Else!"</span>,
<span class="linenr"> 5: </span>       <span style="color: #98be65;">"info"</span> : {
<span class="linenr"> 6: </span>           <span style="color: #98be65;">"directors"</span> : [ <span style="color: #98be65;">"Alice Smith"</span>, <span style="color: #98be65;">"Bob Jones"</span>],
<span class="linenr"> 7: </span>           <span style="color: #98be65;">"release_date"</span> : <span style="color: #98be65;">"2013-01-18T00:00:00Z"</span>,
<span class="linenr"> 8: </span>           <span style="color: #98be65;">"rating"</span> : <span style="color: #da8548; font-weight: bold;">6.2</span>,
<span class="linenr"> 9: </span>           <span style="color: #98be65;">"genres"</span> : [<span style="color: #98be65;">"Comedy"</span>, <span style="color: #98be65;">"Drama"</span>],
<span class="linenr">10: </span>           <span style="color: #98be65;">"image_url"</span> : <span style="color: #98be65;">"http://ia.media-imdb.com/images/N/O9ERWAU7FS797AJ7LU8HN09AMUP908RLlo5JF90EWR7LJKQ7@@._V1_SX400_.jpg"</span>,
<span class="linenr">11: </span>           <span style="color: #98be65;">"plot"</span> : <span style="color: #98be65;">"A rock band plays their music at high volumes, annoying the neighbors."</span>,
<span class="linenr">12: </span>           <span style="color: #98be65;">"actors"</span> : [<span style="color: #98be65;">"David Matthewman"</span>, <span style="color: #98be65;">"Jonathan G. Neff"</span>]
<span class="linenr">13: </span>       }
<span class="linenr">14: </span>   },
<span class="linenr">15: </span>   {
<span class="linenr">16: </span>       <span style="color: #98be65;">"year"</span>: <span style="color: #da8548; font-weight: bold;">2015</span>,
<span class="linenr">17: </span>       <span style="color: #98be65;">"title"</span>: <span style="color: #98be65;">"The Big New Movie"</span>,
<span class="linenr">18: </span>       <span style="color: #98be65;">"info"</span>: {
<span class="linenr">19: </span>           <span style="color: #98be65;">"plot"</span>: <span style="color: #98be65;">"Nothing happens at all."</span>,
<span class="linenr">20: </span>           <span style="color: #98be65;">"rating"</span>: <span style="color: #da8548; font-weight: bold;">0</span>
<span class="linenr">21: </span>       }
<span class="linenr">22: </span>   }
<span class="linenr">23: </span>]
</pre>
</div></li>
<li>你有看到NOSQL如何儲存二進位的資料（圖片）嗎？很簡單，就是只存網址，這樣一來，圖片、影片這種資料就不用全部存在資料庫中，可以存放在其他檔案伺服器裡，不只彈性大，而且也可以降低資料庫伺服器的網路頻寬負擔，因為客戶在存取圖片或影片時可以由其他檔案伺服器去抓資料。<br /></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org949a804"></a>NoSQL的優點<br />
<div class="outline-text-6" id="text-org949a804">
<ul class="org-ul">
<li>橫向擴展能力佳 (Scalability):不必增加伺服器來擴大規模，可以透過分散式架構提供服務，以橫向擴展(Horizontal Scaling)的方式增加效能。<br /></li>
<li>彈性較高 (Flexibility)：NoSQL不像關聯式資料庫需要schema，可以隨意定義資料模型，因此NoSQL可以處理無特定結構或半結構式(semi-structured)的資料<br /></li>
<li>速度優勢：因為NoSQL不包含資料關聯性，查詢速度相對較快。<br /></li>
</ul>
</div>
</li>
<li><a id="orgaa8e5ff"></a>NoSQL的缺點<br />
<div class="outline-text-6" id="text-orgaa8e5ff">
<ul class="org-ul">
<li>資料完整度:不同於關聯式資料庫通常遵循ACID原則 (atomicity, consistency, isolation, durability)以確保資料的完整度，NoSQL較難提供ACID的保證，而是遵循BASE(basic availability, soft state, and eventual consistency) 的原則，並且可能犧牲資料的完整度。<br /></li>
<li>語言標準化:不像關聯式資料庫大多可以使用SQL語言操作，NoSQL不同的資料庫有各自獨特的語言來管理資料。<br /></li>
<li>查詢複雜性：NoSQL針對單一表格的查詢效果佳，但當資料複雜度增加，使用RDBMS的效果會更好。<br /></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org2b4be50" class="outline-4">
<h4 id="org2b4be50"><span class="section-number-4">9.2.2.</span> JSON</h4>
<div class="outline-text-4" id="text-9-2-2">
<p>
JSON是一種基於文本的數據交換格式，源於JavaScript語言，但已被許多其他編程語言所支持。由於其簡單、易讀的語法和跨平台的兼容性，JSON成為了Web開發中廣泛使用的數據格式，尤其適用於API和AJAX應用。<br />
</p>
</div>
</div>
<div id="outline-container-org686a0e3" class="outline-4">
<h4 id="org686a0e3"><span class="section-number-4">9.2.3.</span> 雲端資料庫</h4>
</div>
<div id="outline-container-org12e275f" class="outline-4">
<h4 id="org12e275f"><span class="section-number-4">9.2.4.</span> Entity-relationship model</h4>
</div>
</div>
<div id="outline-container-org3507883" class="outline-3">
<h3 id="org3507883"><span class="section-number-3">9.3.</span> 軟體工程</h3>
<div class="outline-text-3" id="text-9-3">
</div>
<div id="outline-container-orgcde8063" class="outline-4">
<h4 id="orgcde8063"><span class="section-number-4">9.3.1.</span> Unit Test</h4>
</div>
</div>
<div id="outline-container-org8b1b0fe" class="outline-3">
<h3 id="org8b1b0fe"><span class="section-number-3">9.4.</span> AI</h3>
<div class="outline-text-3" id="text-9-4">
</div>
<div id="outline-container-org6d024b6" class="outline-4">
<h4 id="org6d024b6"><span class="section-number-4">9.4.1.</span> Turing Machine</h4>
</div>
<div id="outline-container-orga8be9e0" class="outline-4">
<h4 id="orga8be9e0"><span class="section-number-4">9.4.2.</span> Turing Test</h4>
</div>
<div id="outline-container-org3dd8c04" class="outline-4">
<h4 id="org3dd8c04"><span class="section-number-4">9.4.3.</span> Cloud Computing</h4>
</div>
<div id="outline-container-org6e6aa57" class="outline-4">
<h4 id="org6e6aa57"><span class="section-number-4">9.4.4.</span> Iot</h4>
</div>
<div id="outline-container-org100071a" class="outline-4">
<h4 id="org100071a"><span class="section-number-4">9.4.5.</span> supervised learning, unsupervised learning, reinforcement learning。</h4>
</div>
<div id="outline-container-org5bbc21e" class="outline-4">
<h4 id="org5bbc21e"><span class="section-number-4">9.4.6.</span> 計算梯度下降</h4>
</div>
</div>
<div id="outline-container-org8d4462f" class="outline-3">
<h3 id="org8d4462f"><span class="section-number-3">9.5.</span> 資管</h3>
<div class="outline-text-3" id="text-9-5">
</div>
<div id="outline-container-org88adae8" class="outline-4">
<h4 id="org88adae8"><span class="section-number-4">9.5.1.</span> Information security management</h4>
</div>
</div>
<div id="outline-container-org2078888" class="outline-3">
<h3 id="org2078888"><span class="section-number-3">9.6.</span> 其他</h3>
<div class="outline-text-3" id="text-9-6">
</div>
<div id="outline-container-org0bf2b91" class="outline-4">
<h4 id="org0bf2b91"><span class="section-number-4">9.6.1.</span> 區塊鏈</h4>
</div>
<div id="outline-container-org62978ca" class="outline-4">
<h4 id="org62978ca"><span class="section-number-4">9.6.2.</span> RSA 加密</h4>
</div>
<div id="outline-container-org24c08fc" class="outline-4">
<h4 id="org24c08fc"><span class="section-number-4">9.6.3.</span> 開源/閉源軟體</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Yung-Chin Yen</p>
<p class="date">Created: 2025-01-31 Fri 14:54</p>
</div>
</body>
</html>
